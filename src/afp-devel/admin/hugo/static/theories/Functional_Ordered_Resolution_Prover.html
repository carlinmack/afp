<div id="Weighted_FO_Ordered_Resolution_Prover">
<div class="head"><h1>Theory Weighted_FO_Ordered_Resolution_Prover</h1>
<span class="command">theory</span> <span class="name">Weighted_FO_Ordered_Resolution_Prover</span><br/>
<span class="keyword">imports</span> <a href="FO_Ordered_Resolution_Prover.html"><span class="name">FO_Ordered_Resolution_Prover</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       A Fair Ordered Resolution Prover for First-Order Clauses with Weights
    Author:      Anders Schlichtkrull &lt;andschl at dtu.dk&gt;, 2017
    Author:      Jasmin Blanchette &lt;j.c.blanchette at vu.nl&gt;, 2017
    Maintainer:  Anders Schlichtkrull &lt;andschl at dtu.dk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Fair Ordered Resolution Prover for First-Order Clauses with Weights›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The ‹weighted_RP› prover introduced below operates on finite multisets of clauses and
organizes the multiset of processed clauses as a priority queue to ensure that inferences are
performed in a fair manner, to guarantee completeness.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Weighted_FO_Ordered_Resolution_Prover</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Ordered_Resolution_Prover.FO_Ordered_Resolution_Prover</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Library›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to "Coinductive"? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ldrop_Suc_conv_ltl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ldrop (enat (Suc k)) xs = ltl (ldrop (enat k) xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>eSuc_enat</span><span> </span><span>ldrop_eSuc_conv_ltl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to "Coinductive"? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lhd_ldrop'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enat k &lt; llength xs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lhd (ldrop (enat k) xs) = lnth xs k"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lhd_ldrop</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to "Multiset_More.thy". *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filter_mset_empty_if_finite_and_filter_set_empty</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"{x ∈ X. P x} = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"finite X"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#x ∈# mset_set X. P x#} = {#}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>empty_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Y. set_mset Y = {} ⟹ Y = {#}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set_mset {#x ∈# mset_set X. P x#} = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>empty_empty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to "Lazy_List_Chain.thy". *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_chain_ltl_chain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain R xs ⟹ llength xs = ∞ ⟹ chain R (ltl xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>chain.simps</span><span class="delimiter">[</span><span>of</span><span> </span><span>R</span><span> </span><span>xs</span><span class="delimiter">]</span><span> </span><span>llength_eq_infty_conv_lfinite</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>lfinite_code</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>lfinite_ltl</span><span> </span><span>llist.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to "Lazy_List_Chain.thy". *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inf_chain_ldrop_chain</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>chain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain R xs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ lfinite xs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain R (ldrop (enat k) xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zero_enat_def</span><span> </span><span>chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"llength (ldrop (enat k) xs) = ∞"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_lfinite_llength</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain R (ltl (ldrop (enat k) xs))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf_chain_ltl_chain</span><span class="delimiter">[</span><span>of</span><span> </span><span>R</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ldrop (enat k) xs)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ldrop_Suc_conv_ltl</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>xs</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Prover›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>wclause</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause × nat"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>wstate</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wclause multiset × 'a wclause multiset × 'a wclause multiset × nat"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>state_of_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ 'a state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"state_of_wstate (N, P, Q, n) =
   (set_mset (image_mset fst N), set_mset (image_mset fst P), set_mset (image_mset fst Q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>weighted_FO_resolution_prover</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>FO_resolution_prover</span><span> </span><span>S</span><span> </span><span>subst_atm</span><span> </span><span>id_subst</span><span> </span><span>comp_subst</span><span> </span><span>renamings_apart</span><span> </span><span>atm_of_atms</span><span> </span><span>mgu</span><span> </span><span>less_atm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>    </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a :: wellorder) clause ⇒ 'a clause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>subst_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 's ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>id_subst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>comp_subst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ 's ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>renamings_apart</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause list ⇒ 's list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>atm_of_atms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>mgu</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 's option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>less_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause × nat ⇒ nat"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>weight_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; j ⟹ weight (C, i) &lt; weight (C, j)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>clss_of_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ 'a clause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"clss_of_wstate St ≡ clss_of_state (state_of_wstate St)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>N_of_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ 'a clause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"N_of_wstate St ≡ N_of_state (state_of_wstate St)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>P_of_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ 'a clause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P_of_wstate St ≡ P_of_state (state_of_wstate St)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Q_of_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ 'a clause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Q_of_wstate St ≡ Q_of_state (state_of_wstate St)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wN_of_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ 'a wclause multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wN_of_wstate (N, P, Q, n) = N"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wP_of_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ 'a wclause multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wP_of_wstate (N, P, Q, n) = P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wQ_of_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ 'a wclause multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wQ_of_wstate (N, P, Q, n) = Q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>n_of_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n_of_wstate (N, P, Q, n) = n"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>of_wstate_split</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(wN_of_wstate St, wP_of_wstate St, wQ_of_wstate St, n_of_wstate St) = St"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>St</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>grounding_of_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ 'a clause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grounding_of_wstate St ≡ grounding_of_state (state_of_wstate St)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Liminf_wstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate llist ⇒ 'a state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Liminf_wstate Sts ≡ Liminf_state (lmap state_of_wstate Sts)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>timestamp_le_weight</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ weight (C, n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>weight_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span class="delimiter">]</span><span> </span><span>Suc_le_eq</span><span> </span><span>le_less</span><span> </span><span>le_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>weighted_RP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate ⇒ 'a wstate ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↝<span class="hidden">⇩</span><sub>w</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>tautology_deletion</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Neg A ∈# C ⟹ Pos A ∈# C ⟹ (N + {#(C, i)#}, P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub> (N, P, Q, n)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>forward_subsumption</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ∈# image_mset fst (P + Q) ⟹ subsumes D C ⟹
    (N + {#(C, i)#}, P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub> (N, P, Q, n)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>backward_subsumption_P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ∈# image_mset fst N ⟹ C ∈# image_mset fst P ⟹
    strictly_subsumes D C ⟹ (N, P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub> (N, {#(E, k) ∈# P. E ≠ C#}, Q, n)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>backward_subsumption_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ∈# image_mset fst N ⟹ strictly_subsumes D C ⟹
    (N, P, Q + {#(C, i)#}, n) ↝<span class="hidden">⇩</span><sub>w</sub> (N, P, Q, n)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>forward_reduction</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D + {#L'#} ∈# image_mset fst (P + Q) ⟹ - L = L' ⋅l σ ⟹ D ⋅ σ ⊆# C ⟹
    (N + {#(C + {#L#}, i)#}, P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub> (N + {#(C, i)#}, P, Q, n)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>backward_reduction_P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D + {#L'#} ∈# image_mset fst N ⟹ - L = L' ⋅l σ ⟹ D ⋅ σ ⊆# C ⟹
    (∀j. (C + {#L#}, j) ∈# P ⟶ j ≤ i) ⟹
    (N, P + {#(C + {#L#}, i)#}, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub> (N, P + {#(C, i)#}, Q, n)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>backward_reduction_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D + {#L'#} ∈# image_mset fst N ⟹ - L = L' ⋅l σ ⟹ D ⋅ σ ⊆# C ⟹
    (N, P, Q + {#(C + {#L#}, i)#}, n) ↝<span class="hidden">⇩</span><sub>w</sub> (N, P + {#(C, i)#}, Q, n)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>clause_processing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(N + {#(C, i)#}, P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub> (N, P + {#(C, i)#}, Q, n)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>inference_computation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀(D, j) ∈# P. weight (C, i) ≤ weight (D, j)) ⟹
    N = mset_set ((λD. (D, n)) ` concls_of
      (inference_system.inferences_between (ord_FO_Γ S) (set_mset (image_mset fst Q)) C)) ⟹
    ({#}, P + {#(C, i)#}, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub> (N, {#(D, j) ∈# P. D ≠ C#}, Q + {#(C, i)#}, Suc n)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weighted_RP_imp_RP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"St ↝<span class="hidden">⇩</span><sub>w</sub> St' ⟹ state_of_wstate St ↝ state_of_wstate St'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>weighted_RP.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backward_subsumption_P</span><span> </span><span>D</span><span> </span><span>N</span><span> </span><span>C</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>          </span><span>RP.backward_subsumption_P</span><span class="delimiter">[</span><span>of</span><span> </span><span>D</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ` set_mset N"</span></span></span><span> </span><span>C</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ` set_mset P - {C}"</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"fst ` set_mset Q"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>backward_subsumption_P</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>inference_computation</span><span> </span><span>P</span><span> </span><span>C</span><span> </span><span>i</span><span> </span><span>N</span><span> </span><span>n</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>           </span><span>RP.inference_computation</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ` set_mset N"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ` set_mset Q"</span></span></span><span> </span><span>C</span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"fst ` set_mset P - {C}"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>         </span><span>use</span><span> </span><span>inference_computation</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>finite_ord_FO_resolution_inferences_between</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span>
</span><span>           </span><span class="cartouche"><span class="delete"><span class="delete">‹auto simp: comp_def image_comp inference_system.inferences_between_def›</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>RP.intros</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>final_weighted_RP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ ({#}, {#}, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub> St"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>weighted_RP.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>Sts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate llist"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>full_deriv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"full_chain (↝<span class="hidden">⇩</span><sub>w</sub>) Sts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>empty_P0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P_of_wstate (lhd Sts) = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>empty_Q0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q_of_wstate (lhd Sts) = {}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_Sts0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (clss_of_wstate (lhd Sts))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>clss_of_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lhd Sts"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>deriv</span><span> </span><span class="delimiter">=</span><span> </span><span>full_chain_imp_chain</span><span class="delimiter">[</span><span>OF</span><span> </span><span>full_deriv</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>lhd_lmap_Sts</span><span> </span><span class="delimiter">=</span><span> </span><span>llist.map_sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>chain_not_lnull</span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deriv_RP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (↝) (lmap state_of_wstate Sts)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deriv</span><span> </span><span>weighted_RP_imp_RP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>chain_lmap</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_Sts0_RP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (clss_of_state (lhd (lmap state_of_wstate Sts)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_Sts0</span><span> </span><span>chain_length_pos</span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_P0_RP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P_of_state (lhd (lmap state_of_wstate Sts)) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_P0</span><span> </span><span>chain_length_pos</span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_Q0_RP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q_of_state (lhd (lmap state_of_wstate Sts)) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty_Q0</span><span> </span><span>chain_length_pos</span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Sts_thms</span><span> </span><span class="delimiter">=</span><span> </span><span>deriv_RP</span><span> </span><span>finite_Sts0_RP</span><span> </span><span>empty_P0_RP</span><span> </span><span>empty_Q0_RP</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>weighted_RP_model</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"St ↝<span class="hidden">⇩</span><sub>w</sub> St' ⟹ I ⊨s grounding_of_wstate St' ⟷ I ⊨s grounding_of_wstate St"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>RP_model</span><span> </span><span>Sts_thms</span><span> </span><span>weighted_RP_imp_RP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>S_gQ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause ⇒ 'a clause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"S_gQ ≡ S_Q (lmap state_of_wstate Sts)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>sq</span><span class="delimiter">:</span><span> </span><span>selection</span><span> </span><span>S_gQ</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>S_Q_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv_RP</span><span> </span><span>empty_Q0_RP</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_M_selects_subseteq</span><span> </span><span>S_M_selects_neg_lits</span><span> </span><span>selection_axioms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>gd</span><span class="delimiter">:</span><span> </span><span>ground_resolution_with_selection</span><span> </span><span>S_gQ</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>src</span><span class="delimiter">:</span><span> </span><span>standard_redundancy_criterion_reductive</span><span> </span><span>gd.ord_Γ</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>src</span><span class="delimiter">:</span><span> </span><span>standard_redundancy_criterion_counterex_reducing</span><span> </span><span>gd.ord_Γ</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ground_resolution_with_selection.INTERP S_gQ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ord_Γ_saturated_upto_def</span><span> </span><span class="delimiter">=</span><span> </span><span>src.saturated_upto_def</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ord_Γ_saturated_upto_complete</span><span> </span><span class="delimiter">=</span><span> </span><span>src.saturated_upto_complete</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ord_Γ_contradiction_Rf</span><span> </span><span class="delimiter">=</span><span> </span><span>src.contradiction_Rf</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>weighted_RP_sound</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#} ∈ clss_of_state (Liminf_wstate Sts)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ satisfiable (grounding_of_wstate (lhd Sts))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>RP_sound</span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv_RP</span><span> </span><span>empty_Q0_RP</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>lhd_lmap_Sts</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>RP_filtered_measure</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a wclause ⇒ bool) ⇒ 'a wstate ⇒ nat × nat × nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"RP_filtered_measure ≡ λp (N, P, Q, n).
     (sum_mset (image_mset (λ(C, i). Suc (size C)) {#Di ∈# N + P + Q. p Di#}),
      size {#Di ∈# N. p Di#}, size {#Di ∈# P. p Di#})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>RP_combined_measure</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ 'a wstate ⇒ nat × (nat × nat × nat) × (nat × nat × nat)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"RP_combined_measure ≡ λw St.
     (w + 1 - n_of_wstate St, RP_filtered_measure (λ(C, i). i ≤ w) St,
      RP_filtered_measure (λCi. True) St)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>RP_filtered_relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"((nat × nat × nat) × (nat × nat × nat)) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"RP_filtered_relation ≡ natLess &lt;*lex*&gt; natLess &lt;*lex*&gt; natLess"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>RP_combined_relation</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"((nat × ((nat × nat × nat) × (nat × nat × nat))) ×
    (nat × ((nat × nat × nat) × (nat × nat × nat)))) set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"RP_combined_relation ≡ natLess &lt;*lex*&gt; RP_filtered_relation &lt;*lex*&gt; RP_filtered_relation"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst3 :: 'b * 'c * 'd ⇒ 'b) ≡ fst"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(snd3 :: 'b * 'c * 'd ⇒ 'c) ≡ λx. fst (snd x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(trd3 :: 'b * 'c * 'd ⇒ 'd) ≡ λx. snd (snd x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>
</span><span>  </span><span>wf_RP_filtered_relation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf RP_filtered_relation"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>wf_RP_combined_relation</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf RP_combined_relation"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>natLess_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wf_less</span><span> </span><span>wf_mult</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>multiset_sum_of_Suc_f_monotone</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N ⊂# M ⟹ (∑x ∈# N. Suc (f x)) &lt; (∑x ∈# M. Suc (f x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>N</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>empty</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈# M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑x ∈# M. 1) = (∑x ∈# M - {#y#} + {#y#}. 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = (∑x ∈# M - {#y#}. 1) + (∑x ∈# {#y#}. 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>image_mset_union</span><span> </span><span>sum_mset.union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... &gt; (0 :: nat)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; (∑x ∈# M. Suc (f x))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>gr_zeroI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>add</span><span> </span><span>x</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑y ∈# N. Suc (f y)) &lt; (∑y ∈# M - {#x#}. Suc (f y))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>add</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"M - {#x#}"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_union_subset_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"add_mset x (remove1_mset x M) = M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>add.prems</span><span> </span><span>add_mset_remove_trivial_If</span><span> </span><span>mset_subset_insertD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span> </span><span>add_less_cancel_right</span><span> </span><span>sum_mset.insert</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>multiset_sum_monotone_f'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CC ⊂# DD"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(C, i) ∈# CC. Suc (f C)) &lt; (∑(C, i) ∈# DD. Suc (f C))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>multiset_sum_of_Suc_f_monotone</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ∘ fst"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>comp_apply</span><span> </span><span>image_mset_cong2</span><span> </span><span>split_beta</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filter_mset_strict_subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈# M"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ p x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#y ∈# M. p y#} ⊂# M"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subseteq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#E ∈# M. p E#} ⊆# M"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"count {#E ∈# M. p E#} x = 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; count M x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lt_count</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"count {#y ∈# M. p y#} x &lt; count M x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subseteq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>less_not_refl2</span><span> </span><span>subset_mset.le_neq_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weighted_RP_measure_decreasing_N</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"St ↝<span class="hidden">⇩</span><sub>w</sub> St'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, l) ∈# wN_of_wstate St"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(RP_filtered_measure (λCi. True) St', RP_filtered_measure (λCi. True) St)
    ∈ RP_filtered_relation"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>weighted_RP.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backward_subsumption_P</span><span> </span><span>D</span><span> </span><span>N</span><span> </span><span>C'</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(C', i') ∈# P"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#(E, k) ∈# P. E ≠ C'#} ⊂# P"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>filter_mset_strict_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C', i')"</span></span></span><span> </span><span>P</span><span> </span><span class="string"><span class="delete"><span class="delete">"λX. ¬fst X =  C'"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>filter_mset_cong</span><span> </span><span>fst_conv</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(C, i) ∈# {#(E, k) ∈# P. E ≠ C'#}. Suc (size C)) &lt; (∑(C, i) ∈# P. Suc (size C))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>multiset_sum_monotone_f'</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#(E, k) ∈# P. E ≠ C'#}"</span></span></span><span> </span><span>P</span><span> </span><span>size</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>natLess_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>natLess_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weighted_RP_measure_decreasing_P</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"St ↝<span class="hidden">⇩</span><sub>w</sub> St'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wP_of_wstate St"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(RP_combined_measure (weight (C, i)) St', RP_combined_measure (weight (C, i)) St)
    ∈ RP_combined_relation"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>weighted_RP.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backward_subsumption_P</span><span> </span><span>D</span><span> </span><span>N</span><span> </span><span>C'</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>St</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"St = (N, P, Q, n)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>P'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P' = {#(E, k) ∈# P. E ≠ C'#}"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>St'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"St' = (N, P', Q, n)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>backward_subsumption_P</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(C', i') ∈# P"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P'_sub_P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P' ⊂# P"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>filter_mset_strict_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C', i')"</span></span></span><span> </span><span>P</span><span> </span><span class="string"><span class="delete"><span class="delete">"λDj. fst Dj ≠ C'"</span></span></span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>filter_mset_cong</span><span> </span><span>fst_conv</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P'_subeq_P_filter</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"{#(Ca, ia) ∈# P'. ia ≤ weight (C, i)#} ⊆# {#(Ca, ia) ∈# P. ia ≤ weight (C, i)#}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P'_sub_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>multiset_filter_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst3 (RP_combined_measure (weight (C, i)) St')
    ≤ fst3 (RP_combined_measure (weight (C, i)) St)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St'_def</span><span> </span><span>St_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(C, i) ∈# {#(Ca, ia) ∈# P'. ia ≤ weight (C, i)#}. Suc (size C))
    ≤ (∑x ∈# {#(Ca, ia) ∈# P. ia ≤ weight (C, i)#}. case x of (C, i) ⇒ Suc (size C))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P'_subeq_P_filter</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>sum_image_mset_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst3 (snd3 (RP_combined_measure (weight (C, i)) St'))
    ≤ fst3 (snd3 (RP_combined_measure (weight (C, i)) St))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St'_def</span><span> </span><span>St_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd3 (snd3 (RP_combined_measure (weight (C, i)) St'))
    ≤ snd3 (snd3 (RP_combined_measure (weight (C, i)) St))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St'_def</span><span> </span><span>St_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P'_subeq_P_filter</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"size {#(Ca, ia) ∈# P'. ia ≤ weight (C, i)#}
    ≤ size {#(Ca, ia) ∈# P. ia ≤ weight (C, i)#}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>size_mset_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trd3 (snd3 (RP_combined_measure (weight (C, i)) St'))
    ≤ trd3 (snd3 (RP_combined_measure (weight (C, i)) St))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St'_def</span><span> </span><span>St_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fst_def</span><span> </span><span>snd_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>P'_sub_P</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∑(C, i) ∈# P'. Suc (size C)) &lt; (∑(C, i) ∈# P. Suc (size C))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>multiset_sum_monotone_f'</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#(E, k) ∈# P. E ≠ C'#}"</span></span></span><span> </span><span>P</span><span> </span><span>size</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst3 (trd3 (RP_combined_measure (weight (C, i)) St'))
    &lt; fst3 (trd3 (RP_combined_measure (weight (C, i)) St))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P'_def</span><span> </span><span>St'_def</span><span> </span><span>St_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>natLess_def</span><span> </span><span>P'_def</span><span> </span><span>St'_def</span><span> </span><span>St_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>inference_computation</span><span> </span><span>P</span><span> </span><span>C'</span><span> </span><span>i'</span><span> </span><span>N</span><span> </span><span>n</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≤ weight (C, i)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (C, i) + 1 - n &gt; weight (C, i) + 1 - Suc n"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>natLess_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>n_nle_w</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>St</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"St = ({#}, P + {#(C', i')#}, Q, n)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>St'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"St' =  (N, {#(D, j) ∈# P. D ≠ C'#}, Q + {#(C', i')#}, Suc n)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>concls</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wclause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"concls = (λD. (D, n)) ` concls_of (inference_system.inferences_between (ord_FO_Γ S)
         (fst ` set_mset Q) C')"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite concls"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>concls_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finite_ord_FO_resolution_inferences_between</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{(D, ia) ∈ concls. ia ≤ weight (C, i)} = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>concls_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_nle_w</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#(D, ia) ∈# mset_set concls. ia ≤ weight (C, i)#} = {#}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fin</span><span> </span><span>filter_mset_empty_if_finite_and_filter_set_empty</span><span class="delimiter">[</span><span>of</span><span> </span><span>concls</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_low_weight_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#(D, ia) ∈# N. ia ≤ weight (C, i)#} = {#}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inference_computation</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>concls_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (C', i') ≤ weight (C, i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inference_computation</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i'_le_w_Ci</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i' ≤ weight (C, i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>timestamp_le_weight</span><span class="delimiter">[</span><span>of</span><span> </span><span>i'</span><span> </span><span>C'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#(D, ia) ∈# N + {#(D, j) ∈# P. D ≠ C'#} + (Q + {#(C', i')#}). ia ≤ weight (C, i)#}
      ⊆# {#(D, ia) ∈# {#} + (P + {#(C', i')#}) + Q. ia ≤ weight (C, i)#}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_low_weight_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>multiset_filter_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst3 (RP_combined_measure (weight (C, i)) St')
      ≤ fst3 (RP_combined_measure (weight (C, i)) St)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St'_def</span><span> </span><span>St_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst (RP_filtered_measure ((λ(D, ia). ia ≤ weight (C, i))) St') =
      (∑(C, i) ∈# {#(D, ia) ∈# N + {#(D, j) ∈# P. D ≠ C'#} + (Q + {#(C', i')#}).
         ia ≤ weight (C, i)#}. Suc (size C))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... ≤ (∑(C, i) ∈# {#(D, ia) ∈# {#} + (P + {#(C', i')#}) + Q. ia ≤ weight (C, i)#}.
      Suc (size C))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subs</span><span> </span><span>sum_image_mset_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = fst (RP_filtered_measure (λ(D, ia). ia ≤ weight (C, i)) St)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fst3 (snd3 (RP_combined_measure (weight (C, i)) St'))
      ≤ fst3 (snd3 (RP_combined_measure (weight (C, i)) St))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd3 (snd3 (RP_combined_measure (weight (C, i)) St')) =
      snd3 (snd3 (RP_combined_measure (weight (C, i)) St))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St_def</span><span> </span><span>St'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_low_weight_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trd3 (snd3 (RP_combined_measure (weight (C, i)) St')) &lt;
      trd3 (snd3 (RP_combined_measure (weight (C, i)) St))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St_def</span><span> </span><span>St'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'_le_w_Ci</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_imp_less_Suc</span><span> </span><span>multiset_filter_mono</span><span> </span><span>size_mset_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>natLess_def</span><span> </span><span>St'_def</span><span> </span><span>St_def</span><span> </span><span>lex_prod_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>natLess_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>preserve_min_or_delete_completely</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"St ↝<span class="hidden">⇩</span><sub>w</sub> St'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wP_of_wstate St"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀k. (C, k) ∈# wP_of_wstate St ⟶ i ≤ k"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wP_of_wstate St' ∨ (∀j. (C, j) ∉# wP_of_wstate St')"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>weighted_RP.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>backward_reduction_P</span><span> </span><span>D</span><span> </span><span>L'</span><span> </span><span>N</span><span> </span><span>L</span><span> </span><span>σ</span><span> </span><span>C'</span><span> </span><span>P</span><span> </span><span>i'</span><span> </span><span>Q</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"C = C' + {#L#}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True_outer</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C_i_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# P + {#(C, i')#}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backward_reduction_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>max</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀k. (C, k) ∈# P + {#(C, i')#} ⟹ k ≤ i'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backward_reduction_P</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>True_outer</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"count (P + {#(C, i')#}) (C, i') ≥ 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"count (P + {#(C, i')#}) (C, i') = 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nin_P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i') ∉# P"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_in_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) = (C, i')"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i = i'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j. (C, j) ∈# P + {#(C, i')#} ⟶ j = i'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>max</span><span> </span><span>backward_reduction_P</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>True_outer</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True_outer</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>nin_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_i_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"count (P + {#(C, i')#}) (C, i') &gt; 1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_i_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"count (P + {#(C, i')#}) (C, i') = 1"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>backward_reduction_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>preserve_min_P</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"St ↝<span class="hidden">⇩</span><sub>w</sub> St'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, j) ∈# wP_of_wstate St'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wP_of_wstate St"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀k. (C, k) ∈# wP_of_wstate St ⟶ i ≤ k"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wP_of_wstate St'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>preserve_min_or_delete_completely</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>preserve_min_P_Sts</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enat (Suc k) &lt; llength Sts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wP_of_wstate (lnth Sts k)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(C, j) ∈# wP_of_wstate (lnth Sts (Suc k))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀j. (C, j) ∈# wP_of_wstate (lnth Sts k) ⟶ i ≤ j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wP_of_wstate (lnth Sts (Suc k))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deriv</span><span> </span><span>assms</span><span> </span><span>chain_lnth_rel</span><span> </span><span>preserve_min_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_lnth_in_Supremum_ldrop</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; llength xs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈# (lnth xs i)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ Sup_llist (lmap set_mset (ldrop (enat i) xs))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>ldrop_eq_LConsD</span><span> </span><span>ldropn_0</span><span> </span><span>llist.simps</span><span class="delimiter">(</span><span>13</span><span class="delimiter">)</span><span> </span><span>contra_subsetD</span><span>
</span><span>      </span><span>ldrop_enat</span><span> </span><span>ldropn_Suc_conv_ldropn</span><span> </span><span>lnth_0</span><span> </span><span>lnth_lmap</span><span> </span><span>lnth_subset_Sup_llist</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>persistent_wclause_in_P_if_persistent_clause_in_P</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ Liminf_llist (lmap P_of_state (lmap state_of_wstate Sts))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. (C, i) ∈ Liminf_llist (lmap (set_mset ∘ wP_of_wstate) Sts)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t_C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t_C_p</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enat t_C &lt; llength Sts"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀t. t_C ≤ t ⟹ t &lt; llength Sts ⟹ C ∈ P_of_state (state_of_wstate (lnth Sts t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Liminf_llist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i_p</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wP_of_wstate (lnth Sts t_C)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_C_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lnth Sts t_C"</span></span></span><span class="delimiter">)</span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Ci_in_nth_wP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. (C, i) ∈# wP_of_wstate (lnth Sts (t_C + t))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t_C + t &lt; llength Sts"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>t_C_p</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"t_C + _"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lnth Sts (t_C + t)"</span></span></span><span class="delimiter">)</span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>in_Sup_wP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"in_Sup_wP = (λi. (C, i) ∈ Sup_llist (lmap (set_mset ∘ wP_of_wstate) (ldrop t_C Sts)))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"in_Sup_wP i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_p</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>in_lnth_in_Supremum_ldrop</span><span class="delimiter">[</span><span>of</span><span> </span><span>t_C</span><span> </span><span class="string"><span class="delete"><span class="delete">"lmap wP_of_wstate Sts"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i)"</span></span></span><span class="delimiter">]</span><span> </span><span>t_C_p</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_Sup_wP_def</span><span> </span><span>llist.map_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_least in_Sup_wP j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>in_Sup_wP_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>least_exists</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. (C, i) ∈ Sup_llist (lmap (set_mset ∘ wP_of_wstate) (ldrop t_C Sts)) ⟶ j ≤ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_least_def</span><span> </span><span>in_Sup_wP_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_less</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>j_smallest</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀i t. enat (t_C + t) &lt; llength Sts ⟹ (C, i) ∈# wP_of_wstate (lnth Sts (t_C + t)) ⟹ j ≤ i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>comp_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>add.commute</span><span> </span><span>ldrop_enat</span><span> </span><span>ldrop_eq_LConsD</span><span> </span><span>ldrop_ldrop</span><span> </span><span>ldropn_Suc_conv_ldropn</span><span>
</span><span>        </span><span>plus_enat_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>  </span><span>lnth_ldropn</span><span> </span><span>Sup_llist_def</span><span> </span><span>UN_I</span><span> </span><span>ldrop_lmap</span><span> </span><span>llength_lmap</span><span> </span><span>lnth_lmap</span><span>
</span><span>        </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>j_p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃t_Cj. t_Cj &lt; llength (ldrop (enat t_C) Sts)
    ∧ (C, j) ∈# wP_of_wstate (lnth (ldrop t_C Sts) t_Cj)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>in_Sup_wP_def</span><span> </span><span>Sup_llist_def</span><span> </span><span>is_least_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t_Cj</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>j_p</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(C,j) ∈# wP_of_wstate (lnth Sts (t_C + t_Cj))"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enat (t_C + t_Cj) &lt; llength Sts"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>add.commute</span><span> </span><span>ldrop_enat</span><span> </span><span>ldrop_eq_LConsD</span><span> </span><span>ldrop_ldrop</span><span> </span><span>ldropn_Suc_conv_ldropn</span><span>
</span><span>        </span><span>plus_enat_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>lhd_ldropn</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Ci_stays</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t_C + t_Cj + t &lt; llength Sts ⟹ (C,j) ∈# wP_of_wstate (lnth Sts (t_C + t_Cj + t))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>any_Ck_in_wP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j ≤ k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, k) ∈# wP_of_wstate (lnth Sts (t_C + t_Cj + t))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>k</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>j_p</span><span> </span><span>j_smallest</span><span> </span><span>Suc</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Suc_ile_eq</span><span> </span><span>add.commute</span><span> </span><span>add.left_commute</span><span> </span><span>add_Suc</span><span> </span><span>less_imp_le</span><span> </span><span>plus_enat_simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>          </span><span>the_enat.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Cj_in_wP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, j) ∈# wP_of_wstate (lnth Sts (t_C + t_Cj + t))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>Suc_ile_eq</span><span> </span><span>add.commute</span><span> </span><span>add_Suc_right</span><span> </span><span>less_imp_le</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ P_of_state (state_of_wstate (lnth Sts (Suc (t_C + t_Cj + t))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t_C_p</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃k. (C, k) ∈# wP_of_wstate (lnth Sts (Suc (t_C + t_Cj + t)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Suc.prems</span><span> </span><span>Ci_in_nth_wP</span><span> </span><span>add.commute</span><span> </span><span>add.left_commute</span><span> </span><span>add_Suc_right</span><span> </span><span>enat_ord_code</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, j) ∈# wP_of_wstate (lnth Sts (Suc (t_C + t_Cj + t)))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>preserve_min_P_Sts</span><span> </span><span>Cj_in_wP</span><span> </span><span>any_Ck_in_wP</span><span> </span><span>Suc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, j) ∈# lnth (lmap wP_of_wstate Sts) (Suc (t_C + t_Cj + t))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Suc.prems</span><span> </span><span>add.commute</span><span> </span><span>add_Suc_right</span><span> </span><span>lnth_lmap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀t. t_C + t_Cj ≤ t ⟹ t &lt; llength (lmap (set_mset ∘ wP_of_wstate) Sts) ⟹
    (C, j) ∈# wP_of_wstate (lnth Sts t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ci_stays</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ - (t_C + t_Cj)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_add_diff_inverse</span><span> </span><span>llength_lmap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, j) ∈ Liminf_llist (lmap (set_mset ∘ wP_of_wstate) Sts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Liminf_llist_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>j_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. (C, i) ∈ Liminf_llist (lmap (set_mset ∘ wP_of_wstate) Sts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfinite_not_LNil_nth_llast</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lfinite Sts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sts ≠ LNil"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i &lt; llength Sts. lnth Sts i = llast Sts ∧ (∀j &lt; llength Sts. j ≤ i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>lfinite.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lfinite_LConsI</span><span> </span><span>xs</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = LNil"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>zero_enat_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>i_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enat i &lt; llength xs ∧ lnth xs i = llast xs ∧ (∀j &lt; llength xs. j ≤ enat i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lfinite_LConsI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enat (Suc i) &lt; llength (LCons x xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Suc_ile_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i_p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lnth (LCons x xs) (Suc i) = llast (LCons x xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>gr_implies_not_zero</span><span> </span><span>llast_LCons</span><span> </span><span>llength_lnull</span><span> </span><span>lnth_Suc_LCons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i_p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j &lt; llength (LCons x xs). j ≤ enat (Suc i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>antisym_conv2</span><span> </span><span>eSuc_enat</span><span> </span><span>eSuc_ile_mono</span><span> </span><span>ileI1</span><span> </span><span>iless_Suc_eq</span><span> </span><span>llength_LCons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fair_if_finite</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lfinite Sts"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fair_state_seq (lmap state_of_wstate Sts)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>unfair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ fair_state_seq (lmap state_of_wstate Sts)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_inf_from_last</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀y. ¬ llast Sts ↝<span class="hidden">⇩</span><sub>w</sub> y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fin</span><span> </span><span>full_chain_iff_chain</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span> </span><span>Sts</span><span class="delimiter">]</span><span> </span><span>full_deriv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>unfair</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"C ∈ Liminf_llist (lmap N_of_state (lmap state_of_wstate Sts))
       ∪ Liminf_llist (lmap P_of_state (lmap state_of_wstate Sts))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fair_state_seq_def</span><span> </span><span>Liminf_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i_p</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"enat i &lt; llength Sts"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀j. i ≤ j ⟹ enat j &lt; llength Sts ⟹
     C ∈ N_of_state (state_of_wstate (lnth Sts j)) ∪ P_of_state (state_of_wstate (lnth Sts j))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Liminf_llist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C_in_llast</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"C ∈ N_of_state (state_of_wstate (llast Sts)) ∪ P_of_state (state_of_wstate (llast Sts))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>l_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enat l &lt; llength Sts ∧ lnth Sts l = llast Sts ∧ (∀j &lt; llength Sts. j ≤ enat l)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fin</span><span> </span><span>lfinite_not_LNil_nth_llast</span><span> </span><span>i_p</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"C ∈ N_of_state (state_of_wstate (lnth Sts l)) ∪ P_of_state (state_of_wstate (lnth Sts l))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_p</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>i_p</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>l</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>N</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wclause multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = wN_of_wstate (llast Sts)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>P</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wclause multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P = wP_of_wstate (llast Sts)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wclause multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q = wQ_of_wstate (llast Sts)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = n_of_wstate (llast Sts)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N_of_state (state_of_wstate (llast Sts)) ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(D, j) ∈# N"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>N_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"llast Sts"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"llast Sts ↝<span class="hidden">⇩</span><sub>w</sub> (N - {#(D, j)#}, P + {#(D, j)#}, Q, n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weighted_RP.clause_processing</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"N - {#(D, j)#}"</span></span></span><span> </span><span>D</span><span> </span><span>j</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>N_def</span><span> </span><span>P_def</span><span> </span><span>Q_def</span><span> </span><span>n_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃St'. llast Sts ↝<span class="hidden">⇩</span><sub>w</sub> St'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N_of_state (state_of_wstate (llast Sts)) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N = {#}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>N_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"llast Sts"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ P_of_state (state_of_wstate (llast Sts))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_in_llast</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(D, j) ∈# P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"llast Sts"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (D, j) ∈ weight ` set_mset P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃w. is_least (λw. w ∈ (weight ` set_mset P)) w"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>least_exists</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃D j. (∀(D', j') ∈# P. weight (D, j) ≤ weight (D', j')) ∧ (D, j) ∈# P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>linorder_not_less</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_least_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>6</span><span> </span><span>0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀(D', j') ∈# P. weight (D, j) ≤ weight (D', j'))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>Dj_in_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(D, j) ∈# P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>min</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀(D', j') ∈# P - {#(D, j)#}. weight (D, j) ≤ weight (D', j'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mset_subset_diff_self</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Dj_in_p</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>N'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"N' = mset_set ((λD'. (D', n)) ` concls_of (inference_system.inferences_between (ord_FO_Γ S)
         (set_mset (image_mset fst Q)) D))"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"llast Sts ↝<span class="hidden">⇩</span><sub>w</sub> (N', {#(D', j') ∈# P - {#(D, j)#}. D' ≠ D#}, Q + {#(D,j)#}, Suc n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>weighted_RP.inference_computation</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"P - {#(D, j)#}"</span></span></span><span> </span><span>D</span><span> </span><span>j</span><span> </span><span>N'</span><span> </span><span>n</span><span> </span><span>Q</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>min</span><span> </span><span>N'_def</span><span class="delimiter">]</span><span>
</span><span>        </span><span>of_wstate_split</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"llast Sts"</span></span></span><span class="delimiter">]</span><span> </span><span>Dj_in_p</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>N_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>P_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Q_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>n_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃St'. llast Sts ↝<span class="hidden">⇩</span><sub>w</sub> St'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃St'. llast Sts ↝<span class="hidden">⇩</span><sub>w</sub> St'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_inf_from_last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>N_of_state_state_of_wstate_wN_of_wstate</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ N_of_state (state_of_wstate St)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. (C, i) ∈# wN_of_wstate St"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>N_of_state.elims</span><span> </span><span>assms</span><span> </span><span>eq_fst_iff</span><span> </span><span>fstI</span><span> </span><span>fst_conv</span><span> </span><span>image_iff</span><span> </span><span>of_wstate_split</span><span> </span><span>set_image_mset</span><span>
</span><span>      </span><span>state_of_wstate.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_wN_of_wstate_in_N_of_wstate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wN_of_wstate St ⟹ C ∈ N_of_wstate St"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_guards_query_query</span><span class="delimiter">)</span><span> </span><span>N_of_state.simps</span><span> </span><span>fst_conv</span><span> </span><span>image_eqI</span><span> </span><span>of_wstate_split</span><span>
</span><span>      </span><span>set_image_mset</span><span> </span><span>state_of_wstate.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_wP_of_wstate_in_P_of_wstate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wP_of_wstate St ⟹ C ∈ P_of_wstate St"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_guards_query_query</span><span class="delimiter">)</span><span> </span><span>P_of_state.simps</span><span> </span><span>fst_conv</span><span> </span><span>image_eqI</span><span> </span><span>of_wstate_split</span><span>
</span><span>      </span><span>set_image_mset</span><span> </span><span>state_of_wstate.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_wQ_of_wstate_in_Q_of_wstate</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈# wQ_of_wstate St ⟹ C ∈ Q_of_wstate St"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_guards_query_query</span><span class="delimiter">)</span><span> </span><span>Q_of_state.simps</span><span> </span><span>fst_conv</span><span> </span><span>image_eqI</span><span> </span><span>of_wstate_split</span><span>
</span><span>      </span><span>set_image_mset</span><span> </span><span>state_of_wstate.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>n_of_wstate_weighted_RP_increasing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"St ↝<span class="hidden">⇩</span><sub>w</sub> St' ⟹ n_of_wstate St ≤ n_of_wstate St'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>weighted_RP.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_of_wstate_monotonic</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; llength Sts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ j"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n_of_wstate (lnth Sts i) ≤ n_of_wstate (lnth Sts j)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"j - i"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = j - (i + 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n_of_wstate (lnth Sts (i + 1)) ≤ n_of_wstate (lnth Sts j)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc i &lt; llength Sts"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>le_less_Suc_eq</span><span> </span><span>less_le_trans</span><span> </span><span>not_le</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lnth Sts i ↝<span class="hidden">⇩</span><sub>w</sub> lnth Sts (Suc i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deriv</span><span> </span><span>chain_lnth_rel</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span> </span><span>Sts</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n_of_wstate (lnth Sts i) ≤ n_of_wstate (lnth Sts (i + 1))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_of_wstate_weighted_RP_increasing</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"lnth Sts i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lnth Sts (i + 1)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>infinite_chain_relation_measure</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>measure_decreasing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀St St'. P St ⟹ R St St' ⟹ (m St', m St) ∈ mR"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>non_infer_chain</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain R (ldrop (enat k) Sts)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>inf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"llength Sts = ∞"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. P (lnth (ldrop (enat k) Sts) i)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (λx y. (x, y) ∈ mR)¯¯ (lmap m (ldrop (enat k) Sts))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lnth_rel_chain</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ lnull (lmap m (ldrop (enat k) Sts))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inf</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ldrop_inf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"llength (ldrop (enat k) Sts) = ∞ ∧ ¬ lfinite (ldrop (enat k) Sts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>llength_eq_infty_conv_lfinite</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>St</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"St = lnth (ldrop (enat k) Sts) j"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>St'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"St' = lnth (ldrop (enat k) Sts) (j + 1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P St ∧ P St'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St_def</span><span> </span><span>St'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ldrop_inf</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"R St St'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St_def</span><span> </span><span>St'_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>non_infer_chain</span><span> </span><span>infinite_chain_lnth_rel</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ldrop (enat k) Sts"</span></span></span><span> </span><span>R</span><span> </span><span>j</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(m St', m St) ∈ mR"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>measure_decreasing</span><span> </span><span>P'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(lnth (lmap m (ldrop (enat k) Sts)) (j + 1), lnth (lmap m (ldrop (enat k) Sts)) j)
      ∈ mR"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>St_def</span><span> </span><span>St'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lnth_lmap</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>enat.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>enat_add_left_cancel</span><span> </span><span>enat_ord_simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>inf</span><span> </span><span>ldrop_lmap</span><span> </span><span>llength_lmap</span><span>
</span><span>          </span><span>lnth_ldrop</span><span> </span><span>plus_enat_simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j. enat (j + 1) &lt; llength (lmap m (ldrop (enat k) Sts)) ⟶
    (λx y. (x, y) ∈ mR)¯¯ (lnth (lmap m (ldrop (enat k) Sts)) j)
      (lnth (lmap m (ldrop (enat k) Sts)) (j + 1))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>weighted_RP_fair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fair_state_seq (lmap state_of_wstate Sts)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ fair_state_seq (lmap state_of_wstate Sts)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ lfinite Sts"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fair_if_finite</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"llength Sts = ∞"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>llength_eq_infty_conv_lfinite</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asm</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"C ∈ Liminf_llist (lmap N_of_state (lmap state_of_wstate Sts))
       ∪ Liminf_llist (lmap P_of_state (lmap state_of_wstate Sts))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fair_state_seq_def</span><span> </span><span>Liminf_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ Liminf_llist (lmap N_of_state (lmap state_of_wstate Sts))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enat x &lt; llength Sts"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀xa. x ≤ xa ∧ enat xa &lt; llength Sts ⟶ C ∈ N_of_state (state_of_wstate (lnth Sts xa))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Liminf_llist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃k. ∀j. k ≤ j ⟶ (∃i. (C, i) ∈# wN_of_wstate (lnth Sts j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Liminf_llist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inf</span><span> </span><span>N_of_state_state_of_wstate_wN_of_wstate</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k_p</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⋀j. k ≤ j ⟹ ∃i. (C, i) ∈# wN_of_wstate (lnth Sts j)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Liminf_llist_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>chain_drop_Sts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (↝<span class="hidden">⇩</span><sub>w</sub>) (ldrop k Sts)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deriv</span><span> </span><span>inf</span><span> </span><span>inff</span><span> </span><span>inf_chain_ldrop_chain</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_N_j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀j. ∃i. (C, i) ∈# wN_of_wstate (lnth (ldrop k Sts) j)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.commute</span><span> </span><span>inf</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (λx y. (x, y) ∈ RP_filtered_relation)¯¯ (lmap (RP_filtered_measure (λCi. True))
      (ldrop k Sts))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inff</span><span> </span><span>inf</span><span> </span><span>weighted_RP_measure_decreasing_N</span><span> </span><span>chain_drop_Sts</span><span>
</span><span>        </span><span>infinite_chain_relation_measure</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λSt. ∃i. (C, i) ∈# wN_of_wstate St"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wfP_iff_no_infinite_down_chain_llist</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx y. (x, y) ∈ RP_filtered_relation"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>wf_RP_filtered_relation</span><span> </span><span>inff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>inf_llist_lnth</span><span> </span><span>ldrop_enat_inf_llist</span><span> </span><span>lfinite_inf_llist</span><span>
</span><span>        </span><span>lfinite_lmap</span><span> </span><span>wfPUNIVI</span><span> </span><span>wf_induct_rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ Liminf_llist (lmap P_of_state (lmap state_of_wstate Sts))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asm</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i_p</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"enat i &lt; llength Sts"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⋀j. i ≤ j ∧ enat j &lt; llength Sts ⟹ C ∈ P_of_state (state_of_wstate (lnth Sts j))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Liminf_llist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈ Liminf_llist (lmap (set_mset ∘ wP_of_wstate) Sts)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>persistent_wclause_in_P_if_persistent_clause_in_P</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span>inf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃l. ∀k ≥ l. (C, i) ∈ (set_mset ∘ wP_of_wstate) (lnth Sts k)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Liminf_llist_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inff</span><span> </span><span>inf</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k_p</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(∀k'≥k. (C, i) ∈ (set_mset ∘ wP_of_wstate) (lnth Sts k'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Ci_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k'. (C, i) ∈ (set_mset ∘ wP_of_wstate) (lnth (ldrop k Sts) k')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_p</span><span> </span><span>lnth_ldrop</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span> </span><span>_</span><span> </span><span>Sts</span><span class="delimiter">]</span><span> </span><span>inf</span><span> </span><span>inff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Ci_inn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k'. (C, i) ∈# (wP_of_wstate) (lnth (ldrop k Sts) k')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (↝<span class="hidden">⇩</span><sub>w</sub>) (ldrop k Sts)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deriv</span><span> </span><span>inf_chain_ldrop_chain</span><span> </span><span>inf</span><span> </span><span>inff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"chain (λx y. (x, y) ∈ RP_combined_relation)¯¯
      (lmap (RP_combined_measure (weight (C, i))) (ldrop k Sts))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inff</span><span> </span><span>inf</span><span> </span><span>Ci_in</span><span> </span><span>weighted_RP_measure_decreasing_P</span><span>
</span><span>        </span><span>infinite_chain_relation_measure</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λSt. (C, i) ∈# wP_of_wstate St"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"RP_combined_measure (weight (C, i))"</span></span></span><span> </span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wfP_iff_no_infinite_down_chain_llist</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx y. (x, y) ∈ RP_combined_relation"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span>wf_RP_combined_relation</span><span> </span><span>inff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>inf_llist_lnth</span><span> </span><span>ldrop_enat_inf_llist</span><span> </span><span>lfinite_inf_llist</span><span> </span><span>lfinite_lmap</span><span> </span><span>wfPUNIVI</span><span>
</span><span>          </span><span>wf_induct_rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>weighted_RP_saturated</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"src.saturated_upto (Liminf_llist (lmap grounding_of_wstate Sts))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>RP_saturated_if_fair</span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv_RP</span><span> </span><span>empty_Q0_RP</span><span> </span><span>weighted_RP_fair</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>llist.map_comp</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>weighted_RP_complete</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ satisfiable (grounding_of_wstate (lhd Sts)) ⟹ {#} ∈ Q_of_state (Liminf_wstate Sts)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>RP_complete_if_fair</span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv_RP</span><span> </span><span>empty_Q0_RP</span><span> </span><span>weighted_RP_fair</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>lhd_lmap_Sts</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>weighted_FO_resolution_prover_with_size_timestamp_factors</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>FO_resolution_prover</span><span> </span><span>S</span><span> </span><span>subst_atm</span><span> </span><span>id_subst</span><span> </span><span>comp_subst</span><span> </span><span>renamings_apart</span><span> </span><span>atm_of_atms</span><span> </span><span>mgu</span><span> </span><span>less_atm</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>    </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a :: wellorder) clause ⇒ 'a clause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>subst_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 's ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>id_subst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>comp_subst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ 's ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>renamings_apart</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a literal multiset list ⇒ 's list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>atm_of_atms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>mgu</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 's option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>less_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>size_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>size_factor</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>timestamp_factor</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>timestamp_factor_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"timestamp_factor &gt; 0"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>weight</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wclause ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"weight (C, i) = size_factor * size_multiset (size_literal size_atm) C + timestamp_factor * i"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>weight_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; j ⟹ weight (C, i) &lt; weight (C, j)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>timestamp_factor_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>weight.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">sublocale</span></span><span> </span><span>wrp</span><span class="delimiter">:</span><span> </span><span>weighted_FO_resolution_prover</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>weight</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>weight_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>wrp.weighted_RP</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↝<span class="hidden">⇩</span><sub>w</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Deterministic_FO_Ordered_Resolution_Prover">
<div class="head"><h1>Theory Deterministic_FO_Ordered_Resolution_Prover</h1>
<span class="command">theory</span> <span class="name">Deterministic_FO_Ordered_Resolution_Prover</span><br/>
<span class="keyword">imports</span> <a href="Missing_List.html"><span class="name">Missing_List</span></a> <a href="Weighted_FO_Ordered_Resolution_Prover.html"><span class="name">Weighted_FO_Ordered_Resolution_Prover</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       A Deterministic Ordered Resolution Prover for First-Order Clauses
    Author:      Jasmin Blanchette &lt;j.c.blanchette at vu.nl&gt;, 2017
    Author:      Anders Schlichtkrull &lt;andschl at dtu.dk&gt;, 2018
    Maintainer:  Anders Schlichtkrull &lt;andschl at dtu.dk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A Deterministic Ordered Resolution Prover for First-Order Clauses›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The ‹deterministic_RP› prover introduced below is a deterministic program that works on finite
lists, committing to a strategy for assigning priorities to clauses. However, it is not fully
executable: It abstracts over operations on atoms and employs logical specifications instead of
executable functions for auxiliary notions.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Deterministic_FO_Ordered_Resolution_Prover</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Polynomial_Factorization.Missing_List</span><span> </span><span>Weighted_FO_Ordered_Resolution_Prover</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Library›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>apfst_fst_snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"apfst f x = (f (fst x), snd x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>apfst_conv</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>prod.collapse</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>apfst_comp_rpair_const</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"apfst f ∘ (λx. (x, y)) = (λx. (x, y)) ∘ f"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to Isabelle's "List.thy"? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_remove1_less</span><span class="delimiter">[</span><span>termination_simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set xs ⟹ length (remove1 x xs) &lt; length xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to "Multiset_More.thy". *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subset_mset_imp_subset_add_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⊆# B ⟹ A ⊆# add_mset x B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mset_diff_bothsides</span><span> </span><span>diff_subset_eq_self</span><span> </span><span>multiset_inter_def</span><span> </span><span>subset_mset.inf.absorb2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to "Multiset_More.thy"? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseq_mset_subseteq_mset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subseq xs ys ⟹ mset xs ⊆# mset ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Outer_Cons</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>y</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subseq xs ys"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>subseq_Cons'</span><span> </span><span>subseq_Cons2_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mset.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>mset_subset_eq_add_mset_cancel</span><span> </span><span>subseq_Cons2_iff</span><span>
</span><span>          </span><span>subset_mset_imp_subset_add_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_filter_neq_eq_filter_map</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map f (filter (λy. f x ≠ f y) xs) = filter (λz. f x ≠ z) (map f xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_map_remdups_gen</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mset (map f (remdups_gen f xs)) = mset (remdups_gen (λx. x) (map f xs))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>f</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>remdups_gen.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>map_filter_neq_eq_filter_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_remdups_gen_ident</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (remdups_gen (λx. x) xs) = mset_set (set xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f = (λx. x) ⟹ mset (remdups_gen f xs) = mset_set (set xs)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>f</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>remdups_gen.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>f</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>f</span><span> </span><span>remdups_gen.simps</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>f</span><span class="delimiter">]</span><span> </span><span>mset.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>finite_set</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>15</span><span class="delimiter">)</span><span> </span><span>mset_set.insert_remove</span><span> </span><span>removeAll_filter_not_eq</span><span>
</span><span>          </span><span>remove_code</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>remove_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME: This is a clone of "Lambda_Free_RPOs". *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wf r ⟹ wf {(x, y). (f x, f y) ∈ r}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wf_eq_minimal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>spec</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"f ` Q"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Q</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>fast</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME: This is a clone of "Lambda_Free_RPOs". *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wfP_app</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP p ⟹ wfP (λx y. p (f x) (f y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_app</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(x, y). p x y}"</span></span></span><span> </span><span>f</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Move to Isabelle? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>funpow_fixpoint</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"f x = x ⟹ (f ^^ n) x = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rtranclp_imp_eq_image</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x y. R x y ⟶ f x = f y) ⟹ R<span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup> x y ⟹ f x = f y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtranclp.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tranclp_imp_eq_image</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x y. R x y ⟶ f x = f y) ⟹ R<span class="hidden">⇧</span><sup>+</sup><span class="hidden">⇧</span><sup>+</sup> x y ⟹ f x = f y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>tranclp.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Prover›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>lclause</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a literal list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>dclause</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause × nat"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>dstate</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause list × 'a dclause list × 'a dclause list × nat"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>deterministic_FO_resolution_prover</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>weighted_FO_resolution_prover_with_size_timestamp_factors</span><span> </span><span>S</span><span> </span><span>subst_atm</span><span> </span><span>id_subst</span><span> </span><span>comp_subst</span><span>
</span><span>    </span><span>renamings_apart</span><span> </span><span>atm_of_atms</span><span> </span><span>mgu</span><span> </span><span>less_atm</span><span> </span><span>size_atm</span><span> </span><span>timestamp_factor</span><span> </span><span>size_factor</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span>
</span><span>    </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a :: wellorder) clause ⇒ 'a clause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>subst_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 's ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>id_subst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>comp_subst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ 's ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>renamings_apart</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a literal multiset list ⇒ 's list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>atm_of_atms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>mgu</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set set ⇒ 's option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>less_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>size_atm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>timestamp_factor</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>size_factor</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>S_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S C = {#}"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>less_atm_irrefl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ less_atm A A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex_ground_subst</span><span> </span><span>less_atm_ground</span><span> </span><span>less_atm_stable</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_ground_subst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>wstate_of_dstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dstate ⇒ 'a wstate"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P, Q, n) =
   (mset (map (apfst mset) N), mset (map (apfst mset) P), mset (map (apfst mset) Q), n)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>state_of_dstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dstate ⇒ 'a state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"state_of_dstate (N, P, Q, _) =
   (set (map (mset ∘ fst) N), set (map (mset ∘ fst) P), set (map (mset ∘ fst) Q))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>clss_of_dstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dstate ⇒ 'a clause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"clss_of_dstate St ≡ clss_of_state (state_of_dstate St)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_final_dstate</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dstate ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_final_dstate (N, P, Q, n) ⟷ N = [] ∧ P = []"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>is_final_dstate.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>rtrancl_weighted_RP</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup>) ≡ (↝<span class="hidden">⇩</span><sub>w</sub>)<span class="hidden">⇧</span><sup>*</sup><span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>trancl_weighted_RP</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>+</sup>) ≡ (↝<span class="hidden">⇩</span><sub>w</sub>)<span class="hidden">⇧</span><sup>+</sup><span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_tautology</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_tautology C ⟷ (∃A ∈ set (map atm_of C). Pos A ∈ set C ∧ Neg A ∈ set C)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>subsume</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause list ⇒ 'a lclause ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subsume Ds C ⟷ (∃D ∈ set Ds. subsumes (mset D) (mset C))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>strictly_subsume</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause list ⇒ 'a lclause ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strictly_subsume Ds C ⟷ (∃D ∈ set Ds. strictly_subsumes (mset D) (mset C))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_reducible_on</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a literal ⇒ 'a lclause ⇒ 'a literal ⇒ 'a lclause ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_reducible_on M D L C ⟷ subsumes (mset D + {#- M#}) (mset C + {#L#})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_reducible_lit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause list ⇒ 'a lclause ⇒ 'a literal ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_reducible_lit Ds C L ⟷
   (∃D ∈ set Ds. ∃L' ∈ set D. ∃σ. - L = L' ⋅l σ ∧ mset (remove1 L' D) ⋅ σ ⊆# mset C)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>reduce</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause list ⇒ 'a lclause ⇒ 'a lclause ⇒ 'a lclause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reduce _ _ [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"reduce Ds C (L # C') =
   (if is_reducible_lit Ds (C @ C') L then reduce Ds C C' else L # reduce Ds (L # C) C')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>is_irreducible</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause list ⇒ 'a lclause ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_irreducible Ds C ≡ reduce Ds [] C = C"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>is_reducible</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause list ⇒ 'a lclause ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_reducible Ds C ≡ reduce Ds [] C ≠ C"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>reduce_all</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause ⇒ 'a dclause list ⇒ 'a dclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reduce_all D = map (apfst (reduce [D] []))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>reduce_all2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause ⇒ 'a dclause list ⇒ 'a dclause list × 'a dclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reduce_all2 _ [] = ([], [])"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"reduce_all2 D (Ci # Cs) =
   (let
      (C, i) = Ci;
      C' = reduce [D] [] C
    in
      (if C' = C then apsnd else apfst) (Cons (C', i)) (reduce_all2 D Cs))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>remove_all</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b list ⇒ 'b list ⇒ 'b list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remove_all xs [] = xs"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"remove_all xs (y # ys) = (if y ∈ set xs then remove_all (remove1 y xs) ys else remove_all xs ys)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_all_mset_minus</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset ys ⊆# mset xs ⟹ mset (remove_all xs ys) = mset xs - mset ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>ys</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>y</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ set xs"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>y_in</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset ys ⊆# mset (remove1 y xs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_subset_eq_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y_in</span><span> </span><span>Cons</span><span> </span><span>subs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>resolvent</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause ⇒ 'a ⇒'a lclause ⇒ 'a lclause ⇒ 'a lclause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"resolvent D A CA Ls =
   map (λM. M ⋅l (the (mgu {insert A (atms_of (mset Ls))}))) (remove_all CA Ls @ D)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>resolvable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a lclause ⇒ 'a lclause ⇒ 'a lclause ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"resolvable A D CA Ls ⟷
   (let σ = (mgu {insert A (atms_of (mset Ls))}) in
        σ ≠ None
      ∧ Ls ≠ []
      ∧ maximal_wrt (A ⋅a the σ) ((add_mset (Neg A) (mset D)) ⋅ the σ)
      ∧ strictly_maximal_wrt (A ⋅a the σ) ((mset CA - mset Ls) ⋅ the σ)
      ∧ (∀L ∈ set Ls. is_pos L))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>resolve_on</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a lclause ⇒ 'a lclause ⇒ 'a lclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"resolve_on A D CA = map (resolvent D A CA) (filter (resolvable A D CA) (subseqs CA))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>resolve</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause ⇒ 'a lclause ⇒ 'a lclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"resolve C D =
   concat (map (λL.
     (case L of
        Pos A ⇒ []
      | Neg A ⇒
        if maximal_wrt A (mset D) then
          resolve_on A (remove1 L D) C
        else
          [])) D)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>resolve_rename</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause ⇒ 'a lclause ⇒ 'a lclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"resolve_rename C D =
   (let σs = renamings_apart [mset D, mset C] in
      resolve (map (λL. L ⋅l last σs) C) (map (λL. L ⋅l hd σs) D))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>resolve_rename_either_way</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause ⇒ 'a lclause ⇒ 'a lclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"resolve_rename_either_way C D = resolve_rename C D @ resolve_rename D C"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>select_min_weight_clause</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause ⇒ 'a dclause list ⇒ 'a dclause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"select_min_weight_clause Ci [] = Ci"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"select_min_weight_clause Ci (Dj # Djs) =
   select_min_weight_clause
     (if weight (apfst mset Dj) &lt; weight (apfst mset Ci) then Dj else Ci) Djs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>select_min_weight_clause_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"select_min_weight_clause P0 P ∈ set (P0 # P)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>P</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P0</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>remdups_clss</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause list ⇒ 'a dclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"remdups_clss [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_clss (Ci # Cis) =
   (let
      Ci' = select_min_weight_clause Ci Cis
    in
      Ci' # remdups_clss (filter (λ(D, _). mset D ≠ mset (fst Ci')) (Ci # Cis)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure length"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_measure</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">)</span><span> </span><span>in_measure</span><span> </span><span>length_filter_less</span><span> </span><span>prod.case_eq_if</span><span> </span><span>select_min_weight_clause_in</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>remdups_clss.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>deterministic_RP_step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dstate ⇒ 'a dstate"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deterministic_RP_step (N, P, Q, n) =
   (if ∃Ci ∈ set (P @ Q). fst Ci = [] then
      ([], [], remdups_clss P @ Q, n + length (remdups_clss P))
    else
      (case N of
        [] ⇒
        (case P of
           [] ⇒ (N, P, Q, n)
         | P0 # P' ⇒
           let
             (C, i) = select_min_weight_clause P0 P';
             N = map (λD. (D, n)) (remdups_gen mset (resolve_rename C C
               @ concat (map (resolve_rename_either_way C ∘ fst) Q)));
             P = filter (λ(D, j). mset D ≠ mset C) P;
             Q = (C, i) # Q;
             n = Suc n
           in
             (N, P, Q, n))
      | (C, i) # N ⇒
        let
          C = reduce (map fst (P @ Q)) [] C
        in
          if C = [] then
            ([], [], [([], i)], Suc n)
          else if is_tautology C ∨ subsume (map fst (P @ Q)) C then
            (N, P, Q, n)
          else
            let
              P = reduce_all C P;
              (back_to_P, Q) = reduce_all2 C Q;
              P = back_to_P @ P;
              Q = filter (Not ∘ strictly_subsume [C] ∘ fst) Q;
              P = filter (Not ∘ strictly_subsume [C] ∘ fst) P;
              P = (C, i) # P
            in
              (N, P, Q, n)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>deterministic_RP_step.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">partial_function</span></span><span> </span><span class="delimiter">(</span><span>option</span><span class="delimiter">)</span><span> </span><span>deterministic_RP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dstate ⇒ 'a lclause list option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deterministic_RP St =
   (if is_final_dstate St then
      let (_, _, Q, _) = St in Some (map fst Q)
    else
      deterministic_RP (deterministic_RP_step St))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_final_dstate_imp_not_weighted_RP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_final_dstate St ⟹ ¬ wstate_of_dstate St ↝<span class="hidden">⇩</span><sub>w</sub> St'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrp.final_weighted_RP</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>St</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>wrp.final_weighted_RP</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_final_dstate.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_final_dstate_funpow_imp_deterministic_RP_neq_None</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_final_dstate ((deterministic_RP_step ^^ k) St) ⟹ deterministic_RP St ≠ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>St</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>final_Sk</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>funpow_swap1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>final_Sk</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>deterministic_RP.simps</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>deterministic_RP.simps</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_reducible_lit_mono_cls</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mset C ⊆# mset C' ⟹ is_reducible_lit Ds C L ⟹ is_reducible_lit Ds C' L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_reducible_lit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>subset_mset.order.trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_reducible_lit_mset_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mset C = mset C' ⟹ is_reducible_lit Ds C' L ⟷ is_reducible_lit Ds C L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>is_reducible_lit_mono_cls</span><span> </span><span>subset_mset.order_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_reducible_lit_remove1_Cons_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ∈ set C'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_reducible_lit Ds (C @ remove1 L (M # C')) L ⟷
    is_reducible_lit Ds (M # C @ remove1 L C') L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>is_reducible_lit_mset_iff</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reduce_mset_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset C = mset C' ⟹ reduce Ds C E = reduce Ds C' E"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>E</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span> </span><span>C'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>L</span><span> </span><span>E</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mset_eq</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span>mset_lc_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (L # C) = mset (L # C')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>mset_ce_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (C @ E) = mset (C' @ E)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mset_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mset_eq</span><span class="delimiter">]</span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mset_lc_eq</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_reducible_lit_mset_iff</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mset_ce_eq</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reduce_rotate</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reduce Ds (C @ [L]) E = reduce Ds (L # C) E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduce_mset_eq</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mset_reduce_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (reduce Ds C E) ⊆# mset E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>E</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>subset_mset_imp_subset_add_mset</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reduce_idem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reduce Ds C (reduce Ds C E) = reduce Ds C E"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>E</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>mset_reduce_subset</span><span>
</span><span>      </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>is_reducible_lit_mono_cls</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"C @ reduce Ds (L # C) E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C @ E"</span></span></span><span> </span><span>Ds</span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>E</span><span> </span><span>C</span><span class="delimiter">,</span><span>
</span><span>        </span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_reducible_lit_imp_is_reducible</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"L ∈ set C' ⟹ is_reducible_lit Ds (C @ remove1 L C') L ⟹ reduce Ds C C' ≠ C'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>M</span><span> </span><span>C'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l_in</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l_red</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_reducible_lit Ds (C @ C') M"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mset.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>mset_reduce_subset</span><span> </span><span>multi_self_add_other_not_self</span><span>
</span><span>          </span><span>subset_mset.eq_iff</span><span> </span><span>subset_mset_imp_subset_add_mset</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>m_irred</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"L ∈ set C'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_reducible_lit Ds (M # C @ remove1 L C') L"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l_in</span><span> </span><span>l_red</span><span> </span><span>m_irred</span><span> </span><span>is_reducible_lit_remove1_Cons_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"M # C"</span></span></span><span class="delimiter">]</span><span> </span><span>m_irred</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_reducible_imp_is_reducible_lit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reduce Ds C C' ≠ C' ⟹ ∃L ∈ set C'. is_reducible_lit Ds (C @ remove1 L C') L"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>M</span><span> </span><span>C'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mc'_red</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_reducible_lit Ds (C @ C') M"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>m_irred</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"M # C"</span></span></span><span class="delimiter">]</span><span> </span><span>mc'_red</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>m_irred</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>m_irred</span><span>
</span><span>        </span><span>is_reducible_lit_remove1_Cons_iff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_irreducible_iff_nexists_is_reducible_lit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reduce Ds C C' = C' ⟷ ¬ (∃L ∈ set C'. is_reducible_lit Ds (C @ remove1 L C') L)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_reducible_imp_is_reducible_lit</span><span> </span><span>is_reducible_lit_imp_is_reducible</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_irreducible_mset_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset E = mset E' ⟹ reduce Ds C E = E ⟷ reduce Ds C E' = E'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_irreducible_iff_nexists_is_reducible_lit</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>is_reducible_lit_mset_iff</span><span> </span><span>mset_remove1</span><span> </span><span>set_mset_mset</span><span> </span><span>union_code</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>select_min_weight_clause_min_weight</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ci = select_min_weight_clause P0 P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (apfst mset Ci) = Min ((weight ∘ apfst mset) ` set (P0 # P))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>P</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P0</span><span> </span><span>Ci</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>P1</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ci</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"weight (apfst mset P1) &lt; weight (apfst mset P0)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Min ((weight ∘ apfst mset) ` set (P0 # P1 # P)) =
      Min ((weight ∘ apfst mset) ` set (P1 # P))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>min_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>Ci</span><span> </span><span>P1</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>Ci</span><span> </span><span>P1</span><span class="delimiter">]</span><span> </span><span>ci</span><span> </span><span>True</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Min ((weight ∘ apfst mset) ` set (P0 # P1 # P)) =
      Min ((weight ∘ apfst mset) ` set (P1 # P0 # P))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>Min</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Min ((weight ∘ apfst mset) ` set (P0 # P1 # P)) =
      Min ((weight ∘ apfst mset) ` set (P0 # P))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>min_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>use</span><span> </span><span>False</span><span> </span><span>eq_iff</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>Ci</span><span> </span><span>P0</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>Ci</span><span> </span><span>P1</span><span class="delimiter">]</span><span> </span><span>ci</span><span> </span><span>False</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remdups_clss_Nil_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"remdups_clss Cs = [] ⟷ Cs = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Cs</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>hypsubst</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>remdups_clss.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_N_if_Nil_in_P_or_Q</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>nil_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[] ∈ fst ` set (P @ Q)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ([], P, Q, n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>N0</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N0 # N, P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate (N, P, Q, n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>          </span><span>wrp.forward_subsumption</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) P)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) Q)"</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"mset (fst N0)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) N)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd N0"</span></span></span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>use</span><span> </span><span>nil_in</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹force simp: image_def apfst_fst_snd›</span></span></span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_strictly_subsumed_clauses_in_P</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>c_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ fst ` set N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p_nsubs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀D ∈ fst ` set P. ¬ strictly_subsume [C] D"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P @ P', Q, n)
    ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (N, P @ filter (Not ∘ strictly_subsume [C] ∘ fst) P', Q, n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_nsubs</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"length P'"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P</span><span> </span><span>P'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>less</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p_nsubs</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"length P'"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Dj</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd P'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P''</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl P'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P' = hd P' # tl P'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_Suc_conv</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.exhaust_sel</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"strictly_subsume [C] (fst ?Dj)"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>subs</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p_filtered</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#(E, k) ∈# image_mset (apfst mset) (mset P). E ≠ mset (fst ?Dj)#} =
        image_mset (apfst mset) (mset P)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>filter_mset_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λ_. True"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>            </span><span>use</span><span> </span><span>subs</span><span> </span><span>p_nsubs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auto simp: strictly_subsume_def›</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#(E, k) ∈# image_mset (apfst mset) (mset P'). E ≠ mset (fst ?Dj)#} =
        {#(E, k) ∈# image_mset (apfst mset) (mset ?P''). E ≠ mset (fst ?Dj)#}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>p'</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… =
        image_mset (apfst mset) (mset (filter (λ(E, l). mset E ≠ mset (fst ?Dj)) ?P''))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_mset_filter_swap</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>mset_filter</span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p'_filtered</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"{#(E, k) ∈# image_mset (apfst mset) (mset P'). E ≠ mset (fst ?Dj)#} =
        image_mset (apfst mset) (mset (filter (λ(E, l). mset E ≠ mset (fst ?Dj)) ?P''))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P @ P', Q, n)
        ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate (N, P @ filter (λ(E, l). mset E ≠ mset (fst ?Dj)) ?P'', Q, n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>              </span><span>wrp.backward_subsumption_P</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset C"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) N)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (fst ?Dj)"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) (P @ P'))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) Q)"</span></span></span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>          </span><span>use</span><span> </span><span>c_in</span><span> </span><span>subs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auto simp add: p_filtered p'_filtered arg_cong[OF p', of set]
            strictly_subsume_def›</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"…
        ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (N, P @ filter (Not ∘ strictly_subsume [C] ∘ fst) P', Q, n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>              </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (λ(E, l). mset E ≠ mset (fst ?Dj)) ?P''"</span></span></span><span> </span><span>P</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>p'</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subs</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. image_mset (apfst mset) x"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>strictly_subsume_def</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>p'</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>list.size</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>less_Suc0</span><span> </span><span>less_add_same_cancel1</span><span> </span><span>linorder_neqE_nat</span><span>
</span><span>            </span><span>not_add_less1</span><span> </span><span>sum_length_filter_compl</span><span> </span><span>trans_less_add1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_nsubs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>nsubs</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>              </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P''</span><span> </span><span class="string"><span class="delete"><span class="delete">"P @ [?Dj]"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nsubs</span><span> </span><span>p_nsubs</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p'</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>mset</span><span class="delimiter">]</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>p'</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>f</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>p'</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>remove_strictly_subsumed_clauses_in_Q</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ fst ` set N"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P, Q @ Q', n)
    ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (N, P, Q @ filter (Not ∘ strictly_subsume [C] ∘ fst) Q', n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Q'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>Dj</span><span> </span><span>Q'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P, Q @ Dj # Q', n) ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup>
    wstate_of_dstate (N, P, Q @ filter (Not ∘ strictly_subsume [C] ∘ fst) [Dj] @ Q', n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"strictly_subsume [C] (fst Dj)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>subs</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P, Q @ Dj # Q', n) ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate (N, P, Q @ Q', n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>            </span><span>wrp.backward_subsumption_Q</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset C"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) N)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (fst Dj)"</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) P)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) (Q @ Q'))"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd Dj"</span></span></span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>use</span><span> </span><span>c_in</span><span> </span><span>subs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auto simp: apfst_fst_snd strictly_subsume_def›</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q @ filter (Not ∘ strictly_subsume [C] ∘ fst) [Dj]"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reduce_clause_in_P</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>c_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ fst ` set N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p_irred</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(E, k) ∈ set (P @ P'). k &gt; j ⟶ is_irreducible [C] E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)
    ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (N, P @ (D @ reduce [C] D D', j) # P', Q, n)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>D'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ih</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>L</span><span> </span><span>D'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_reducible_lit [C] (D @ D') L"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>l_red</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a literal"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>l'_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L' ∈ set C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>not_l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"- L = L' ⋅l σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (remove1 L' C) ⋅ σ ⊆# mset (D @ D')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_reducible_lit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ldd'_red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_reducible [C] (L # D @ D')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_reducible_lit_imp_is_reducible</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l_red</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lt_imp_neq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(E, k) ∈ set (P @ P'). j &lt; k ⟶ mset E ≠ mset (L # D @ D')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_irred</span><span> </span><span>ldd'_red</span><span> </span><span>is_irreducible_mset_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P @ (D @ L # D', j) # P', Q, n)
      ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate (N, P @ (D @ D', j) # P', Q, n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>            </span><span>wrp.backward_reduction_P</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset C - {#L'#}"</span></span></span><span> </span><span>L'</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) N)"</span></span></span><span> </span><span>L</span><span> </span><span>σ</span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"mset (D @ D')"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) (P @ P'))"</span></span></span><span> </span><span>j</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) Q)"</span></span></span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l'_in</span><span> </span><span>not_l</span><span> </span><span>subs</span><span> </span><span>c_in</span><span> </span><span>lt_imp_neq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>D</span><span class="delimiter">]</span><span> </span><span>l_red</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"D @ [L]"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reduce_clause_in_Q</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>c_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ fst ` set N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p_irred</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(E, k) ∈ set P. k &gt; j ⟶ is_irreducible [C] E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>d'_red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reduce [C] D D' ≠ D'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P, Q @ (D @ D', j) # Q', n)
    ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (N, (D @ reduce [C] D D', j) # P, Q @ Q', n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d'_red</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>D'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>L</span><span> </span><span>D'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ld'_red</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_reducible_lit [C] (D @ D') L"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>l_red</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a literal"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>l'_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L' ∈ set C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>not_l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"- L = L' ⋅l σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (remove1 L' C) ⋅ σ ⊆# mset (D @ D')"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_reducible_lit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P, Q @ (D @ L # D', j) # Q', n)
      ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate (N, (D @ D', j) # P, Q @ Q', n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>            </span><span>wrp.backward_reduction_Q</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset C - {#L'#}"</span></span></span><span> </span><span>L'</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) N)"</span></span></span><span> </span><span>L</span><span> </span><span>σ</span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"mset (D @ D')"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) P)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) (Q @ Q'))"</span></span></span><span> </span><span>j</span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>          </span><span>use</span><span> </span><span>l'_in</span><span> </span><span>not_l</span><span> </span><span>subs</span><span> </span><span>c_in</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l_red</span><span> </span><span>p_irred</span><span> </span><span>reduce_clause_in_P</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c_in</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span>P</span><span> </span><span>j</span><span> </span><span>D</span><span> </span><span>D'</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q @ Q'"</span></span></span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>l_nred</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d'_red</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reduce [C] (D @ [L]) D' ≠ D'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ld'_red</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>d'_red</span><span class="delimiter">]</span><span> </span><span>l_nred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reduce_clauses_in_P</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>c_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ fst ` set N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p_irred</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(E, k) ∈ set P. is_irreducible [C] E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P @ P', Q, n) ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (N, P @ reduce_all C P', Q, n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reduce_all_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_irred</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"length P'"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P</span><span> </span><span>P'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>suc_l</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p_irred</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p'_nnil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P' ≠ []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>j</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"j = Max (snd ` set P')"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Dj</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>dj_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Dj ∈ set P'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>snd_dj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd Dj = j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Max_in</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd ` set P'"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>image_def</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>image_def</span><span> </span><span>j_def</span><span> </span><span>length_Suc_conv</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>suc_l</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k ∈ snd ` set P'. k ≤ j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>j_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p'_nnil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>j_max</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(E, k) ∈ set P'. j ≥ k"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P1'</span><span> </span><span>P2'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause list"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>p'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P' = P1' @ Dj # P2'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dj_in</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P @ P1' @ Dj # P2', Q, n)
     ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>surjective_pairing</span><span class="delimiter">[</span><span>of</span><span> </span><span>Dj</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>snd_dj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>apfst_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduce_clause_in_P</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>append_Nil</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>c_in</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_irred</span><span> </span><span>j_max</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>p'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P @ P1' @ apfst (reduce [C] []) Dj # P2', Q, n)
     ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (N, P @ map (apfst (reduce [C] [])) (P1' @ Dj # P2'), Q, n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>          </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"P1' @ P2'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"apfst (reduce [C] []) Dj # P"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_l</span><span> </span><span>reduce_idem</span><span> </span><span>p_irred</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reduce_clauses_in_Q</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>c_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ fst ` set N"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p_irred</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(E, k) ∈ set P. is_irreducible [C] E"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P, Q @ Q', n)
    ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (N, fst (reduce_all2 C Q') @ P, Q @ snd (reduce_all2 C Q'), n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_irred</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Q'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>Dj</span><span> </span><span>Q'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p_irred</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_irreducible [C] (fst Dj)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q @ [Dj]"</span></span></span><span class="delimiter">]</span><span> </span><span>p_irred</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>d_red</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P, Q @ Dj # Q', n)
      ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (N, (reduce [C] [] (fst Dj), snd Dj) # P, Q @ Q', n)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_irred</span><span> </span><span>reduce_clause_in_Q</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>P</span><span> </span><span class="string"><span class="delete"><span class="delete">"snd Dj"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span>_</span><span> </span><span>Q</span><span> </span><span>Q'</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>c_in</span><span> </span><span>_</span><span> </span><span>d_red</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Dj</span><span class="delimiter">)</span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(reduce [C] [] (fst Dj), snd Dj) # P"</span></span></span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span>d_red</span><span> </span><span>p_irred</span><span> </span><span>reduce_idem</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eligible_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eligible S σ As DA ⟷ As = [] ∨ length As = 1 ∧ maximal_wrt (hd As ⋅a σ) (DA ⋅ σ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eligible.simps</span><span> </span><span>S_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>hd_conv_nth</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_resolve_one_side_prem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ord_resolve S CAs DA AAs As σ E ⟹ length CAs = 1 ∧ length AAs = 1 ∧ length As = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ord_resolve.cases</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eligible_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_resolve_rename_one_side_prem</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ord_resolve_rename S CAs DA AAs As σ E ⟹ length CAs = 1 ∧ length AAs = 1 ∧ length As = 1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>ord_resolve_rename.cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ord_resolve_one_side_prem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Bin_ord_resolve</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause ⇒ 'a clause ⇒ 'a clause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Bin_ord_resolve C D ≡ {E. ∃AA A σ. ord_resolve S [C] D [AA] [A] σ E}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Bin_ord_resolve_rename</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause ⇒ 'a clause ⇒ 'a clause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Bin_ord_resolve_rename C D ≡ {E. ∃AA A σ. ord_resolve_rename S [C] D [AA] [A] σ E}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resolve_on_eq_UNION_Bin_ord_resolve</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mset ` set (resolve_on A D CA) =
   {E. ∃AA σ. ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] σ E}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>E</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a literal list"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E ∈ set (resolve_on A D CA)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E ∈ resolvent D A CA ` {Ls. subseq Ls CA ∧ resolvable A D CA Ls}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolve_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Ls</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Ls_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"resolvent D A CA Ls = E"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subseq Ls CA ∧ resolvable A D CA Ls"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = the (mgu {insert A (atms_of (mset Ls))})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ_p</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"mgu {insert A (atms_of (mset Ls))} = Some σ"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Ls ≠ []"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"eligible S σ [A] (add_mset (Neg A) (mset D))"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"strictly_maximal_wrt (A ⋅a σ) ((mset CA - mset Ls) ⋅ σ)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀L ∈ set Ls. is_pos L"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ls_p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolvable_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Let_def</span><span> </span><span>eligible.simps</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>σ_p</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ_p2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"the (mgu {insert A (atms_of (mset Ls))}) = σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Ls_sub_CA</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset Ls ⊆# mset CA"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>subseq_mset_subseteq_mset</span><span> </span><span>Ls_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (resolvent D A CA Ls) = sum_list [mset CA - mset Ls] ⋅ σ + mset D ⋅ σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolvent_def</span><span> </span><span>σ_p2</span><span> </span><span>subst_cls_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_all_mset_minus</span><span class="delimiter">[</span><span>of</span><span> </span><span>Ls</span><span> </span><span>CA</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length [mset CA - mset Ls] = Suc 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀L ∈ set Ls. is_pos L"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ_p</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>list_all_iff</span><span class="delimiter">[</span><span>of</span><span> </span><span>is_pos</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#Pos (atm_of x). x ∈# mset Ls#} = mset Ls"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Ls</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset CA = [mset CA - mset Ls] ! 0 + {#Pos (atm_of x). x ∈# mset Ls#}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ls_sub_CA</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ls ≠ []"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Some σ = mgu {insert A (atm_of ` set Ls)}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ_p</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>atms_of_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eligible S σ [A] (add_mset (Neg A) (mset D))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strictly_maximal_wrt (A ⋅a σ) ([mset CA - mset Ls] ! 0 ⋅ σ)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ_p</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S (mset CA) = {#}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>S_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Cs. mset (resolvent D A CA Ls) = sum_list Cs ⋅ σ + mset D ⋅ σ
        ∧ length Cs = Suc 0 ∧ mset CA = Cs ! 0 + {#Pos (atm_of x). x ∈# mset Ls#}
        ∧ Ls ≠ [] ∧ Some σ = mgu {insert A (atm_of ` set Ls)}
        ∧ eligible S σ [A] (add_mset (Neg A) (mset D)) ∧ strictly_maximal_wrt (A ⋅a σ) (Cs ! 0 ⋅ σ)
        ∧ S (mset CA) = {#}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [image_mset atm_of (mset Ls)] [A]
      σ (mset (resolvent D A CA Ls))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ord_resolve.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃AA σ. ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] σ (mset E)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ls_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset ` set (resolve_on A D CA)
    ⊆ {E. ∃AA σ. ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] σ E}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>E</span><span> </span><span>AA</span><span> </span><span>σ</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_resolve S [mset CA] (add_mset (Neg A) (mset D)) [AA] [A] σ E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>res'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E = sum_list Cs ⋅ σ + mset D ⋅ σ"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"length Cs = Suc 0"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"mset CA = Cs ! 0 + poss AA"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"AA ≠ {#}"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Some σ = mgu {insert A (set_mset AA)}"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"eligible S σ [A] (add_mset (Neg A) (mset D))"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"strictly_maximal_wrt (A ⋅a σ) (Cs ! 0 ⋅ σ)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"S (Cs ! 0 + poss AA) = {#}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ord_resolve.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C = Cs ! 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>res</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"E = sum_list Cs ⋅ σ + mset D ⋅ σ"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"mset CA = C + poss AA"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"AA ≠ {#}"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"Some σ = mgu {insert A (set_mset AA)}"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"eligible S σ [A] (add_mset (Neg A) (mset D))"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"strictly_maximal_wrt (A ⋅a σ) (C ⋅ σ)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"S (C + poss AA) = {#}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ord_resolve.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"E = C ⋅ σ + mset D ⋅ σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res'</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Cs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>res'</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> </span><span>res</span><span class="delimiter">(</span><span>2</span><span>-</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Al. mset Al = AA ∧ subseq (map Pos Al) CA"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>CA</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>AA</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>L</span><span> </span><span>CA</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ∈# poss AA "</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pos_L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_pos L"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A'. Pos A' ∈# poss AA ⟹
          remove1_mset (Pos A') (C + poss AA) = C + poss (remove1_mset A' AA)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>AA</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset CA = C + (poss (AA - {#atm_of L#}))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>add_mset_remove_trivial</span><span> </span><span>rem</span><span> </span><span>literal.collapse</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>mset.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>pos_L</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Al. mset Al = remove1_mset (atm_of L) AA ∧ subseq (map Pos Al) CA"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"((AA - {#atm_of L#}))"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Al</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"mset Al = remove1_mset (atm_of L) AA ∧ subseq (map Pos Al) CA"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"mset (atm_of L # Al) = AA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"subseq (map Pos (atm_of L # Al)) (L # CA)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>pos_L</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset CA = remove1_mset L C + poss AA"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>add_mset_remove_trivial</span><span> </span><span>mset.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>set_mset_union</span><span> </span><span>single_subset_iff</span><span>
</span><span>              </span><span>subset_mset.add_diff_assoc2</span><span> </span><span>union_single_eq_member</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Al. mset Al = AA ∧ subseq (map Pos Al) CA"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"C - {#L#}"</span></span></span><span> </span><span>AA</span><span class="delimiter">]</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Al</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Al_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset Al = AA"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subseq (map Pos Al) CA"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Ls</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ls = map Pos Al"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>diff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset CA - mset Ls = C"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ls_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Al_p</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ls_subq_ca</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subseq Ls CA"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ls_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Al_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃y. mgu {insert A (atms_of (mset Ls))} = Some y"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ls_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Al_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>atms_of_poss</span><span> </span><span>mset_map</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ls ≠ []"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Al_p</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Ls_def</span><span> </span><span>res'</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"the (mgu {insert A (set Al)}) = σ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res'</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Al_p</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.sel</span><span>  </span><span>set_mset_mset</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eligible S (the (mgu {insert A (atms_of (mset Ls))})) [A]
        (add_mset (Neg A) (mset D))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ls_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"strictly_maximal_wrt (A ⋅a the (mgu {insert A (atms_of (mset Ls))}))
        ((mset CA - mset Ls) ⋅ the (mgu {insert A (atms_of (mset Ls))}))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Ls_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res</span><span> </span><span>σ_p</span><span> </span><span>Al_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀L ∈ set Ls. is_pos L"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Ls_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"resolvable A D CA Ls"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolvable_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>eligible.simps</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ls_sub_ca</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset Ls ⊆# mset CA"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ls_subq_ca</span><span> </span><span>subseq_mset_subseteq_mset</span><span class="delimiter">[</span><span>of</span><span> </span><span>Ls</span><span> </span><span>CA</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#x ⋅l σ. x ∈# mset CA - mset Ls#} + {#M ⋅l σ. M ∈# mset D#} = C ⋅ σ + mset D ⋅ σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>diff</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_cls_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#x ⋅l σ. x ∈# mset CA - mset Ls#} + {#M ⋅l σ. M ∈# mset D#} = E"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res'</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#M ⋅l σ. M ∈# mset (remove_all CA Ls)#} + {#M ⋅l σ . M ∈# mset D#} = E"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>remove_all_mset_minus</span><span class="delimiter">[</span><span>of</span><span> </span><span>Ls</span><span> </span><span>CA</span><span class="delimiter">]</span><span> </span><span>ls_sub_ca</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (resolvent D A CA Ls) = E"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolvable_def</span><span> </span><span>Let_def</span><span> </span><span>resolvent_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Al_p</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Ls_def</span><span> </span><span>atms_of_poss</span><span> </span><span>res'</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>image_mset_union</span><span> </span><span>mset_append</span><span> </span><span>mset_map</span><span> </span><span>option.sel</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E ∈ mset ` set (resolve_on A D CA)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolve_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{E. ∃AA σ. ord_resolve S [mset CA] ({#Neg A#} + mset D) [AA] [A] σ E}
    ⊆ mset ` set (resolve_on A D CA)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_resolve_eq_UNION_set_resolve_on</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set (resolve C D) =
   (⋃L ∈ set D.
      (case L of
         Pos _ ⇒ {}
       | Neg A ⇒ if maximal_wrt A (mset D) then set (resolve_on A (remove1 L D) C) else {}))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolve_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>literal.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resolve_eq_Bin_ord_resolve</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset ` set (resolve C D) = Bin_ord_resolve (mset C) (mset D)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_resolve_eq_UNION_set_resolve_on</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>image_UN</span><span> </span><span>literal.case_distrib</span><span> </span><span>if_distrib</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>resolve_on_eq_UNION_Bin_ord_resolve</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_antisym</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>literal.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>literal.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Neg A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>bexI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>AA</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>ord_resolve.simps</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>ord_resolve.simps</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>eligible_iff</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>subst_cls_add_mset</span><span> </span><span>subst_cls_union</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>maximal_wrt_subst</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>sat</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>ord_resolve.simps</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>set_mset_mset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>poss_in_map_clauseD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"poss AA ⊆# map_clause f C ⟹ ∃AA0. poss AA0 ⊆# C ∧ AA = {#f A. A ∈# AA0#}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>AA</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>add</span><span> </span><span>A</span><span> </span><span>AA</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>aaa_sub</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Pos A ∈# map_clause f C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aaa_sub</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>pa0_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pos A0 ∈# C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A = f A0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarify</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>literal.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>literal.exhaust</span><span> </span><span>literal.inject</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>literal.simps</span><span class="delimiter">(</span><span>9</span><span class="delimiter">,</span><span>10</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"poss AA ⊆# map_clause f (C - {#Pos A0#})"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pa0_in</span><span> </span><span>aaa_sub</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_mset_remove1_mset_if</span><span> </span><span>insert_subset_eq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>AA0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>paa0_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"poss AA0 ⊆# C - {#Pos A0#}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>aa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"AA = image_mset f AA0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"poss (add_mset A0 AA0) ⊆# C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pa0_in</span><span> </span><span>paa0_sub</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_subset_eq_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"add_mset A AA = image_mset f (add_mset A0 AA0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>a</span><span> </span><span>aa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>poss_subset_filterD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"poss AA ⊆# {#L ⋅l ρ. L ∈# mset C#} ⟹ ∃AA0. poss AA0 ⊆# mset C ∧ AA = AA0 ⋅am ρ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_atm_mset_def</span><span> </span><span>subst_lit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>poss_in_map_clauseD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>neg_in_map_literalD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Neg A ∈ map_literal f ` D ⟹ ∃A0. Neg A0 ∈ D ∧ A = f A0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>neg_in_filterD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Neg A ∈# {#L ⋅l ρ'. L ∈# mset D#} ⟹ ∃A0. Neg A0 ∈# mset D ∧ A = A0 ⋅a ρ'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_lit_def</span><span> </span><span>image_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>neg_in_map_literalD</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resolve_rename_eq_Bin_ord_resolve_rename</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mset ` set (resolve_rename C D) = Bin_ord_resolve_rename (mset C) (mset D)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>order_antisym</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ρs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"renamings_apart [mset D, mset C]"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ρ'</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ρ' = hd ?ρs"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>ρ</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ρ = last ?ρs"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tl_ρs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tl ?ρs = [ρ]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ρ_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>renamings_apart_length</span><span> </span><span>Nitpick.size_list_simp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc_length_conv</span><span> </span><span>last.simps</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>length_greater_0_conv</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>E</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>e_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ∈ mset ` set (resolve_rename C D)"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>e_in</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>AA</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>aa_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"poss AA ⊆# mset C ⋅ ρ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>a_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Neg A ∈# mset D ⋅ ρ'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>res_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ord_resolve S [mset C ⋅ ρ] {#L ⋅l ρ'. L ∈# mset D#} [AA] [A] σ E"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ρ'_def</span><span> </span><span>ρ_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e_in</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolve_rename_def</span><span> </span><span>Let_def</span><span> </span><span>resolve_eq_Bin_ord_resolve</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>ord_resolve_one_side_prem</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>ord_resolve.simps</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>AA</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subst_cls_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Melem_subst_cls</span><span> </span><span>set_mset_mset</span><span> </span><span>subst_cls_def</span><span> </span><span>union_single_eq_member</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>AA0</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a multiset"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>aa0_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"poss AA0 ⊆# mset C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>aa</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"AA = AA0 ⋅am ρ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aa_sub</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ord_resolve.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>res_e</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>poss_subset_filterD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>aa_sub</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>subst_cls_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A0</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>a0_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Neg A0 ∈ set D"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A = A0 ⋅a ρ'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>atomize_elim</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ord_resolve.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>res_e</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>neg_in_filterD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a_in</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>subst_cls_def</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E ∈ Bin_ord_resolve_rename (mset C) (mset D)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ord_resolve_rename.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>res_e</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>AA0</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>aa0_sub</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>A0</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>a0_in</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>aa</span><span> </span><span>a</span><span> </span><span>ρ'_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ρ_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>tl_ρs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_cls_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>E</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>e_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ∈ Bin_ord_resolve_rename (mset C) (mset D)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E ∈ mset ` set (resolve_rename C D)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e_in</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>resolve_rename_def</span><span> </span><span>Let_def</span><span> </span><span>resolve_eq_Bin_ord_resolve</span><span> </span><span>ord_resolve_rename.simps</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"AA ⋅am ρ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ⋅a ρ'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>tl_ρs</span><span> </span><span>ρ'_def</span><span> </span><span>ρ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_cls_def</span><span> </span><span>subst_cls_lists_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bin_ord_FO_Γ_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ord_FO_Γ S = {Infer {#CA#} DA E | CA DA AA A σ E. ord_resolve_rename S [CA] DA [AA] [A] σ E}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ord_FO_Γ_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>order.antisym</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>ord_resolve_rename_one_side_prem</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_length_conv</span><span> </span><span>length_0_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_FO_Γ_side_prem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"γ ∈ ord_FO_Γ S ⟹ side_prems_of γ = {#THE D. D ∈# side_prems_of γ#}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bin_ord_FO_Γ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>clarsimp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ord_FO_Γ_infer_from_Collect_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{γ ∈ ord_FO_Γ S. infer_from (DD ∪ {C}) γ ∧ C ∈# prems_of γ} =
   {γ ∈ ord_FO_Γ S. ∃D ∈ DD ∪ {C}. prems_of γ = {#C, D#}}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>infer_from_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_eq_subset</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>ord_FO_Γ_side_prem</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ord_FO_Γ_side_prem</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>ord_FO_Γ_side_prem</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>ord_FO_Γ_side_prem</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inferences_between_eq_UNION</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inference_system.inferences_between (ord_FO_Γ S) Q C =
  inference_system.inferences_between (ord_FO_Γ S) {C} C
  ∪ (⋃D ∈ Q. inference_system.inferences_between (ord_FO_Γ S) {D} C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ord_FO_Γ_infer_from_Collect_eq</span><span> </span><span>inference_system.inferences_between_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>concls_of_inferences_between_singleton_eq_Bin_ord_resolve_rename</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"concls_of (inference_system.inferences_between (ord_FO_Γ S) {D} C) =
   Bin_ord_resolve_rename C C ∪ Bin_ord_resolve_rename C D ∪ Bin_ord_resolve_rename D C"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>order_antisym</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>E</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>e_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"E ∈ concls_of (inference_system.inferences_between (ord_FO_Γ S) {D} C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E ∈ Bin_ord_resolve_rename C C ∪ Bin_ord_resolve_rename C D
    ∪ Bin_ord_resolve_rename D C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inference_system.inferences_between_def</span><span> </span><span>ord_FO_Γ_infer_from_Collect_eq</span><span>
</span><span>      </span><span>bin_ord_FO_Γ_def</span><span> </span><span>infer_from_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>add_mset_eq_add_mset</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>inference_system.inferences_between_def</span><span> </span><span>infer_from_def</span><span> </span><span>ord_FO_Γ_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>concls_of_inferences_between_eq_Bin_ord_resolve_rename</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"concls_of (inference_system.inferences_between (ord_FO_Γ S) Q C) =
   Bin_ord_resolve_rename C C ∪ (⋃D ∈ Q. Bin_ord_resolve_rename C D ∪ Bin_ord_resolve_rename D C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>inferences_between_eq_UNION</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_Un</span><span> </span><span>image_UN</span><span> </span><span>concls_of_inferences_between_singleton_eq_Bin_ord_resolve_rename</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>resolve_rename_either_way_eq_congls_of_inferences_between</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mset ` set (resolve_rename C C) ∪ (⋃D ∈ Q. mset ` set (resolve_rename_either_way C D)) =
   concls_of (inference_system.inferences_between (ord_FO_Γ S) (mset ` Q) (mset C))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>resolve_rename_either_way_def</span><span> </span><span>image_Un</span><span> </span><span>resolve_rename_eq_Bin_ord_resolve_rename</span><span>
</span><span>      </span><span>concls_of_inferences_between_eq_Bin_ord_resolve_rename</span><span> </span><span>UN_Un_distrib</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compute_inferences</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ci_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈ set P"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>ci_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(D, j) ∈# mset (map (apfst mset) P). weight (mset C, i) ≤ weight (D, j)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate ([], P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub>
     wstate_of_dstate (map (λD. (D, n)) (remdups_gen mset (resolve_rename C C @
         concat (map (resolve_rename_either_way C ∘ fst) Q))),
       filter (λ(D, j). mset D ≠ mset C) P, (C, i) # Q, Suc n)"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate (?N, _)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ms_ci_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(mset C, i) ∈# image_mset (apfst mset) (mset P)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ci_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>          </span><span>wrp.inference_computation</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) P) - {#(mset C, i)#}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset C"</span></span></span><span> </span><span>i</span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) ?N)"</span></span></span><span> </span><span>n</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) Q)"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add_mset_remove_trivial_eq</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>ms_ci_in</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ms_ci_in</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ci_in</span><span> </span><span>image_mset_remove1_mset_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>apfst_conv</span><span> </span><span>case_prodE</span><span> </span><span>case_prodI2</span><span> </span><span>case_prod_conv</span><span> </span><span>filter_mset_cong</span><span>
</span><span>        </span><span>image_mset_filter_swap</span><span> </span><span>mset_filter</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ci_min</span><span> </span><span>in_diffD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>list.map_comp</span><span> </span><span>apfst_comp_rpair_const</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>list.map_comp</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>mset_map</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>mset_map_remdups_gen</span><span> </span><span>mset_remdups_gen_ident</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>image_mset_mset_set</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>mset_set_eq_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>finite_ord_FO_resolution_inferences_between</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λN. (λD. (D, n)) ` N"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>map_concat</span><span> </span><span>list.map_comp</span><span> </span><span>image_comp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>resolve_rename_either_way_eq_congls_of_inferences_between</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span class="string"><span class="delete"><span class="delete">"fst ` set Q"</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_comp</span><span> </span><span>comp_def</span><span> </span><span>image_UN</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonfinal_deterministic_RP_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>nonfinal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ is_final_dstate St"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"St' = deterministic_RP_step St"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate St ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>+</sup> wstate_of_dstate St'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"St = (N, P, Q, n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>St</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>st</span><span> </span><span>deterministic_RP_step.simps</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Ci ∈ set P ∪ set Q. fst Ci = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>nil_in</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>nil_in</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nil_in'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[] ∈ fst ` set (P @ Q)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nil_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>image_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>star</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[] ∈ fst ` set (P @ Q) ⟹
      wstate_of_dstate (N, P, Q, n)
      ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (remdups_clss P)"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>N</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>len_p</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nil_in'</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p_nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P = []"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_p</span><span> </span><span>remdups_clss_Nil_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, [], Q, n) ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ([], [], Q, n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>empty_N_if_Nil_in_P_or_Q</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nil_in'</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>p_nil</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>p_nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>suc_k</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nil_in'</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ≠ []"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_k</span><span> </span><span>remdups_clss_Nil_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>p_cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P = hd P # tl P"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>ci</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) = select_min_weight_clause (hd P) (tl P)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.exhaust</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ci_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈ set P"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ci</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_cons</span><span> </span><span>select_min_weight_clause_in</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tl P"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ci_min</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(D, j) ∈# mset (map (apfst mset) P). weight (mset C, i) ≤ weight (D, j)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>p_cons</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>select_min_weight_clause_min_weight</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ci</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (λ(D, j). mset D ≠ mset C) P"</span></span></span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ms_p'_ci_q_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (remdups_clss ?P' @ (C, i) # Q) = mset (remdups_clss P @ Q)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>p_cons</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>remdups_clss.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>case_prod_beta</span><span> </span><span>p_cons</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ci</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (remdups_clss P) = length (remdups_clss ?P') + 1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Suc_eq_plus1_left</span><span> </span><span>add.assoc</span><span> </span><span>add_right_cancel</span><span> </span><span>length_Cons</span><span> </span><span>length_append</span><span>
</span><span>            </span><span>mset_eq_length</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N, P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ([], P, Q, n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>empty_N_if_Nil_in_P_or_Q</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nil_in'</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"… ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate (N', ?P', (C, i) # Q, Suc n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>atomize_elim</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>compute_inferences</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ci_in</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>use</span><span> </span><span>ci_min</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ([], [], remdups_clss P @ Q, n + length (remdups_clss P))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>            </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P'</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) # Q"</span></span></span><span> </span><span>N'</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ms_p'_ci_q_eq</span><span> </span><span>suc_k</span><span> </span><span>nil_in'</span><span> </span><span>ci_in</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>len_p</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>apfst_conv</span><span> </span><span>image_mset_add_mset</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>st</span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>star</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nil_in'</span><span class="delimiter">]</span><span> </span><span>nonfinal</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>st</span><span> </span><span>is_final_dstate.simps</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>cases</span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>nil_ni</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>nil_ni</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>N</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>n_nil</span><span class="delimiter">:</span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>n_nil</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_nil</span><span> </span><span>nonfinal</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>st</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_final_dstate.simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>p_cons</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>P0</span><span> </span><span>P'</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>p_cons</span><span> </span><span>list.case</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>p_cons</span><span class="delimiter">]</span><span>
</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span>ci</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) = select_min_weight_clause P0 P'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.exhaust</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>select</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ci_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(C, i) ∈ set P"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>select_min_weight_clause_in</span><span class="delimiter">[</span><span>of</span><span> </span><span>P0</span><span> </span><span>P'</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>ci</span><span> </span><span>p_cons</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>st</span><span> </span><span>n_nil</span><span> </span><span>step</span><span> </span><span>p_cons</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>ci</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>prod.case</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>tranclp.r_into_trancl</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>compute_inferences</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ci_in</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>select_min_weight_clause_min_weight</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ci</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>p_cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>n_cons</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>Ci</span><span> </span><span>N'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>n_cons</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>ci</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ci = (C, i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Ci</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ci</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>C'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"C' = reduce (map fst P @ map fst Q) [] C"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>ci</span><span> </span><span>C'_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate ((E @ C, i) # N', P, Q, n)
           ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ((E @ reduce (map fst P @ map fst Q) E C, i) # N', P, Q, n)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>E</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C'_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>C</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>E</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>L</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_reducible_lit (map fst P @ map fst Q) (E @ C) L"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>l_red</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>red_lc</span><span class="delimiter">:</span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"reduce (map fst P @ map fst Q) E (L # C) = reduce (map fst P @ map fst Q) E C"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span>D'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a literal list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a literal"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"D ∈ set (map fst P @ map fst Q)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"D' = remove1 L' D"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"L' ∈ set D"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"- L = L' ⋅l σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"mset D' ⋅ σ ⊆# mset (E @ C)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l_red</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_reducible_lit_def</span><span> </span><span>comp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ</span><span class="delimiter">:</span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"mset D' + {#L'#} ∈ set (map (mset ∘ fst) (P @ Q))"</span></span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"- L = L' ⋅l σ ∧ mset D' ⋅ σ ⊆# mset (E @ C)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_reducible_lit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate ((E @ L # C, i) # N', P, Q, n)
              ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate ((E @ C, i) # N', P, Q, n)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>                  </span><span>wrp.forward_reduction</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset D'"</span></span></span><span> </span><span>L'</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) P)"</span></span></span><span>
</span><span>                    </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) Q)"</span></span></span><span> </span><span>L</span><span> </span><span>σ</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (E @ C)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) N')"</span></span></span><span>
</span><span>                    </span><span>i</span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="delimiter">(</span><span>use</span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auto simp: comp_def›</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>red_lc</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span>E</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"L # E"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>red_C</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate ((C, i) # N', P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ((C', i) # N', P, Q, n)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>C'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>self_append_conv2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>proc_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate ((C', i) # N', P', Q', n')
          ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate (N', (C', i) # P', Q', n')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P'</span><span> </span><span>Q'</span><span> </span><span>n'</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>              </span><span>wrp.clause_processing</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) N')"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset C'"</span></span></span><span> </span><span>i</span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) P')"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) Q')"</span></span></span><span> </span><span>n'</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>            </span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"C' = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>c'_nil</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>c'_nil</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>filter_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (Not ∘ strictly_subsume [[]] ∘ fst) P = []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>filter_q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"filter (Not ∘ strictly_subsume [[]] ∘ fst) Q = []"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nil_ni</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>strictly_subsume_def</span><span> </span><span>filter_empty_conv</span><span> </span><span>find_None_iff</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>red_C</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>c'_nil</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (([], i) # N', P, Q, n)
            ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (([], i) # N', [], Q, n)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>                </span><span>remove_strictly_subsumed_clauses_in_P</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>append_Nil</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>                </span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_p</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (([], i) # N', [], [], n)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>                </span><span>remove_strictly_subsumed_clauses_in_Q</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>append_Nil</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>                </span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_q</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>proc_C</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>c'_nil</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>tranclp.r_into_trancl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate (N', [([], i)], [], n)
            ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ([], [([], i)], [], n)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>empty_N_if_Nil_in_P_or_Q</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate ([], [], [([], i)], Suc n)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>                </span><span>wrp.inference_computation</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#}"</span></span></span><span> </span><span>i</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#}"</span></span></span><span> </span><span>n</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#}"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>ord_FO_resolution_inferences_between_empty_empty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>step</span><span> </span><span>st</span><span> </span><span>n_cons</span><span> </span><span>ci</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>c'_nnil</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>c'_nnil</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_tautology C' ∨ subsume (map fst P @ map fst Q) C'"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>taut_or_subs</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>taut_or_subs</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate ((C', i) # N', P, Q, n) ↝<span class="hidden">⇩</span><sub>w</sub> wstate_of_dstate (N', P, Q, n)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_tautology C'"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">'a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>              </span><span>neg_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Neg A ∈ set C'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pos_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Pos A ∈ set C'"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_tautology_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>                    </span><span>wrp.tautology_deletion</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset C'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) N')"</span></span></span><span> </span><span>i</span><span>
</span><span>                      </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) P)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) Q)"</span></span></span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="delimiter">(</span><span>use</span><span> </span><span>neg_a</span><span> </span><span>pos_a</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subsume (map fst P @ map fst Q) C'"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>taut_or_subs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>              </span><span>d_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D ∈ set (map fst P @ map fst Q)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes (mset D) (mset C')"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subsume_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span>
</span><span>                    </span><span>wrp.forward_subsumption</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset D"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) P)"</span></span></span><span>
</span><span>                      </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) Q)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset C'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (map (apfst mset) N')"</span></span></span><span> </span><span>i</span><span> </span><span>n</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>                  </span><span>use</span><span> </span><span>d_in</span><span> </span><span>subs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹auto simp: subsume_def›</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>step</span><span> </span><span>st</span><span> </span><span>n_cons</span><span> </span><span>ci</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>red_C</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp_into_tranclp1</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>not_taut_or_subs</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>not_taut_or_subs</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>          </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>P'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a literal list × nat) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"P' = reduce_all C' P"</span></span></span><span>
</span><span>
</span><span>          </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>back_to_P</span><span> </span><span>Q'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>            </span><span>red_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(back_to_P, Q') = reduce_all2 C' Q"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>prod.exhaust</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>red_Q</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>          </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Q''</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a literal list × nat) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"Q'' = filter (Not ∘ strictly_subsume [C'] ∘ fst) Q'"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>P''</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a literal list × nat) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"P'' = filter (Not ∘ strictly_subsume [C'] ∘ fst) (back_to_P @ P')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>P'_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>Q''_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>P''_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>              </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>          </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>red_C</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate ((C', i) # N', P, Q, n)
              ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ((C', i) # N', P', Q, n)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduce_clauses_in_P</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>append_Nil</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ((C', i) # N', back_to_P @ P', Q', n)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P'_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduce_clauses_in_Q</span><span class="delimiter">[</span><span>of</span><span> </span><span>C'</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span>Q</span><span class="delimiter">,</span><span> </span><span>folded</span><span> </span><span>red_Q</span><span class="delimiter">,</span><span>
</span><span>                  </span><span>unfolded</span><span> </span><span>append_Nil</span><span> </span><span>prod.sel</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>reduce_idem</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reduce_all_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ((C', i) # N', back_to_P @ P', Q'', n)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Q''_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>remove_strictly_subsumed_clauses_in_Q</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>append_Nil</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>              </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate ((C', i) # N', P'', Q'', n)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>P''_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>remove_strictly_subsumed_clauses_in_P</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>append_Nil</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>proc_C</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>tranclp.r_into_trancl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>step</span><span> </span><span>st</span><span> </span><span>n_cons</span><span> </span><span>ci</span><span> </span><span>P''_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>final_deterministic_RP_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_final_dstate St ⟹ deterministic_RP_step St = St"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>St</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>deterministic_RP_step.simps</span><span> </span><span>is_final_dstate.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deterministic_RP_SomeD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"deterministic_RP (N, P, Q, n) = Some R"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃N' P' Q' n'. (∃k. (deterministic_RP_step ^^ k) (N, P, Q, n) = (N', P', Q', n'))
    ∧ is_final_dstate (N', P', Q', n') ∧ R = map fst Q'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>deterministic_RP.raw_induct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>self_call</span><span> </span><span>St</span><span> </span><span>R</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"St = (N, P, Q, n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>St</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>st</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_final_dstate (N, P, Q, n)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(deterministic_RP_step ^^ 0) (N, P, Q, n) = (N, P, Q, n)
      ∧ is_final_dstate (N, P, Q, n) ∧ R = map fst Q"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>st</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>nonfinal</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>step</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>nonfinal</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N'</span><span> </span><span>P'</span><span> </span><span>Q'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n'</span><span> </span><span>k</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(deterministic_RP_step ^^ k) (deterministic_RP_step (N, P, Q, n)) = (N', P', Q', n')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_final_dstate (N', P', Q', n')"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"R = map fst Q'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>st</span><span> </span><span>funpow_Suc_right</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>fun_cong</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>comp_apply</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span>
</span><span>    </span><span>N0</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>n0</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a lclause list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>St0</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dstate"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"St0 ≡ (N0, [], [], n0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>grounded_N0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grounded_N0 ≡ grounding_of_clss (set (map (mset ∘ fst) N0))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>grounded_R</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"grounded_R ≡ grounding_of_clss (set (map mset R))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primcorec</span></span><span> </span><span>derivation_from</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dstate ⇒ 'a dstate llist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"derivation_from St =
   LCons St (if is_final_dstate St then LNil else derivation_from (deterministic_RP_step St))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Sts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dstate llist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Sts ≡ derivation_from St0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>wSts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate llist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"wSts ≡ lmap wstate_of_dstate Sts"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>full_deriv_wSts_trancl_weighted_RP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"full_chain (↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>+</sup>) wSts"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sts' = derivation_from St0' ⟹ full_chain (↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>+</sup>) (lmap wstate_of_dstate Sts')"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>St0'</span><span> </span><span>Sts'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>coinduction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>St0'</span><span> </span><span>Sts'</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>full_chain.coinduct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>sts'</span><span class="delimiter">:</span><span> </span><span>full_chain</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_final_dstate St0'"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl (lmap wstate_of_dstate Sts') = LNil"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sts'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lmap wstate_of_dstate Sts' = LCons (wstate_of_dstate St0') LNil"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sts'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>derivation_from.code</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>derivation_from.code</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀St''. ¬ wstate_of_dstate St0' ↝<span class="hidden">⇩</span><sub>w</sub> St''"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_final_dstate_imp_not_weighted_RP</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>tranclpD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>nfinal</span><span class="delimiter">:</span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lmap wstate_of_dstate Sts' =
        LCons (wstate_of_dstate St0') (lmap wstate_of_dstate (ltl Sts'))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sts'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>derivation_from.code</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl Sts' = derivation_from (deterministic_RP_step St0')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sts'</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nfinal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>derivation_from.code</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate St0' ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>+</sup> wstate_of_dstate (lhd (ltl Sts'))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sts'</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nonfinal_deterministic_RP_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>nfinal</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>nfinal</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>derivation_from.code</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>deriv_wSts_trancl_weighted_RP</span><span> </span><span class="delimiter">=</span><span> </span><span>full_chain_imp_chain</span><span class="delimiter">[</span><span>OF</span><span> </span><span>full_deriv_wSts_trancl_weighted_RP</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>sswSts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a wstate llist"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sswSts = (SOME wSts'.
     full_chain (↝<span class="hidden">⇩</span><sub>w</sub>) wSts' ∧ emb wSts wSts' ∧ lhd wSts' = lhd wSts ∧ llast wSts' = llast wSts)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sswSts</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"full_chain (↝<span class="hidden">⇩</span><sub>w</sub>) sswSts ∧ emb wSts sswSts ∧ lhd sswSts = lhd wSts ∧ llast sswSts = llast wSts"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>sswSts_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>someI_ex</span><span class="delimiter">[</span><span>OF</span><span> </span><span>full_chain_tranclp_imp_exists_full_chain</span><span class="delimiter">[</span><span>OF</span><span>
</span><span>          </span><span>full_deriv_wSts_trancl_weighted_RP</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>full_deriv_sswSts_weighted_RP</span><span> </span><span class="delimiter">=</span><span> </span><span>sswSts</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>emb_sswSts</span><span> </span><span class="delimiter">=</span><span> </span><span>sswSts</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>lfinite_sswSts_iff</span><span> </span><span class="delimiter">=</span><span> </span><span>emb_lfinite</span><span class="delimiter">[</span><span>OF</span><span> </span><span>emb_sswSts</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>lhd_sswSts</span><span> </span><span class="delimiter">=</span><span> </span><span>sswSts</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>llast_sswSts</span><span> </span><span class="delimiter">=</span><span> </span><span>sswSts</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>deriv_sswSts_weighted_RP</span><span> </span><span class="delimiter">=</span><span> </span><span>full_chain_imp_chain</span><span class="delimiter">[</span><span>OF</span><span> </span><span>full_deriv_sswSts_weighted_RP</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_lnull_sswSts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ lnull sswSts"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deriv_sswSts_weighted_RP</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>chain.cases</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_ssgP0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wrp.P_of_wstate (lhd sswSts) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lhd_sswSts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>derivation_from.code</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_ssgQ0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wrp.Q_of_wstate (lhd sswSts) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lhd_sswSts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>derivation_from.code</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>sswSts_thms</span><span> </span><span class="delimiter">=</span><span> </span><span>full_deriv_sswSts_weighted_RP</span><span> </span><span>empty_ssgP0</span><span> </span><span>empty_ssgQ0</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>S_ssgQ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause ⇒ 'a clause"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"S_ssgQ ≡ wrp.S_gQ sswSts"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ord_Γ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a inference set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ord_Γ ≡ ground_resolution_with_selection.ord_Γ S_ssgQ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Rf</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause set ⇒ 'a clause set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Rf ≡ standard_redundancy_criterion.Rf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>Ri</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause set ⇒ 'a inference set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ri ≡ standard_redundancy_criterion.Ri ord_Γ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>saturated_upto</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a clause set ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"saturated_upto ≡ redundancy_criterion.saturated_upto ord_Γ Rf Ri"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>drp_some</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deterministic_RP St0 = Some R"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfinite_Sts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lfinite Sts"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>deterministic_RP.raw_induct</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>drp_some</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>self_call</span><span> </span><span>St</span><span> </span><span>St'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>step</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>derivation_from.code</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ih</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lfinite_wSts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lfinite wSts"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lfinite_lmap</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>lfinite_Sts</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>lfinite_sswSts</span><span> </span><span class="delimiter">=</span><span> </span><span>lfinite_sswSts_iff</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>lfinite_wSts</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span>
</span><span>  </span><span>deterministic_RP_saturated</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"saturated_upto grounded_R"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?saturated</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>deterministic_RP_model</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"I ⊨s grounded_N0 ⟷ I ⊨s grounded_R"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?model</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>N'</span><span> </span><span>P'</span><span> </span><span>Q'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a dclause list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>n'</span><span> </span><span>k</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>k_steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(deterministic_RP_step ^^ k) St0 = (N', P', Q', n')"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"_ = ?Stk"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>final</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_final_dstate (N', P', Q', n')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R = map fst Q'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deterministic_RP_SomeD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>drp_some</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wrp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wstate_of_dstate St0 ↝<span class="hidden">⇩</span><sub>w</sub><span class="hidden">⇧</span><sup>*</sup> wstate_of_dstate (llast Sts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lfinite_chain_imp_rtranclp_lhd_llast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>deriv_sswSts_weighted_RP</span><span> </span><span>derivation_from.disc_iff</span><span> </span><span>derivation_from.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>        </span><span>lfinite_Sts</span><span> </span><span>lfinite_sswSts</span><span> </span><span>llast_lmap</span><span> </span><span>llist.map_sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>sswSts</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_sts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"llast Sts = ?Stk"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(deterministic_RP_step ^^ k') St0' = ?Stk ⟹ llast (derivation_from St0') = ?Stk"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>St0'</span><span> </span><span>k'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k'</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>St0'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>final</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>derivation_from.code</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>suc_k'_steps</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_final_dstate St0'"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"deterministic_RP_step St0'"</span></span></span><span class="delimiter">]</span><span> </span><span>suc_k'_steps</span><span> </span><span>final_deterministic_RP_step</span><span>
</span><span>            </span><span>funpow_fixpoint</span><span class="delimiter">[</span><span>of</span><span> </span><span>deterministic_RP_step</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"deterministic_RP_step St0'"</span></span></span><span class="delimiter">]</span><span> </span><span>suc_k'_steps</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>derivation_from.code</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>llast_LCons</span><span> </span><span>funpow_swap1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_steps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fin_gr_fgsts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lfinite (lmap wrp.grounding_of_wstate sswSts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lfinite_lmap</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>lfinite_sswSts</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lim_last</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Liminf_llist (lmap wrp.grounding_of_wstate sswSts) =
    wrp.grounding_of_wstate (llast sswSts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lfinite_Liminf_llist</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin_gr_fgsts</span><span class="delimiter">]</span><span> </span><span>llast_lmap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lfinite_sswSts</span><span> </span><span>not_lnull_sswSts</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_lnull_sswSts</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_st0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wrp.grounding_of_wstate (wstate_of_dstate St0) = grounded_N0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>clss_of_state_def</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?saturated ∧ ?model"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"[] ∈ set R"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>emp_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#} ∈ grounded_R"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>grounding_of_clss_def</span><span> </span><span>grounding_of_cls_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>ex_ground_subst</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"grounded_R ⊆ wrp.grounding_of_wstate (llast sswSts)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r</span><span> </span><span>llast_sswSts</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_sts</span><span> </span><span>llast_lmap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lfinite_Sts</span><span class="delimiter">]</span><span> </span><span>clss_of_state_def</span><span> </span><span>grounding_of_clss_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_last_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"grounded_R ⊆ wrp.grounding_of_wstate (wstate_of_dstate (llast Sts))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lfinite_Sts</span><span> </span><span>llast_lmap</span><span> </span><span>llast_sswSts</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_r_fls</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ I ⊨s grounded_R"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emp_in</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_clss_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_last_fls</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ I ⊨s wrp.grounding_of_wstate (wstate_of_dstate (llast Sts))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gr_last_st</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_clss_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?saturated</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrp.ord_Γ_saturated_upto_def</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sswSts_thms</span><span class="delimiter">]</span><span>
</span><span>        </span><span>wrp.ord_Γ_contradiction_Rf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sswSts_thms</span><span> </span><span>emp_in</span><span class="delimiter">]</span><span> </span><span>inference_system.inferences_from_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?model</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>gr_r_fls</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>eq_False</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp_imp_eq_image</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λSt. I ⊨s wrp.grounding_of_wstate St"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>wrp</span><span class="delimiter">,</span><span>
</span><span>            </span><span>unfolded</span><span> </span><span>gr_st0</span><span> </span><span>gr_last_fls</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>eq_False</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>use</span><span> </span><span>wrp.weighted_RP_model</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sswSts_thms</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_last</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wrp.grounding_of_wstate (llast sswSts) = grounded_R"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>final</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>r</span><span> </span><span>llast_sswSts</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_sts</span><span> </span><span>llast_lmap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lfinite_Sts</span><span class="delimiter">]</span><span> </span><span>clss_of_state_def</span><span> </span><span>comp_def</span><span>
</span><span>          </span><span>is_final_dstate.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gr_last_st</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wrp.grounding_of_wstate (wstate_of_dstate (llast Sts)) = grounded_R"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lfinite_Sts</span><span> </span><span>llast_lmap</span><span> </span><span>llast_sswSts</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?saturated</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wrp.weighted_RP_saturated</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sswSts_thms</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>gr_last</span><span> </span><span>lim_last</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?model</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtranclp_imp_eq_image</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(↝<span class="hidden">⇩</span><sub>w</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"λSt. I ⊨s wrp.grounding_of_wstate St"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>wrp</span><span class="delimiter">,</span><span>
</span><span>            </span><span>unfolded</span><span> </span><span>gr_st0</span><span> </span><span>gr_last_st</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>use</span><span> </span><span>wrp.weighted_RP_model</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sswSts_thms</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?saturated</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?model</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>deterministic_RP_refutation</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ satisfiable grounded_N0 ⟷ {#} ∈ grounded_R"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs ⟷ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ satisfiable grounded_R"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>true_clss_def</span><span> </span><span>true_cls_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deterministic_RP_model</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ satisfiable grounded_R"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deterministic_RP_model</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wrp.ord_Γ_saturated_upto_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sswSts_thms</span><span> </span><span>deterministic_RP_saturated</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>drp_none</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deterministic_RP St0 = None"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>deterministic_RP_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"satisfiable grounded_N0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>unsat</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ satisfiable grounded_N0"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unsat_wSts0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ satisfiable (wrp.grounding_of_wstate (lhd wSts))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unsat</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>derivation_from.code</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>clss_of_state_def</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bot_in_ss</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#} ∈ Q_of_state (wrp.Liminf_wstate sswSts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wrp.weighted_RP_complete</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sswSts_thms</span><span> </span><span>unsat_wSts0</span><span class="delimiter">[</span><span>folded</span><span> </span><span>lhd_sswSts</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bot_in_lim</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#} ∈ Q_of_state (wrp.Liminf_wstate wSts)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"lfinite Sts"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wrp.Liminf_wstate sswSts = wrp.Liminf_wstate wSts"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Liminf_state_fin</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fin</span><span> </span><span>lfinite_sswSts_iff</span><span> </span><span>not_lnull_sswSts</span><span class="delimiter">,</span><span>
</span><span>          </span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>llast_lmap</span><span class="delimiter">,</span><span>
</span><span>          </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lfinite_sswSts_iff</span><span> </span><span>fin</span><span> </span><span>not_lnull_sswSts</span><span> </span><span>llast_sswSts</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bot_in_ss</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>bot_in_ss</span><span> </span><span>Q_of_Liminf_state_inf</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>emb_lmap</span><span class="delimiter">[</span><span>OF</span><span> </span><span>emb_sswSts</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>k</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>k_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enat k &lt; llength Sts"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>emp_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#} ∈ wrp.Q_of_wstate (lnth wSts k)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Liminf_state_def</span><span> </span><span>Liminf_llist_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>emp_in</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{#} ∈ Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"enat k &lt; llength Sts' ⟹ Sts' = derivation_from St0' ⟹
      {#} ∈ wrp.Q_of_wstate (lnth (lmap wstate_of_dstate Sts') k) ⟹
      {#} ∈ Q_of_state (state_of_dstate ((deterministic_RP_step ^^ k) St0'))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>St0'</span><span> </span><span>Sts'</span><span> </span><span>k</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>k</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>St0'</span><span> </span><span>Sts'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>derivation_from.code</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>St0'</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>comp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ih</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sk_lt</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sts'</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>emp_in_sk</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>k_lt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"enat k &lt; llength (ltl Sts')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sk_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Sts'</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Suc_ile_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl Sts' = derivation_from (deterministic_RP_step St0')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sts'</span><span> </span><span>k_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Sts'</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{#} ∈ wrp.Q_of_wstate (lnth (lmap wstate_of_dstate (ltl Sts')) k)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>emp_in_sk</span><span> </span><span>k_lt</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Sts'</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ltl Sts'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"deterministic_RP_step St0'"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>funpow_swap1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_lt</span><span> </span><span>emp_in</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"deterministic_RP St0 ≠ None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_final_dstate_funpow_imp_deterministic_RP_neq_None</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc k"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(deterministic_RP_step ^^ k) St0"</span></span></span><span class="delimiter">,</span><span>
</span><span>        </span><span>use</span><span> </span><span>emp_in</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹force simp: deterministic_RP_step.simps is_final_dstate.simps›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>drp_none</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="IsaFoR_Term">
<div class="head"><h1>Theory IsaFoR_Term</h1>
<span class="command">theory</span> <span class="name">IsaFoR_Term</span><br/>
<span class="keyword">imports</span> <a href="Derive.html"><span class="name">Derive</span></a> <a href="Abstract_Substitution.html"><span class="name">Abstract_Substitution</span></a> <a href="Unification.html"><span class="name">Unification</span></a> <a href="Subsumption.html"><span class="name">Subsumption</span></a> <a href="Wellorder_Extension.html"><span class="name">Wellorder_Extension</span></a> <a href="Restricted_Predicates.html"><span class="name">Restricted_Predicates</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       Integration of IsaFoR Terms
    Author:      Dmitriy Traytel &lt;traytel at inf.ethz.ch&gt;, 2014
    Author:      Anders Schlichtkrull &lt;andschl at dtu.dk&gt;, 2017
    Maintainer:  Anders Schlichtkrull &lt;andschl at dtu.dk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Integration of \textsf{IsaFoR} Terms›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This theory implements the abstract interface for atoms and substitutions using
the \textsf{IsaFoR} library (part of the AFP entry ‹First_Order_Terms›).
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>IsaFoR_Term</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>    </span><span>Deriving.Derive</span><span>
</span><span>    </span><span>Ordered_Resolution_Prover.Abstract_Substitution</span><span>
</span><span>    </span><span>First_Order_Terms.Unification</span><span>
</span><span>    </span><span>First_Order_Terms.Subsumption</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"HOL-Cardinals.Wellorder_Extension"</span></span></span><span>
</span><span>    </span><span>Open_Induction.Restricted_Predicates</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">hide_const</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="delimiter">)</span><span> </span><span>mgu</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>subst_apply_literal</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term literal ⇒ ('f, 'v, 'w) gsubst ⇒ ('f, 'w) term literal"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋅lit"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"L ⋅lit σ ≡ map_literal (λA. A ⋅ σ) L"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>subst_apply_clause</span><span> </span><span class="delimiter">::</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term clause ⇒ ('f, 'v, 'w) gsubst ⇒ ('f, 'w) term clause"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋅cls"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"C ⋅cls σ = image_mset (λL. L ⋅lit σ) C"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>vars_lit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term literal ⇒ 'v set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vars_lit L ≡ vars_term (atm_of L)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vars_clause</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term clause ⇒ 'v set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vars_clause C = Union (set_mset (image_mset vars_lit C))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vars_clause_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, 'v) term clause list ⇒ 'v set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vars_clause_list Cs = Union (vars_clause ` set Cs) "</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>vars_partitioned</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f,'v) term clause list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vars_partitioned Cs ⟷
   (∀i &lt; length Cs. ∀j &lt; length Cs. i ≠ j ⟶ (vars_clause (Cs ! i) ∩ vars_clause (Cs ! j)) = {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_clause_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ⊆# C ⟹ vars_clause S ⊆ vars_clause C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_clause_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>substitution_ops</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span>Var</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∘<span class="hidden">⇩</span><sub>s</sub>)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_ground_atm_is_ground_on_var</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_atm (A ⋅ σ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ vars_term A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_atm (σ v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>ts</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_ground_atm_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_ground_lit_is_ground_on_var</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ground_lit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_lit (subst_lit L σ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v_in_L</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ vars_lit L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_atm (σ v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"atm_of L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v_in_L</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ vars_term ?A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_atm (?A ⋅ σ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_lit</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_ground_lit_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>A_p</span><span> </span><span>is_ground_atm_is_ground_on_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_ground_cls_is_ground_on_var</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>ground_clause</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_cls (subst_cls C σ)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>v_in_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ vars_clause C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_atm (σ v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v_in_C</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>L_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ∈# C"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ vars_lit L"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_clause_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_lit (subst_lit L σ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_clause</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_ground_cls_def</span><span> </span><span>subst_cls_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>L_p</span><span> </span><span>is_ground_lit_is_ground_on_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_ground_cls_list_is_ground_on_var</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ground_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_cls_list (subst_cls_list Cs σ)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v_in_Cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ vars_clause_list Cs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_atm (σ v)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v_in_Cs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C ∈ set Cs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ vars_clause C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_clause_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_cls (subst_cls C σ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_list</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_ground_cls_list_def</span><span> </span><span>subst_cls_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>C_p</span><span> </span><span>is_ground_cls_is_ground_on_var</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_on_vars_lit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ vars_lit L. σ v = τ v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_lit L σ = subst_lit L τ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>L</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pos</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ vars_term x. σ v = τ v ⟹ subst_atm_abbrev x σ = subst_atm_abbrev x τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>term_subst_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_lit_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Neg</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ vars_term x. σ v = τ v ⟹ subst_atm_abbrev x σ = subst_atm_abbrev x τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>term_subst_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_lit_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Neg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_list_of_mset_in_S</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (list_of_mset S)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_of_mset S ! i ∈# S"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_of_mset S ! i ∈ set (list_of_mset S)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_of_mset S ! i ∈# mset (list_of_mset S)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>in_multiset_in_set</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_on_vars_clause</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ vars_clause S. σ v = τ v"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_cls S σ = subst_cls S τ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>assms</span><span> </span><span>image_eqI</span><span> </span><span>image_mset_cong2</span><span> </span><span>mem_simps</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>same_on_vars_lit</span><span> </span><span>set_image_mset</span><span>
</span><span>      </span><span>subst_cls_def</span><span> </span><span>vars_clause_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_partitioned_var_disjoint</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_partitioned Cs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"var_disjoint Cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>var_disjoint_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σs</span><span> </span><span class="delimiter">::</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹('b ⇒ ('a, 'b) term) list›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length σs = length Cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>vars_partitioned_def</span><span class="delimiter">]</span><span> </span><span>Fun_More.fun_merge</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"map vars_clause Cs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nth σs"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>σ_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; length (map vars_clause Cs). ∀x ∈ map vars_clause Cs ! i. σ x = (σs ! i) x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; length Cs. ∀S. S ⊆# Cs ! i ⟶ subst_cls S (σs ! i) = subst_cls S σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span class="delimiter">,</span><span> </span><span>rule</span><span class="delimiter">,</span><span> </span><span>rule</span><span class="delimiter">,</span><span> </span><span>rule</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) term literal multiset"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"i &lt; length Cs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"S ⊆# Cs ! i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ vars_clause S. (σs ! i) v = σ v"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_clause_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>S</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cs ! i"</span></span></span><span class="delimiter">]</span><span> </span><span>σ_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_cls S (σs ! i) = subst_cls S σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>same_on_vars_clause</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃τ. ∀i&lt;length Cs. ∀S. S ⊆# Cs ! i ⟶ subst_cls S (σs ! i) = subst_cls S τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_in_instance_in_range_term</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vars_term (subst_atm_abbrev A σ) ⊆ Union (image vars_term (range σ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_in_instance_in_range_lit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_lit (subst_lit L σ) ⊆ Union (image vars_term (range σ))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>L</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Pos</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term (A ⋅ σ) ⊆ Union (image vars_term (range σ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_in_instance_in_range_term</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>σ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Neg</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_term (A ⋅ σ) ⊆ Union (image vars_term (range σ))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_in_instance_in_range_term</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>σ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_in_instance_in_range_cls</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls C σ) ⊆ Union (image vars_term (range σ))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_clause_def</span><span> </span><span>subst_cls_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_in_instance_in_range_lit</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>σ</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>renamings_apart</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, nat) term clause list ⇒ (('f, nat) subst) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"renamings_apart [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"renamings_apart (C # Cs) =
   (let σs = renamings_apart Cs in
      (λv. Var (v + Max (vars_clause_list (subst_cls_lists Cs σs) ∪ {0}) + 1)) # σs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>var_map_of_subst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, nat) subst ⇒ nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"var_map_of_subst σ v = the_Var (σ v)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>len_renamings_apart</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (renamings_apart Cs) = length Cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Cs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>renamings_apart_is_Var</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ ∈ set (renamings_apart Cs). ∀x. is_Var (σ x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Cs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>renamings_apart_inj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ ∈ set (renamings_apart Cs). inj σ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>Cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj (λv. Var (Suc (v + Max (vars_clause_list
               (subst_cls_lists Cs (renamings_apart Cs)) ∪ {0}))))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>add_right_imp_eq</span><span> </span><span>injI</span><span> </span><span>nat.inject</span><span> </span><span>term.inject</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_vars_clause</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (vars_clause x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_clause_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>finite_vars_clause_list</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (vars_clause_list Cs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_clause_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Cs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Suc_Max_notin_set</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite X ⟹ Suc (v + Max (insert 0 X)) ∉ X"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Max.boundedE</span><span> </span><span>Suc_n_not_le_n</span><span> </span><span>empty_iff</span><span> </span><span>finite.insertI</span><span> </span><span>le_add2</span><span> </span><span>vimageE</span><span> </span><span>vimageI</span><span>
</span><span>      </span><span>vimage_Suc_insert_0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_partitioned_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_partitioned []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_partitioned_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_cls_lists_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_cls_lists Cs [] = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_cls_lists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_clause_hd_partitioned_from_tl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Cs ≠[]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (hd (subst_cls_lists Cs (renamings_apart Cs)))
    ∩ vars_clause_list (tl (subst_cls_lists Cs (renamings_apart Cs))) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>C</span><span> </span><span>Cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>σ'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ nat"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ' = (λv. (Suc (v + Max ((vars_clause_list (subst_cls_lists Cs
                        (renamings_apart Cs))) ∪ {0}))))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('a, nat) term"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = (λv. Var (σ' v))"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls C σ) ⊆ ⋃ (vars_term ` range σ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_in_instance_in_range_cls</span><span class="delimiter">[</span><span>of</span><span> </span><span>C</span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (renamings_apart (C # Cs))"</span></span></span><span class="delimiter">]</span><span> </span><span>σ_def</span><span> </span><span>σ'_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋃ (vars_term ` range σ)
    ∩ vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range σ' ∩ vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ'_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_Max_notin_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ_def</span><span> </span><span>σ'_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls C σ)
     ∩ vars_clause_list (subst_cls_lists Cs (renamings_apart Cs)) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ_def</span><span> </span><span>σ'_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_cls_lists_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>subst_cls_lists_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_partitioned_renamings_apart</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>C</span><span> </span><span>Cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ij</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"i &lt; Suc (length Cs)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"j &lt; i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) ∩
        vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =
        {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j'</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i'j'</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"i = 0"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"j = Suc j'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) ∩
        vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =
        {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ij</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i'</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i'j'</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"i = Suc i'"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"j = 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>disjoin_C_Cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) ∩
        vars_clause_list ((subst_cls_lists Cs (renamings_apart Cs))) = {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_clause_hd_partitioned_from_tl</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"C # Cs"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>subst_cls_lists_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(subst_cls_lists Cs (renamings_apart Cs) ! i')
          ∈ set (subst_cls_lists Cs (renamings_apart Cs))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'j'</span><span> </span><span>ij</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_cls_lists_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_less_SucD</span><span> </span><span>length_map</span><span> </span><span>len_renamings_apart</span><span> </span><span>length_zip</span><span> </span><span>min_less_iff_conj</span><span>
</span><span>              </span><span>nth_mem</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"x ∈ vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'j'</span><span> </span><span>ij</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_cls_lists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃D ∈ set (subst_cls_lists Cs (renamings_apart Cs)). x ∈ vars_clause D"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i')
        ⊆ Union (set (map vars_clause ((subst_cls_lists Cs (renamings_apart Cs)))))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! 0) ∩
        vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') =
        {}"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>disjoin_C_Cs</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_clause_list_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_cls_lists Cs (renamings_apart Cs) ! i' =
        subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'j'</span><span> </span><span>ij</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_cls_lists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) ∩
        vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =
        {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i'j'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Int_commute</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i'</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j'</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i'j'</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"i = Suc i'"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"j = Suc j'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i'&lt;length (subst_cls_lists Cs (renamings_apart Cs))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ij</span><span> </span><span>i'j'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_cls_lists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>len_renamings_apart</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j'&lt;length (subst_cls_lists Cs (renamings_apart Cs))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ij</span><span> </span><span>i'j'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_cls_lists_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>len_renamings_apart</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i' ≠ j'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i = Suc i'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹j = Suc j'›</span></span></span><span> </span><span>ij</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! i') ∩
          vars_clause (subst_cls_lists Cs (renamings_apart Cs) ! j') =
          {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_partitioned_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) ∩
        vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =
        {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>i'j'</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_cls_lists_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹i = 0›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹j = 0›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! i) ∩
        vars_clause (subst_cls_lists (C # Cs) (renamings_apart (C # Cs)) ! j) =
        {}›</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ij</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_partitioned_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Int_commute</span><span> </span><span>Suc_lessI</span><span> </span><span>len_renamings_apart</span><span> </span><span>length_map</span><span>
</span><span>        </span><span>length_nth_simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>length_zip</span><span> </span><span>min.idem</span><span> </span><span>nat.inject</span><span> </span><span>not_less_eq</span><span> </span><span>subst_cls_lists_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>substitution</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var :: _ ⇒ ('f, nat) term"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∘<span class="hidden">⇩</span><sub>s</sub>)"</span></span></span><span> </span><span>renamings_apart</span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun undefined"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>standard</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A. A ⋅ Var = A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A τ σ. A ⋅ τ ∘<span class="hidden">⇩</span><sub>s</sub> σ = A ⋅ τ ⋅ σ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀σ τ. (⋀A. A ⋅ σ = A ⋅ τ) ⟹ σ = τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_term_eqI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>C</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, nat) term clause"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_cls (subst_cls C σ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ground_atms_σ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀v. v ∈ vars_clause C ⟹ is_ground_atm (σ v)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>is_ground_cls_is_ground_on_var</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>some_ground_trm</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, nat) term"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"some_ground_trm = (Fun undefined [])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ground_trm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_atm some_ground_trm"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_ground_atm_def</span><span> </span><span>some_ground_trm_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>τ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ = (λv. if v ∈ vars_clause C then σ v else some_ground_trm)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>τ_σ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ vars_clause C. σ v = τ v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>τ_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_ground_τ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_atm (τ v)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>v</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v ∈ vars_clause C"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_atms_σ</span><span> </span><span>τ_σ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>τ_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ground_trm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_subst τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_ground_subst_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_ground_atm (subst_atm_abbrev A τ)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>v</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_ground_τ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fun</span><span> </span><span>f</span><span> </span><span>As</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_ground_τ</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_ground_atm_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀v ∈ vars_clause C. σ v = τ v"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>τ_σ</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_clause_list_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_cls C σ = subst_cls C τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>same_on_vars_clause</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃τ. is_ground_subst τ ∧ subst_cls C τ = subst_cls C σ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Cs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, nat) term clause list"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (renamings_apart Cs) = length Cs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len_renamings_apart</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Cs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, nat) term clause list"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ρ</span><span> </span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('f, nat) Term.term"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ρ_renaming</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ρ ∈ set (renamings_apart Cs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inj_is_renaming</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⋀σ :: ('f, nat) subst. (⋀x. is_Var (σ x)) ⟹ inj σ ⟹ is_renaming σ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, nat) subst"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>is_var_σ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. is_Var (σ x)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>inj_σ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj σ"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>σ'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ' = var_map_of_subst σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>σ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ = Var ∘ σ'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>σ'_def</span><span> </span><span>var_map_of_subst_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_var_σ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>is_var_σ</span><span> </span><span>inj_σ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inj σ'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_renaming_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_domain_def</span><span> </span><span>inj_on_def</span><span> </span><span>σ'_def</span><span> </span><span>var_map_of_subst_def</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>term.collapse</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv σ' ∘ σ' = id"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_o_cancel</span><span class="delimiter">[</span><span>of</span><span> </span><span>σ'</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var ∘ (inv σ' ∘ σ') = Var"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. (Var ∘ (inv σ' ∘ σ')) x = Var x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. ((Var ∘ σ') ∘<span class="hidden">⇩</span><sub>s</sub> (Var ∘ (inv σ'))) x = Var x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subst_compose_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∘<span class="hidden">⇩</span><sub>s</sub> (Var ∘ (inv σ')) = Var"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>σ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_renaming σ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_renaming_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀σ ∈ (set (renamings_apart Cs)). is_renaming σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>renamings_apart_is_Var</span><span> </span><span>renamings_apart_inj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_renaming ρ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ρ_renaming</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Cs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f, nat) term clause list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_partitioned (subst_cls_lists Cs (renamings_apart Cs))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_partitioned_renamings_apart</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"var_disjoint (subst_cls_lists Cs (renamings_apart Cs))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>vars_partitioned_var_disjoint</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀σ As Bs. Fun undefined As ⋅ σ = Fun undefined Bs ⟷ map (λA. A ⋅ σ) As = Bs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (strictly_generalizes_atm :: ('f, 'v) term ⇒ _ ⇒ _)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>wfP_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_subset</span><span class="delimiter">[</span><span>OF</span><span> </span><span>wf_subsumes</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>strictly_generalizes_atm_def</span><span> </span><span>generalizes_atm_def</span><span> </span><span>term_subsumable.subsumes_def</span><span>
</span><span>        </span><span>subsumeseq_term.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>pairs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ ('a × 'a) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pairs (x # y # xs) = (x, y) # pairs (y # xs)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pairs _ = []"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare</span><span> </span><span class="string"><span class="delete"><span class="delete">"term"</span></span></span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>compare</span><span> </span><span class="string"><span class="delete"><span class="delete">"literal"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>class_linorder_compare</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"class.linorder (le_of_comp compare) (lt_of_comp compare)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>standard</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lt_of_comp_def</span><span> </span><span>le_of_comp_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>order.splits</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comparator.sym</span><span> </span><span>comparator_compare</span><span> </span><span>invert_order.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>order.distinct</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comparator_compare</span><span> </span><span>comparator_def</span><span> </span><span>order.distinct</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comparator.sym</span><span> </span><span>comparator_compare</span><span> </span><span>invert_order.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>order.distinct</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>comparator.sym</span><span> </span><span>comparator_compare</span><span> </span><span>invert_order.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>order.distinct</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>compare_linorder</span><span class="delimiter">:</span><span> </span><span>linorder</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"le_of_comp compare"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lt_of_comp compare"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>class_linorder_compare</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Pairs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Pairs AAA = concat (compare_linorder.sorted_list_of_set
     ((pairs ∘ compare_linorder.sorted_list_of_set) ` AAA))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unifies_all_pairs_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀p ∈ set (pairs xs). fst p ⋅ σ = snd p ⋅ σ) ⟷ (∀a ∈ set xs. ∀b ∈ set xs. a ⋅ σ = b ⋅ σ)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>pairs.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>pairs.simps</span><span> </span><span>list.set</span><span> </span><span>ball_Un</span><span> </span><span>ball_simps</span><span> </span><span>simp_thms</span><span> </span><span>fst_conv</span><span> </span><span>snd_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_pair_in_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A,B) ∈ set ((pairs As))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ set As ∧ B ∈ set As"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>As</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>A</span><span> </span><span>As</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Cons_outer</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>As</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons_outer</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>B</span><span> </span><span>As'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons_outer</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_pairs_sorted_list_of_set_in_set</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"finite AAA"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀AA ∈ AAA. finite AA"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"AB_pairs ∈ (pairs ∘ compare_linorder.sorted_list_of_set) ` AAA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(A :: _ :: compare, B) ∈ set AB_pairs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃AA. AA ∈ AAA ∧ A ∈ AA ∧ B ∈ AA"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"AB_pairs ∈ (pairs ∘ compare_linorder.sorted_list_of_set) ` AAA"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>AA</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>AA_p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"AA ∈ AAA ∧ (pairs ∘ compare_linorder.sorted_list_of_set) AA = AB_pairs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(A, B) ∈ set (pairs (compare_linorder.sorted_list_of_set AA))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>AA_p</span><span class="delimiter">[</span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ set (compare_linorder.sorted_list_of_set AA)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"B ∈ set (compare_linorder.sorted_list_of_set AA)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>in_pair_in_set</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>AA_p</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unifiers_Pairs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"finite AAA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀AA ∈ AAA. finite AA"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"unifiers (set (Pairs AAA)) = {σ. is_unifiers σ AAA}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span class="delimiter">;</span><span> </span><span>rule</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) subst"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∈ unifiers (set (Pairs AAA))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀AA. AA ∈ AAA ⟹ card (AA ⋅<span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>t</sub> σ) ≤ Suc 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>AA</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) term set"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"AA ∈ AAA"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p ∈ set (pairs (compare_linorder.sorted_list_of_set AA)).
      subst_atm_abbrev (fst p) σ = subst_atm_abbrev (snd p) σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pairs_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀A ∈ AA. ∀B ∈ AA. subst_atm_abbrev A σ = subst_atm_abbrev B σ"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>asm'</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>unifies_all_pairs_iff</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compare_linorder.sorted_list_of_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (AA ⋅<span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>t</sub> σ) ≤ Suc 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>imageE</span><span> </span><span>card.empty</span><span> </span><span>card_Suc_eq</span><span> </span><span>card_mono</span><span> </span><span>finite.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>finite_insert</span><span> </span><span>le_SucI</span><span>
</span><span>           </span><span>singletonI</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∈ {σ. is_unifiers σ AAA}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_unifiers_def</span><span> </span><span>is_unifier_def</span><span> </span><span>subst_atms_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'b) subst"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∈ {σ. is_unifiers σ AAA}"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>AB_pairs</span><span> </span><span>A</span><span> </span><span>B</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"AB_pairs ∈ set (compare_linorder.sorted_list_of_set
         ((pairs ∘ compare_linorder.sorted_list_of_set) ` AAA))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(A, B) ∈ set AB_pairs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃AA. AA ∈ AAA ∧ A ∈ AA ∧ B ∈ AA"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>in_pairs_sorted_list_of_set_in_set</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>AA</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"AA ∈ AAA"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ AA"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ AA"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span>assms</span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>card_AA_σ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"card (AA ⋅<span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>t</sub> σ) ≤ Suc 0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_unifiers_def</span><span> </span><span>is_unifier_def</span><span> </span><span>subst_atms_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_atm_abbrev A σ = subst_atm_abbrev B σ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"card (AA ⋅<span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>t</sub> σ) = Suc 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_atm_abbrev A σ ∈ AA ⋅<span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>t</sub> σ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>assms</span><span> </span><span>asm</span><span> </span><span>card_AA_σ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_atm_abbrev B σ ∈ AA ⋅<span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>t</sub> σ"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>assms</span><span> </span><span>asm</span><span> </span><span>card_AA_σ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>assms</span><span> </span><span>asm</span><span> </span><span>card_AA_σ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>card_Suc_eq</span><span> </span><span>singletonD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"card (AA ⋅<span class="hidden">⇩</span><sub>s</sub><span class="hidden">⇩</span><sub>e</sub><span class="hidden">⇩</span><sub>t</sub> σ) = 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>assms</span><span> </span><span>asm</span><span> </span><span>card_AA_σ</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>assms</span><span> </span><span>asm</span><span> </span><span>card_AA_σ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∈ unifiers (set (Pairs AAA))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Pairs_def</span><span> </span><span>unifiers_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mgu_sets AAA = map_option subst_of (unify (Pairs AAA) [])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>mgu</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋅)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Var :: _ ⇒ ('f :: compare, nat) term"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∘<span class="hidden">⇩</span><sub>s</sub>)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fun undefined"</span></span></span><span>
</span><span>  </span><span>renamings_apart</span><span> </span><span>mgu_sets</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>AAA</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a :: compare, nat) term set set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, nat) subst"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite AAA"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀AA ∈ AAA. finite AA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mgu_sets AAA = Some σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_imgu σ (set (Pairs AAA))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unify_sound</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mgu_sets_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_mgu σ AAA"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_imgu_def</span><span> </span><span>is_mgu_def</span><span> </span><span>unifiers_Pairs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>AAA</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a :: compare, nat) term set set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>σ</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, nat) subst"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>fin</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite AAA"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀AA ∈ AAA. finite AA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_unifiers σ AAA"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"σ ∈ unifiers (set (Pairs AAA))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>is_mgu_def</span><span> </span><span>unifiers_Pairs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>fin</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃τ. mgu_sets AAA = Some τ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unify_complete</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mgu_sets_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>linorder</span><span> </span><span>prod</span><span>
</span><span class="keyword1"><span class="command">derive</span></span><span> </span><span>linorder</span><span> </span><span>list</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Executable_Subsumption">
<div class="head"><h1>Theory Executable_Subsumption</h1>
<span class="command">theory</span> <span class="name">Executable_Subsumption</span><br/>
<span class="keyword">imports</span> <a href="IsaFoR_Term.html"><span class="name">IsaFoR_Term</span></a> <a href="Matching.html"><span class="name">Matching</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       An Executable Algorithm for Clause Subsumption
    Author:      Dmitriy Traytel &lt;traytel at inf.ethz.ch&gt;, 2017
    Maintainer:  Anders Schlichtkrull &lt;andschl at dtu.dk&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹An Executable Algorithm for Clause Subsumption›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This theory provides a functional implementation of clause subsumption, building
on the \textsf{IsaFoR} library (part of the AFP entry ‹First_Order_Terms›).
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Executable_Subsumption</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>IsaFoR_Term</span><span> </span><span>First_Order_Terms.Matching</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Naive Implementation of Clause Subsumption›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>subsumes_list</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subsumes_list [] Ks σ = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes_list (L # Ls) Ks σ =
     (∃K ∈ set Ks. is_pos K = is_pos L ∧
       (case match_term_list [(atm_of L, atm_of K)] σ of
         None ⇒ False
       | Some ρ ⇒ subsumes_list Ls (remove1 K Ks) ρ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atm_of_map_literal</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"atm_of (map_literal f l) = f (atm_of l)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>l</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extends_subst σ τ = (∀x ∈ dom σ. σ x = τ x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extends_subst_refl</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extends_subst σ σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extends_subst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extends_subst_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extends_subst σ τ ⟹ extends_subst τ ρ ⟹ extends_subst σ ρ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extends_subst_def</span><span> </span><span>dom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extends_subst_dom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extends_subst σ τ ⟹ dom σ ⊆ dom τ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extends_subst_def</span><span> </span><span>dom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extends_subst_extends</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extends_subst σ τ ⟹ x ∈ dom σ ⟹ τ x = σ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extends_subst_def</span><span> </span><span>dom_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extends_subst_fun_upd_new</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"σ x = None ⟹ extends_subst (σ(x ↦ t)) τ ⟷ extends_subst σ τ ∧ τ x = Some t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extends_subst_def</span><span> </span><span>dom_fun_upd</span><span> </span><span>subst_of_map_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dom_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extends_subst_fun_upd_matching</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"σ x = Some t ⟹ extends_subst (σ(x ↦ t)) τ ⟷ extends_subst σ τ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extends_subst_def</span><span> </span><span>dom_fun_upd</span><span> </span><span>subst_of_map_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dom_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extends_subst_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extends_subst Map.empty τ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extends_subst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extends_subst_cong_term</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"extends_subst σ τ ⟹ vars_term t ⊆ dom σ ⟹ t ⋅ subst_of_map Var σ = t ⋅ subst_of_map Var τ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extends_subst_def</span><span> </span><span>subst_of_map_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>term_subst_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>extends_subst_cong_lit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"extends_subst σ τ ⟹ vars_lit L ⊆ dom σ ⟹ L ⋅lit subst_of_map Var σ = L ⋅lit subst_of_map Var τ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extends_subst_cong_term</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes_modulo C D σ =
   (∃τ. dom τ = vars_clause C ∪ dom σ ∧ extends_subst σ τ ∧ subst_cls C (subst_of_map Var τ) ⊆# D)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>subsumes_list_modulo</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subsumes_list_modulo Ls Ks σ ≡ subsumes_modulo (mset Ls) (mset Ks) σ"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vars_clause_add_mset</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vars_clause (add_mset L C) = vars_lit L ∪ vars_clause C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vars_clause_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subsumes_list_modulo_Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes_list_modulo (L # Ls) Ks σ ⟷
  (∃K ∈ set Ks. ∃τ. extends_subst σ τ ∧ dom τ = vars_lit L ∪ dom σ ∧ L ⋅lit (subst_of_map Var τ) = K
     ∧ subsumes_list_modulo Ls (remove1 K Ks) τ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subsumes_modulo_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>safe</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span> </span><span>left_right</span><span> </span><span>right_left</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>left_right</span><span> </span><span>τ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ⋅lit subst_of_map Var τ"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. if x ∈ vars_lit L ∪ dom σ then τ x else None"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>τ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extends_subst_def</span><span> </span><span>dom_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span>
</span><span>      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insert_subset_eq_iff</span><span> </span><span>subst_lit_def</span><span>  </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>extends_subst_cong_lit</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>right_left</span><span> </span><span>K</span><span> </span><span>τ</span><span> </span><span>τ'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>bexI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"L ⋅lit subst_of_map Var τ"</span></span></span><span class="delimiter">]</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>τ'</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>τ</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>insert_subset_eq_iff</span><span> </span><span>subst_lit_def</span><span> </span><span>extends_subst_cong_lit</span><span>
</span><span>       </span><span>intro</span><span class="delimiter">:</span><span> </span><span>extends_subst_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decompose_Some_var_terms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"decompose (Fun f ss) (Fun g ts) = Some eqs ⟹
   f = g ∧ length ss = length ts ∧ eqs = zip ss ts ∧
   (⋃(t, u)∈set ((Fun f ss, Fun g ts) # P). vars_term t) =
   (⋃(t, u)∈set (eqs @ P). vars_term t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>decompose_Some</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_zip</span><span> </span><span>in_set_conv_nth</span><span> </span><span>Bex_def</span><span> </span><span>image_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>match_term_list_sound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"match_term_list tus σ = Some τ ⟹
  extends_subst σ τ ∧ dom τ = (⋃(t, u)∈set tus. vars_term t) ∪ dom σ ∧
  (∀(t,u)∈set tus. t ⋅ subst_of_map Var τ = u)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>tus</span><span> </span><span>σ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>match_term_list.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>x</span><span> </span><span>t</span><span> </span><span>P</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extends_subst_fun_upd_new</span><span> </span><span>extends_subst_fun_upd_matching</span><span> 
</span><span>      </span><span>subst_of_map_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>extends_subst_extends</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>f</span><span> </span><span>ss</span><span> </span><span>g</span><span> </span><span>ts</span><span> </span><span>P</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>eqs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"decompose (Fun f ss) (Fun g ts) = Some eqs"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"match_term_list (eqs @ P) σ = Some τ"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>decompose_Some_var_terms</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span>P</span><span class="delimiter">,</span><span> </span><span>elim_format</span><span class="delimiter">]</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span> </span><span>extend</span><span> </span><span>dom</span><span> </span><span>subst</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>subst</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subst</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">,</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>6</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_nth</span><span> </span><span>list_eq_iff_nth_eq</span><span> </span><span>Ball_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>match_term_list_complete</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"match_term_list tus σ = None ⟹
   extends_subst σ τ ⟹ dom τ = (⋃(t, u)∈set tus. vars_term t) ∪ dom σ ⟹
    (∃(t,u)∈set tus. t ⋅ subst_of_map Var τ ≠ u)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>tus</span><span> </span><span>σ</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>τ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>match_term_list.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>x</span><span> </span><span>t</span><span> </span><span>P</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>extends_subst_fun_upd_new</span><span> </span><span>extends_subst_fun_upd_matching</span><span> 
</span><span>      </span><span>subst_of_map_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>extends_subst_extends</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>fun_upd_apply</span><span>
</span><span>      </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>f</span><span> </span><span>ss</span><span> </span><span>g</span><span> </span><span>ts</span><span> </span><span>P</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"decompose (Fun f ss) (Fun g ts) = None"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>eqs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"decompose (Fun f ss) (Fun g ts) = Some eqs"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"match_term_list (eqs @ P) σ = None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx. x ∪ dom σ"</span></span></span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>decompose_Some_var_terms</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span>P</span><span class="delimiter">,</span><span> </span><span>elim_format</span><span class="delimiter">]</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span> </span><span>subst</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>subst</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subst</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subst</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>subst</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>0</span><span> </span><span>3</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>in_set_conv_nth</span><span> </span><span>list_eq_iff_nth_eq</span><span> </span><span>Ball_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unique_extends_subst</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>extends</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extends_subst σ τ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extends_subst σ ρ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>dom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dom τ = vars_term t ∪ dom σ"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dom ρ = vars_term t ∪ dom σ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ⋅ subst_of_map Var ρ = t ⋅ subst_of_map Var τ"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ρ = τ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>a</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ dom σ"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>b</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ vars_term t"</span></span></span><span> </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>c</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ dom τ"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ρ x = τ x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>a</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>extends</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>extends_subst_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>eq</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Var</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>dom</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>dom</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subst_of_map_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ρ x = None"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ x = None"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subsumes_list_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subsumes_list Ls Ks σ ⟷ subsumes_list_modulo Ls Ks σ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Ls</span><span> </span><span>Ks</span><span> </span><span>σ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subsumes_list.induct</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Nil</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>L</span><span> </span><span>Ls</span><span> </span><span>Ks</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subsumes_list_modulo_Cons</span><span> </span><span>subsumes_list.simps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span class="delimiter">(</span><span>intro</span><span> </span><span>bex_cong</span><span class="delimiter">[</span><span>OF</span><span> </span><span>refl</span><span class="delimiter">]</span><span> </span><span>ext</span><span> </span><span>iffI</span><span class="delimiter">;</span><span> </span><span>elim</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span> </span><span>LR</span><span> </span><span>RL</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>LR</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>LR</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>K</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>L</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons.IH</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>match_term_list_sound</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>RL</span><span> </span><span>K</span><span> </span><span>τ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"match_term_list [(atm_of L, atm_of K)] σ"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>RL</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons.IH</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>match_term_list_complete</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>τ'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>RL</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>unique_extends_subst</span><span class="delimiter">[</span><span>of</span><span> </span><span>σ</span><span> </span><span>τ</span><span> </span><span>τ'</span><span> </span><span class="string"><span class="delete"><span class="delete">"atm_of L"</span></span></span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons.IH</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>match_term_list_sound</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subsumes_modulo_def</span><span> </span><span>subst_cls_def</span><span> </span><span>vars_clause_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>extends_subst_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subsumes_subsumes_list</span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subsumes (mset Ls) (mset Ks) = subsumes_list Ls Ks Map.empty"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subsumes_list_alt</span><span class="delimiter">[</span><span>of</span><span> </span><span>Ls</span><span> </span><span>Ks</span><span> </span><span>Map.empty</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes (mset Ls) (mset Ks)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>σ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_cls (mset Ls) σ ⊆# mset Ks"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subsumes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>τ</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"τ = (λx. if x ∈ vars_clause (mset Ls) then Some (σ x) else None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes_list_modulo Ls Ks Map.empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subsumes_modulo_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>same_on_vars_clause</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>σ</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_of_map Var τ"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>τ</span><span class="delimiter">]</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subst_of_map_def</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subsumes_modulo_def</span><span> </span><span>subst_lit_def</span><span> </span><span>subsumes_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strictly_subsumes_subsumes_list</span><span class="delimiter">[</span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"strictly_subsumes (mset Ls) (mset Ks) =
    (subsumes_list Ls Ks Map.empty ∧ ¬ subsumes_list Ks Ls Map.empty)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>strictly_subsumes_def</span><span> </span><span>subsumes_subsumes_list</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subsumes_list_filterD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes_list Ls (filter P Ks) σ ⟹ subsumes_list Ls Ks σ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Ls</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>Ks</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>L</span><span> </span><span>Ls</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Cons.IH</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_remove1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subsumes_list_filterI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>match</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀L K σ τ. L ∈ set Ls ⟹
    match_term_list [(atm_of L, atm_of K)] σ = Some τ ⟹ is_pos L = is_pos K ⟹ P K)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes_list Ls Ks σ ⟹ subsumes_list Ls (filter P Ks) σ"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Ls</span><span> </span><span>Ks</span><span> </span><span>σ</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>subsumes_list.induct</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Nil</span><span> </span><span>Cons</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>L</span><span> </span><span>Ls</span><span> </span><span>Ks</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>subsumes_list.simps</span><span> </span><span>set_filter</span><span> </span><span>bex_simps</span><span> </span><span>conj_assoc</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>bexE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span>
</span><span>        </span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>filter_remove1</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Cons.IH</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subsumes_list_Cons_filter_iff</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sorted_wrt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted_wrt leq (L # Ls)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"transp leq"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>match</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀L K σ τ.
    match_term_list [(atm_of L, atm_of K)] σ = Some τ ⟹ is_pos L = is_pos K ⟹ leq L K)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes_list (L # Ls) (filter (leq L) Ks) σ ⟷ subsumes_list (L # Ls) Ks σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subsumes_list_filterD</span><span> </span><span>subsumes_list_filterI</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>assumption</span><span class="delimiter">?</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>list.set</span><span> </span><span>insert_iff</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>match</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>K</span><span> </span><span>σ</span><span> </span><span>τ</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sorted_wrt</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>List.sorted_wrt.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>bspec</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>transpD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>match</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>leq_head</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f::linorder, 'v) term ⇒ ('f, 'v) term ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"leq_head t u = (case (root t, root u) of
    (None, _) ⇒ True
  | (_, None) ⇒ False
  | (Some f, Some g) ⇒ f ≤ g)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"leq_lit L K = (case (K, L) of
    (Neg _, Pos _) ⇒ True
  | (Pos _, Neg _) ⇒ False
  | _ ⇒ leq_head (atm_of L) (atm_of K))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>transp_leq_lit</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"transp leq_lit"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>transp_def</span><span> </span><span>leq_lit_def</span><span> </span><span>leq_head_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>literal.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reflp_leq_lit</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reflp_on leq_lit A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>reflp_on_def</span><span> </span><span>leq_lit_def</span><span> </span><span>leq_head_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>literal.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>total_leq_lit</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"total_on leq_lit A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>total_on_def</span><span> </span><span>leq_lit_def</span><span> </span><span>leq_head_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>literal.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>leq_head_subst</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"leq_head t (t ⋅ σ)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>leq_head_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>leq_lit_match</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>L</span><span> </span><span>K</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('f :: linorder, 'v) term literal"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match_term_list [(atm_of L, atm_of K)] σ = Some τ ⟹ is_pos L = is_pos K ⟹ leq_lit L K"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>L</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>K</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>leq_lit_def</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>match_term_list_sound</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Optimized Implementation of Clause Subsumption›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>subsumes_list_filter</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subsumes_list_filter [] Ks σ = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes_list_filter (L # Ls) Ks σ =
     (let Ks = filter (leq_lit L) Ks in
     (∃K ∈ set Ks. is_pos K = is_pos L ∧
       (case match_term_list [(atm_of L, atm_of K)] σ of
         None ⇒ False
       | Some ρ ⇒ subsumes_list_filter Ls (remove1 K Ks) ρ)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sorted_wrt_subsumes_list_subsumes_list_filter</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sorted_wrt leq_lit Ls ⟹ subsumes_list Ls Ks σ = subsumes_list_filter Ls Ks σ"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>Ls</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>Ks</span><span> </span><span>σ</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>L</span><span> </span><span>Ls</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes_list (L # Ls) Ks σ = subsumes_list (L # Ls) (filter (leq_lit L) Ks) σ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>subsumes_list_Cons_filter_iff</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>leq_lit_match</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subsumes_list (L # Ls) (filter (leq_lit L) Ks) σ = subsumes_list_filter (L # Ls) Ks σ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Cons.IH</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Definition of Deterministic QuickSort›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This is the functional description of the standard variant of deterministic
  QuickSort that always chooses the first list element as the pivot as given
  by Hoare in 1962. For a list that is already sorted, this leads to $n(n-1)$
  comparisons, but as is well known, the average case is much better.

  The code below is adapted from Manuel Eberl's ‹Quick_Sort_Cost› AFP
  entry, but without invoking probability theory and using a predicate instead
  of a set.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>quicksort</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a ⇒ bool) ⇒ 'a list ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"quicksort _ [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"quicksort R (x # xs) =
     quicksort R (filter (λy. R y x) xs) @ [x] @ quicksort R (filter (λy. ¬ R y x) xs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We can easily show that this QuickSort is correct:
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>mset_quicksort</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mset (quicksort R xs) = mset xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>R</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>quicksort.induct</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>set_quicksort</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (quicksort R xs) = set xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>R</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>quicksort.induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>sorted_wrt_quicksort</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transp R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"total_on R (set xs)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"reflp_on R (set xs)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"sorted_wrt R (quicksort R xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>R</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>quicksort.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>R</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>total</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R a b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ R b a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set (x#xs)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"b ∈ set (x#xs)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2.prems"</span></span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>total_on_def</span><span> </span><span>reflp_on_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a = b"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sorted_wrt R (quicksort R (filter (λy. R y x) xs))"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"sorted_wrt R (quicksort R (filter (λy. ¬ R y x) xs))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2.prems"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span class="string"><span class="delete"><span class="delete">"2.IH"</span></span></span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>total_on_def</span><span> </span><span>reflp_on_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sorted_wrt_append</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹transp R›</span></span></span><span>
</span><span>     </span><span>intro</span><span class="delimiter">:</span><span> </span><span>transpD</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹transp R›</span></span></span><span class="delimiter">]</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>total</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
End of the material adapted from Eberl's ‹Quick_Sort_Cost›.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subsumes_list_subsumes_list_filter</span><span class="delimiter">[</span><span>abs_def</span><span class="delimiter">,</span><span> </span><span>code_unfold</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"subsumes_list Ls Ks σ = subsumes_list_filter (quicksort leq_lit Ls) Ks σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>box_equals</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>subsumes_list_alt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>subsumes_list_alt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span>sorted_wrt_subsumes_list_subsumes_list_filter</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>sorted_wrt_quicksort</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>