<div id="Random_BSTs">
<div class="head">
<h1>Theory Random_BSTs</h1>
</div>
<pre class="source"><span class="comment1">(*
  File:     Random_BSTs.thy
  Author:   Manuel Eberl &lt;eberlm@in.tum.de&gt;

  Expected shape of random Binary Search Trees
*)</span>
<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Expected shape of random Binary Search Trees›</span></span>
<span class="keyword1"><span class="command">theory</span></span> Random_BSTs
  <span class="keyword2"><span class="keyword">imports</span></span>
    <a href="../../HOL/HOL/Complex_Main.html">Complex_Main</a>
    <span class="quoted">"<a href="../../HOL/HOL-Probability/Random_Permutations.html">HOL-Probability.Random_Permutations</a>"</span>
    <span class="quoted">"<a href="../../HOL/HOL-Data_Structures/Tree_Set.html">HOL-Data_Structures.Tree_Set</a>"</span>
    <a href="../Quick_Sort_Cost/Quick_Sort_Average_Case.html">Quick_Sort_Cost.Quick_Sort_Average_Case</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(* TODO: Hide this in the proper place *)</span>
<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> Tree_Set.insert

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Auxiliary lemmas›</span></span>

<span class="comment1">(* TODO: Move? *)</span>
<span class="keyword1" id="Random_BSTs-linorder_on_linorder_class"><span class="command">lemma</span></span> linorder_on_linorder_class <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"linorder_on UNIV <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="main">(</span><span class="bound">y</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> linorder<span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> linorder_on_def refl_on_def antisym_def trans_def total_on_def<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-Nil_in_permutations_of_set_iff"><span class="command">lemma</span></span> Nil_in_permutations_of_set_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">∈</span> permutations_of_set <span class="free">A</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> permutations_of_set_def<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-max_power_distrib_right"><span class="command">lemma</span></span> max_power_distrib_right<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">a</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linordered_semidom"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">&gt;</span> <span class="main">1</span> <span class="main">⟹</span> max <span class="main">(</span><span class="free">a</span> <span class="main">^</span> <span class="free">b</span><span class="main">)</span> <span class="main">(</span><span class="free">a</span> <span class="main">^</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">a</span> <span class="main">^</span> max <span class="free">b</span> <span class="free">c</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> max_def<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-set_tree_empty_iff"><span class="command">lemma</span></span> set_tree_empty_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set_tree <span class="free">t</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">⟷</span> <span class="free">t</span> <span class="main">=</span> Leaf"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Random_BSTs-card_set_tree_bst"><span class="command">lemma</span></span> card_set_tree_bst<span class="main">:</span> <span class="quoted"><span class="quoted">"bst <span class="free">t</span> <span class="main">⟹</span> card <span class="main">(</span>set_tree <span class="free">t</span><span class="main">)</span> <span class="main">=</span> size <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set_tree <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">r</span><span class="main">⟩</span> <span class="main">=</span> insert <span class="skolem">x</span> <span class="main">(</span>set_tree <span class="skolem">l</span> <span class="main">∪</span> set_tree <span class="skolem">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> Node.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">…</span> <span class="main">=</span> Suc <span class="main">(</span>card <span class="main">(</span>set_tree <span class="skolem">l</span> <span class="main">∪</span> set_tree <span class="skolem">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> card_insert_disjoint<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> Node <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">(</span>set_tree <span class="skolem">l</span> <span class="main">∪</span> set_tree <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> size <span class="skolem">l</span> <span class="main">+</span> size <span class="skolem">r</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> card_Un_disjoint<span class="main">)</span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Random_BSTs-pair_pmf_cong"><span class="command">lemma</span></span> pair_pmf_cong<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="free">p'</span> <span class="main">⟹</span> <span class="free">q</span> <span class="main">=</span> <span class="free">q'</span> <span class="main">⟹</span> pair_pmf <span class="free">p</span> <span class="free">q</span> <span class="main">=</span> pair_pmf <span class="free">p'</span> <span class="free">q'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Random_BSTs-expectation_add_pair_pmf"><span class="command">lemma</span></span> expectation_add_pair_pmf<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'c</span><span class="main">::</span><span class="main">{</span>banach<span class="main">,</span> second_countable_topology<span class="main">}</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>set_pmf <span class="free">p</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>set_pmf <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">+</span> <span class="free">g</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span>
           measure_pmf.expectation <span class="free">p</span> <span class="free">f</span> <span class="main">+</span> measure_pmf.expectation <span class="free">q</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">+</span> <span class="free">g</span> <span class="bound">y</span><span class="main">)</span> <span class="main">=</span>
          measure_pmf.expectation <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>fst <span class="bound">z</span><span class="main">)</span> <span class="main">+</span> <span class="free">g</span> <span class="main">(</span>snd <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_prod_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> measure_pmf.expectation <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>fst <span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">+</span>
                  measure_pmf.expectation <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span>snd <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Bochner_Integration.integral_add integrable_measure_pmf_finite<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span>fst <span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
               measure_pmf.expectation <span class="main">(</span>map_pmf fst <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">f</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf fst <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="free">p</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_fst_pair_pmf<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> <span class="free">g</span> <span class="main">(</span>snd <span class="bound">z</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
               measure_pmf.expectation <span class="main">(</span>map_pmf snd <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="free">g</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf snd <span class="main">(</span>pair_pmf <span class="free">p</span> <span class="free">q</span><span class="main">)</span> <span class="main">=</span> <span class="free">q</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_snd_pair_pmf<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Creating a BST from a list›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following recursive function creates a binary search tree from a given list of
  elements by inserting them into an initially empty BST from left to right. We will prove
  that this is the case later, but the recursive definition has the advantage of giving us
  a useful induction rule, so we chose that definition and prove the alternative definitions later.

  This recursion, which already almost looks like QuickSort, will be key in analysing the
  shape distributions of random BSTs.
›</span></span>
<span class="keyword1"><span class="command">fun</span></span> <span class="entity">bst_of_list</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linorder list <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">bst_of_list</span> <span class="main">[]</span> <span class="main">=</span> Leaf"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">bst_of_list</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span>
     Node <span class="main">(</span><span class="free">bst_of_list</span> <span class="main">[</span><span class="bound">y</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free">bst_of_list</span> <span class="main">[</span><span class="bound">y</span> <span class="main">←</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">]</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Random_BSTs-bst_of_list_eq_Leaf_iff"><span class="command">lemma</span></span> bst_of_list_eq_Leaf_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bst_of_list <span class="free">xs</span> <span class="main">=</span> Leaf <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[]</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Random_BSTs-bst_of_list_snoc"><span class="command">lemma</span></span> bst_of_list_snoc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"bst_of_list <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="main">[</span><span class="free">y</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> Tree_Set.insert <span class="free">y</span> <span class="main">(</span>bst_of_list <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bst_of_list.induct<span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Random_BSTs-bst_of_list_append"><span class="command">lemma</span></span> bst_of_list_append<span class="main">:</span>
  <span class="quoted"><span class="quoted">"bst_of_list <span class="main">(</span><span class="free">xs</span> <span class="main">@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> fold Tree_Set.insert <span class="free">ys</span> <span class="main">(</span>bst_of_list <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"bst_of_list <span class="main">(</span><span class="skolem">xs</span> <span class="main">@</span> <span class="main">(</span><span class="skolem">y</span> <span class="main">#</span> <span class="skolem">ys</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bst_of_list <span class="main">(</span><span class="main">(</span><span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">y</span><span class="main">]</span><span class="main">)</span> <span class="main">@</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> fold Tree_Set.insert <span class="skolem">ys</span> <span class="main">(</span>bst_of_list <span class="main">(</span><span class="skolem">xs</span> <span class="main">@</span> <span class="main">[</span><span class="skolem">y</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Cons.IH<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following now shows that the recursive function indeed corresponds to the
  notion of inserting the elements from the list from left to right.
›</span></span>
<span class="keyword1" id="Random_BSTs-bst_of_list_altdef"><span class="command">lemma</span></span> bst_of_list_altdef<span class="main">:</span> <span class="quoted"><span class="quoted">"bst_of_list <span class="free">xs</span> <span class="main">=</span> fold Tree_Set.insert <span class="free">xs</span> Leaf"</span></span>
  <span class="keyword1"><span class="command">using</span></span> bst_of_list_append<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Random_BSTs-size_bst_insert"><span class="command">lemma</span></span> size_bst_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∉</span> set_tree <span class="free">t</span> <span class="main">⟹</span> size <span class="main">(</span>Tree_Set.insert <span class="free">x</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>size <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Random_BSTs-set_bst_insert"><span class="command">lemma</span></span> set_bst_insert <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set_tree <span class="main">(</span>Tree_Set.insert <span class="free">x</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">x</span> <span class="main">(</span>set_tree <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Random_BSTs-set_bst_of_list"><span class="command">lemma</span></span> set_bst_of_list <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set_tree <span class="main">(</span>bst_of_list <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> set <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Random_BSTs-size_bst_of_list_distinct"><span class="command">lemma</span></span> size_bst_of_list_distinct <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"distinct <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"size <span class="main">(</span>bst_of_list <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> length <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> rev_induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> size_bst_insert<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-strict_mono_on_imp_less_iff"><span class="command">lemma</span></span> strict_mono_on_imp_less_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"strict_mono_on <span class="free">f</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="main">(</span><span class="free">f</span> <span class="free">y</span> <span class="main">::</span> <span class="tfree">'b</span> <span class="main">::</span> linorder<span class="main">)</span> <span class="main">⟷</span> <span class="free">x</span> <span class="main">&lt;</span> <span class="main">(</span><span class="free">y</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">::</span> linorder<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> linorder_cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> strict_mono_on_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Random_BSTs-bst_of_list_map"><span class="command">lemma</span></span> bst_of_list_map<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linorder <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">::</span> linorder"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"strict_mono_on <span class="free">f</span> <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"set <span class="free">xs</span> <span class="main">⊆</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"bst_of_list <span class="main">(</span>map <span class="free">f</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> map_tree <span class="free">f</span> <span class="main">(</span>bst_of_list <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bst_of_list.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="bound">xa</span><span class="main">←</span><span class="skolem">xs</span> <span class="main">.</span> <span class="free">f</span> <span class="bound">xa</span> <span class="main">&lt;</span> <span class="free">f</span> <span class="skolem">x</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="bound">xa</span><span class="main">←</span><span class="skolem">xs</span> <span class="main">.</span> <span class="bound">xa</span> <span class="main">&lt;</span> <span class="skolem">x</span><span class="main">]</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="bound">xa</span><span class="main">←</span><span class="skolem">xs</span> <span class="main">.</span> <span class="free">f</span> <span class="bound">xa</span> <span class="main">&gt;</span> <span class="free">f</span> <span class="skolem">x</span><span class="main">]</span> <span class="main">=</span> <span class="main">[</span><span class="bound">xa</span><span class="main">←</span><span class="skolem">xs</span> <span class="main">.</span> <span class="bound">xa</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">]</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.prems"</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> strict_mono_on_imp_less_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> filter_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> filter_map o_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>  


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Random BSTs›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Analogously to the previous section, we can now view the concept of a random BST
  (i.\,e.\ a BST obtained by inserting a given set of elements in random order) in two
  different ways.

  We again start with the recursive variant:
›</span></span>
<span class="keyword1"><span class="command">function</span></span> <span class="entity">random_bst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linorder set <span class="main">⇒</span> <span class="tfree">'a</span> tree pmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">random_bst</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword1">if</span> <span class="main">¬</span>finite <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">{}</span> <span class="keyword1">then</span>
        return_pmf Leaf
      <span class="keyword1">else</span> <span class="keyword1">do</span> <span class="main">{</span>
        <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">;</span>
        <span class="bound">l</span> <span class="main">←</span> <span class="free">random_bst</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">;</span>
        <span class="bound">r</span> <span class="main">←</span> <span class="free">random_bst</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">;</span>
        return_pmf <span class="main">(</span>Node <span class="bound">l</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span>
     <span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted">finite_psubset</span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">declare</span></span> random_bst.simps <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1" id="Random_BSTs-random_bst_empty"><span class="command">lemma</span></span> random_bst_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"random_bst <span class="main">{}</span> <span class="main">=</span> return_pmf Leaf"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_bst.simps<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-set_pmf_random_permutation"><span class="command">lemma</span></span> set_pmf_random_permutation <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="free">A</span> <span class="main">⟹</span> set_pmf <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">xs</span><span class="main">.</span> distinct <span class="bound">xs</span> <span class="main">∧</span> set <span class="bound">xs</span> <span class="main">=</span> <span class="free">A</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> set_pmf_of_set<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> permutations_of_setD<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The alternative characterisation is the more intuitive one where we simply pick a
  random permutation of the set elements uniformly at random and insert them into an empty
  tree from left to right:
›</span></span>
<span class="keyword1" id="Random_BSTs-random_bst_altdef"><span class="command">lemma</span></span> random_bst_altdef<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"random_bst <span class="free">A</span> <span class="main">=</span> map_pmf bst_of_list <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_psubset_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>psubset <span class="skolem">A</span><span class="main">)</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">L</span></span> <span class="skolem"><span class="skolem">R</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">L</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">x</span> <span class="keyword3"><span class="command">assume</span></span> x<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">A</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">L</span> <span class="skolem">x</span> <span class="main">⊂</span> <span class="skolem">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="skolem">x</span> <span class="main">⊂</span> <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> L_def R_def<span class="main">)</span>
    <span class="keyword1"><span class="command">note</span></span> this <span class="main">[</span><span class="operator">THEN</span> psubset.IH<span class="main">]</span>
  <span class="keyword1"><span class="command">}</span></span> <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> this

  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">note</span></span> A <span class="main">=</span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"random_bst <span class="skolem">A</span> <span class="main">=</span>
            <span class="keyword1">do</span> <span class="main">{</span>
              <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
              <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span> <span class="main">←</span> pair_pmf <span class="main">(</span>random_bst <span class="main">(</span><span class="skolem">L</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>random_bst <span class="main">(</span><span class="skolem">R</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
              return_pmf <span class="main">(</span>Node <span class="bound">l</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span>
            <span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">unfolding</span></span> pair_pmf_def L_def R_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> random_bst.simps<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_return_pmf bind_assoc_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
                      <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                      <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="bound">r</span><span class="main">)</span> <span class="main">←</span> pair_pmf
                        <span class="main">(</span>map_pmf bst_of_list <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="main">(</span><span class="skolem">L</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                        <span class="main">(</span>map_pmf bst_of_list <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="main">(</span><span class="skolem">R</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                      return_pmf <span class="main">(</span>Node <span class="bound">l</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span>
                    <span class="main">}</span>"</span></span>
     <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> bind_pmf_cong refl<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> IH<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
                     <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                     <span class="main">(</span><span class="bound">ls</span><span class="main">,</span> <span class="bound">rs</span><span class="main">)</span> <span class="main">←</span> pair_pmf <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="main">(</span><span class="skolem">L</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
                                          <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="main">(</span><span class="skolem">R</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                     return_pmf <span class="main">(</span>Node <span class="main">(</span>bst_of_list <span class="bound">ls</span><span class="main">)</span> <span class="bound">x</span> <span class="main">(</span>bst_of_list <span class="bound">rs</span><span class="main">)</span><span class="main">)</span>
                   <span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> map_pair <span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_pmf_def case_prod_unfold bind_return_pmf bind_assoc_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">L</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> L_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">R</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">.</span> <span class="main">¬</span><span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> R_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span>
                 <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                 <span class="main">(</span><span class="bound">ls</span><span class="main">,</span> <span class="bound">rs</span><span class="main">)</span> <span class="main">←</span> pair_pmf <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>
                                      <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">.</span> <span class="main">¬</span><span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                 return_pmf <span class="main">(</span>Node <span class="main">(</span>bst_of_list <span class="bound">ls</span><span class="main">)</span> <span class="bound">x</span> <span class="main">(</span>bst_of_list <span class="bound">rs</span><span class="main">)</span><span class="main">)</span>
               <span class="main">}</span> <span class="main">=</span>
               <span class="keyword1">do</span> <span class="main">{</span>
                 <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                 <span class="main">(</span><span class="bound">ls</span><span class="main">,</span> <span class="bound">rs</span><span class="main">)</span> <span class="main">←</span> map_pmf <span class="main">(</span>partition <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>
                               <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="main">(</span><span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                 return_pmf <span class="main">(</span>Node <span class="main">(</span>bst_of_list <span class="bound">ls</span><span class="main">)</span> <span class="bound">x</span> <span class="main">(</span>bst_of_list <span class="bound">rs</span><span class="main">)</span><span class="main">)</span>
               <span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> bind_pmf_cong refl partition_random_permutations <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
                      <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                      <span class="main">(</span><span class="bound">ls</span><span class="main">,</span> <span class="bound">rs</span><span class="main">)</span> <span class="main">←</span> map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> <span class="main">(</span><span class="main">[</span><span class="bound">y</span><span class="main">←</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">]</span><span class="main">,</span> <span class="main">[</span><span class="bound">y</span><span class="main">←</span><span class="bound">xs</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="bound">x</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
                                    <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="main">(</span><span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                      return_pmf <span class="main">(</span>Node <span class="main">(</span>bst_of_list <span class="bound">ls</span><span class="main">)</span> <span class="bound">x</span> <span class="main">(</span>bst_of_list <span class="bound">rs</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> A
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> bind_pmf_cong refl map_pmf_cong<span class="main">)</span>
         <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> filter_cong <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> permutations_of_setD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> order.strict_iff_order<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_pmf bst_of_list <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="skolem">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> random_permutation_of_set<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem"><span class="quoted"><span class="skolem">A</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
                 <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_pmf_def bind_return_pmf o_def bind_assoc_pmf not_le<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_of_set_singleton<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Random_BSTs-finite_set_random_bst"><span class="command">lemma</span></span> finite_set_random_bst <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"finite <span class="free">A</span> <span class="main">⟹</span> finite <span class="main">(</span>set_pmf <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_bst_altdef<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-random_bst_code"><span class="command">lemma</span></span> random_bst_code <span class="main">[</span><span class="operator">code</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"random_bst <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> map_pmf bst_of_list <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="main">(</span>set <span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> random_bst_altdef<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Random_BSTs-random_bst_singleton"><span class="command">lemma</span></span> random_bst_singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"random_bst <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">=</span> return_pmf <span class="main">(</span>Node Leaf <span class="free">x</span> Leaf<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_bst_altdef pmf_of_set_singleton<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-size_random_bst"><span class="command">lemma</span></span> size_random_bst<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">∈</span> set_pmf <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"size <span class="free">t</span> <span class="main">=</span> card <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">xs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"distinct <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> set <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">=</span> bst_of_list <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> random_bst_altdef <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> permutations_of_setD<span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="free">A</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> distinct_card<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Random_BSTs-random_bst_image"><span class="command">lemma</span></span> random_bst_image<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"strict_mono_on <span class="free">f</span> <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"random_bst <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> map_pmf <span class="main">(</span>map_tree <span class="free">f</span><span class="main">)</span> <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> inj<span class="main">:</span> <span class="quoted"><span class="quoted">"inj_on <span class="free">f</span> <span class="free">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> strict_mono_on_imp_inj_on<span class="main">)</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"inj_on <span class="main">(</span>map <span class="free">f</span><span class="main">)</span> <span class="main">(</span>permutations_of_set <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> inj_on_mapI<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">with</span></span> assms inj <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"random_bst <span class="main">(</span><span class="free">f</span> <span class="main">`</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> 
                         map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bst_of_list <span class="main">(</span>map <span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_bst_altdef permutations_of_set_image_inj map_pmf_of_set_inj <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span>
                  pmf.map_comp o_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_pmf <span class="main">(</span>map_tree <span class="free">f</span><span class="main">)</span> <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> random_bst_altdef<span class="main">[</span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹finite <span class="free">A</span>›</span></span><span class="main">]</span> pmf.map_comp o_def <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> map_pmf_cong refl bst_of_list_map<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">f</span></span></span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">A</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> permutations_of_setD<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We can also re-phrase the non-recursive definition using the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> fold_random_permutation<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  combinator from the HOL-Probability library, which folds over a given set in random order.
›</span></span>
<span class="keyword1" id="Random_BSTs-random_bst_altdef'"><span class="command">lemma</span></span> random_bst_altdef'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"random_bst <span class="free">A</span> <span class="main">=</span> fold_random_permutation Tree_Set.insert Leaf <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"random_bst <span class="free">A</span> <span class="main">=</span> map_pmf bst_of_list <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> random_bst_altdef<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">xs</span><span class="main">.</span> fold Tree_Set.insert <span class="bound">xs</span> Leaf<span class="main">)</span> <span class="main">(</span>pmf_of_set <span class="main">(</span>permutations_of_set <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> map_pmf_cong refl<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> bst_of_list_altdef<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> fold_random_permutation Tree_Set.insert Leaf <span class="free">A</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fold_random_permutation_fold<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Expected height›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  For the purposes of the analysis of the expected height, we define the following notion
  of `expected height', which is essentially two to the power of the height (as defined
  by Cormen \textit{et al.}) with a special treatment for the empty tree, which has exponential
  height 0.

  Note that the height defined by Cormen \textit{et al.}\ differs from the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> height<span class="antiquote"><span class="antiquote">}</span></span></span></span>
  function here in Isabelle in that for them, the height of the empty tree is undefined and
  the height of a singleton tree is 0 etc., whereas in Isabelle, the height of the empty tree is
  0 and the height of a singleton tree is 1.
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eheight</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eheight</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> Leaf <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>height <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Random_BSTs-eheight_Leaf"><span class="command">lemma</span></span> eheight_Leaf <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eheight Leaf <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eheight_def<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-eheight_Node_singleton"><span class="command">lemma</span></span> eheight_Node_singleton <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eheight <span class="main">(</span>Node Leaf <span class="free">x</span> Leaf<span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eheight_def<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-eheight_Node"><span class="command">lemma</span></span> eheight_Node<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">≠</span> Leaf <span class="main">∨</span> <span class="free">r</span> <span class="main">≠</span> Leaf <span class="main">⟹</span> eheight <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> max <span class="main">(</span>eheight <span class="free">l</span><span class="main">)</span> <span class="main">(</span>eheight <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">r</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eheight_def max_power_distrib_right<span class="main">)</span>


<span class="keyword1"><span class="command">fun</span></span> <span class="entity">eheight_rbst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> nat pmf"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eheight_rbst</span> <span class="main">0</span> <span class="main">=</span> return_pmf <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eheight_rbst</span> <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> return_pmf <span class="main">1</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eheight_rbst</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span>
     <span class="keyword1">do</span> <span class="main">{</span>
       <span class="bound">k</span> <span class="main">←</span> pmf_of_set <span class="main">{..</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">}</span><span class="main">;</span>
       <span class="bound">h1</span> <span class="main">←</span> <span class="free">eheight_rbst</span> <span class="bound">k</span><span class="main">;</span>
       <span class="bound">h2</span> <span class="main">←</span> <span class="free">eheight_rbst</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">-</span> <span class="bound">k</span><span class="main">)</span><span class="main">;</span>
       return_pmf <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> max <span class="bound">h1</span> <span class="bound">h2</span><span class="main">)</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eheight_exp</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> real"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eheight_exp</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> measure_pmf.expectation <span class="main">(</span>eheight_rbst <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> real"</span></span>

<span class="keyword1" id="Random_BSTs-eheight_rbst_reduce"><span class="command">lemma</span></span> eheight_rbst_reduce<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"eheight_rbst <span class="free">n</span> <span class="main">=</span>
             <span class="keyword1">do</span> <span class="main">{</span><span class="bound">k</span> <span class="main">←</span> pmf_of_set <span class="main">{..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">;</span> <span class="bound">h1</span> <span class="main">←</span> eheight_rbst <span class="bound">k</span><span class="main">;</span> <span class="bound">h2</span> <span class="main">←</span> eheight_rbst <span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="bound">k</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">;</span>
                 return_pmf <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> max <span class="bound">h1</span> <span class="bound">h2</span><span class="main">)</span><span class="main">}</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> eheight_rbst.cases<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lessThan_Suc_atMost<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-Leaf_in_set_random_bst_iff"><span class="command">lemma</span></span> Leaf_in_set_random_bst_iff<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"Leaf <span class="main">∈</span> set_pmf <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"Leaf <span class="main">∈</span> set_pmf <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> size_random_bst<span class="main">[</span><span class="operator">OF</span> this<span class="main">]</span> <span class="keyword2"><span class="keyword">and</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>  

<span class="keyword1" id="Random_BSTs-eheight_rbst"><span class="command">lemma</span></span> eheight_rbst<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"eheight_rbst <span class="main">(</span>card <span class="free">A</span><span class="main">)</span> <span class="main">=</span> map_pmf eheight <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_psubset_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>psubset <span class="skolem">A</span><span class="main">)</span>
 <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">rank</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rank</span> <span class="main">=</span> linorder_rank <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span> <span class="skolem">A</span>"</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{}</span> <span class="main">∨</span> is_singleton <span class="skolem">A</span> <span class="main">∨</span> card <span class="skolem">A</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> not_less le_Suc_eq is_singleton_altdef<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">consider</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"is_singleton <span class="skolem">A</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"card <span class="skolem">A</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> 3
    <span class="keyword1"><span class="command">hence</span></span> nonempty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">from</span></span> 3 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span>is_singleton <span class="skolem">A</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_singleton_def<span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> exists_other<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">y</span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≠</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_singleton_def<span class="main">)</span>

    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"map_pmf eheight <span class="main">(</span>random_bst <span class="skolem">A</span><span class="main">)</span> <span class="main">=</span> 
             <span class="keyword1">do</span> <span class="main">{</span>
               <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
               <span class="bound">l</span> <span class="main">←</span> random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">;</span>
               <span class="bound">r</span> <span class="main">←</span> random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">;</span>
               return_pmf <span class="main">(</span>eheight <span class="main">(</span>Node <span class="bound">l</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
             <span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> random_bst.simps<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> map_bind_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
                      <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                      <span class="bound">l</span> <span class="main">←</span> random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">;</span>
                      <span class="bound">r</span> <span class="main">←</span> random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">;</span>
                      return_pmf <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> max <span class="main">(</span>eheight <span class="bound">l</span><span class="main">)</span> <span class="main">(</span>eheight <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
                    <span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> 3 <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> exists_other
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> bind_pmf_cong refl<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> eheight_Node<span class="main">)</span>
         <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Leaf_in_set_random_bst_iff not_less nonempty eheight_Node<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
                      <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                      <span class="bound">h1</span> <span class="main">←</span> map_pmf eheight <span class="main">(</span>random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
                      <span class="bound">h2</span> <span class="main">←</span> map_pmf eheight <span class="main">(</span>random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
                      return_pmf <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> max <span class="bound">h1</span> <span class="bound">h2</span><span class="main">)</span>
                    <span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_map_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
                      <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                      <span class="bound">h1</span> <span class="main">←</span> eheight_rbst <span class="main">(</span>card <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
                      <span class="bound">h2</span> <span class="main">←</span> eheight_rbst <span class="main">(</span>card <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
                      return_pmf <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> max <span class="bound">h1</span> <span class="bound">h2</span><span class="main">)</span>
                    <span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> bind_pmf_cong psubset.IH <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> refl<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
                      <span class="bound">k</span> <span class="main">←</span> map_pmf <span class="skolem">rank</span> <span class="main">(</span>pmf_of_set <span class="skolem">A</span><span class="main">)</span><span class="main">;</span>
                      <span class="bound">h1</span> <span class="main">←</span> eheight_rbst <span class="bound">k</span><span class="main">;</span>
                      <span class="bound">h2</span> <span class="main">←</span> eheight_rbst <span class="main">(</span>card <span class="skolem">A</span> <span class="main">-</span> <span class="bound">k</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">;</span>
                      return_pmf <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> max <span class="bound">h1</span> <span class="bound">h2</span><span class="main">)</span>
                    <span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> bind_map_pmf
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> bind_pmf_cong refl<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rank</span> <span class="skolem">x</span> <span class="main">=</span> card <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">-</span><span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rank_def linorder_rank_def<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">-</span><span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">-</span><span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">…</span> <span class="main">=</span> <span class="skolem">rank</span> <span class="skolem">x</span> <span class="main">+</span> card <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> card_Un_disjoint<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rank_def linorder_rank_def<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> card <span class="skolem">A</span> <span class="main">-</span> <span class="skolem">rank</span> <span class="skolem">x</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> 2 <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf <span class="skolem">rank</span> <span class="main">(</span>pmf_of_set <span class="skolem">A</span><span class="main">)</span> <span class="main">=</span> pmf_of_set <span class="main">{..&lt;</span>card <span class="skolem">A</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> rank_def
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> map_pmf_of_set_bij_betw bij_betw_linorder_rank<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">UNIV</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">do</span> <span class="main">{</span>
                 <span class="bound">k</span> <span class="main">←</span> pmf_of_set <span class="main">{..&lt;</span>card <span class="skolem">A</span><span class="main">}</span><span class="main">;</span>
                 <span class="bound">h1</span> <span class="main">←</span> eheight_rbst <span class="bound">k</span><span class="main">;</span>
                 <span class="bound">h2</span> <span class="main">←</span> eheight_rbst <span class="main">(</span>card <span class="skolem">A</span> <span class="main">-</span> <span class="bound">k</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">;</span>
                 return_pmf <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> max <span class="bound">h1</span> <span class="bound">h2</span><span class="main">)</span>
               <span class="main">}</span> <span class="main">=</span> eheight_rbst <span class="main">(</span>card <span class="skolem">A</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> eheight_rbst_reduce <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> is_singleton_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Random_BSTs-finite_pmf_set_eheight_rbst"><span class="command">lemma</span></span> finite_pmf_set_eheight_rbst <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">intro</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>set_pmf <span class="main">(</span>eheight_rbst <span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eheight_rbst <span class="free">n</span> <span class="main">=</span> map_pmf eheight <span class="main">(</span>random_bst <span class="main">{..&lt;</span><span class="free">n</span><span class="main">}</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> eheight_rbst <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>set_pmf <span class="main">…</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Random_BSTs-eheight_exp_0"><span class="command">lemma</span></span> eheight_exp_0 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eheight_exp <span class="main">0</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eheight_exp_def<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-eheight_exp_1"><span class="command">lemma</span></span> eheight_exp_1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eheight_exp <span class="main">(</span>Suc <span class="main">0</span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eheight_exp_def lessThan_Suc<span class="main">)</span>

<span class="keyword1" id="Random_BSTs-eheight_exp_reduce_bound"><span class="command">lemma</span></span> eheight_exp_reduce_bound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"eheight_exp <span class="free">n</span> <span class="main">≤</span> <span class="numeral">4</span> <span class="main">/</span> <span class="free">n</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> eheight_exp <span class="bound">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"real <span class="main">(</span>max <span class="skolem">a</span> <span class="skolem">b</span><span class="main">)</span> <span class="main">=</span> max <span class="main">(</span>real <span class="skolem">a</span><span class="main">)</span> <span class="main">(</span>real <span class="skolem">b</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">a</span> <span class="skolem">b</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_def<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="main">(</span><span class="bound">h1</span><span class="main">,</span><span class="bound">h2</span><span class="main">)</span><span class="main">.</span> max <span class="bound">h1</span> <span class="bound">h2</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">k</span><span class="main">.</span> pair_pmf <span class="main">(</span>eheight_rbst <span class="bound">k</span><span class="main">)</span> <span class="main">(</span>eheight_rbst <span class="main">(</span><span class="free">n</span> <span class="main">-</span> Suc <span class="bound">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eheight_exp <span class="free">n</span> <span class="main">=</span> measure_pmf.expectation <span class="main">(</span>eheight_rbst <span class="free">n</span><span class="main">)</span> real"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eheight_exp_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">1</span> <span class="main">/</span> real <span class="free">n</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> measure_pmf.expectation
                                         <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">h1</span><span class="main">,</span><span class="bound">h2</span><span class="main">)</span><span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> max <span class="bound">h1</span> <span class="bound">h2</span><span class="main">)</span> <span class="main">(</span><span class="var">?p</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span> real<span class="main">)</span>"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="main">_</span> <span class="main">*</span> <span class="var">?S</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> pair_pmf_def map_bind_pmf
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> eheight_rbst_reduce <span class="main"><span class="main">[</span></span><span class="operator">OF</span> assms<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> pmf_expectation_bind_pmf_of_set<span class="main">)</span>
       <span class="main">(</span><span class="operator">insert</span> assms<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum_divide_distrib <span class="dynamic"><span class="dynamic">divide_simps</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> measure_pmf.expectation <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="numeral">2</span> <span class="main">*</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span>map_pmf <span class="var">?f</span> <span class="main">(</span><span class="var">?p</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> real<span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> pmf.map_comp o_def case_prod_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> measure_pmf.expectation <span class="main">(</span>map_pmf <span class="var">?f</span> <span class="main">(</span><span class="var">?p</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span> real<span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> <span class="main">_</span> <span class="main">*</span> <span class="var">?S'</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> integral_map_pmf<span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_distrib_left<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?S'</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> measure_pmf.expectation <span class="main">(</span><span class="var">?p</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">h1</span><span class="main">,</span><span class="bound">h2</span><span class="main">)</span><span class="main">.</span> max <span class="main">(</span>real <span class="bound">h1</span><span class="main">)</span> <span class="main">(</span>real <span class="bound">h2</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_prod_unfold<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> measure_pmf.expectation <span class="main">(</span><span class="var">?p</span> <span class="bound">k</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">h1</span><span class="main">,</span><span class="bound">h2</span><span class="main">)</span><span class="main">.</span> real <span class="bound">h1</span> <span class="main">+</span> real <span class="bound">h2</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> integral_map_pmf case_prod_unfold
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sum_mono Bochner_Integration.integral_mono integrable_measure_pmf_finite<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> eheight_exp <span class="bound">k</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> eheight_exp <span class="main">(</span><span class="free">n</span> <span class="main">-</span> Suc <span class="bound">k</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> expectation_add_pair_pmf<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sum.distrib eheight_exp_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> eheight_exp <span class="main">(</span><span class="free">n</span> <span class="main">-</span> Suc <span class="bound">k</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="free">n</span><span class="main">.</span> eheight_exp <span class="bound">k</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sum.reindex_bij_witness<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">k</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="free"><span class="free"><span class="free">n</span></span></span> <span class="main"><span class="main"><span class="main">-</span></span></span> Suc <span class="bound"><span class="bound"><span class="bound">k</span></span></span>"</span></span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">k</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="free"><span class="free"><span class="free">n</span></span></span> <span class="main"><span class="main"><span class="main">-</span></span></span> Suc <span class="bound"><span class="bound"><span class="bound">k</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">/</span> real <span class="free">n</span> <span class="main">*</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">*</span> <span class="main">(</span><span class="main">…</span> <span class="main">+</span> <span class="main">…</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="numeral">4</span> <span class="main">/</span> real <span class="free">n</span> <span class="main">*</span> <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult_left_mono divide_right_mono<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We now define the following upper bound on the expected exponential height due to
  Cormen\ \textit{et\ al.}~\cite{cormen}:
›</span></span>
<span class="keyword1" id="Random_BSTs-eheight_exp_bound"><span class="command">lemma</span></span> eheight_exp_bound<span class="main">:</span> <span class="quoted"><span class="quoted">"eheight_exp <span class="free">n</span> <span class="main">≤</span> real <span class="main">(</span><span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">4</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> less_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>less <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">consider</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">&gt;</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">case</span></span> 3
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"eheight_exp <span class="skolem">n</span> <span class="main">≤</span> <span class="numeral">4</span> <span class="main">/</span> <span class="skolem">n</span> <span class="main">*</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> eheight_exp <span class="bound">k</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> eheight_exp_reduce_bound<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> eheight_exp <span class="bound">k</span><span class="main">)</span> <span class="main">≤</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> real <span class="main">(</span><span class="main">(</span><span class="bound">k</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">4</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sum_mono less.IH<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> real <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">k</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">4</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_divide_distrib<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">&lt;</span><span class="skolem">n</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">k</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">k</span><span class="main">≤</span><span class="skolem">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="bound">k</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">&gt;</span> <span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sum.cong<span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">4</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> choose_rising_sum<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="numeral">3</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">-</span> <span class="main">1</span>"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">&gt;</span> <span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add_ac Suc3_eq_add_3<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">4</span> <span class="main">/</span> real <span class="skolem">n</span> <span class="main">*</span> <span class="main">(</span><span class="main">…</span> <span class="main">/</span> <span class="numeral">4</span><span class="main">)</span> <span class="main">=</span> real <span class="main">(</span><span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">4</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">&gt;</span> <span class="main">1</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">n</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> binomial_fact fact_numeral <span class="dynamic"><span class="dynamic">divide_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">&gt;</span> <span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mult_left_mono divide_right_mono<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> eval_nat_numeral<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We then show that this is indeed an upper bound on the expected exponential height by induction
  over the set of elements. This proof mostly follows that by Cormen\ \textit{et al.}~\cite{cormen},
  and partially an answer on the Computer Science Stack Exchange~\cite{sofl}.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Since the function $\uplambda x.\ 2 ^ x$ is convex, we can then easily derive a bound on the
  actual height using Jensen's inequality:
›</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">height_exp_approx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> real"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">height_exp_approx</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> log <span class="numeral">2</span> <span class="main">(</span>real <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">4</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> height_expectation_bound<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> height
             <span class="main">≤</span> height_exp_approx <span class="main">(</span>card <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"convex_on UNIV <span class="main">(</span><span class="keyword1">(powr)</span> <span class="numeral">2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> convex_on_realI<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f' <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> ln <span class="numeral"><span class="numeral"><span class="numeral">2</span></span></span> <span class="main"><span class="main"><span class="main">*</span></span></span> <span class="numeral"><span class="numeral"><span class="numeral">2</span></span></span> <span class="keyword1"><span class="keyword1"><span class="keyword1">powr</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">derivative_eq_intros</span></span> DERIV_powr <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> powr_def <span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="keyword1">powr</span> measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> real <span class="main">(</span>height <span class="bound">t</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span>
          measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> <span class="numeral">2</span> <span class="keyword1">powr</span> real <span class="main">(</span>height <span class="bound">t</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> measure_pmf.jensens_inequality<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> I <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">UNIV</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> integrable_measure_pmf_finite<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> <span class="numeral">2</span> <span class="keyword1">powr</span> real <span class="main">(</span>height <span class="bound">t</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>height <span class="bound">t</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> powr_realpow<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>height <span class="bound">t</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
               measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> real <span class="main">(</span>eheight <span class="bound">t</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> integral_cong_AE<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> AE_measure_pmf_iff random_bst_altdef eheight_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> measure_pmf.expectation <span class="main">(</span>map_pmf eheight <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span><span class="main">)</span> real"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf eheight <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">=</span> eheight_rbst <span class="main">(</span>card <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> eheight_rbst <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">fact</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">…</span> real <span class="main">=</span> eheight_exp <span class="main">(</span>card <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eheight_exp_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">≤</span> real <span class="main">(</span><span class="main">(</span>card <span class="free">A</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">4</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> eheight_exp_bound<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> real <span class="main">(</span>height <span class="bound">t</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
               measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> real <span class="main">(</span>height <span class="bound">t</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> integral_cong_AE AE_pmfI<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">t</span><span class="main">)</span>
    <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">A</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> of_nat_diff<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Suc_le_eq random_bst_altdef<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="keyword1">powr</span> measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> real <span class="main">(</span>height <span class="bound">t</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>
                  <span class="main">≤</span> real <span class="main">(</span><span class="main">(</span>card <span class="free">A</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">4</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"log <span class="numeral">2</span> <span class="main">(</span><span class="numeral">2</span> <span class="keyword1">powr</span> measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> real <span class="main">(</span>height <span class="bound">t</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span>
           log <span class="numeral">2</span> <span class="main">(</span>real <span class="main">(</span><span class="main">(</span>card <span class="free">A</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">4</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> log_le_cancel_iff<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> real <span class="main">(</span>height <span class="bound">t</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">t</span><span class="main">.</span> real <span class="main">(</span>height <span class="bound">t</span><span class="main">)</span><span class="main">)</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> Bochner_Integration.integral_diff<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> integrable_measure_pmf_finite<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> height_exp_approx_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This upper bound is asymptotically equivalent to $c \ln n$ with
  $c = \frac{3}{\ln 2} \approx 4.328$. This is actually a relatively tight upper bound, since
  the exact asymptotics of the expected height of a random BST is $c \ln n$ with
  $c \approx 4.311$.~\cite{reed} However, the proof of these precise asymptotics is very intricate
  and we will therefore be content with the upper bound.

  In particular, we can now show that the expected height is $O(\log n)$.
›</span></span>
<span class="keyword1" id="Random_BSTs-ln_sum_bigo_ln"><span class="command">lemma</span></span> ln_sum_bigo_ln<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">::</span>real<span class="main">.</span> ln <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="keyword1">O(</span>ln<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> bigoI_tendsto<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> eventually_gt_at_top<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">1</span><span class="main">::</span>real"</span></span><span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">::</span>real<span class="main">.</span> ln <span class="bound">x</span> <span class="main">≠</span> <span class="main">0</span><span class="main">)</span> at_top"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">eventually_elim</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ln <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="free">c</span><span class="main">)</span> <span class="main">/</span> ln <span class="bound">x</span><span class="main">)</span> <span class="main">⤏</span> <span class="main">1</span><span class="main">)</span> at_top"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> lhospital_at_top_at_top<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ln <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="keyword1">has_real_derivative</span> inverse <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">at</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> at_top"</span></span>
      <span class="keyword1"><span class="command">using</span></span> eventually_gt_at_top<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">c</span>"</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">eventually_elim</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">derivative_eq_intros</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ln <span class="bound">x</span><span class="main">)</span> <span class="keyword1">has_real_derivative</span> inverse <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="keyword1">at</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> at_top"</span></span>
      <span class="keyword1"><span class="command">using</span></span> eventually_gt_at_top<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="main">0</span></span><span class="main">]</span>
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">eventually_elim</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">derivative_eq_intros</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> inverse <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="free">c</span><span class="main">)</span> <span class="main">/</span> inverse <span class="bound">x</span><span class="main">)</span> <span class="main">⤏</span> <span class="main">1</span><span class="main">)</span> at_top"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> Lim_transform_eventually<span class="main">)</span>
      <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> inverse <span class="main">(</span><span class="main">1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">/</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> inverse <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="free">c</span><span class="main">)</span> <span class="main">/</span> inverse <span class="bound">x</span><span class="main">)</span> at_top"</span></span>
        <span class="keyword1"><span class="command">using</span></span> eventually_gt_at_top<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">::</span>real"</span></span><span class="main">]</span> eventually_gt_at_top<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">-</span><span class="free">c</span>"</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">eventually_elim</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> inverse <span class="main">(</span><span class="main">1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">/</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⤏</span> inverse <span class="main">(</span><span class="main">1</span> <span class="main">+</span> <span class="main">0</span><span class="main">)</span><span class="main">)</span> at_top"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> tendsto_inverse tendsto_add tendsto_const
              real_tendsto_divide_at_top<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tendsto_const<span class="main"><span class="main">]</span></span> filterlim_ident<span class="main">)</span> <span class="operator">simp_all</span>
      <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> inverse <span class="main">(</span><span class="main">1</span> <span class="main">+</span> <span class="free">c</span> <span class="main">/</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⤏</span> <span class="main">1</span><span class="main">)</span> at_top"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ln_at_top eventually_at_top_not_equal<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">corollary</span></span> height_expectation_bigo<span class="main">:</span> <span class="quoted"><span class="quoted">"height_exp_approx <span class="main">∈</span> <span class="keyword1">O(</span>ln<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?T</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">::</span>real<span class="main">.</span> log <span class="numeral">2</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> log <span class="numeral">2</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">+</span> log <span class="numeral">2</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> log <span class="numeral">2</span> <span class="numeral">24</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> height_exp_approx <span class="bound">n</span> <span class="main">=</span>
          log <span class="numeral">2</span> <span class="main">(</span>real <span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> log <span class="numeral">2</span> <span class="main">(</span>real <span class="bound">n</span> <span class="main">+</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">+</span> log <span class="numeral">2</span> <span class="main">(</span>real <span class="bound">n</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> log <span class="numeral">2</span> <span class="numeral">24</span><span class="main">)</span><span class="main">)</span> at_top"</span></span>
    <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"eventually <span class="main">(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> <span class="main">_</span> <span class="main">=</span> <span class="var">?T</span> <span class="bound">n</span><span class="main">)</span> at_top"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">using</span></span> eventually_gt_at_top<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"<span class="main">0</span><span class="main">::</span>nat"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">eventually_elim</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>elim <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"height_exp_approx <span class="skolem">n</span> <span class="main">=</span> log <span class="numeral">2</span> <span class="main">(</span>real <span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="numeral">3</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">4</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> height_exp_approx_def log_divide<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"real <span class="main">(</span><span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">choose</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">=</span> real <span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="keyword1">gchoose</span> <span class="numeral">3</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> binomial_gbinomial<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">/</span> <span class="numeral">4</span> <span class="main">=</span> <span class="main">(</span>real <span class="skolem">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>real <span class="skolem">n</span> <span class="main">+</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span>real <span class="skolem">n</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">/</span> <span class="numeral">24</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gbinomial_pochhammer' numeral_3_eq_3 pochhammer_Suc add_ac<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"log <span class="numeral">2</span> <span class="main">…</span> <span class="main">=</span> log <span class="numeral">2</span> <span class="main">(</span>real <span class="skolem">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> log <span class="numeral">2</span> <span class="main">(</span>real <span class="skolem">n</span> <span class="main">+</span> <span class="numeral">2</span><span class="main">)</span> <span class="main">+</span> log <span class="numeral">2</span> <span class="main">(</span>real <span class="skolem">n</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">-</span> log <span class="numeral">2</span> <span class="numeral">24</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> log_divide log_mult<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"height_exp_approx <span class="main">∈</span> <span class="keyword1">Θ(</span><span class="var">?T</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> bigthetaI_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ln <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="skolem">c</span><span class="main">)</span> <span class="main">/</span> ln <span class="numeral">2</span><span class="main">)</span> <span class="main">∈</span> <span class="keyword1">O(</span>ln<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">c</span> <span class="main">::</span> <span class="quoted">real</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> landau_o.big.cdiv_in_iff'<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> ln_sum_bigo_ln<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?T</span> <span class="main">∈</span> <span class="keyword1">O(</span><span class="main">λ</span><span class="bound">n</span><span class="main">.</span> ln <span class="main">(</span>real <span class="bound">n</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> log_def
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> bigo_real_nat_transfer sum_in_bigo ln_sum_bigo_ln *<span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Lookup costs›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The following function describes the cost incurred when looking up a specific element
  in a specific BST. The cost corresponds to the number of edges traversed in the lookup.
›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">lookup_cost</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linorder <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lookup_cost</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> Leaf <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">lookup_cost</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span>
     <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> <span class="main">0</span>
      <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">then</span> Suc <span class="main">(</span><span class="free">lookup_cost</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>
      <span class="keyword1">else</span> Suc <span class="main">(</span><span class="free">lookup_cost</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Some of the literature defines these costs as 1 in the case that the current node is
  the correct one, i.\,e.\ their costs are our costs plus 1. These alternative costs are
  exactly the number of comparisons performed in the lookup. Our cost function has the
  advantage of precisely summing up to the internal path length and therefore gives us
  slightly nicer results, and since the difference is only a ${}+1$ in the end, this
  variant seemed more reasonable.
›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  It can be shown with a simple induction that The sum of all lookup costs in a tree is the
  internal path length of the tree.
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> sum_lookup_costs<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">t</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">::</span> linorder tree"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"bst <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">x</span><span class="main">∈</span>set_tree <span class="free">t</span><span class="main">.</span> lookup_cost <span class="bound">x</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> ipl <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Node.prems
    <span class="keyword1"><span class="command">have</span></span> disj<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> set_tree <span class="skolem">l</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> set_tree <span class="skolem">r</span>"</span></span> <span class="quoted"><span class="quoted">"set_tree <span class="skolem">l</span> <span class="main">∩</span> set_tree <span class="skolem">r</span> <span class="main">=</span> <span class="main">{}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set_tree <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">=</span> insert <span class="skolem">x</span> <span class="main">(</span>set_tree <span class="skolem">l</span> <span class="main">∪</span> set_tree <span class="skolem">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">y</span><span class="main">∈</span><span class="main">…</span><span class="main">.</span> lookup_cost <span class="bound">y</span> <span class="main">(</span>Node <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> lookup_cost <span class="skolem">x</span> <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">r</span><span class="main">⟩</span> <span class="main">+</span>
               <span class="main">(</span><span class="main">∑</span><span class="bound">y</span><span class="main">∈</span>set_tree <span class="skolem">l</span><span class="main">.</span> lookup_cost <span class="bound">y</span> <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">r</span><span class="main">⟩</span><span class="main">)</span> <span class="main">+</span> <span class="main">(</span><span class="main">∑</span><span class="bound">y</span><span class="main">∈</span>set_tree <span class="skolem">r</span><span class="main">.</span> lookup_cost <span class="bound">y</span> <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">r</span><span class="main">⟩</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> disj <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum.union_disjoint<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">y</span><span class="main">∈</span>set_tree <span class="skolem">l</span><span class="main">.</span> lookup_cost <span class="bound">y</span> <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">r</span><span class="main">⟩</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">y</span><span class="main">∈</span>set_tree <span class="skolem">l</span><span class="main">.</span> <span class="main">1</span> <span class="main">+</span> lookup_cost <span class="bound">y</span> <span class="skolem">l</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> disj <span class="keyword2"><span class="keyword">and</span></span> Node <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sum.cong refl<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> size <span class="skolem">l</span> <span class="main">+</span> ipl <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Node
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sum.distrib<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_set_tree_bst<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∑</span><span class="bound">y</span><span class="main">∈</span>set_tree <span class="skolem">r</span><span class="main">.</span> lookup_cost <span class="bound">y</span> <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">r</span><span class="main">⟩</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∑</span><span class="bound">y</span><span class="main">∈</span>set_tree <span class="skolem">r</span><span class="main">.</span> <span class="main">1</span> <span class="main">+</span> lookup_cost <span class="bound">y</span> <span class="skolem">r</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> disj <span class="keyword2"><span class="keyword">and</span></span> Node <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> sum.cong refl<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> size <span class="skolem">r</span> <span class="main">+</span> ipl <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Node
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sum.distrib<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> card_set_tree_bst<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This allows us to easily show that the expected cost of looking up a random element in a
  fixed tree is the internal path length divided by the number of elements.
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> expected_lookup_cost<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"bst <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≠</span> Leaf"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>pmf_of_set <span class="main">(</span>set_tree <span class="free">t</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> lookup_cost <span class="bound">x</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span>
             ipl <span class="free">t</span> <span class="main">/</span> size <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> integral_pmf_of_set<span class="main">)</span>
                 <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sum_lookup_costs of_nat_sum <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> card_set_tree_bst<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Therefore, we will now turn to analysing the internal path length of a random BST. This
  then clearly related to the expected lookup costs of a random element in a random BST by
  the above result.
›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Average Path Length›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The internal path length satisfies the recursive equation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> ipl.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator"><span class="operator">of</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">l</span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">x</span></span></span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">r</span></span></span></span><span class="main"><span class="main">]</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
  This is quite similar to the number of comparisons performed by QuickSort, and indeed, we can
  reduce the internal path length of a random BST to the number of comparisons performed by
  QuickSort on a randomly-ordered list relatively easily:
›</span></span>
<span class="keyword1"><span class="command">theorem</span></span> map_pmf_random_bst_eq_rqs_cost<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"map_pmf ipl <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">=</span> rqs_cost <span class="main">(</span>card <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_psubset_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>psubset <span class="skolem">A</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">=</span> <span class="main">{}</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">note</span></span> A <span class="main">=</span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">A</span> <span class="main">≠</span> <span class="main">{}</span>›</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">n</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> card <span class="skolem">A</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
    <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">rank</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">rank</span> <span class="main">=</span> linorder_rank <span class="main">{</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span><span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≤</span> <span class="bound">y</span><span class="main">}</span> <span class="skolem">A</span>"</span></span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> card<span class="main">:</span> <span class="quoted"><span class="quoted">"card <span class="skolem">A</span> <span class="main">=</span> Suc <span class="skolem">n</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"card <span class="skolem">A</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> n_def<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf ipl <span class="main">(</span>random_bst <span class="skolem">A</span><span class="main">)</span> <span class="main">=</span>
                   <span class="keyword1">do</span> <span class="main">{</span>
                     <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                     <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">r</span><span class="main">)</span> <span class="main">←</span> pair_pmf <span class="main">(</span>random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
                     return_pmf <span class="main">(</span>ipl <span class="main">(</span>Node <span class="bound">l</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>
                   <span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> random_bst.simps<span class="main">)</span>
         <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pair_pmf_def card map_pmf_def bind_assoc_pmf bind_return_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
                      <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                      <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">r</span><span class="main">)</span> <span class="main">←</span> pair_pmf <span class="main">(</span>random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
                      return_pmf <span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> ipl <span class="bound">l</span> <span class="main">+</span> ipl <span class="bound">r</span><span class="main">)</span>
                    <span class="main">}</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> bind_pmf_cong refl<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarify</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span> <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword2"><span class="keyword">and</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="main">=</span> card <span class="main">(</span><span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> n_def<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">∪</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">…</span> <span class="main">=</span> card <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">+</span> card <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">}</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">A</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> card_Un_disjoint<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword2"><span class="keyword">and</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> size <span class="skolem">l</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> size_random_bst<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword2"><span class="keyword">and</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"card <span class="main">{</span><span class="bound"><span class="bound">y</span></span><span class="main">∈</span><span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> size <span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> size_random_bst<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
                      <span class="bound">x</span> <span class="main">←</span> pmf_of_set <span class="skolem">A</span><span class="main">;</span>
                      <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">r</span><span class="main">)</span> <span class="main">←</span> pair_pmf <span class="main">(</span>map_pmf ipl <span class="main">(</span>random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>
                                        <span class="main">(</span>map_pmf ipl <span class="main">(</span>random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="bound">x</span><span class="main">}</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                      return_pmf <span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="bound">l</span> <span class="main">+</span> <span class="bound">r</span><span class="main">)</span>
                    <span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> map_pair <span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> case_prod_unfold bind_map_pmf<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">do</span> <span class="main">{</span>
                      <span class="bound">i</span> <span class="main">←</span> map_pmf <span class="skolem">rank</span> <span class="main">(</span>pmf_of_set <span class="skolem">A</span><span class="main">)</span><span class="main">;</span>
                      <span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">r</span><span class="main">)</span> <span class="main">←</span> pair_pmf <span class="main">(</span>rqs_cost <span class="bound">i</span><span class="main">)</span> <span class="main">(</span>rqs_cost <span class="main">(</span><span class="skolem">n</span> <span class="main">-</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
                      return_pmf <span class="main">(</span><span class="skolem">n</span> <span class="main">+</span> <span class="bound">l</span> <span class="main">+</span> <span class="bound">r</span><span class="main">)</span>
                    <span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="main">_</span> <span class="main">=</span> bind_pmf <span class="main">_</span> <span class="var">?f</span>"</span></span><span class="main">)</span> <span class="keyword1"><span class="command">unfolding</span></span> bind_map_pmf
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">intro</span> bind_pmf_cong refl pair_pmf_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">x</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf ipl <span class="main">(</span>random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> rqs_cost <span class="main">(</span>card <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> 1 <span class="keyword2"><span class="keyword">and</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> psubset.IH<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&lt;</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">rank</span> <span class="skolem">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rank_def linorder_rank_def<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">x</span><span class="main">)</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf ipl <span class="main">(</span>random_bst <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> rqs_cost <span class="main">(</span>card <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword2"><span class="keyword">and</span></span> A <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> psubset.IH<span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> <span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span> <span class="main">-</span> <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≤</span> <span class="skolem">x</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"card <span class="main">{</span><span class="bound"><span class="bound">y</span></span> <span class="main">∈</span> <span class="skolem">A</span><span class="main">.</span> <span class="bound">y</span> <span class="main">&gt;</span> <span class="skolem">x</span><span class="main">}</span> <span class="main">=</span> card <span class="main">…</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> 2 <span class="keyword2"><span class="keyword">and</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="skolem">n</span> <span class="main">-</span> <span class="skolem">rank</span> <span class="skolem">x</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> card_Diff_subset<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rank_def linorder_rank_def n_def<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> A <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf <span class="skolem">rank</span> <span class="main">(</span>pmf_of_set <span class="skolem">A</span><span class="main">)</span> <span class="main">=</span> pmf_of_set <span class="main">{..&lt;</span>card <span class="skolem">A</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> rank_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> map_pmf_of_set_bij_betw bij_betw_linorder_rank<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted"><span class="quoted">UNIV</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">{..&lt;</span>card <span class="skolem">A</span><span class="main">}</span> <span class="main">=</span> <span class="main">{..</span><span class="skolem">n</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> card<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf_of_set <span class="main">…</span> <span class="main">⤜</span> <span class="var">?f</span> <span class="main">=</span> rqs_cost <span class="main">(</span>card <span class="skolem">A</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pair_pmf_def bind_assoc_pmf bind_return_pmf card<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  In particular, this means that the expected values are the same:
›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> expected_ipl_random_bst_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> ipl <span class="main">=</span> rqs_cost_exp <span class="main">(</span>card <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> ipl <span class="main">=</span>
          measure_pmf.expectation <span class="main">(</span>map_pmf ipl <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span><span class="main">)</span> real"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"map_pmf ipl <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> <span class="main">=</span> rqs_cost <span class="main">(</span>card <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> map_pmf_random_bst_eq_rqs_cost<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">…</span> real <span class="main">=</span> rqs_cost_exp <span class="main">(</span>card <span class="free">A</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> expectation_rqs_cost<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Therefore, the results about the expected number of comparisons of QuickSort carry over
  to the expected internal path length:
›</span></span>
<span class="keyword1"><span class="command">corollary</span></span> expected_ipl_random_bst_eq'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"finite <span class="free">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>   <span class="quoted"><span class="quoted">"measure_pmf.expectation <span class="main">(</span>random_bst <span class="free">A</span><span class="main">)</span> ipl <span class="main">=</span>
             <span class="numeral">2</span> <span class="main">*</span> real <span class="main">(</span>card <span class="free">A</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> harm <span class="main">(</span>card <span class="free">A</span><span class="main">)</span> <span class="main">-</span> <span class="numeral">4</span> <span class="main">*</span> real <span class="main">(</span>card <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> expected_ipl_random_bst_eq rqs_cost_exp_eq assms<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>