<div id="FingerTree">
<div class="head"><h1>Theory FingerTree</h1>
<span class="command">theory</span> <span class="name">FingerTree</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2-3 Finger Trees"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FingerTree</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  We implement and prove correct 2-3 finger trees as described by Ralf Hinze 
  and Ross Paterson\cite{HiPa06}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  This theory is organized as follows: 
  Section~\ref{sec:datatype} contains the finger-tree datatype, its invariant
  and its abstraction function to lists.
  The Section~\ref{sec:operations} contains the operations 
  on finger trees and their correctness lemmas.
  Section~\ref{sec:hide_invar} contains a finger tree datatype with implicit
  invariant, and, finally, Section~\ref{sec:doc} contains a documentation
  of the implemented operations.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\paragraph{Technical Issues}›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  As Isabelle lacks proper support of namespaces, we
  try to simulate namespaces by locales.

  The problem is, that we define lots of internal functions that
  should not be exposed to the user at all.
  Moreover, we define some functions with names equal to names
  from Isabelle's standard library. These names make perfect sense
  in the context of FingerTrees, however, they shall not be exposed 
  to anyone using this theory indirectly, hiding the standard library
  names there.

  Our approach puts all functions and lemmas inside the locale 
  {\em FingerTree\_loc},
  and then interprets this locale with the prefix {\em FingerTree}.
  This makes all definitions visible outside the locale, with
  qualified names. Inside the locale, however, one can use unqualified names.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Datatype definition"</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:datatype}›</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>FingerTreeStruc_loc</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Nodes: Non empty 2-3 trees, with all elements stored within the leafs plus a 
  cached annotation 
›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>Node</span><span> </span><span class="delimiter">=</span><span> </span><span>Tip</span><span> </span><span class="tfree">'e</span><span> </span><span class="tfree">'a</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>Node2</span><span> </span><span class="tfree">'a</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="delimiter">|</span><span> 
</span><span>  </span><span>Node3</span><span> </span><span class="tfree">'a</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Digit: one to four ordered Nodes›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>Digit</span><span> </span><span class="delimiter">=</span><span> </span><span>One</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>   </span><span>Two</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>   </span><span>Three</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>   </span><span>Four</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹FingerTreeStruc: 
    The empty tree, a single node or some nodes and a deeper tree›</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>FingerTreeStruc</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>Empty</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>Single</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span>Deep</span><span> </span><span class="tfree">'a</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Digit"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) FingerTreeStruc"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Digit"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Invariant"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>FingerTreeStruc_loc</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹\paragraph{Auxiliary functions}\ \\›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Readout the cached annotation of a node›</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>gmn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Node ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmn (Tip e a) = a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmn (Node2 a _ _) = a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmn (Node3 a _ _ _) = a"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The annotation of a digit is computed on the fly›</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>gmd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Digit ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmd (One a) = gmn a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmd (Two a b) = (gmn a) + (gmn b)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmd (Three a b c) = (gmn a) + (gmn b) + (gmn c)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmd (Four a b c d) = (gmn a) + (gmn b) + (gmn c) + (gmn d)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Readout the cached annotation of a finger tree›</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>gmft</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmft Empty = 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmft (Single nd) = gmn nd"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmft (Deep a _ _ _) = a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Depth and cached annotations have to be correct›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_leveln_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('e,'a) Node ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node 0 (Tip _ _) ⟷ True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node (Suc n) (Node2 _ n1 n2) ⟷ 
    is_leveln_node n n1 ∧ is_leveln_node n n2"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node (Suc n) (Node3 _ n1 n2 n3) ⟷ 
    is_leveln_node n n1 ∧ is_leveln_node n n2 ∧ is_leveln_node n n3"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node _ _ ⟷ False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>is_leveln_digit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('e,'a) Digit ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n (One n1) ⟷ is_leveln_node n n1"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n (Two n1 n2) ⟷ is_leveln_node n n1 ∧ 
    is_leveln_node n n2"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n (Three n1 n2 n3) ⟷ is_leveln_node n n1 ∧ 
    is_leveln_node n n2 ∧ is_leveln_node n n3"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n (Four n1 n2 n3 n4) ⟷ is_leveln_node n n1 ∧ 
    is_leveln_node n n2 ∧ is_leveln_node n n3 ∧ is_leveln_node n n4"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>is_leveln_ftree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ⇒ ('e,'a) FingerTreeStruc ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n Empty ⟷ True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n (Single nd) ⟷ is_leveln_node n nd"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n (Deep _ l t r) ⟷ is_leveln_digit n l ∧ 
    is_leveln_digit n r ∧ is_leveln_ftree (Suc n) t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>is_measured_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Node ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_node (Tip _ _) ⟷ True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_node (Node2 a n1 n2) ⟷ ((is_measured_node n1) ∧ 
    (is_measured_node n2)) ∧ (a = (gmn n1) + (gmn n2))"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_node (Node3 a n1 n2 n3) ⟷ ((is_measured_node n1) ∧ 
    (is_measured_node n2) ∧ (is_measured_node n3)) ∧ 
    (a = (gmn n1) + (gmn n2) + (gmn n3))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>is_measured_digit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Digit ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit (One a) = is_measured_node a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit (Two a b) = 
    ((is_measured_node a) ∧ (is_measured_node b))"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit (Three a b c) = 
    ((is_measured_node a) ∧ (is_measured_node b) ∧ (is_measured_node c))"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit (Four a b c d) = ((is_measured_node a) ∧ 
    (is_measured_node b) ∧ (is_measured_node c) ∧ (is_measured_node d))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>is_measured_ftree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree Empty ⟷ True"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree (Single n1) ⟷ (is_measured_node n1)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree (Deep a l m r) ⟷ ((is_measured_digit l) ∧ 
    (is_measured_ftree m) ∧ (is_measured_digit r)) ∧ 
    (a = ((gmd l) + (gmft m) + (gmd r)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Structural invariant for finger trees"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t == is_leveln_ftree 0 t ∧ is_measured_ftree t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abstraction to Lists"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>nodeToList</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node ⇒ ('e × 'a) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodeToList (Tip e a) = [(e,a)]"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodeToList (Node2 _ a b) = (nodeToList a) @ (nodeToList b)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodeToList (Node3 _ a b c) 
    = (nodeToList a) @ (nodeToList b) @ (nodeToList c)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>digitToList</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Digit ⇒ ('e × 'a) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToList (One a) = nodeToList a"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToList (Two a b) = (nodeToList a) @ (nodeToList b)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToList (Three a b c) 
    = (nodeToList a) @ (nodeToList b) @ (nodeToList c)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToList (Four a b c d) 
    = (nodeToList a) @ (nodeToList b) @ (nodeToList c) @ (nodeToList d)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"List representation of a finger tree"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>toList</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e ,'a) FingerTreeStruc ⇒ ('e × 'a) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"toList Empty = []"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"toList (Single a) = nodeToList a"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"toList (Deep _ pr m sf) = (digitToList pr) @ (toList m) @ (digitToList sf)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodeToList_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodeToList nd ≠ Nil"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nd</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>digitToList_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToList d ≠ Nil"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToList_empty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary lemmas›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gmn_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_node nd"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gmn nd = sum_list (map snd (nodeToList nd))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>nd</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gmd_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit d"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gmd d = sum_list (map snd (digitToList d))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gmn_correct</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gmft_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree t 
  ⟹ (gmft t) = sum_list (map snd (toList t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ft_invar_def</span><span> </span><span>gmd_correct</span><span> </span><span>gmn_correct</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gmft_correct2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t ⟹ (gmft t) = sum_list (map snd (toList t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>ft_invar_def</span><span> </span><span>gmft_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Operations›</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:operations}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Empty tree›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Empty_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"toList Empty = []"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ft_invar Empty"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ft_invar_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Exactly the empty finger tree represents the empty list›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>toList_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList t = [] ⟷ t = Empty"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToList_empty</span><span> </span><span>digitToList_empty</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Annotation›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Sum of annotations of all elements of a finger tree"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>annot</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ 'a"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"annot t = gmft t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ft_invar t ⟹ annot t = sum_list (map snd (toList t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>gmft_correct</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>annot_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gmft_correct2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Appending›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary functions to fill in the annotations›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>deep</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Digit ⇒ ('e,'a) FingerTreeStruc 
    ⇒ ('e,'a) Digit ⇒ ('e, 'a) FingerTreeStruc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deep pr m sf = Deep ((gmd pr) + (gmft m) + (gmd sf)) pr m sf"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>node2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"node2 nd1 nd2 = Node2 ((gmn nd1)+(gmn nd2)) nd1 nd2"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>node3</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"node3 nd1 nd2 nd3 = Node3 ((gmn nd1)+(gmn nd2)+(gmn nd3)) nd1 nd2 nd3"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Append a node at the left end"</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nlcons</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Node ⇒ ('e,'a) FingerTreeStruc 
    ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span>  
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="comment">― ‹Recursively we append a node, if the digit is full we push down a node3›</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlcons a Empty = Single a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlcons a (Single b) = deep (One a) Empty (One b)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlcons a (Deep _ (One b) m sf) = deep (Two a b) m sf"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlcons a (Deep _ (Two b c) m sf) = deep (Three a b c) m sf"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlcons a (Deep _ (Three b c d) m sf) = deep (Four a b c d) m sf"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlcons a (Deep _ (Four b c d e) m sf) 
    = deep (Two a b) (nlcons (node3 c d e) m) sf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Append a node at the right end"</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nrcons</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc 
    ⇒ ('e,'a) Node ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="comment">― ‹Recursively we append a node, if the digit is full we push down a node3›</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nrcons Empty a = Single a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nrcons (Single b) a = deep (One b) Empty (One a)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nrcons (Deep _ pr m (One b)) a = deep pr m (Two  b a)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nrcons (Deep _ pr m (Two b c)) a = deep pr m (Three b c a)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nrcons (Deep _ pr m (Three b c d)) a = deep pr m (Four b c d a)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nrcons (Deep _ pr m (Four b c d e)) a 
    = deep pr (nrcons m (node3 b c d)) (Two e a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nlcons_invlevel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦is_leveln_ftree n t; is_leveln_node n nd⟧ 
  ⟹ is_leveln_ftree n (nlcons nd t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>nd</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nlcons.induct</span><span class="delimiter">)</span><span> 
</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span> </span><span>node3_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nlcons_invmeas</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦is_measured_ftree t; is_measured_node nd⟧ 
  ⟹ is_measured_ftree (nlcons nd t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>nd</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nlcons.induct</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span> </span><span>node3_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>nlcons_inv</span><span> </span><span class="delimiter">=</span><span> </span><span>nlcons_invlevel</span><span> </span><span>nlcons_invmeas</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nlcons_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (nlcons a t) = (nodeToList a) @ (toList t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nlcons.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span> </span><span>toList_def</span><span> </span><span>node3_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nrcons_invlevel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦is_leveln_ftree n t; is_leveln_node n nd⟧ 
  ⟹ is_leveln_ftree n (nrcons t nd)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>nd</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>nd</span><span> </span><span>n</span><span> </span><span>rule</span><span class="delimiter">:</span><span>nrcons.induct</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span> </span><span>node3_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nrcons_invmeas</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦is_measured_ftree t; is_measured_node nd⟧ 
  ⟹ is_measured_ftree (nrcons t nd)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>nd</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>nd</span><span> </span><span>rule</span><span class="delimiter">:</span><span>nrcons.induct</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span> </span><span>node3_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>nrcons_inv</span><span> </span><span class="delimiter">=</span><span> </span><span>nrcons_invlevel</span><span> </span><span>nrcons_invmeas</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nrcons_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (nrcons t a) = (toList t) @ (nodeToList a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>a</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nrcons.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span> </span><span>toList_def</span><span> </span><span>node3_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Append an element at the left end"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lcons</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e × 'a::monoid_add) 
    ⇒ ('e,'a) FingerTreeStruc ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊲"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a ⊲ t = nlcons (Tip (fst a) (snd a)) t"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcons_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar (a ⊲ t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (a ⊲ t) = a # (toList t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ft_invar_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lcons_def</span><span> </span><span>nlcons_list</span><span> </span><span>nlcons_invlevel</span><span> </span><span>nlcons_invmeas</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcons_inv</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ft_invar t ⟹ ft_invar (a ⊲ t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lcons_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcons_list</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (a ⊲ t) = a # (toList t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lcons_def</span><span> </span><span>nlcons_list</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Append an element at the right end"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rcons</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ ('e × 'a) ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span>
</span><span>      </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊳"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t ⊳ a = nrcons t (Tip (fst a) (snd a))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rcons_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar (t ⊳ a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (t ⊳ a) = (toList t) @ [a]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nrcons_inv</span><span> </span><span>ft_invar_def</span><span> </span><span>rcons_def</span><span> </span><span>nrcons_list</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rcons_inv</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ft_invar t ⟹ ft_invar (t ⊳ a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rcons_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rcons_list</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (t ⊳ a) = (toList t) @ [a]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nrcons_list</span><span> </span><span>rcons_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Convert list to tree›</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>toTree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e × 'a::monoid_add) list ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"toTree [] = Empty"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"toTree (a#xs) = a ⊲ (toTree xs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>toTree_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ft_invar (toTree l)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"toList (toTree l) = l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ft_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toTree_def</span><span> </span><span>lcons_list</span><span> </span><span>lcons_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toTree_def</span><span> </span><span>lcons_list</span><span> </span><span>lcons_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  Note that this lemma is a completeness statement of our implementation, 
  as it can be read as:
  ,,All lists of elements have a valid representation as a finger tree.''
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Detaching leftmost/rightmost element›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>digitToTree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Digit ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToTree (One a) = Single a"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToTree (Two a b) = deep (One a) Empty (One b)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToTree (Three a b c) = deep (Two a b) Empty (One c)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToTree (Four a b c d) = deep (Two a b) Empty (Two c d)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>nodeToDigit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node ⇒ ('e,'a) Digit"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodeToDigit (Tip e a) = One (Tip e a)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodeToDigit (Node2 _ a b) = Two a b"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodeToDigit (Node3 _ a b c) = Three a b c"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nlistToDigit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node list ⇒ ('e,'a) Digit"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlistToDigit [a] = One a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlistToDigit [a,b] = Two a b"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlistToDigit [a,b,c] = Three a b c"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlistToDigit [a,b,c,d] = Four a b c d"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>digitToNlist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Digit ⇒ ('e,'a) Node list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToNlist (One a) = [a]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToNlist (Two a b) = [a,b] "</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToNlist (Three a b c) = [a,b,c]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"digitToNlist (Four a b c d) = [a,b,c,d]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary function to unwrap a Node element›</span></span></span><span> 
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>n_unwrap</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node ⇒ ('e × 'a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n_unwrap (Tip e a) = (e,a)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n_unwrap (Node2 _ a b) = undefined"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"n_unwrap (Node3 _ a b c) = undefined"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>ViewnRes</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('e,'a) Node × ('e,'a) FingerTreeStruc) option"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewnres_cases</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>r</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) ViewnRes"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="delimiter">(</span><span>Nil</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"r=None"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>          </span><span class="delimiter">(</span><span>Cons</span><span class="delimiter">)</span><span> </span><span>a</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r=Some (a,t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewnres_split</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P (case_option f1 (case_prod f2) x) = 
  ((x = None ⟶ P f1) ∧ (∀a b. x = Some (a,b) ⟶ P (f2 a b)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Detach the leftmost node. Return @{const None} on empty finger tree.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>viewLn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ ('e,'a) ViewnRes"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewLn Empty = None"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewLn (Single a) = Some (a, Empty)"</span></span></span><span class="delimiter">|</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewLn (Deep _ (Two a b) m sf) = Some (a, (deep (One b) m sf))"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewLn (Deep _ (Three a b c) m sf) = Some (a, (deep (Two b c) m sf))"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewLn (Deep _ (Four a b c d) m sf) = Some (a, (deep (Three b c d) m sf))"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewLn (Deep _ (One a) m sf) = 
    (case viewLn m of 
      None ⇒ Some (a, (digitToTree sf)) |
      Some (b, m2) ⇒ Some (a, (deep (nodeToDigit b) m2 sf)))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Detach the rightmost node. Return @{const None} on empty finger tree.›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>viewRn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ ('e,'a) ViewnRes"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewRn Empty = None"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewRn (Single a) = Some (a, Empty)"</span></span></span><span> </span><span class="delimiter">|</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewRn (Deep _ pr m (Two a b)) = Some (b, (deep pr m (One a)))"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewRn (Deep _ pr m (Three a b c)) = Some (c, (deep pr m (Two a b)))"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewRn (Deep _ pr m (Four a b c d)) = Some (d, (deep pr m (Three a b c)))"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewRn (Deep _ pr m (One a)) = 
    (case viewRn m of 
      None ⇒ Some (a, (digitToTree pr))|
      Some (b, m2) ⇒ Some (a, (deep pr m2 (nodeToDigit b))))"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* TODO: Head, last geht auch in O(1) !!! *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> 
</span><span>  </span><span>digitToTree_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n d ⟹ is_leveln_ftree n (digitToTree d)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit d ⟹ is_measured_ftree (digitToTree d)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">,</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">,</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>digitToTree_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (digitToTree d) = digitToList d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodeToDigit_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node (Suc n) nd ⟹ is_leveln_digit n (nodeToDigit nd) "</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_node nd ⟹ is_measured_digit (nodeToDigit nd)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>nd</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>nd</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodeToDigit_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToList (nodeToDigit nd) = nodeToList nd"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>nd</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewLn_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ Empty ⟷ (viewLn t) ≠ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Empty</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Single</span><span> </span><span>Node</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Deep</span><span> </span><span>a</span><span> </span><span>l</span><span> </span><span>x</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewLn x"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewLn_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦
  is_measured_ftree t; is_leveln_ftree n t; viewLn t = Some (nd, s)
  ⟧ ⟹ is_measured_ftree s ∧ is_measured_node nd ∧ 
        is_leveln_ftree n s ∧ is_leveln_node n nd"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>nd</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>viewLn.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewLn_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ux</span><span> </span><span>a</span><span> </span><span>m</span><span> </span><span>sf</span><span> </span><span>n</span><span> </span><span>nd</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>av</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀n nd s.
           ⟦is_measured_ftree m; is_leveln_ftree n m; viewLn m = Some (nd, s)⟧
           ⟹ is_measured_ftree s ∧
              is_measured_node nd ∧ is_leveln_ftree n s ∧ is_leveln_node n nd "</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">" is_measured_ftree (Deep ux (One a) m sf) "</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n (Deep ux (One a) m sf)"</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"viewLn (Deep ux (One a) m sf) = Some (nd, s)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree s ∧
          is_measured_node nd ∧ is_leveln_ftree n s ∧ is_leveln_node n nd"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewLn m"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>viewnres_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>av</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = digitToTree sf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v1</span><span> </span><span>av</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree s ∧
       is_measured_node nd ∧ is_leveln_ftree n s ∧ is_leveln_node n nd"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToTree_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>m2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>av</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = (deep (nodeToDigit b) m2 sf)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>myiv</span><span> </span><span class="delimiter">=</span><span> </span><span>av</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span> </span><span>b</span><span> </span><span>m2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v2</span><span> </span><span>av</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m ∧ is_leveln_ftree (Suc n) m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m2 ∧
   is_measured_node b ∧ is_leveln_ftree (Suc n) m2 ∧ is_leveln_node (Suc n) b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>myiv</span><span> </span><span>Cons</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>av</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>v2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree s ∧
          is_measured_node nd ∧ is_leveln_ftree n s ∧ is_leveln_node n nd"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span> </span><span>nodeToDigit_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewLn_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" viewLn t = Some (nd, s) 
  ⟹ toList t = (nodeToList nd) @ (toList s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>nd</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>viewLn.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toList_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toList_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toList_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>m</span><span> </span><span>sf</span><span> </span><span>nd</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prems</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewLn m"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>viewnres_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>av</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = Empty"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>viewLn_empty</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>av</span><span> </span><span>prems</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nodeToList a @ toList m @ digitToList sf = nodeToList nd @ toList s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToTree_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>        
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>m2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = (deep (nodeToDigit b) m2 sf)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span>prems</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nodeToList a @ toList m @ digitToList sf = nodeToList nd @ toList s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span> </span><span>nodeToDigit_list</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewRn_empty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ Empty ⟷ (viewRn t) ≠ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Empty</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Single</span><span> </span><span>Node</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Deep</span><span> </span><span>a</span><span> </span><span>l</span><span> </span><span>x</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewRn x"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewRn_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦
  is_measured_ftree t; is_leveln_ftree n t; viewRn t = Some (nd, s)
  ⟧ ⟹ is_measured_ftree s ∧ is_measured_node nd ∧ 
       is_leveln_ftree n s ∧ is_leveln_node n nd"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>nd</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>viewRn.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewRn_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ux</span><span> </span><span>a</span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>n</span><span> </span><span>nd</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>av</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀n nd s.
           ⟦is_measured_ftree m; is_leveln_ftree n m; viewRn m = Some (nd, s)⟧
           ⟹ is_measured_ftree s ∧
              is_measured_node nd ∧ is_leveln_ftree n s ∧ is_leveln_node n nd "</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">" is_measured_ftree (Deep ux pr m (One a)) "</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n (Deep ux pr m (One a))"</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"viewRn (Deep ux pr m (One a)) = Some (nd, s)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree s ∧
          is_measured_node nd ∧ is_leveln_ftree n s ∧ is_leveln_node n nd"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewRn m"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>viewnres_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>av</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = digitToTree pr"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v1</span><span> </span><span>av</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree s ∧
       is_measured_node nd ∧ is_leveln_ftree n s ∧ is_leveln_node n nd"</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToTree_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>m2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>av</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = (deep pr m2 (nodeToDigit b))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>myiv</span><span> </span><span class="delimiter">=</span><span> </span><span>av</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span> </span><span>b</span><span> </span><span>m2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v2</span><span> </span><span>av</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m ∧ is_leveln_ftree (Suc n) m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>bv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m2 ∧
   is_measured_node b ∧ is_leveln_ftree (Suc n) m2 ∧ is_leveln_node (Suc n) b"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>myiv</span><span> </span><span>Cons</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>av</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>v2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree s ∧
          is_measured_node nd ∧ is_leveln_ftree n s ∧ is_leveln_node n nd"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span> </span><span>nodeToDigit_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewRn_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewRn t = Some (nd, s) 
  ⟹ toList t = (toList s) @ (nodeToList nd)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>nd</span><span> </span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>viewRn.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toList_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toList_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toList_def</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>prems</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>pr</span><span> </span><span>m</span><span> </span><span>a</span><span> </span><span>nd</span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewRn m"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>viewnres_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>av</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = Empty"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>viewRn_empty</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>av</span><span> </span><span>prems</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToList pr @ toList m @ nodeToList a = toList s @ nodeToList nd"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToTree_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>        
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>b</span><span> </span><span>m2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = (deep pr m2 (nodeToDigit b))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span>prems</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToList pr @ toList m @ nodeToList a = toList s @ nodeToList nd"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span> </span><span>nodeToDigit_list</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>viewres</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('e ×'a) × ('e,'a) FingerTreeStruc) option"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Detach the leftmost element. Return @{const None} on empty finger tree.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>viewL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ ('e,'a) viewres"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">"viewL t = (case viewLn t of 
  None ⇒ None |
  (Some (a, t2)) ⇒ Some ((n_unwrap a), t2))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewL_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(t=Empty ⟹ viewL t = None)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(t≠Empty ⟹ (∃a s. viewL t = Some (a, s) ∧ ft_invar s 
                        ∧ toList t = a # toList s))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t=Empty"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewL t = None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewL_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ Empty"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>INV'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree 0 t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ft_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewLn t ≠ None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewLn_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>nd</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>vn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewLn t = Some (nd, s)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewLn t"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewL t = Some (a, s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewL_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV'</span><span> </span><span>vn</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree s ∧ is_leveln_ftree 0 s 
         ∧ is_leveln_node 0 nd ∧ is_measured_node nd"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"toList t = (nodeToList nd) @ (toList s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewLn_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>0</span><span> </span><span>nd</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>viewLn_list</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v1</span><span> </span><span>vn</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodeToList nd = [a]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewL_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v1</span><span> </span><span>v2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a s. viewL t = Some (a, s) ∧ ft_invar s ∧ toList t = a # toList s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ft_invar_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewL_correct_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewL Empty = None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewL_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewL_correct_nonEmpty</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ Empty"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewL t = Some (a, s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList t = a # toList s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>viewL_correct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Detach the rightmost element. Return @{const None} on empty finger tree.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>viewR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ ('e,'a) viewres"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewR t = (case viewRn t of 
    None ⇒ None |
    (Some (a, t2)) ⇒ Some ((n_unwrap a), t2))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewR_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>INV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(t = Empty ⟹ viewR t = None)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(t ≠ Empty ⟹ (∃ a s. viewR t = Some (a, s) ∧ ft_invar s 
                          ∧ toList t = toList s @ [a]))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t=Empty"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewR t = None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewR_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>NE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ Empty"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>INV'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree 0 t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree t"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ft_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NE</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewRn t ≠ None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewRn_empty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>nd</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>vn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewRn t = Some (nd, s)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewRn t"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewR t = Some (a, s)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewR_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>INV'</span><span> </span><span>vn</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree s ∧ is_leveln_ftree 0 s 
         ∧ is_leveln_node 0 nd ∧ is_measured_node nd"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"toList t = (toList s) @ (nodeToList nd)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewRn_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span> </span><span>0</span><span> </span><span>nd</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>viewRn_list</span><span class="delimiter">[</span><span>of</span><span> </span><span>t</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v1</span><span> </span><span>vn</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodeToList nd = [a]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewR_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nd</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v1</span><span> </span><span>v2</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a s. viewR t = Some (a, s) ∧ ft_invar s ∧ toList t = toList s @ [a]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>ft_invar_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewR_correct_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewR Empty = None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>viewR_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewR_correct_nonEmpty</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ Empty"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"viewR t = Some (a, s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar s ∧ toList t = toList s @ [a]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>viewR_correct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Finger trees viewed as a double-ended queue. The head and tail functions
  here are only
  defined for non-empty queues, while the view-functions were also defined for
  empty finger trees.›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Check for emptiness"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>isEmpty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) FingerTreeStruc ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>code</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isEmpty t = (t = Empty)"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isEmpty_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isEmpty t ⟷ toList t = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>isEmpty_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toList_empty</span><span class="delimiter">)</span><span>
</span><span class="comment">― ‹Avoid comparison with @{text "(=)"}, and thus unnecessary equality-class
    parameter on element types in generated code›</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isEmpty t = (case t of Empty ⇒ True | _ ⇒ False)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>isEmpty_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Leftmost element"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>head</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ 'e × 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"head t = (case viewL t of (Some (a, _)) ⇒ a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>head_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ Empty"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = hd (toList t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>viewL_correct</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>v1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"viewL t = Some (a, s) ∧ ft_invar s ∧ toList t = a # toList s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>head_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (toList t) = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"All but the leftmost element"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tail</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tail t = (case viewL t of (Some (_, m)) ⇒ m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tail_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ Empty"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (tail t) = tl (toList t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar (tail t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>viewL_correct</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>v1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"viewL t = Some (a, s) ∧ ft_invar s ∧ toList t = a # toList s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tail t = s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tail_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tl (toList t) = toList s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v1</span><span> </span><span>v2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"toList (tail t) = tl (toList t)"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ft_invar (tail t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Rightmost element"</span></span></span><span>  
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>headR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ 'e × 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"headR t = (case viewR t of (Some (a, _)) ⇒ a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>headR_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ Empty"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"headR t = last (toList t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>viewR_correct</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>v1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"viewR t = Some (a, s) ∧ ft_invar s ∧ toList t = toList s @ [a]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"headR t = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>headR_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"All but the rightmost element"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>tailR</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tailR t = (case viewR t of (Some (_, m)) ⇒ m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tailR_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ≠ Empty"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (tailR t) = butlast (toList t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar (tailR t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>viewR_correct</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>v1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"viewR t = Some (a, s) ∧ ft_invar s ∧ toList t = toList s @ [a]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tailR t = s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tailR_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (tailR t) = butlast (toList t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar (tailR t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Concatenation›</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>lconsNlist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Node list 
    ⇒ ('e,'a) FingerTreeStruc ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lconsNlist [] t = t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lconsNlist (x#xs) t = nlcons x (lconsNlist xs t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>rconsNlist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc 
    ⇒ ('e,'a) Node list ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rconsNlist t []  = t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"rconsNlist t (x#xs)  = rconsNlist (nrcons t x) xs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nodes</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Node list  ⇒ ('e,'a) Node list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodes [a, b] = [node2 a b]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodes [a, b, c] = [node3 a b c]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodes [a,b,c,d] = [node2 a b, node2 c d]"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nodes (a#b#c#xs) = (node3 a b c) # (nodes xs)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Recursively we concatenate two FingerTreeStrucs while we keep the 
  inner Nodes in a list›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>app3</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ ('e,'a) Node list 
    ⇒ ('e,'a) FingerTreeStruc ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"app3 Empty xs t = lconsNlist xs t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"app3 t xs Empty = rconsNlist t xs"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"app3 (Single x) xs t = nlcons x (lconsNlist xs t)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"app3 t xs (Single x) = nrcons (rconsNlist t xs) x"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"app3 (Deep _ pr1 m1 sf1) ts (Deep _ pr2 m2 sf2) =
    deep pr1 (app3 m1 
      (nodes ((digitToNlist sf1) @ ts @ (digitToNlist pr2))) m2) sf2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lconsNlist_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n t"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x∈set xs. (is_leveln_node n x ∧ is_measured_node x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n (lconsNlist xs t) ∧ is_measured_ftree (lconsNlist xs t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlcons_invlevel</span><span> </span><span>nlcons_invmeas</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rconsNlist_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n t"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree t"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x∈set xs. (is_leveln_node n x ∧ is_measured_node x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n (rconsNlist t xs) ∧ is_measured_ftree (rconsNlist t xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nrcons_invlevel</span><span> </span><span>nrcons_invmeas</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodes_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set ts. is_leveln_node n x ∧ is_measured_node x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ts ≥ 2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set (nodes ts). is_leveln_node (Suc n) x ∧ is_measured_node x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>ts</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nodes.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>node2_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>node3_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>node2_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>4</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>v</span><span> </span><span>vb</span><span> </span><span>vc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>node3_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦∀x∈set []. is_leveln_node n x ∧ is_measured_node x; 2 ≤ length []⟧
    ⟹ ∀x∈set (nodes []). is_leveln_node (Suc n) x ∧ is_measured_node x"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span>  </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀v. ⟦∀x∈set [v]. is_leveln_node n x ∧ is_measured_node x; 2 ≤ length [v]⟧
    ⟹ ∀x∈set (nodes [v]). is_leveln_node (Suc n) x ∧ is_measured_node x"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodes_inv2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit sf1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit pr2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set ts. is_leveln_node n x ∧ is_measured_node x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀x∈set (nodes (digitToNlist sf1 @ ts @ digitToNlist pr2)).
                is_leveln_node (Suc n) x ∧ is_measured_node x"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" ∀x∈set (digitToNlist sf1 @ ts @ digitToNlist pr2). 
                 is_leveln_node n x ∧ is_measured_node x"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToNlist_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sf1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pr2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pr2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pr2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pr2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (digitToNlist sf1 @ ts @ digitToNlist pr2) ≥ 2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sf1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pr2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v1</span><span> </span><span>nodes_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToNlist sf1 @ ts @ digitToNlist pr2"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app3_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n t1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n t2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree t1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree t2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x∈set xs. (is_leveln_node n x ∧ is_measured_node x)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n (app3 t1 xs t2) ∧ is_measured_ftree (app3 t1 xs t2)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>t1</span><span> </span><span>xs</span><span> </span><span>t2</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>app3.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>xs</span><span> </span><span>t</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lconsNlist_inv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2_1"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rconsNlist_inv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"2_2"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lconsNlist_inv</span><span> </span><span>rconsNlist_inv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"3_1"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lconsNlist_inv</span><span> </span><span>nlcons_invlevel</span><span> </span><span>nlcons_invmeas</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"3_2"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>app3.simps</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lconsNlist_inv</span><span> </span><span>nlcons_invlevel</span><span> </span><span>nlcons_invmeas</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>4</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>app3.simps</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rconsNlist_inv</span><span> </span><span>nrcons_invlevel</span><span> </span><span>nrcons_invmeas</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>5</span><span> </span><span>uu</span><span> </span><span>pr1</span><span> </span><span>m1</span><span> </span><span>sf1</span><span> </span><span>ts</span><span> </span><span>uv</span><span> </span><span>pr2</span><span> </span><span>m2</span><span> </span><span>sf2</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m1"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"5.prems"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_leveln_ftree_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m1"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>v4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"5.prems"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_measured_ftree_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf1"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit sf1"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr2"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit pr2"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀x∈set ts. is_leveln_node n x ∧ is_measured_node x"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"5.prems"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_leveln_ftree_def</span><span> </span><span>is_measured_ftree_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>v6</span><span> </span><span class="delimiter">=</span><span> </span><span>nodes_inv2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>v5</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>v7</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"5.hyps"</span></span></span><span class="delimiter">[</span><span>OF</span><span> </span><span>v1</span><span> </span><span>v2</span><span> </span><span>v3</span><span> </span><span>v4</span><span> </span><span>v6</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v8</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf2"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit sf2"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr1"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit pr1"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"5.prems"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_leveln_ftree_def</span><span> </span><span>is_measured_ftree_def</span><span class="delimiter">)</span><span>
</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>v7</span><span> </span><span>v8</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_leveln_ftree_def</span><span> </span><span>is_measured_ftree_def</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>nlistToList</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('e, 'a) Node) list ⇒ ('e × 'a) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlistToList [] = []"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlistToList (x#xs) = (nodeToList x) @ (nlistToList xs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nodes_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs ≥ 2 ⟹ nlistToList (nodes xs) = nlistToList xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nodes.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>node2_def</span><span> </span><span>node3_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nlistToList_app</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlistToList (xs@ys) = (nlistToList xs) @ (nlistToList ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ys</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nlistListLCons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (lconsNlist xs t) = (nlistToList xs) @ (toList t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlcons_list</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nlistListRCons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (rconsNlist t xs) = (toList t) @ (nlistToList xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nrcons_list</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app3_list_lem1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlistToList (nodes (digitToNlist sf1 @ ts @ digitToNlist pr2)) =
       digitToList sf1 @ nlistToList ts @ digitToList pr2"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (digitToNlist sf1 @ ts @ digitToNlist pr2) ≥ 2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sf1</span><span class="delimiter">,</span><span>cases</span><span> </span><span>pr2</span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(nlistToList (digitToNlist sf1 @ ts @ digitToNlist pr2)) 
       = (digitToList sf1 @ nlistToList ts @ digitToList pr2)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>sf1</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>pr2</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistToList_app</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pr2</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pr2</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>pr2</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>nodes_list</span><span class="delimiter">[</span><span>OF</span><span> </span><span>len1</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app3_list</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"toList (app3 t1 xs t2) = (toList t1) @ (nlistToList xs) @ (toList t2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t1</span><span> </span><span>xs</span><span> </span><span>t2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>app3.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistListLCons</span><span> </span><span>nlistListRCons</span><span> </span><span>nlcons_list</span><span> </span><span>nrcons_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>app3_list_lem1</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>app</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) FingerTreeStruc ⇒ ('e,'a) FingerTreeStruc 
       ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"app t1 t2 = app3 t1 [] t2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar t2"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (app t1 t2) = (toList t1) @ (toList t2)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar (app t1 t2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>app3_inv</span><span> </span><span>app3_list</span><span> </span><span>ft_invar_def</span><span> </span><span>app_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ft_invar t1;ft_invar t2⟧ ⟹ ft_invar (app t1 t2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>app3_inv</span><span> </span><span>ft_invar_def</span><span> </span><span>app_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_list</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (app t1 t2) = (toList t1) @ (toList t2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>app3_list</span><span> </span><span>app_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Splitting"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>SplitDigit</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Node list  × ('e,'a) Node × ('e,'a) Node list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>SplitTree</span><span>  </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('e,'a) FingerTreeStruc × ('e,'a) Node × ('e,'a) FingerTreeStruc"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary functions to create a correct finger tree 
    even if the left or right digit is empty›</span></span></span><span> 
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>deepL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Node list ⇒ ('e,'a) FingerTreeStruc 
    ⇒ ('e,'a) Digit ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deepL [] m sf = (case (viewLn m) of None ⇒ digitToTree sf |
                                 (Some (a, m2)) ⇒ deep (nodeToDigit a) m2 sf)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deepL pr m sf = deep (nlistToDigit pr) m sf"</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>deepR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Digit ⇒ ('e,'a) FingerTreeStruc 
    ⇒ ('e,'a) Node list ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deepR pr m [] = (case (viewRn m) of None ⇒ digitToTree pr |
                                 (Some (a, m2)) ⇒ deep pr m2 (nodeToDigit a))"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deepR pr m sf = deep pr m (nlistToDigit sf)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Splitting a list of nodes›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>splitNlist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::monoid_add ⇒ bool) ⇒ 'a ⇒ ('e,'a) Node list 
    ⇒ ('e,'a) SplitDigit"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"splitNlist p i [a]   = ([],a,[])"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"splitNlist p i (a#b) = 
    (let i2 = (i + gmn a) in 
      (if (p i2) 
        then ([],a,b) 
        else 
         (let (l,x,r) = (splitNlist p i2 b) in ((a#l),x,r))))"</span></span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Splitting a digit by converting it into a list of nodes›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>splitDigit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::monoid_add ⇒ bool) ⇒ 'a ⇒ ('e,'a) Digit 
    ⇒ ('e,'a) SplitDigit"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"splitDigit p i d = splitNlist p i (digitToNlist d)"</span></span></span><span> 
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Creating a finger tree from list of nodes›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>nlistToTree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a::monoid_add) Node list 
    ⇒ ('e,'a) FingerTreeStruc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nlistToTree xs = lconsNlist xs Empty"</span></span></span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Recursive splitting into a left and right tree and a center node›</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>nsplitTree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::monoid_add ⇒ bool) ⇒ 'a ⇒ ('e,'a) FingerTreeStruc 
    ⇒ ('e,'a) SplitTree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nsplitTree p i Empty = (Empty, Tip undefined undefined, Empty)"</span></span></span><span> 
</span><span>      </span><span class="comment">― ‹Making the function total›</span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nsplitTree p i (Single ea) = (Empty,ea,Empty)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nsplitTree p i (Deep _ pr m sf) = 
     (let 
       vpr = (i + gmd pr); 
       vm = (vpr + gmft m) 
      in 
        if (p vpr) then 
          (let (l,x,r) = (splitDigit p i pr) in 
            (nlistToTree l,x,deepL r m sf)) 
        else (if (p vm) then 
          (let (ml,xs,mr) = (nsplitTree p vpr m); 
            (l,x,r) = (splitDigit p (vpr + gmft ml) (nodeToDigit xs)) in
              (deepR pr ml l,x,deepL r mr sf))
        else 
          (let (l,x,r) = (splitDigit p vm sf) in 
            (deepR pr m l,x,nlistToTree r))    
      ))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nlistToTree_inv</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set nl. is_measured_node x ⟹ is_measured_ftree (nlistToTree nl)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set nl. is_leveln_node n x ⟹ is_leveln_ftree n (nlistToTree nl)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>nlistToTree_def</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>nl</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlcons_invmeas</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nl</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlcons_invlevel</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nlistToTree_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (nlistToTree nl) = nlistToList nl"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistToTree_def</span><span> </span><span>nlistListLCons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deepL_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf ∧ is_measured_digit sf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set pr. (is_measured_node x ∧ is_leveln_node n x) ∧ length pr ≤ 4"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n (deepL pr m sf) ∧ is_measured_ftree (deepL pr m sf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>m</span><span> </span><span>sf</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>deepL.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>viewnres_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToTree_inv</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span> </span><span>sf</span><span> </span><span>Node</span><span> </span><span>FingerTreeStruc</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m"</span></span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit sf"</span></span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"viewLn m = Some (Node, FingerTreeStruc)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n (nodeToDigit Node) 
        ∧ is_leveln_ftree (Suc n) FingerTreeStruc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewLn_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span> </span><span>Node</span><span> </span><span>FingerTreeStruc</span><span class="delimiter">]</span><span> </span><span>nodeToDigit_inv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span> </span><span>sf</span><span> </span><span>Node</span><span> </span><span>FingerTreeStruc</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms1</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit sf"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"viewLn m = Some (Node, FingerTreeStruc)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit (nodeToDigit Node) ∧ is_measured_ftree FingerTreeStruc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>viewLn_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span> </span><span>Node</span><span> </span><span>FingerTreeStruc</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_node Node ∧ is_leveln_node (Suc n) Node"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewLn_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span> </span><span>Node</span><span> </span><span>FingerTreeStruc</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit (nodeToDigit Node)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToDigit_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span> </span><span>va</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_measured_node v ∧ is_leveln_node n (v:: ('a,'b) Node) ∧
    length  (va::('a, 'b) Node list) ≤ 3 ∧ 
    (∀x∈set va. is_measured_node x ∧ is_leveln_node n x ∧ length va ≤ 3)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n (nlistToDigit (v # va)) 
       ∧ is_measured_digit (nlistToDigit (v # va))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v#va"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nlistToDigit.cases</span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*corollary deepL_inv':
  assumes "is_leveln_ftree (Suc n) m" "is_measured_ftree m"
  and "is_leveln_digit n sf" "is_measured_digit sf"
  and "∀ x ∈ set pr. (is_measured_node x ∧ is_leveln_node n x)" "length pr ≤ 4"
  shows  "is_leveln_ftree n (deepL pr m sf)" "is_measured_ftree (deepL pr m sf)"
  using assms deepL_inv by blast+
*)</span></span></span></span></span><span>
</span><span>            
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nlistToDigit_list</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ length xs ∧ length xs ≤ 4"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToList(nlistToDigit xs) = nlistToList xs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nlistToDigit.cases</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deepL_list</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf ∧ is_measured_digit sf"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set pr. (is_measured_node x ∧ is_leveln_node n x) ∧ length pr ≤ 4"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (deepL pr m sf) = nlistToList pr @ toList m @ digitToList sf"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>m</span><span> </span><span>sf</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>deepL.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>m</span><span> </span><span>sf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>viewnres_split</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewLn m = None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = Empty"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>viewLn_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList m = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (digitToTree sf) = toList m @ digitToList sf"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>digitToTree_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>nd</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewLn m = Some (nd, t)"</span></span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nodeToList nd @ toList t = toList m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>viewLn_list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToList (nodeToDigit nd) @ toList t = toList m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToDigit_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>v</span><span> </span><span>va</span><span> </span><span>m</span><span> </span><span>sf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>deepL.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistToDigit_list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deepR_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr ∧ is_measured_digit pr"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set sf. (is_measured_node x ∧ is_leveln_node n x) ∧ length sf ≤ 4"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n (deepR pr m sf) ∧ is_measured_ftree (deepR pr m sf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>m</span><span> </span><span>sf</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>deepR.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>viewnres_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToTree_inv</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>Node</span><span> </span><span>FingerTreeStruc</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m"</span></span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit pr"</span></span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">"viewRn m = Some (Node, FingerTreeStruc)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n (nodeToDigit Node) 
    ∧ is_leveln_ftree (Suc n) FingerTreeStruc"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewRn_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span> </span><span>Node</span><span> </span><span>FingerTreeStruc</span><span class="delimiter">]</span><span> </span><span>nodeToDigit_inv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>Node</span><span> </span><span>FingerTreeStruc</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms1</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit pr"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"viewRn m = Some (Node, FingerTreeStruc)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree FingerTreeStruc ∧ is_measured_digit (nodeToDigit Node)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>viewRn_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span> </span><span>Node</span><span> </span><span>FingerTreeStruc</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_node Node ∧ is_leveln_node (Suc n) Node"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewRn_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span> </span><span>Node</span><span> </span><span>FingerTreeStruc</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit (nodeToDigit Node)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToDigit_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>v</span><span> </span><span>va</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_measured_node v ∧ is_leveln_node n (v:: ('a,'b) Node) ∧
    length  (va::('a, 'b) Node list) ≤ 3 ∧ 
    (∀x∈set va. is_measured_node x ∧ is_leveln_node n x ∧ length va ≤ 3)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n (nlistToDigit (v # va)) ∧ 
        is_measured_digit (nlistToDigit (v # va))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"v#va"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nlistToDigit.cases</span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>           
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deepR_list</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr ∧ is_measured_digit pr"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set sf. (is_measured_node x ∧ is_leveln_node n x) ∧ length sf ≤ 4"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (deepR pr m sf) = digitToList pr @ toList m @ nlistToList sf"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>m</span><span> </span><span>sf</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>deepR.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>viewnres_split</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewRn m = None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = Empty"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>viewRn_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList m = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (digitToTree pr) = digitToList pr @ toList m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>digitToTree_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>nd</span><span> </span><span>t</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewRn m = Some (nd, t)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m"</span></span></span><span> 
</span><span>           </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList t @ nodeToList nd = toList m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>viewRn_list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList t @ digitToList (nodeToDigit nd) = toList m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToDigit_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>m</span><span> </span><span>v</span><span> </span><span>va</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>deepR.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deep_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistToDigit_list</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>gmnl</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a::monoid_add) Node list ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"gmnl [] = 0"</span></span></span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"gmnl (x#xs) = gmn x + gmnl xs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gmnl_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set xs. is_measured_node x"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"gmnl xs = sum_list (map snd (nlistToList xs))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.assoc</span><span> </span><span>gmn_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitNlist_correct</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" ⟦
  ⋀(a::'a) (b::'a). p a ⟹ p (a + b);
  ¬ p i;
  p (i + gmnl (nl ::('e,'a::monoid_add) Node list));
  splitNlist p i nl = (l, n, r)
  ⟧ ⟹  
  ¬ p (i + (gmnl l))
  ∧
  p (i + (gmnl l) + (gmn n))
  ∧
  nl = l @ n # r
  "</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span>nl</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>l</span><span> </span><span>n</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>splitNlist.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span>a</span><span> </span><span>v</span><span> </span><span>va</span><span> </span><span>l</span><span> </span><span>n</span><span> </span><span>r</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IV</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + (gmn a))"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IV</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IV2</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> </span><span>IV</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l1</span><span> </span><span>n1</span><span> </span><span>r1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span>v1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitNlist p (i + gmn a) (v # va) = (l1, n1, r1)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitNlist p (i + gmn a) (v # va)"</span></span></span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>miv</span><span> </span><span class="delimiter">=</span><span> </span><span>IV2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmn a"</span></span></span><span> </span><span>l1</span><span> </span><span>n1</span><span> </span><span>r1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"p (i + gmn a + gmnl (v # va))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IV2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>miv2</span><span> </span><span class="delimiter">=</span><span>  </span><span>miv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>IV2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>IV2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>IV2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>  </span><span>v2</span><span> </span><span>v1</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a # l1 = l"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n1 = n"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r1 = r"</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>IV2</span><span> </span><span>v1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>miv2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>v4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + gmn a + gmnl l1) ∧ 
             p (i + gmn a + gmnl l1 + gmn n1) ∧ 
             v # va = l1 @ n1 # r1"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v2</span><span> </span><span>v3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>digitToNlist_inv</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit d ⟹ (∀ x ∈ set (digitToNlist d). is_measured_node x)"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n d ⟹ (∀ x ∈ set (digitToNlist d). is_leveln_node n x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gmnl_gmd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit d ⟹ gmnl (digitToNlist d) = gmd d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gmn_gmd</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_measured_node nd ⟹ gmd (nodeToDigit nd) = gmn nd"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToDigit_inv</span><span> </span><span>nodeToDigit_list</span><span> </span><span>gmn_correct</span><span> </span><span>gmd_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitDigit_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦
  ⋀(a::'a) (b::'a). p a ⟹ p (a + b);
  ¬ p i;
  is_measured_digit d;
  is_leveln_digit n d;
  p (i + gmd (d ::('e,'a::monoid_add) Digit));
  splitDigit p i d = (l, nd, r)
  ⟧ ⟹  
  ¬ p (i + (gmnl l))
  ∧
  p (i + (gmnl l) + (gmn nd))
  ∧
  (∀ x ∈ set l. (is_measured_node x ∧ is_leveln_node n x))
  ∧
  (∀ x ∈ set r. (is_measured_node x ∧ is_leveln_node n x))
  ∧
  (is_measured_node nd ∧ is_leveln_node n nd )
  "</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span>d</span><span> </span><span>n</span><span> </span><span>l</span><span> </span><span>nd</span><span> </span><span>r</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. p a ⟹ p (a + b)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ p i"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_digit d"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd d)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p i d = (l, nd, r)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n d"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span> </span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + gmnl (digitToNlist d))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gmnl_gmd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>snc</span><span> </span><span class="delimiter">=</span><span> </span><span>splitNlist_correct</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToNlist d"</span></span></span><span> </span><span>l</span><span> </span><span>nd</span><span> </span><span>r</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitNlist p i (digitToNlist d) = (l, nd, r)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splitDigit_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>snc1</span><span> </span><span class="delimiter">=</span><span> </span><span>snc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>v1</span><span> </span><span>v2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>v3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + gmnl l) ∧ p (i + gmnl l + gmn nd) ∧ 
             digitToNlist d = l @ nd # r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>v4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" ∀ x ∈ set (digitToNlist d). is_measured_node x"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">" ∀ x ∈ set (digitToNlist d). is_leveln_node n x"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToNlist_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>v5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set l. (is_measured_node x ∧ is_leveln_node n x)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set r. (is_measured_node x ∧ is_leveln_node n x)"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_measured_node nd ∧ is_leveln_node n nd"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v3</span><span> </span><span>v5</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + gmnl l) ∧ p (i + gmnl l + gmn nd) ∧ 
    (∀x∈set l. is_measured_node x ∧ is_leveln_node n x) ∧ 
    (∀x∈set r. is_measured_node x ∧ is_leveln_node n x) ∧ 
    is_measured_node nd ∧ is_leveln_node n nd"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitDigit_inv'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦
  splitDigit p i d = (l, nd, r);
  is_measured_digit d;
  is_leveln_digit n d
  ⟧ ⟹  
  (∀ x ∈ set l. (is_measured_node x ∧ is_leveln_node n x))
  ∧
  (∀ x ∈ set r. (is_measured_node x ∧ is_leveln_node n x))
  ∧
  (is_measured_node nd ∧ is_leveln_node n nd )
  "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>splitDigit_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitDigit_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p i d = (l,n,r) ⟹ 
  (digitToList d) = (nlistToList l) @ (nodeToList n) @ (nlistToList r)
  ∧ length l ≤ 4 ∧ length r ≤ 4"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>splitDigit_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gmnl_gmft</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set nl. is_measured_node x ⟹ 
  gmft (nlistToTree nl) = gmnl nl"</span></span></span><span>  
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gmnl_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>nl</span><span class="delimiter">]</span><span> </span><span>nlistToTree_list</span><span class="delimiter">[</span><span>of</span><span> </span><span>nl</span><span class="delimiter">]</span><span>  
</span><span>                   </span><span>nlistToTree_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>nl</span><span class="delimiter">]</span><span>  </span><span>gmft_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"nlistToTree nl"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gmftR_gmnl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr ∧ is_measured_digit pr"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set sf. (is_measured_node x ∧ is_leveln_node n x) ∧ length sf ≤ 4"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"gmft (deepR pr m sf) = gmd pr + gmft m + gmnl sf"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (deepR pr m sf) = digitToList pr @ toList m @ nlistToList sf"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deepR_list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_measured_ftree (deepR pr m sf)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deepR_inv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>v3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gmft (deepR pr m sf) = 
        sum_list (map snd (digitToList pr @ toList m @ nlistToList sf))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gmft_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>v4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"gmd pr + gmft m + gmnl sf = 
        sum_list (map snd (digitToList pr @ toList m @ nlistToList sf))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gmd_correct</span><span> </span><span>gmft_correct</span><span> </span><span>gmnl_correct</span><span> </span><span>assms</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsplitTree_invpres</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦
  is_leveln_ftree n (s:: ('e,'a::monoid_add) FingerTreeStruc);
  is_measured_ftree s;  
  ¬ p i; 
  p (i + (gmft s));
  (nsplitTree p i s) = (l, nd, r)⟧ 
  ⟹ 
  is_leveln_ftree n l
  ∧
  is_measured_ftree l
  ∧
  is_leveln_ftree n r
  ∧
  is_measured_ftree r
  ∧
  is_leveln_node n nd
  ∧
  is_measured_node nd
  "</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span>s</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>l</span><span> </span><span>nd</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nsplitTree.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span>uu</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>m</span><span> </span><span>sf</span><span> </span><span>n</span><span> </span><span>l</span><span> </span><span>nd</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd pr)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span>l1xr1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p i pr = (l1,x,r1)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p i pr"</span></span></span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = nlistToTree l1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = deepL r1 m sf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1xr1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToList pr = nlistToList l1 @ nodeToList x @ nlistToList r1"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"length l1 ≤ 4"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length r1 ≤ 4"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splitDigit_list</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>pr_m_sf_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr ∧ is_measured_digit pr"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf ∧ is_measured_digit sf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>True</span><span> </span><span>l1xr1</span><span>  
</span><span>        </span><span>splitDigit_inv'</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>l1_x_r1_inv</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set l1. (is_measured_node x ∧ is_leveln_node n x)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set r1. (is_measured_node x ∧ is_leveln_node n x)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"is_measured_node x ∧ is_leveln_node n x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1_x_r1_inv</span><span> </span><span>v1</span><span> </span><span>v2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>ziel3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n l ∧ is_measured_ftree l ∧
        is_leveln_ftree n r ∧ is_measured_ftree r ∧ 
        is_leveln_node n nd ∧ is_measured_node nd"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistToTree_inv</span><span> </span><span>deepL_inv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>case1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd pr + gmft m)"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>case1</span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>l1xr1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p (i + gmd pr + gmft m) sf = (l1,x,r1)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p (i + gmd pr + gmft m) sf"</span></span></span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>case1</span><span> </span><span>False</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = deepR pr m l1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = nlistToTree r1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1xr1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToList sf = nlistToList l1 @ nodeToList x @ nlistToList r1"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"length l1 ≤ 4"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length r1 ≤ 4"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splitDigit_list</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>pr_m_sf_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr ∧ is_measured_digit pr"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf ∧ is_measured_digit sf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>v7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd pr + gmft m + gmd sf)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pr_m_sf_inv</span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>case1</span><span> </span><span>False</span><span> </span><span>l1xr1</span><span>  
</span><span>             </span><span>splitDigit_inv'</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmd pr + gmft m"</span></span></span><span> </span><span>sf</span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span> </span><span>n</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set l1. (is_measured_node x ∧ is_leveln_node n x)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set r1. (is_measured_node x ∧ is_leveln_node n x)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_measured_node x ∧ is_leveln_node n x"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1_x_r1_inv</span><span> </span><span>v1</span><span> </span><span>v2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>ziel3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n l ∧ is_measured_ftree l ∧
          is_leveln_ftree n r ∧ is_measured_ftree r ∧ 
          is_leveln_node n nd ∧ is_measured_node nd"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistToTree_inv</span><span> </span><span>deepR_inv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ziel3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>case1</span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>l1_x_r1</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"nsplitTree p (i + gmd pr) m = (l1, x, r1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"nsplitTree p (i + gmd pr) m"</span></span></span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>pr_m_sf_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr ∧ is_measured_digit pr"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf ∧ is_measured_digit sf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span>case1</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"3.hyps"</span></span></span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmd pr"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmd pr + gmft m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span class="delimiter">]</span><span> 
</span><span>          </span><span>3</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>l1_x_r1</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) l1 ∧ is_measured_ftree l1"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) r1 ∧ is_measured_ftree r1"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node (Suc n) x ∧ is_measured_node x"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l2</span><span> </span><span>x2</span><span> </span><span>r2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l2_x2_r2</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"splitDigit p (i + gmd pr + gmft l1) (nodeToDigit x) = (l2,x2,r2)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p (i + gmd pr + gmft l1) (nodeToDigit x)"</span></span></span><span class="delimiter">,</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1_x_r1_inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>ndx_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n (nodeToDigit x) ∧
          is_measured_digit (nodeToDigit x)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToDigit_inv</span><span> </span><span>gmn_gmd</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>spdi</span><span> </span><span class="delimiter">=</span><span> </span><span>splitDigit_inv'</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmd pr + gmft l1"</span></span></span><span> 
</span><span>                                      </span><span class="string"><span class="delete"><span class="delete">"nodeToDigit x"</span></span></span><span> </span><span>l2</span><span> </span><span>x2</span><span> </span><span>r2</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ndx_inv</span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>l2_x2_r2</span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>l2_x2_r2_inv</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀x∈set l2. is_measured_node x ∧ is_leveln_node n x"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀x∈set r2. is_measured_node x ∧ is_leveln_node n x"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_measured_node x2 ∧ is_leveln_node n x2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spdi</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>spdl</span><span> </span><span class="delimiter">=</span><span>  </span><span>splitDigit_list</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmd pr + gmft l1"</span></span></span><span> 
</span><span>                                        </span><span class="string"><span class="delete"><span class="delete">"nodeToDigit x"</span></span></span><span> </span><span>l2</span><span> </span><span>x2</span><span> </span><span>r2</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l2_x2_r2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>l2_x2_r2_list</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"digitToList (nodeToDigit x) = 
            nlistToList l2 @ nodeToList x2 @ nlistToList r2"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"length l2 ≤ 4 ∧ length r2 ≤ 4"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spdl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>case1</span><span> </span><span>True</span><span> </span><span>3</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>l1_x_r1</span><span> </span><span>l2_x2_r2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>l_nd_r</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"l = deepR pr l1 l2"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"nd = x2"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"r = deepL r2 r1 sf"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dr1</span><span> </span><span class="delimiter">=</span><span> </span><span>deepR_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dr1</span><span> </span><span>l2_x2_r2_inv</span><span> </span><span>l2_x2_r2_list</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>l_nd_r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>l_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n l ∧ is_measured_ftree l"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dl1</span><span> </span><span class="delimiter">=</span><span> </span><span>deepL_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dl1</span><span> </span><span>l2_x2_r2_inv</span><span> </span><span>l2_x2_r2_list</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>l_nd_r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>r_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n r ∧ is_measured_ftree r"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l2_x2_r2_inv</span><span> </span><span>l_nd_r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>nd_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node n nd ∧ is_measured_node nd"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l_inv</span><span> </span><span>r_inv</span><span> </span><span>nd_inv</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nsplitTree_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦
  is_leveln_ftree n (s:: ('e,'a::monoid_add) FingerTreeStruc);
  is_measured_ftree s;  
  ⋀(a::'a) (b::'a). p a ⟹ p (a + b);
  ¬ p i; 
  p (i + (gmft s));
  (nsplitTree p i s) = (l, nd, r)⟧ 
  ⟹ (toList s) = (toList l) @ (nodeToList nd) @ (toList r) 
  ∧
  ¬ p (i + (gmft l))
  ∧
  p (i + (gmft l) + (gmn nd))
  ∧
  is_leveln_ftree n l
  ∧
  is_measured_ftree l
  ∧
  is_leveln_ftree n r
  ∧
  is_measured_ftree r
  ∧
  is_leveln_node n nd
  ∧
  is_measured_node nd
  "</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span>s</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>n</span><span> </span><span>l</span><span> </span><span>nd</span><span> </span><span>r</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>nsplitTree.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span>uu</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>m</span><span> </span><span>sf</span><span> </span><span>n</span><span> </span><span>l</span><span> </span><span>nd</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd pr)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span>l1xr1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p i pr = (l1,x,r1)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p i pr"</span></span></span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span>3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = nlistToTree l1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = deepL r1 m sf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1xr1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToList pr = nlistToList l1 @ nodeToList x @ nlistToList r1"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"length l1 ≤ 4"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length r1 ≤ 4"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splitDigit_list</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>pr_m_sf_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr ∧ is_measured_digit pr"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf ∧ is_measured_digit sf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>True</span><span> </span><span>l1xr1</span><span>  
</span><span>        </span><span>splitDigit_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span class="string"><span class="delete"><span class="delete">"pr"</span></span></span><span> </span><span>n</span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>l1_x_r1_inv</span><span class="delimiter">:</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + (gmnl l1))"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"p (i + (gmnl l1) + (gmn x))"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set l1. (is_measured_node x ∧ is_leveln_node n x)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set r1. (is_measured_node x ∧ is_leveln_node n x)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"is_measured_node x ∧ is_leveln_node n x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v2</span><span> </span><span>v1</span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>             
</span><span>        </span><span>ziel1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (Deep uu pr m sf) = toList l @ nodeToList nd @ toList r"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistToTree_list</span><span> </span><span>deepL_list</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>v1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>v3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gmft l = gmnl l1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gmnl_gmft</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>v1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>ziel2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ¬ p (i + gmft l)"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"p (i + gmft l + gmn nd)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>v1</span><span> </span><span>v2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>ziel3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n l ∧ is_measured_ftree l ∧
        is_leveln_ftree n r ∧ is_measured_ftree r ∧ 
        is_leveln_node n nd ∧ is_measured_node nd"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistToTree_inv</span><span> </span><span>deepL_inv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ziel1</span><span> </span><span>ziel2</span><span> </span><span>ziel3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>case1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd pr + gmft m)"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>case1</span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>l1xr1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p (i + gmd pr + gmft m) sf = (l1,x,r1)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p (i + gmd pr + gmft m) sf"</span></span></span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>case1</span><span> </span><span>False</span><span> </span><span>3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>v1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = deepR pr m l1"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = nlistToTree r1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1xr1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"digitToList sf = nlistToList l1 @ nodeToList x @ nlistToList r1"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"length l1 ≤ 4"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length r1 ≤ 4"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splitDigit_list</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>pr_m_sf_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr ∧ is_measured_digit pr"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf ∧ is_measured_digit sf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>v7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd pr + gmft m + gmd sf)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pr_m_sf_inv</span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>case1</span><span> </span><span>False</span><span> </span><span>l1xr1</span><span>  
</span><span>             </span><span>splitDigit_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmd pr + gmft m"</span></span></span><span> </span><span>sf</span><span> </span><span>n</span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + gmd pr + gmft m + gmnl l1)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd pr + gmft m + gmnl l1 + gmn x)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set l1. (is_measured_node x ∧ is_leveln_node n x)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀ x ∈ set r1. (is_measured_node x ∧ is_leveln_node n x)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_measured_node x ∧ is_leveln_node n x"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v2</span><span> </span><span>v1</span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>             
</span><span>          </span><span>ziel1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (Deep uu pr m sf) = toList l @ nodeToList nd @ toList r"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistToTree_list</span><span> </span><span>deepR_list</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>v1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>v3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"gmft r = gmnl r1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gmnl_gmft</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span> </span><span>v1</span><span> </span><span>v2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>ziel2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" ¬ p (i + gmft l)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"p (i + gmft l + gmn nd)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gmftR_gmnl</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span>v1</span><span> </span><span>v2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>ziel3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n l ∧ is_measured_ftree l ∧
          is_leveln_ftree n r ∧ is_measured_ftree r ∧ 
          is_leveln_node n nd ∧ is_measured_node nd"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nlistToTree_inv</span><span> </span><span>deepR_inv</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ziel1</span><span> </span><span>ziel2</span><span> </span><span>ziel3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>case1</span><span> </span><span>3</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>l1_x_r1</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"nsplitTree p (i + gmd pr) m = (l1, x, r1)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"nsplitTree p (i + gmd pr) m"</span></span></span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>pr_m_sf_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n pr ∧ is_measured_digit pr"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) m ∧ is_measured_ftree m"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n sf ∧ is_measured_digit sf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>True</span><span> </span><span>case1</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"3.hyps"</span></span></span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmd pr"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmd pr + gmft m"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc n"</span></span></span><span> </span><span>l1</span><span> </span><span>x</span><span> </span><span>r1</span><span class="delimiter">]</span><span> 
</span><span>          </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>l1_x_r1</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + gmd pr + gmft l1)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd pr + gmft l1 + gmn x)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) l1 ∧ is_measured_ftree l1"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree (Suc n) r1 ∧ is_measured_ftree r1"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node (Suc n) x ∧ is_measured_node x"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l1_x_r1_list</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"toList m = toList l1 @ nodeToList x @ toList r1"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l2</span><span> </span><span>x2</span><span> </span><span>r2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l2_x2_r2</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"splitDigit p (i + gmd pr + gmft l1) (nodeToDigit x) = (l2,x2,r2)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitDigit p (i + gmd pr + gmft l1) (nodeToDigit x)"</span></span></span><span class="delimiter">,</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>ndx_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_digit n (nodeToDigit x) ∧
          is_measured_digit (nodeToDigit x)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd pr + gmft l1 + gmd (nodeToDigit x))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToDigit_inv</span><span> </span><span>gmn_gmd</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>spdi</span><span> </span><span class="delimiter">=</span><span> </span><span>splitDigit_inv</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmd pr + gmft l1"</span></span></span><span> 
</span><span>                                      </span><span class="string"><span class="delete"><span class="delete">"nodeToDigit x"</span></span></span><span> </span><span>n</span><span> </span><span>l2</span><span> </span><span>x2</span><span> </span><span>r2</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ndx_inv</span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>l2_x2_r2</span><span> </span><span>3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>l2_x2_r2_inv</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ p (i + gmd pr + gmft l1 + gmnl l2)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"p (i + gmd pr + gmft l1 + gmnl l2 + gmn x2)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀x∈set l2. is_measured_node x ∧ is_leveln_node n x"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∀x∈set r2. is_measured_node x ∧ is_leveln_node n x"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"is_measured_node x2 ∧ is_leveln_node n x2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spdi</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>spdl</span><span> </span><span class="delimiter">=</span><span>  </span><span>splitDigit_list</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + gmd pr + gmft l1"</span></span></span><span> 
</span><span>                                        </span><span class="string"><span class="delete"><span class="delete">"nodeToDigit x"</span></span></span><span> </span><span>l2</span><span> </span><span>x2</span><span> </span><span>r2</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l2_x2_r2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>l2_x2_r2_list</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"digitToList (nodeToDigit x) = 
            nlistToList l2 @ nodeToList x2 @ nlistToList r2"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"length l2 ≤ 4 ∧ length r2 ≤ 4"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>spdl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>case1</span><span> </span><span>True</span><span> </span><span>3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>l1_x_r1</span><span> </span><span>l2_x2_r2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>l_nd_r</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"l = deepR pr l1 l2"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"nd = x2"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"r = deepL r2 r1 sf"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dr1</span><span> </span><span class="delimiter">=</span><span> </span><span>deepR_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dr1</span><span> </span><span>l2_x2_r2_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>l2_x2_r2_list</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>l_nd_r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>l_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n l ∧ is_measured_ftree l"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>dl1</span><span> </span><span class="delimiter">=</span><span> </span><span>deepL_inv</span><span class="delimiter">[</span><span>OF</span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dl1</span><span> </span><span>l2_x2_r2_inv</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>l2_x2_r2_list</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>l_nd_r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span>r_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree n r ∧ is_measured_ftree r"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l2_x2_r2_inv</span><span> </span><span>l_nd_r</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span>nd_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node n nd ∧ is_measured_node nd"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l_nd_r</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>l2_x2_r2_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>             </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>l2_x2_r2_list</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split_point</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">" ¬ p (i + gmft l)"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"p (i + gmft l + gmn nd)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gmftR_gmnl</span><span> </span><span>add.assoc</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l2_x2_r2_list</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_list</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"nodeToList x = nlistToList l2 @ nodeToList x2 @ nlistToList r2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToDigit_list</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>             </span><span>l2_x2_r2_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>l2_x2_r2_list</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>l_nd_r</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList l = digitToList pr @ toList l1 @ nlistToList l2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deepR_list</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>l1_x_r1_inv</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>pr_m_sf_inv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>l2_x2_r2_inv</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>             </span><span>l2_x2_r2_list</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>l_nd_r</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>r_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList r = nlistToList r2 @ toList r1 @ digitToList sf"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deepL_list</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x_list</span><span> </span><span>l1_x_r1_list</span><span> </span><span>l_list</span><span> </span><span>r_list</span><span> </span><span>l_nd_r</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"toList (Deep uu pr m sf) = toList l @ nodeToList nd @ toList r"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>split_point</span><span> </span><span>l_inv</span><span> </span><span>r_inv</span><span> </span><span>nd_inv</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  A predicate on the elements of a monoid is called {\em monotone},
  iff, when it holds for some value $a$, it also holds for all values $a+b$:
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Split a finger tree by a monotone predicate on the annotations, using
    a given initial value. Intuitively, the elements are summed up from left to 
    right, and the split is done when the predicate first holds for the sum.
    The predicate must not hold for the initial value of the summation, and must
    hold for the sum of all elements.
›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>splitTree</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a::monoid_add ⇒ bool) ⇒ 'a ⇒ ('e, 'a) FingerTreeStruc 
    ⇒ ('e, 'a) FingerTreeStruc × ('e × 'a) × ('e, 'a) FingerTreeStruc"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"splitTree p i t = (let (l, x, r) = nsplitTree p i t in (l, (n_unwrap x), r))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitTree_invpres</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar (s:: ('e,'a::monoid_add) FingerTreeStruc)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>init_ff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ p i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sum_tt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + annot s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>fmt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(splitTree p i s) = (l, (e,a), r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l1</span><span> </span><span>nd</span><span> </span><span>r1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>l1_nd_r1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nsplitTree p i s = (l1, nd, r1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"nsplitTree p i s"</span></span></span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>l0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = l1"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(e,a) = n_unwrap nd"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"r = r1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splitTree_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>nsp</span><span> </span><span class="delimiter">=</span><span> </span><span>nsplitTree_invpres</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span>s</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span>l1</span><span> </span><span>nd</span><span> </span><span>r1</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + gmft s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>ft_invar_def</span><span> </span><span>annot_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>l1_nd_r1</span><span> </span><span>l0</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>v1</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree 0 l ∧ is_measured_ftree l"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree 0 r ∧ is_measured_ftree r"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node 0 nd  ∧ is_measured_node nd"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsp</span><span> </span><span>ft_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ft_invar_def</span><span> </span><span>annot_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitTree_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar (s:: ('e,'a::monoid_add) FingerTreeStruc)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a b. p a ⟶ p (a + b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>init_ff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ p i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sum_tt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + annot s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>fmt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(splitTree p i s) = (l, (e,a), r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(toList s) = (toList l) @ (e,a) # (toList r)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + annot l)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"p (i + annot l + a)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"ft_invar l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l1</span><span> </span><span>nd</span><span> </span><span>r1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>l1_nd_r1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nsplitTree p i s = (l1, nd, r1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"nsplitTree p i s"</span></span></span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>l0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = l1"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(e,a) = n_unwrap nd"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"r = r1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splitTree_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>nsp</span><span> </span><span class="delimiter">=</span><span> </span><span>nsplitTree_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>0</span><span> </span><span>s</span><span> </span><span>p</span><span> </span><span>i</span><span> </span><span>l1</span><span> </span><span>nd</span><span> </span><span>r1</span><span class="delimiter">]</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + gmft s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>ft_invar_def</span><span> </span><span>annot_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>l1_nd_r1</span><span> </span><span>l0</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>v1</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(toList s) = (toList l) @ (nodeToList nd) @ (toList r)"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + (gmft l))"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"p (i + (gmft l) + (gmn nd))"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree 0 l ∧ is_measured_ftree l"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_ftree 0 r ∧ is_measured_ftree r"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"is_leveln_node 0 nd  ∧ is_measured_node nd"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nsp</span><span> </span><span>ft_invar_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>v1</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>l0</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>ndea</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nd = Tip e a"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>nd</span><span class="delimiter">)</span><span>  </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>nd_list_inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"nodeToList nd = [(e,a)]"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"gmn nd = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"(toList s) = (toList l) @ (e,a) # (toList r)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + annot l)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"p (i + annot l + a)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"ft_invar l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar r"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>ft_invar_def</span><span> </span><span>annot_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitTree_correctE</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar (s:: ('e,'a::monoid_add) FingerTreeStruc)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a b. p a ⟶ p (a + b)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>init_ff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ p i"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sum_tt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + annot s)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>l</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(splitTree p i s) = (l, (e,a), r)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(toList s) = (toList l) @ (e,a) # (toList r)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + annot l)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"p (i + annot l + a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"ft_invar l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ft_invar r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>fmt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(splitTree p i s) = (l, (e,a), r)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(splitTree p i s)"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>splitTree_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span>p</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span> </span><span>fmt</span><span class="delimiter">]</span><span> </span><span>fmt</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Folding›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>foldl_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s ⇒ 'e × 'a ⇒ 's) ⇒ 's ⇒ ('e,'a) Node ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl_node f σ (Tip e a) = f σ (e,a)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl_node f σ (Node2 _ a b) = foldl_node f (foldl_node f σ a) b"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl_node f σ (Node3 _ a b c) = 
    foldl_node f (foldl_node f (foldl_node f σ a) b) c"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>foldl_digit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s ⇒ 'e × 'a ⇒ 's) ⇒ 's ⇒ ('e,'a) Digit ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl_digit f σ (One n1) = foldl_node f σ n1"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl_digit f σ (Two n1 n2) = foldl_node f (foldl_node f σ n1) n2"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl_digit f σ (Three n1 n2 n3) = 
    foldl_node f (foldl_node f (foldl_node f σ n1) n2) n3"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl_digit f σ (Four n1 n2 n3 n4) = 
    foldl_node f (foldl_node f (foldl_node f (foldl_node f σ n1) n2) n3) n4"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>foldr_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e × 'a ⇒ 's ⇒ 's) ⇒ ('e,'a) Node ⇒ 's  ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr_node f (Tip e a) σ = f (e,a) σ "</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr_node f (Node2 _ a b) σ = foldr_node f a (foldr_node f b σ)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr_node f (Node3 _ a b c) σ 
    = foldr_node f a (foldr_node f b (foldr_node f c σ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>foldr_digit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e × 'a ⇒ 's ⇒ 's) ⇒ ('e,'a) Digit ⇒ 's ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr_digit f (One n1) σ = foldr_node f n1 σ"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr_digit f (Two n1 n2) σ = foldr_node f n1 (foldr_node f n2 σ)"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr_digit f (Three n1 n2 n3) σ =
    foldr_node f n1 (foldr_node f n2 (foldr_node f n3 σ))"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr_digit f (Four n1 n2 n3 n4) σ =
    foldr_node f n1 (foldr_node f n2 (foldr_node f n3 (foldr_node f n4 σ)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldl_node_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl_node f σ nd = List.foldl f σ (nodeToList nd)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nd</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToList_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldl_digit_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl_digit f σ d = List.foldl f σ (digitToList d)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>d</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToList_def</span><span> </span><span>foldl_node_correct</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldr_node_correct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr_node f nd σ = List.foldr f (nodeToList nd) σ"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>nd</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToList_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldr_digit_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr_digit f d σ = List.foldr f (digitToList d) σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>d</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToList_def</span><span> </span><span>foldr_node_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fold from left"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>foldl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('s ⇒ 'e × 'a ⇒ 's) ⇒ 's ⇒ ('e,'a) FingerTreeStruc ⇒ 's"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl f σ Empty = σ"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl f σ (Single nd) = foldl_node f σ nd"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl f σ (Deep _ d1 m d2) = 
    foldl_digit f (foldl f (foldl_digit f σ d1) m) d2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldl_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldl f σ t = List.foldl f σ (toList t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toList_def</span><span> </span><span>foldl_node_correct</span><span> </span><span>foldl_digit_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fold from right"</span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>foldr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e × 'a ⇒ 's ⇒ 's) ⇒ ('e,'a) FingerTreeStruc ⇒ 's ⇒ 's"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr f Empty σ = σ"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr f (Single nd) σ = foldr_node f nd σ"</span></span></span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr f (Deep _ d1 m d2) σ 
    = foldr_digit f d1 (foldr f m(foldr_digit f d2 σ))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldr_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"foldr f t σ = List.foldr f (toList t) σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"σ"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toList_def</span><span> </span><span>foldr_node_correct</span><span> </span><span>foldr_digit_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Number of elements"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>count_node</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e, 'a) Node ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count_node (Tip _ a) = 1"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count_node (Node2 _ a b) = count_node a + count_node b"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count_node (Node3 _ a b c) = count_node a + count_node b + count_node c"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>count_digit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) Digit ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count_digit (One a) = count_node a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count_digit (Two a b) = count_node a + count_node b"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count_digit (Three a b c) = count_node a + count_node b + count_node c"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count_digit (Four a b c d) 
    = count_node a + count_node b + count_node c + count_node d"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>count_node_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count_node n = length (nodeToList n)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nodeToList_def</span><span> </span><span>count_node_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>count_digit_correct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count_digit d = length (digitToList d)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>digitToList_def</span><span> </span><span>count_digit_def</span><span> </span><span>count_node_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>count</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,'a) FingerTreeStruc ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count Empty = 0"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count (Single a) = count_node a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count (Deep _ pr m sf) = count_digit pr + count m + count_digit sf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>count_correct</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"count t = length (toList t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">,</span><span> 
</span><span>    </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toList_def</span><span> </span><span>count_def</span><span> 
</span><span>                   </span><span>count_digit_correct</span><span> </span><span>count_node_correct</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Expose finger tree functions as qualified names.
  Generate code equations *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>FingerTreeStruc</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc_loc</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Hide the concrete syntax *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>FingerTreeStruc.lcons</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊲"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">no_notation</span></span><span> </span><span>FingerTreeStruc.rcons</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊳"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Hiding the invariant"</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:hide_invar}›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  In this section, we define the datatype of all FingerTrees that fulfill their
  invariant, and define the operations to work on this datatype.
  The advantage is, that the correctness lemmas do no longer contain 
  explicit invariant predicates, what makes them more handy to use.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Datatype"</span></span></span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span> </span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>FingerTree</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{t :: ('e, 'a::monoid_add) FingerTreeStruc. FingerTreeStruc.ft_invar t}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Empty ∈ ?FingerTree"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Rep_FingerTree_invar</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FingerTreeStruc.ft_invar (Rep_FingerTree t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Rep_FingerTree</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FingerTreeStruc.ft_invar t ⟹ Rep_FingerTree (Abs_FingerTree t) = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Abs_FingerTree_inverse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>code</span><span> </span><span>abstype</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Abs_FingerTree (Rep_FingerTree t) = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Rep_FingerTree_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>viewres</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{ r:: (('e × 'a) × ('e,'a::monoid_add) FingerTreeStruc) option . 
    case r of None ⇒ True | Some (a,t) ⇒ FingerTreeStruc.ft_invar t}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>None</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>code</span><span> </span><span>abstype</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Abs_viewres (Rep_viewres x) = x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Rep_viewres_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Abs_viewres_inverse_None</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Rep_viewres (Abs_viewres None) = None"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_viewres_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Abs_viewres_inverse_Some</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FingerTreeStruc.ft_invar t ⟹ 
    Rep_viewres (Abs_viewres (Some (a,t))) = Some (a,t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_viewres_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_viewres_isNone r == Rep_viewres r = None"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_viewres_a r == 
    case (Rep_viewres r) of Some (a,t) ⇒ a"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_viewres_t r == 
  case (Rep_viewres r) of None ⇒ Abs_FingerTree Empty 
                        | Some (a,t) ⇒ Abs_FingerTree t"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree (extract_viewres_t r) = 
    (case (Rep_viewres r) of None ⇒ Empty | Some (a,t) ⇒ t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>option.split_asm</span><span> 
</span><span>             </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extract_viewres_t_def</span><span> </span><span>Abs_viewres_inverse_Some</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_viewres r == 
    if extract_viewres_isNone r then None 
    else Some (extract_viewres_a r, extract_viewres_t r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedef</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">overloaded</span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span class="tfree">'e</span><span class="delimiter">,</span><span class="tfree">'a</span><span class="delimiter">)</span><span> </span><span>splitres</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{ ((l,a,r):: (('e,'a) FingerTreeStruc × ('e × 'a) × ('e,'a::monoid_add) FingerTreeStruc))
    | l a r.
        FingerTreeStruc.ft_invar l ∧ FingerTreeStruc.ft_invar r}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(Empty,undefined,Empty)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span> </span><span>code</span><span> </span><span>abstype</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Abs_splitres (Rep_splitres x) = x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Rep_splitres_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Abs_splitres_inverse</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FingerTreeStruc.ft_invar r ⟹ FingerTreeStruc.ft_invar s ⟹ 
      Rep_splitres (Abs_splitres ((r,a,s))) = (r,a,s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_splitres_inverse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_splitres_a r == case (Rep_splitres r) of (l,a,s) ⇒ a"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_splitres_l r == case (Rep_splitres r) of (l,a,r) ⇒ 
    Abs_FingerTree l"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree (extract_splitres_l r) = (case 
    (Rep_splitres r) of (l,a,r) ⇒ l)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>option.split_asm</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extract_splitres_l_def</span><span> </span><span>Abs_splitres_inverse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_splitres_r r == case (Rep_splitres r) of (l,a,r) ⇒ 
    Abs_FingerTree r"</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree (extract_splitres_r r) = (case 
  (Rep_splitres r) of (l,a,r) ⇒ r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span> </span><span>option.split_asm</span><span> 
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>extract_splitres_r_def</span><span> </span><span>Abs_splitres_inverse</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_splitres r == 
  (extract_splitres_l r,
  extract_splitres_a r,
  extract_splitres_r r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Definition of Operations"</span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>FingerTree_loc</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList t == FingerTreeStruc.toList (Rep_FingerTree t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>empty</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"empty == Abs_FingerTree FingerTreeStruc.Empty"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree empty = FingerTreeStruc.Empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_rep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t=empty ⟷ Rep_FingerTree t = Empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Rep_FingerTree_inverse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"annot t == FingerTreeStruc.annot (Rep_FingerTree t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toTree t == Abs_FingerTree (FingerTreeStruc.toTree t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree (toTree t) = FingerTreeStruc.toTree t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>toTree_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lcons a t == 
    Abs_FingerTree (FingerTreeStruc.lcons a (Rep_FingerTree t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree (lcons a t) = (FingerTreeStruc.lcons a (Rep_FingerTree t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lcons_def</span><span> </span><span>FingerTreeStruc.lcons_correct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rcons t a == 
    Abs_FingerTree (FingerTreeStruc.rcons (Rep_FingerTree t) a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree (rcons t a) = (FingerTreeStruc.rcons (Rep_FingerTree t) a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rcons_def</span><span> </span><span>FingerTreeStruc.rcons_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewL_aux t == 
    Abs_viewres (FingerTreeStruc.viewL (Rep_FingerTree t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewL t == extract_viewres (viewL_aux t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_viewres (viewL_aux t) = (FingerTreeStruc.viewL (Rep_FingerTree t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(FingerTreeStruc.viewL (Rep_FingerTree t))"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewL_aux_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree t = Empty"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.viewL_correct_nonEmpty</span><span>
</span><span>                 </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree t"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_viewres_inverse_Some</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewR_aux t == 
    Abs_viewres (FingerTreeStruc.viewR (Rep_FingerTree t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewR t == extract_viewres (viewR_aux t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_viewres (viewR_aux t) = (FingerTreeStruc.viewR (Rep_FingerTree t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(FingerTreeStruc.viewR (Rep_FingerTree t))"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>viewR_aux_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree t = Empty"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> 
</span><span>      </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.viewR_correct_nonEmpty</span><span>
</span><span>                </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree t"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>      </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_viewres_inverse_Some</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isEmpty t == FingerTreeStruc.isEmpty (Rep_FingerTree t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"head t = FingerTreeStruc.head (Rep_FingerTree t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tail t ≡ 
    if t=empty then 
      empty 
    else 
      Abs_FingerTree (FingerTreeStruc.tail (Rep_FingerTree t))"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹Make function total, to allow abstraction›</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree (tail t) = 
    (if (FingerTreeStruc.isEmpty (Rep_FingerTree t)) then Empty 
     else FingerTreeStruc.tail (Rep_FingerTree t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tail_def</span><span> </span><span>FingerTreeStruc.tail_correct</span><span> </span><span>FingerTreeStruc.isEmpty_def</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"headR t = FingerTreeStruc.headR (Rep_FingerTree t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tailR t ≡ 
    if t=empty then 
      empty 
    else 
      Abs_FingerTree (FingerTreeStruc.tailR (Rep_FingerTree t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree (tailR t) = 
    (if (FingerTreeStruc.isEmpty (Rep_FingerTree t)) then Empty 
    else FingerTreeStruc.tailR (Rep_FingerTree t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tailR_def</span><span> </span><span>FingerTreeStruc.tailR_correct</span><span> </span><span>FingerTreeStruc.isEmpty_def</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>empty_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"app s t = Abs_FingerTree (
    FingerTreeStruc.app (Rep_FingerTree s) (Rep_FingerTree t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree (app s t) = 
      FingerTreeStruc.app (Rep_FingerTree s) (Rep_FingerTree t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>app_def</span><span> </span><span>FingerTreeStruc.app_correct</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"splitTree_aux p i t == if (¬p i ∧ p (i+annot t)) then
    Abs_splitres (FingerTreeStruc.splitTree p i (Rep_FingerTree t))
  else
    Abs_splitres (Empty,undefined,Empty)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"splitTree p i t == extract_splitres (splitTree_aux p i t)"</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code</span><span> </span><span>abstract</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Rep_splitres (splitTree_aux p i t) = (if (¬p i ∧ p (i+annot t)) then
      (FingerTreeStruc.splitTree p i (Rep_FingerTree t))
    else
      (Empty,undefined,Empty))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FingerTreeStruc.splitTree_invpres</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree t"</span></span></span><span> </span><span>p</span><span> </span><span>i</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splitTree_aux_def</span><span> </span><span>annot_def</span><span> </span><span>Abs_splitres_inverse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"FingerTreeStruc.splitTree p i (Rep_FingerTree t)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_FingerTree_inverse</span><span> </span><span>Abs_splitres_inverse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>foldl</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"foldl f σ t == FingerTreeStruc.foldl f σ (Rep_FingerTree t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>foldr</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"foldr f t σ == FingerTreeStruc.foldr f (Rep_FingerTree t) σ"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>count</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"count t == FingerTreeStruc.count (Rep_FingerTree t)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Correctness statements"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>empty_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList t = [] ⟷ t=empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.toList_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>toList_of_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList empty = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>empty_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.toList_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annot_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"annot t = sum_list (map snd (toList t))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>annot_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.annot_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>toTree_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (toTree l) = l"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>toTree_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.toTree_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcons_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (lcons a t) = a#toList t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>lcons_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.lcons_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rcons_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (rcons t a) = toList t@[a]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>rcons_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.rcons_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewL_correct</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t = empty ⟹ viewL t = None"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t ≠ empty ⟹ ∃a s. viewL t = Some (a,s) ∧ toList t = a#toList s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>viewL_def</span><span> </span><span>viewL_aux_def</span><span> 
</span><span>      </span><span>extract_viewres_def</span><span> </span><span>extract_viewres_isNone_def</span><span> 
</span><span>      </span><span>extract_viewres_a_def</span><span>
</span><span>      </span><span>extract_viewres_t_def</span><span>
</span><span>      </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.viewL_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>FingerTreeStruc.viewL_correct</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Rep_FingerTree_invar</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_viewres_inverse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewL_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewL empty = None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>viewL_correct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewL_nonEmpty</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t≠empty"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewL t = Some (a,s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList t = a#toList s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>viewL_correct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewR_correct</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t = empty ⟹ viewR t = None"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"t ≠ empty ⟹ ∃a s. viewR t = Some (a,s) ∧ toList t = toList s@[a]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>viewR_def</span><span> </span><span>viewR_aux_def</span><span> 
</span><span>      </span><span>extract_viewres_def</span><span> </span><span>extract_viewres_isNone_def</span><span> 
</span><span>      </span><span>extract_viewres_a_def</span><span>
</span><span>      </span><span>extract_viewres_t_def</span><span>
</span><span>      </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.viewR_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>FingerTreeStruc.viewR_correct</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Rep_FingerTree_invar</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Abs_viewres_inverse</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewR_empty</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"viewR empty = None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>viewR_correct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>viewR_nonEmpty</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t≠empty"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"viewR t = Some (a,s)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"toList t = toList s@[a]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>viewR_correct</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isEmpty_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"isEmpty t ⟷ t=empty"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>isEmpty_def</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.isEmpty_correct</span><span> </span><span>FingerTreeStruc.toList_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>head_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t≠empty ⟹ head t = hd (toList t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>head_def</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.head_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tail_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t≠empty ⟹ toList (tail t) = tl (toList t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>tail_def</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.tail_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>headR_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t≠empty ⟹ headR t = last (toList t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>headR_def</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.headR_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tailR_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t≠empty ⟹ toList (tailR t) = butlast (toList t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>tailR_def</span><span> </span><span>empty_rep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.tailR_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>app_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"toList (app s t) = toList s @ toList t"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>app_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.app_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitTree_correct</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a b. p a ⟶ p (a + b)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>init_ff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ p i"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sum_tt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + annot s)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>fmt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(splitTree p i s) = (l, (e,a), r)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(toList s) = (toList l) @ (e,a) # (toList r)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + annot l)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"p (i + annot l + a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span>
</span><span>      </span><span>FingerTreeStruc.splitTree_correctE</span><span class="delimiter">[</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p</span><span class="delimiter">=</span><span>p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree s"</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>OF</span><span> </span><span>_</span><span> </span><span>mono</span><span> </span><span>init_ff</span><span> </span><span>sum_tt</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>annot_def</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>      </span><span>simplified</span><span>
</span><span>      </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fmt</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>splitTree_aux_def</span><span> </span><span>splitTree_def</span><span> </span><span>annot_def</span><span> 
</span><span>      </span><span>extract_splitres_def</span><span> </span><span>extract_splitres_l_def</span><span> 
</span><span>      </span><span>extract_splitres_a_def</span><span> </span><span>extract_splitres_r_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>prod.split_asm</span><span> 
</span><span>      </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>init_ff</span><span> </span><span>sum_tt</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>annot_def</span><span class="delimiter">]</span><span> </span><span>Abs_splitres_inverse</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span>
</span><span>      </span><span>FingerTreeStruc.splitTree_correctE</span><span class="delimiter">[</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p</span><span class="delimiter">=</span><span>p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree s"</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>OF</span><span> </span><span>_</span><span> </span><span>mono</span><span> </span><span>init_ff</span><span> </span><span>sum_tt</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>annot_def</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>      </span><span>simplified</span><span>
</span><span>      </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fmt</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>splitTree_aux_def</span><span> </span><span>splitTree_def</span><span> </span><span>annot_def</span><span> 
</span><span>      </span><span>extract_splitres_def</span><span> </span><span>extract_splitres_l_def</span><span> 
</span><span>      </span><span>extract_splitres_a_def</span><span> </span><span>extract_splitres_r_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>prod.split_asm</span><span> 
</span><span>      </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>init_ff</span><span> </span><span>sum_tt</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>annot_def</span><span class="delimiter">]</span><span> </span><span>Abs_splitres_inverse</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span>
</span><span>      </span><span>FingerTreeStruc.splitTree_correctE</span><span class="delimiter">[</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p</span><span class="delimiter">=</span><span>p</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Rep_FingerTree s"</span></span></span><span class="delimiter">,</span><span>
</span><span>      </span><span>OF</span><span> </span><span>_</span><span> </span><span>mono</span><span> </span><span>init_ff</span><span> </span><span>sum_tt</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>annot_def</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>      </span><span>simplified</span><span>
</span><span>      </span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fmt</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>splitTree_aux_def</span><span> </span><span>splitTree_def</span><span> </span><span>annot_def</span><span> 
</span><span>      </span><span>extract_splitres_def</span><span> </span><span>extract_splitres_l_def</span><span> 
</span><span>      </span><span>extract_splitres_a_def</span><span> </span><span>extract_splitres_r_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>prod.split_asm</span><span> 
</span><span>      </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>init_ff</span><span> </span><span>sum_tt</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>annot_def</span><span class="delimiter">]</span><span> </span><span>Abs_splitres_inverse</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splitTree_correctE</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a b. p a ⟶ p (a + b)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>init_ff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ p i"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>sum_tt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"p (i + annot s)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>l</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(splitTree p i s) = (l, (e,a), r)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(toList s) = (toList l) @ (e,a) # (toList r)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"¬ p (i + annot l)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"p (i + annot l + a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span>e</span><span> </span><span>a</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>fmt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(splitTree p i s) = (l, (e,a), r)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(splitTree p i s)"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>splitTree_correct</span><span class="delimiter">[</span><span>of</span><span> </span><span>p</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span> </span><span>fmt</span><span class="delimiter">]</span><span> </span><span>fmt</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldl_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"foldl f σ t = List.foldl f σ (toList t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>foldl_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.foldl_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>foldr_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"foldr f t σ = List.foldr f (toList t) σ"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>foldr_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.foldr_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>count_correct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"count t = length (toList t)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>toList_def</span><span> </span><span>count_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FingerTreeStruc.count_correct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>FingerTree</span><span class="delimiter">:</span><span> </span><span>FingerTree_loc</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\clearpage›</span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Interface Documentation"</span></span></span><span>
</span><span class="keyword1"><span class="command">text_raw</span></span><span class="cartouche"><span class="delete"><span class="delete">‹\label{sec:doc}›</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    In this section, we list all supported operations on finger trees,
    along with a short plaintext documentation and their correctness statements.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*#DOC
  fun [no_spec] FingerTree.toList
    Convert to list ($O(n)$)

  fun FingerTree.empty
    The empty finger tree ($O(1)$)

  fun FingerTree.annot
    Return sum of all annotations ($O(1)$)

  fun FingerTree.toTree
    Convert list to finger tree ($O(n\log(n))$)

  fun FingerTree.lcons
    Append element at the left end ($O(\log(n))$, $O(1)$ amortized)

  fun FingerTree.rcons
    Append element at the right end ($O(\log(n))$, $O(1)$ amortized)

  fun FingerTree.viewL
    Detach leftmost element ($O(\log(n))$, $O(1)$ amortized)

  fun FingerTree.viewR
    Detach rightmost element ($O(\log(n))$, $O(1)$ amortized)

  fun FingerTree.isEmpty
    Check whether tree is empty ($O(1)$)

  fun FingerTree.head
    Get leftmost element of non-empty tree ($O(\log(n))$)

  fun FingerTree.tail
    Get all but leftmost element of non-empty tree ($O(\log(n))$)

  fun FingerTree.headR
    Get rightmost element of non-empty tree ($O(\log(n))$)

  fun FingerTree.tailR
    Get all but rightmost element of non-empty tree ($O(\log(n))$)

  fun FingerTree.app
    Concatenate two finger trees ($O(\log(m+n))$)

  fun [long_type] FingerTree.splitTree
    Split tree by a monotone predicate. ($O(\log(n))$)

    A predicate $p$ over the annotations is called monotone, iff, for all 
    annotations
    $a,b$ with $p(a)$, we have already $p(a+b)$.

    Splitting is done by specifying a monotone predicate $p$ that does not hold
    for the initial value $i$ of the summation, but holds for $i$ plus the sum
    of all annotations. The tree is then split at the position where $p$ starts to
    hold for the sum of all elements up to that position.

  fun [long_type] FingerTree.foldl
    Fold with function from left

  fun [long_type] FingerTree.foldr
    Fold with function from right

  fun FingerTree.count
    Return the number of elements

*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    \underline{@{term_type "FingerTree.toList"}}\\                                               
        Convert to list ($O(n)$)\\                                                               


    \underline{@{term_type "FingerTree.empty"}}\\
        The empty finger tree ($O(1)$)\\         
    {\bf Spec} ‹FingerTree.empty_correct›:
    @{thm [display] "FingerTree.empty_correct"}   


    \underline{@{term_type "FingerTree.annot"}}\\
        Return sum of all annotations ($O(1)$)\\ 
    {\bf Spec} ‹FingerTree.annot_correct›:
    @{thm [display] "FingerTree.annot_correct"}   


    \underline{@{term_type "FingerTree.toTree"}}\\
        Convert list to finger tree ($O(n\log(n))$)\\
    {\bf Spec} ‹FingerTree.toTree_correct›:  
    @{thm [display] "FingerTree.toTree_correct"}     


    \underline{@{term_type "FingerTree.lcons"}}\\
        Append element at the left end ($O(\log(n))$, $O(1)$ amortized)\\                                                            
    {\bf Spec} ‹FingerTree.lcons_correct›:                                                                                   
    @{thm [display] "FingerTree.lcons_correct"}                                                                                      
                                                                                                                     
                                                                                                                     
    \underline{@{term_type "FingerTree.rcons"}}\\                                                                    
        Append element at the right end ($O(\log(n))$, $O(1)$ amortized)\\                                           
    {\bf Spec} ‹FingerTree.rcons_correct›:                                                                   
    @{thm [display] "FingerTree.rcons_correct"}                                                                      
                                                                                                                     
                                                                                                                     
    \underline{@{term_type "FingerTree.viewL"}}\\                                                                    
        Detach leftmost element ($O(\log(n))$, $O(1)$ amortized)\\                                                   
    {\bf Spec} ‹FingerTree.viewL_correct›:                                                                   
    @{thm [display] "FingerTree.viewL_correct"}                                                                      
                                                                                                                     

    \underline{@{term_type "FingerTree.viewR"}}\\
        Detach rightmost element ($O(\log(n))$, $O(1)$ amortized)\\
    {\bf Spec} ‹FingerTree.viewR_correct›:                 
    @{thm [display] "FingerTree.viewR_correct"}                    


    \underline{@{term_type "FingerTree.isEmpty"}}\\
        Check whether tree is empty ($O(1)$)\\     
    {\bf Spec} ‹FingerTree.isEmpty_correct›:
    @{thm [display] "FingerTree.isEmpty_correct"}   


    \underline{@{term_type "FingerTree.head"}}\\
        Get leftmost element of non-empty tree ($O(\log(n))$)\\
    {\bf Spec} ‹FingerTree.head_correct›:              
    @{thm [display] "FingerTree.head_correct"}                 


    \underline{@{term_type "FingerTree.tail"}}\\
        Get all but leftmost element of non-empty tree ($O(\log(n))$)\\
    {\bf Spec} ‹FingerTree.tail_correct›:                      
    @{thm [display] "FingerTree.tail_correct"}                         


    \underline{@{term_type "FingerTree.headR"}}\\
        Get rightmost element of non-empty tree ($O(\log(n))$)\\
    {\bf Spec} ‹FingerTree.headR_correct›:              
    @{thm [display] "FingerTree.headR_correct"}                 


    \underline{@{term_type "FingerTree.tailR"}}\\
        Get all but rightmost element of non-empty tree ($O(\log(n))$)\\
    {\bf Spec} ‹FingerTree.tailR_correct›:
    @{thm [display] "FingerTree.tailR_correct"}


    \underline{@{term_type "FingerTree.app"}}\\
        Concatenate two finger trees ($O(\log(m+n))$)\\
    {\bf Spec} ‹FingerTree.app_correct›:
    @{thm [display] "FingerTree.app_correct"}


    \underline{@{term "FingerTree.splitTree"}}
    @{term_type [display] "FingerTree.splitTree"}
        Split tree by a monotone predicate. ($O(\log(n))$)

    A predicate $p$ over the annotations is called monotone, iff, for all
    annotations
    $a,b$ with $p(a)$, we have already $p(a+b)$.

    Splitting is done by specifying a monotone predicate $p$ that does not hold
    for the initial value $i$ of the summation, but holds for $i$ plus the sum
    of all annotations. The tree is then split at the position where $p$ starts to
    hold for the sum of all elements up to that position.\\
    {\bf Spec} ‹FingerTree.splitTree_correct›:
    @{thm [display] "FingerTree.splitTree_correct"}


    \underline{@{term "FingerTree.foldl"}}
    @{term_type [display] "FingerTree.foldl"}
        Fold with function from left\\
    {\bf Spec} ‹FingerTree.foldl_correct›:
    @{thm [display] "FingerTree.foldl_correct"}


    \underline{@{term "FingerTree.foldr"}}
    @{term_type [display] "FingerTree.foldr"}
        Fold with function from right\\
    {\bf Spec} ‹FingerTree.foldr_correct›:
    @{thm [display] "FingerTree.foldr_correct"}


    \underline{@{term_type "FingerTree.count"}}\\
        Return the number of elements\\
    {\bf Spec} ‹FingerTree.count_correct›:
    @{thm [display] "FingerTree.count_correct"}
›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Test">
<div class="head"><h1>Theory Test</h1>
<span class="command">theory</span> <span class="name">Test</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Code_Target_Numeral.html"><span class="name">Code_Target_Numeral</span></a> <a href="FingerTree.html"><span class="name">FingerTree</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Test</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Code_Target_Numeral"</span></span></span><span> </span><span>FingerTree</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Test code generation, to early detect problems with code generator.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_toList</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_toList == FingerTree.toList"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_toTree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ ('e,nat) FingerTree"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_toTree == FingerTree.toTree"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ ('e,nat) FingerTree"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_empty u == FingerTree.empty"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_annot</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_annot == FingerTree.annot"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_lcons</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ ('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_lcons == FingerTree.lcons"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_rcons</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_rcons == FingerTree.rcons"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_viewL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_viewL == FingerTree.viewL"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_viewR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_viewR == FingerTree.viewR"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_isEmpty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_isEmpty == FingerTree.isEmpty"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_head</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_head == FingerTree.head"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_tail</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_tail == FingerTree.tail"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_headR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_headR == FingerTree.headR"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_tailR</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_tailR == FingerTree.tailR"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_app</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_app == FingerTree.app"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_splitTree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ nat ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_splitTree == FingerTree.splitTree"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_foldl</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ _ ⇒ ('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_foldl == FingerTree.foldl"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_foldr</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"_ ⇒ ('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_foldr == FingerTree.foldr"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> 
</span><span>  </span><span>fti_count</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('e,nat) FingerTree ⇒ _"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fti_count == FingerTree.count"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">export_code</span></span><span> 
</span><span>  </span><span>fti_toList</span><span>
</span><span>  </span><span>fti_toTree</span><span>
</span><span>  </span><span>fti_empty</span><span>
</span><span>  </span><span>fti_annot</span><span>
</span><span>  </span><span>fti_lcons</span><span>
</span><span>  </span><span>fti_rcons</span><span>
</span><span>  </span><span>fti_viewL</span><span>
</span><span>  </span><span>fti_viewR</span><span>
</span><span>  </span><span>fti_isEmpty</span><span>
</span><span>  </span><span>fti_head</span><span>
</span><span>  </span><span>fti_tail</span><span>
</span><span>  </span><span>fti_headR</span><span>
</span><span>  </span><span>fti_tailR</span><span>
</span><span>  </span><span>fti_app</span><span>
</span><span>  </span><span>fti_splitTree</span><span>
</span><span>  </span><span>fti_foldl</span><span>
</span><span>  </span><span>fti_foldr</span><span>
</span><span>  </span><span>fti_count</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Haskell</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>OCaml</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SML</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML_val</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  val t1 = @{code fti_toTree}
    [("a", @{code nat_of_integer} 1), ("b", @{code nat_of_integer} 2), ("c", @{code nat_of_integer} 3)];
  val t2 = @{code fti_toTree}
    [("d", @{code nat_of_integer} 1), ("e", @{code nat_of_integer} 2), ("f", @{code nat_of_integer} 3)];
  val t3 = @{code fti_app} t1 t2;
  val t3 = @{code fti_app} t3 (@{code fti_empty} ());

  val t4 = @{code fti_lcons} ("g", @{code nat_of_integer} 7) t3;
  val t4 = @{code fti_rcons} t3 ("g", @{code nat_of_integer} 7);
  @{code fti_toList} t4;
  @{code fti_annot} t4;
  @{code fti_viewL} t4;
  @{code fti_viewR} t4;
  @{code fti_head} t4;
  @{code fti_tail} t4;
  @{code fti_headR} t4;
  @{code fti_tailR} t4;
  @{code fti_count} t4;
  @{code fti_isEmpty} t4;
  @{code fti_isEmpty} (@{code fti_empty} ());

  val (tl,(e,tr)) = @{code fti_splitTree} (fn a =&gt; @{code integer_of_nat} a &gt;= 10) (@{code nat_of_integer} 0) t4;
  @{code fti_toList} tl; e; @{code fti_toList} tr;

  @{code fti_foldl} (fn s =&gt; fn (_, a) =&gt; s + @{code integer_of_nat} a) 0 t4;
  @{code fti_foldr} (fn (_, a) =&gt; fn s =&gt; s + @{code integer_of_nat} a) t4 0;
›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>
</div>
</div>