<div id="CYK">
<div class="head"><h1>Theory CYK</h1>
<span class="command">theory</span> <span class="name">CYK</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Title:      A formalisation of the Cocke-Younger-Kasami algorithm
   Author:     Maksym Bortin &lt;Maksym.Bortin@nicta.com.au&gt;
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CYK</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The theory is structured as follows. First section deals with modelling
      of grammars, derivations, and the language semantics. Then the basic 
      properties are proved. Further, CYK is abstractly specified and its 
      underlying recursive relationship proved. The final section contains a 
      prototypical implementation accompanied by a proof of its correctness.›</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Basic modelling"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Grammars in Chomsky normal form"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A grammar in Chomsky normal form is here simply modelled  
      by a list of production rules (the type CNG below), each having a non-terminal 
      symbol on the lhs and either two non-terminals or one terminal 
      symbol on the rhs."</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'n</span><span class="delimiter">,</span><span> </span><span class="tfree">'t</span><span class="delimiter">)</span><span> </span><span>RHS</span><span> </span><span class="delimiter">=</span><span> </span><span>Branch</span><span> </span><span class="tfree">'n</span><span> </span><span class="tfree">'n</span><span>
</span><span>                      </span><span class="delimiter">|</span><span> </span><span>Leaf</span><span> </span><span class="tfree">'t</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'n</span><span class="delimiter">,</span><span> </span><span class="tfree">'t</span><span class="delimiter">)</span><span> </span><span>CNG</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n × ('n, 't) RHS) list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abbreviating the list append symbol for better readability"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>list_append</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a list ⇒ 'a list"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋅"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs ⋅ ys ≡ xs @ ys"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Derivation by grammars"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A \emph{word form} (or sentential form) may be built of both non-terminal and terminal 
       symbols, as opposed to a \emph{word} that contains only terminals. By the usage of disjoint 
       union, non-terminals are injected into a word form by @{term "Inl"} whereas terminals -- 
       by @{term "Inr"}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'n</span><span class="delimiter">,</span><span> </span><span class="tfree">'t</span><span class="delimiter">)</span><span> </span><span>word_form</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n + 't) list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'t</span><span> </span><span>word</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'t list"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A single step derivation relation on word forms is induced by a grammar in the standard way,
      replacing a non-terminal within a word form in accordance to the production rules."</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>DSTEP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) CNG ⇒ (('n, 't) word_form × ('n, 't) word_form) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DSTEP G = {(l ⋅ [Inl N] ⋅ r, x) | l N r rhs x. (N, rhs) ∈ set G ∧ 
                                     (case rhs of
                                       Branch A B ⇒ x = l ⋅ [Inl A, Inl B] ⋅ r
                                     | Leaf t ⇒ x = l ⋅ [Inr t] ⋅ r)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>DSTEP'</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) word_form ⇒ ('n, 't) CNG ⇒ ('n, 't) word_form ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ -_→ _"</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span> </span><span>61</span><span class="delimiter">,</span><span> </span><span>60</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w -G→ w' ≡ (w, w') ∈ DSTEP G"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>DSTEP_reflc</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) word_form ⇒ ('n, 't) CNG ⇒ ('n, 't) word_form ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ -_→<span class="hidden">⇧</span><sup>=</sup> _"</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span> </span><span>61</span><span class="delimiter">,</span><span> </span><span>60</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w -G→<span class="hidden">⇧</span><sup>=</sup> w' ≡ (w, w') ∈ (DSTEP G)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>DSTEP_transc</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) word_form ⇒ ('n, 't) CNG ⇒ ('n, 't) word_form ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ -_→<span class="hidden">⇧</span><sup>+</sup> _"</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span> </span><span>61</span><span class="delimiter">,</span><span> </span><span>60</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w -G→<span class="hidden">⇧</span><sup>+</sup> w' ≡ (w, w') ∈ (DSTEP G)<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>DSTEP_rtransc</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) word_form ⇒ ('n, 't) CNG ⇒ ('n, 't) word_form ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ -_→<span class="hidden">⇧</span><sup>*</sup> _"</span></span></span><span> </span><span class="delimiter">[</span><span>60</span><span class="delimiter">,</span><span> </span><span>61</span><span class="delimiter">,</span><span> </span><span>60</span><span class="delimiter">]</span><span> </span><span>61</span><span class="delimiter">)</span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w -G→<span class="hidden">⇧</span><sup>*</sup> w' ≡ (w, w') ∈ (DSTEP G)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"The generated language semantics"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"The language generated by a grammar from a non-terminal symbol 
      comprises all words that can be derived from the non-terminal 
      in one or more steps.
      Notice that by the presented grammar modelling, languages containing 
      the empty word cannot be generated. Hence in rare situations when such 
      languages are required, the empty word case should be treated separately."</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Lang</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) CNG ⇒ 'n ⇒ 't word set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Lang G S = {w. [Inl S] -G→<span class="hidden">⇧</span><sup>+</sup> map Inr w }"</span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹So, for instance, a grammar generating the language $a^nb^n$  
       from the non-terminal @{term "''S''"} might look as follows.›</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"G_anbn = 
[(''S'', Branch ''A'' ''T''),
 (''S'', Branch ''A'' ''B''),
 (''T'', Branch ''S'' ''B''),
 (''A'', Leaf ''a''),
 (''B'', Leaf ''b'')]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Now the term @{term "Lang G_anbn ''S''"} denotes the set of words of
       the form $a^nb^n$ with $n &gt; 0$. This is intuitively clear, but not 
       straight forward to show, and a lengthy proof for that is out of scope.›</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Basic properties"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prod_into_DSTEP1</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(S, Branch A B) ∈ set G ⟹
 L ⋅ [Inl S] ⋅ R -G→ L ⋅ [Inl A, Inl B] ⋅ R"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"L"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>prod_into_DSTEP2</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(S, Leaf a) ∈ set G ⟹
 L ⋅ [Inl S] ⋅ R -G→ L ⋅ [Inr a] ⋅ R"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"L"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DSTEP_D</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"s -G→ t ⟹ 
 ∃L N R rhs. s = L ⋅ [Inl N] ⋅ R ∧ (N, rhs) ∈ set G ∧ 
 (∀A B. rhs = Branch A B ⟶ t = L ⋅ [Inl A, Inl B] ⋅ R) ∧
 (∀x. rhs = Leaf x ⟶ t = L ⋅ [Inr x] ⋅ R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split_asm</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DSTEP_append</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s -G→ t"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L  ⋅  s  ⋅  R -G→ L  ⋅  t  ⋅  R"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃l N r rhs. s = l ⋅ [Inl N] ⋅ r ∧ (N, rhs) ∈ set G ∧ 
                         (∀A B. rhs = Branch A B ⟶ t = l ⋅ [Inl A, Inl B] ⋅ r) ∧
                         (∀x. rhs = Leaf x ⟶ t = l ⋅ [Inr x] ⋅ r)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃l N r rhs. ?P l N r rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>DSTEP_D</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span>N</span><span> </span><span>r</span><span> </span><span>rhs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P l N r rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"L ⋅ l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>N</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"r ⋅ R"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>rhs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DSTEP_star_mono</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"s -G→<span class="hidden">⇧</span><sup>*</sup> t ⟹ length s ≤ length t"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtrancl_induct</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> </span><span>u</span><span> 
</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s -G→<span class="hidden">⇧</span><sup>*</sup> t"</span></span></span><span>
</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t -G→ u"</span></span></span><span>
</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length s ≤ length t"</span></span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length s ≤ length u"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃L N R rhs. t = L ⋅ [Inl N] ⋅ R ∧ (N, rhs) ∈ set G ∧ 
                          (∀A B. rhs = Branch A B ⟶ u = L ⋅ [Inl A, Inl B] ⋅ R) ∧
                          (∀x. rhs = Leaf x ⟶ u = L ⋅ [Inr x] ⋅ R)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃L N R rhs. ?P L N R rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>DSTEP_D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span>N</span><span> </span><span>R</span><span> </span><span>rhs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P L N R rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>rhs</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DSTEP_comp</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ⋅ r -G→ t"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃l' r'. l -G→<span class="hidden">⇧</span><sup>=</sup> l' ∧ r -G→<span class="hidden">⇧</span><sup>=</sup> r' ∧ t = l' ⋅ r'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃L N R rhs. l ⋅ r = L ⋅ [Inl N] ⋅ R ∧ (N, rhs) ∈ set G ∧ 
                         (∀A B. rhs = Branch A B ⟶ t = L ⋅ [Inl A, Inl B] ⋅ R) ∧
                        (∀x. rhs = Leaf x ⟶ t = L ⋅ [Inr x] ⋅ R)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃L N R rhs. ?T L N R rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>DSTEP_D</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span>N</span><span> </span><span>R</span><span> </span><span>rhs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?T L N R rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ⋅ r = L ⋅ Inl N # R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u. (l = L ⋅ u ∧ u ⋅ r = Inl N # R) ∨ (l ⋅ u = L ∧ r = u ⋅ Inl N # R)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>append_eq_append_conv2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l = L ⋅ xs ∧ xs ⋅ r = Inl N # R ∨ l ⋅ xs = L ∧ r = xs  ⋅  Inl N # R"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C1 ∨ ?C2"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>rhs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Leaf</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = L ⋅ [Inr x] ⋅ R ∧ (N, Leaf x) ∈ set G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?C1"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>L</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>z</span><span> </span><span>zs</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"L ⋅ Inr x # zs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?C2"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>L</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>z</span><span> </span><span>zs</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split</span><span class="delimiter">,</span><span> 
</span><span>         </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"z#zs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>N</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>R</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Leaf x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Branch</span><span> </span><span>A</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t = L ⋅ [Inl A, Inl B] ⋅ R ∧ (N, Branch A B) ∈ set G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?C1"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>L</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>z</span><span> </span><span>zs</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"L ⋅ [Inl A, Inl B] ⋅ zs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?C2"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>L</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>z</span><span> </span><span>zs</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split</span><span class="delimiter">,</span><span> 
</span><span>         </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"z#zs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>N</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>R</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Branch A B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>DSTEP_star_comp1</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ⋅ r -G→<span class="hidden">⇧</span><sup>*</sup> t"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃l' r'. l -G→<span class="hidden">⇧</span><sup>*</sup> l' ∧ r -G→<span class="hidden">⇧</span><sup>*</sup> r' ∧ t = l' ⋅ r'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. s -G→<span class="hidden">⇧</span><sup>*</sup> t ⟹ 
       ∀l r. s = l ⋅ r ⟶ (∃l' r'. l -G→<span class="hidden">⇧</span><sup>*</sup> l' ∧ r -G→<span class="hidden">⇧</span><sup>*</sup> r' ∧ t = l' ⋅ r')"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. ?P s t ⟹ ?Q s t"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtrancl_induct</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>u</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P s t"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t -G→ u"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q s t"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q s u"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span> </span><span>r</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = l ⋅ r"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃l' r'. l -G→<span class="hidden">⇧</span><sup>*</sup> l' ∧ r -G→<span class="hidden">⇧</span><sup>*</sup> r' ∧ t = l' ⋅ r'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l'</span><span> </span><span>r'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l -G→<span class="hidden">⇧</span><sup>*</sup> l' ∧ r -G→<span class="hidden">⇧</span><sup>*</sup> r' ∧ t = l' ⋅ r'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l' ⋅ r' -G→ u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃l'' r''. l' -G→<span class="hidden">⇧</span><sup>=</sup>  l'' ∧ r' -G→<span class="hidden">⇧</span><sup>=</sup> r'' ∧ u = l'' ⋅ r''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>DSTEP_comp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l''</span><span> </span><span>r''</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l' -G→<span class="hidden">⇧</span><sup>=</sup>  l'' ∧ r' -G→<span class="hidden">⇧</span><sup>=</sup> r'' ∧ u = l'' ⋅ r''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l' -G→<span class="hidden">⇧</span><sup>*</sup> l'' ∧ r' -G→<span class="hidden">⇧</span><sup>*</sup> r'' ∧ u = l'' ⋅ r''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃l' r'. l -G→<span class="hidden">⇧</span><sup>*</sup> l' ∧ r -G→<span class="hidden">⇧</span><sup>*</sup> r' ∧ u = l' ⋅ r'"</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>l''</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>r''</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>DSTEP_star_comp2</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l -G→<span class="hidden">⇧</span><sup>*</sup> l'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r -G→<span class="hidden">⇧</span><sup>*</sup> r'"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ⋅ r -G→<span class="hidden">⇧</span><sup>*</sup> l' ⋅ r'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l -G→<span class="hidden">⇧</span><sup>*</sup> l' ⟹ 
       ∀r r'. r -G→<span class="hidden">⇧</span><sup>*</sup> r' ⟶ l ⋅ r -G→<span class="hidden">⇧</span><sup>*</sup> l' ⋅ r'"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P l l' ⟹ ?Q l l'"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q l l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rtrancl_induct</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s -G→ t"</span></span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ⋅ r -G→<span class="hidden">⇧</span><sup>*</sup> l ⋅ s"</span></span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ⋅ r -G→<span class="hidden">⇧</span><sup>*</sup> l ⋅ t"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ⋅ s -G→ l ⋅ t"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>L</span><span class="delimiter">=</span><span>l</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>DSTEP_append</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s -G→ t"</span></span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q l s"</span></span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q l t"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>r</span><span> </span><span>r'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r -G→<span class="hidden">⇧</span><sup>*</sup> r'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ⋅ r -G→<span class="hidden">⇧</span><sup>*</sup> s ⋅ r'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ⋅ r' -G→ t ⋅ r'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>L</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R</span><span class="delimiter">=</span><span>r'</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>DSTEP_append</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ⋅ r -G→<span class="hidden">⇧</span><sup>*</sup> t ⋅ r'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DSTEP_trancl_term</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl S] -G→<span class="hidden">⇧</span><sup>+</sup> t"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Inr x ∈ set t"</span></span></span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃N. (N, Leaf x) ∈ set G"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl S] -G→<span class="hidden">⇧</span><sup>+</sup> t ⟹ 
       ∀x. Inr x ∈ set t ⟶ (∃N. (N, Leaf x) ∈ set G)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P t ⟹ ?Q t"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>trancl_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl S] -G→ t"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃rhs. (S, rhs) ∈ set G ∧ 
                      (∀A B. rhs = Branch A B ⟶ t = [Inl A, Inl B]) ∧
                      (∀x. rhs = Leaf x ⟶ t = [Inr x])"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃rhs. ?P rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split_asm</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span>
</span><span>      </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split_asm</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>rhs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>rhs</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s -G→ t"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q s"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃L N R rhs. s = L ⋅ [Inl N] ⋅ R ∧ (N, rhs) ∈ set G ∧ 
                         (∀A B. rhs = Branch A B ⟶ t = L ⋅ [Inl A, Inl B] ⋅ R) ∧
                         (∀x. rhs = Leaf x ⟶ t = L ⋅ [Inr x] ⋅ R)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃L N R rhs. ?P L N R rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>DSTEP_D</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>L</span><span> </span><span>N</span><span> </span><span>R</span><span> </span><span>rhs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P L N R rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>rhs</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Properties of generated languages"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Lang_no_Nil</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"w ∈ Lang G S ⟹ w ≠ []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Lang_def</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>trancl_into_rtrancl</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>DSTEP_star_mono</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Lang_rtrancl_eq</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(w ∈ Lang G S) = [Inl S] -G→<span class="hidden">⇧</span><sup>*</sup> map Inr w"</span></span></span><span>          </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = (?p ∈ ?R<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Lang_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>trancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?p ∈ ?R<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?p ∈ (?R<span class="hidden">⇧</span><sup>+</sup>)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>rtrancl_trancl_reflcl</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl S] = map Inr w ∨ ?p ∈ ?R<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?p ∈ ?R<span class="hidden">⇧</span><sup>+</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>w</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> 
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Lang_term</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"w ∈ Lang G S ⟹ 
 ∀x ∈ set w. ∃N. (N, Leaf x) ∈ set G"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Lang_def</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>DSTEP_trancl_term</span><span class="delimiter">,</span><span> 
</span><span>   </span><span>simp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>imageI</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Lang_eq1</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"([x] ∈ Lang G S) = ((S, Leaf x) ∈ set G)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Lang_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>trancl_unfold_left</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl S] -G→ t"</span></span></span><span>
</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t -G→<span class="hidden">⇧</span><sup>*</sup> [Inr x]"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>DSTEP_star_mono</span><span class="delimiter">[</span><span>OF</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length t ≤ 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. t = [z]"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[] -G→<span class="hidden">⇧</span><sup>*</sup> [Inr x]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. ([], s) ∈ (DSTEP G)<span class="hidden">⇧</span><sup>*</sup> ⟹ s = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtrancl_induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>DSTEP_D</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>OF</span><span> </span><span>d</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>z</span><span> </span><span>zs</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = z#zs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃z. (S, Leaf z) ∈ set G ∧ t = [Inr z]"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split_asm</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span> 
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(S, Leaf x) ∈ set G"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>z</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(S, Leaf z) ∈ set G"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inr z] -G→<span class="hidden">⇧</span><sup>*</sup> [Inr x]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([Inr z], [Inr x]) ∈ ((DSTEP G)<span class="hidden">⇧</span><sup>+</sup>)<span class="hidden">⇧</span><sup>=</sup>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inr z] = [Inr x] ∨ [Inr z] -G→<span class="hidden">⇧</span><sup>+</sup> [Inr x]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = z"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inr z] = [Inr x]"</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inr z] -G→<span class="hidden">⇧</span><sup>+</sup> [Inr x]"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃u. [Inr z] -G→ u ∧ u -G→<span class="hidden">⇧</span><sup>*</sup> [Inr x]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>trancl_unfold_left</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inr z] -G→ u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(S, Leaf x) ∈ set G"</span></span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl S] -G→<span class="hidden">⇧</span><sup>+</sup> [Inr x]"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>r_into_trancl</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span>
</span><span>    </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Leaf x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span>
</span><span>    </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Lang_eq2</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(w ∈ Lang G S ∧ 1 &lt; length w) = 
 (∃A B. (S, Branch A B) ∈ set G ∧ (∃l r. w = l ⋅ r ∧ l ∈ Lang G A ∧ r ∈ Lang G B))"</span></span></span><span>  
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>Lang_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>trancl_unfold_left</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>map_Inr_split</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀xs. ∀zs w. map Inr w = xs ⋅ zs ⟶ 
                       (∃u v. w = u ⋅ v ∧ xs = map Inr u ∧ zs = map Inr v)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 &lt; length w"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl S] -G→ t"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"t -G→<span class="hidden">⇧</span><sup>*</sup> map Inr w"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃A B. (S, Branch A B) ∈ set G ∧ t = [Inl A, Inl B]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>RHS.split_asm</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = [Inr x]"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inr x] -G→<span class="hidden">⇧</span><sup>*</sup> map Inr w"</span></span></span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x s. [Inr x] -G→<span class="hidden">⇧</span><sup>*</sup> s ⟹ s = [Inr x]"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtrancl_induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>DSTEP_D</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>L</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>OF</span><span> </span><span>d</span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w = [x]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>w</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(S, Branch A B) ∈ set G ∧ t = [Inl A, Inl B]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl A] ⋅ [Inl B] -G→<span class="hidden">⇧</span><sup>*</sup> map Inr w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>DSTEP_star_comp1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>e</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l'</span><span> </span><span>r'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl A] -G→<span class="hidden">⇧</span><sup>*</sup> l' ∧ [Inl B] -G→<span class="hidden">⇧</span><sup>*</sup> r' ∧ 
                              map Inr w = l'  ⋅  r'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>map_Inr_split</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>e</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>u</span><span> </span><span>v</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w = u ⋅ v ∧ l' = map Inr u ∧ r' = map Inr v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl A] -G→<span class="hidden">⇧</span><sup>*</sup> map Inr u ∧ [Inl B] -G→<span class="hidden">⇧</span><sup>*</sup> map Inr v"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>A</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>B</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>d</span><span class="delimiter">,</span><span>
</span><span>     </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>u</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>v</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>f</span><span class="delimiter">,</span><span>
</span><span>     </span><span class="delimiter">(</span><span>subst</span><span> </span><span>Lang_rtrancl_eq</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>g</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>l</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(S, Branch A B) ∈ set G ∧ w = l ⋅ r ∧ l ∈ Lang G A ∧ r ∈ Lang G B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl A] ⋅ [Inl B] -G→<span class="hidden">⇧</span><sup>*</sup> map Inr l ⋅ map Inr r"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>DSTEP_star_comp2</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>Lang_rtrancl_eq</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">,</span><span>
</span><span>     </span><span>subst</span><span> </span><span>Lang_rtrancl_eq</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[Inl A] ⋅ [Inl B] -G→<span class="hidden">⇧</span><sup>*</sup> map Inr w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w ∈ Lang G S"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Lang_def</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>trancl_unfold_left</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>b</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[Inl A] ⋅ [Inl B]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>relcompI</span><span class="delimiter">,</span><span>
</span><span>     </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DSTEP_def</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span>
</span><span>     </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Branch A B"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>a</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>    
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; length w"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>leI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length l + length r ≤ Suc 0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l = [] ∨ r = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l = []"</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[] ∈ Lang G A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Lang_no_Nil</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"r = []"</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[] ∈ Lang G B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Lang_no_Nil</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Abstract specification of CYK"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A subword of a word $w$, starting at the position $i$ 
      (first element is at the position $0$) and having the length $j$, is defined as follows."</span></span></span><span> 
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subword w i j = take j (drop i w)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Thus, to any subword of the given word $w$ CYK assigns all non-terminals
      from which this subword is derivable by the grammar $G$."</span></span></span><span> 
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CYK G w i j = {S. subword w i j ∈ Lang G S}"</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties of @{term "subword"}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subword_length</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"i + j ≤ length w ⟹ length(subword w i j) = j"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subword_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subword_nth1</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"i + j ≤ length w ⟹ k &lt; j ⟹ 
(subword w i j)!k = w!(i + k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subword_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subword_nth2</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 ≤ length w"</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subword w i 1 = [w!i]"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>subword_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃x. subword w i 1 = [x]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"subword w i 1"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"subword w i 1 = [x]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>subword_nth1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"(0 :: nat)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = w!i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subword_self</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"subword w 0 (length w) = w"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subword_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>take_split</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"∀n m. n ≤ length xs ⟶ n ≤ m ⟶
 take n xs ⋅ take (m - n) (drop n xs) = take m xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>m</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subword_split</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"i + j ≤ length w ⟹ 0 &lt; k ⟹ k &lt; j ⟹
 subword w i j = subword w i k ⋅ subword w (i + k) (j - k)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subword_def</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>take_split</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">=</span><span>k</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span>
</span><span>   </span><span>rule_tac</span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λx. take (j - k) (drop x w)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>arg_cong</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subword_split2</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subword w i j = l ⋅ r"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j ≤ length w"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; length l"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; length r"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l = subword w i (length l) ∧ r = subword w (i + length l) (j - length l)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length(subword w i j) = j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subword_length</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>length</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>A</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length l &lt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + length l ≤ length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subword w i j = subword w i (length l) ⋅ subword w (i + length l) (j - length l)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subword_split</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>B</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l ⋅ r = subword w i (length l) ⋅ subword w (i + length l) (j - length l)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>append_eq_append_conv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>subword_length</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> 
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Properties of @{term "CYK"}›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CYK_Lang</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(S ∈ CYK G w 0 (length w)) = (w ∈ Lang G S)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CYK_def</span><span> </span><span>subword_self</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CYK_eq1</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"i + 1 ≤ length w ⟹
 CYK G w i 1 = {S. (S, Leaf (w!i)) ∈ set G}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CYK_def</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>subword_nth2</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span>
</span><span>   </span><span>subst</span><span> </span><span>Lang_eq1</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>CYK_eq2</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j ≤ length w"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; j"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CYK G w i j = {X | X A B k. (X, Branch A B) ∈ set G ∧ A ∈ CYK G w i k ∧ B ∈ CYK G w (i + k) (j - k) ∧ 1 ≤ k ∧ k &lt; j}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_eqI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CYK_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span>
</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"subword w i j ∈ Lang G X"</span></span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃A B. (X, Branch A B) ∈ set G ∧ (∃k. subword w i k ∈ Lang G A ∧ subword w (i + k) (j - k) ∈ Lang G B ∧ Suc 0 ≤ k ∧ k &lt; j)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; length(subword w i j)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>subword_length</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>B</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Lang_eq2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>l</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(X, Branch A B) ∈ set G ∧ subword w i j = l ⋅ r ∧ l ∈ Lang G A ∧ r ∈ Lang G B"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Lang_no_Nil</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; length l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Lang_no_Nil</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; length r"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>r</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>subword_split2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>e</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>A</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>B</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> 
</span><span>        </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"length l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 ≤ length l ∧ length l &lt; j"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?A ∧ ?B"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>d</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>length</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>c</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conjunct2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length(subword w i j) = j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>subword_length</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length l + length r = j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?B</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span>
</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃A B. (X, Branch A B) ∈ set G ∧ (∃k. subword w i k ∈ Lang G A ∧ subword w (i + k) (j - k) ∈ Lang G B ∧ Suc 0 ≤ k ∧ k &lt; j)"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>k</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(X, Branch A B) ∈ set G ∧ subword w i k ∈ Lang G A ∧ subword w (i + k) (j - k) ∈ Lang G B ∧ Suc 0 ≤ k ∧ k &lt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"subword w i j ∈ Lang G X"</span></span></span><span> 
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Lang_eq2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>conjunct1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>A</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>B</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">,</span><span>
</span><span>       </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"subword w i k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"subword w (i + k) (j - k)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">,</span><span>
</span><span>       </span><span>rule</span><span> </span><span>subword_split</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Implementation"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"One of the particularly interesting features of CYK implementation 
is that it follows the principles of dynamic programming, constructing a 
table of solutions for sub-problems in the bottom-up style reusing already 
stored results."</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Main cycle"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"This is an auxiliary implementation of the membership test on lists."</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>mem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a list ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">"mem a [] = False"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"mem a (x#xs) = (x = a ∨ mem a xs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"mem x xs = (x ∈ set xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>xs</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"The purpose of the following is to collect non-terminals that appear on the lhs of a production
      such that the first non-terminal on its rhs appears in the first of two given lists and the second
      non-terminal -- in the second list."</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>match_prods</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) CNG ⇒ 'n list ⇒ 'n list ⇒ 'n list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"match_prods [] ls rs = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"match_prods ((X, Branch A B)#ps) ls rs = 
          (if mem A ls ∧ mem B rs then X # match_prods ps ls rs
           else match_prods ps ls rs)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"match_prods ((X, Leaf a)#ps) ls rs = match_prods ps ls rs"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>match_prods</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(X ∈ set(match_prods G ls rs)) = 
 (∃A ∈ set ls. ∃B ∈ set rs. (X, Branch A B) ∈ set G)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>G</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>rename_tac</span><span> </span><span>l</span><span> </span><span>r</span><span> </span><span>ps</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>r</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span>     
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"The following function is the inner cycle of the algorithm. The parameters $i$ and $j$
      identify a subword starting at $i$ with the length $j$, whereas $k$ is used to iterate through
      its splits (which are of course subwords as well) all having the length greater $0$ but less than $j$. 
      The parameter $T$ represents a table containing CYK solutions for those splits."</span></span></span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>inner</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) CNG ⇒ (nat × nat ⇒ 'n list) ⇒ nat ⇒ nat ⇒ nat ⇒ 'n list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner G T i k j = 
(if k &lt; j then match_prods G (T(i, k)) (T(i + k, j - k)) @ inner G T i (k + 1) j
 else [])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure(λ(a, b, c, d, e). e - d)"</span></span></span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>wf_measure</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>inner.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inner</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(X ∈ set(inner G T i k j)) =
 (∃l. k ≤ l ∧ l &lt; j ∧ X ∈ set(match_prods G (T(i, l)) (T(i + l, j - l))))"</span></span></span><span> 
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L G T i k j = ?R G T i k j"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>G</span><span> </span><span>T</span><span> </span><span>i</span><span> </span><span>k</span><span> </span><span>j</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>inner.induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>G</span><span> </span><span>T</span><span> </span><span>i</span><span> </span><span>k</span><span> </span><span>j</span><span>
</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; j ⟹ ?L G T i (k + 1) j = ?R G T i (k + 1) j"</span></span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L G T i k j = ?R G T i k j"</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; j"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; j"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?L G T i (k + 1) j = ?R G T i (k + 1) j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>inner.simps</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>k</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ set(inner G T i (Suc k) j)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R G T i (k + 1) j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R G T i k j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>l</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R G T i k j"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ≤ l ∧ l &lt; j ∧ X ∈ set(match_prods G (T(i, l)) (T(i + l, j - l)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ set(match_prods G (T(i, k)) (T(i + k, j - k))) ∨ ?L G T i (Suc k) j"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc k ≤ l"</span></span></span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>c</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>l</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>d</span><span class="delimiter">,</span><span> 
</span><span>         </span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ Suc k ≤ l"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l = k"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ set(match_prods G (T(i, k)) (T(i + k, j - k)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ k &lt; j"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>inner.simps</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>   
</span><span>   
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Now the main part of the algorithm just iterates through all subwords up to the given length $len$,
       calls @{term "inner"} on these, and stores the results in the table $T$. The length $j$ is supposed to 
       be greater than $1$ -- the subwords of length $1$ will be handled in the initialisation phase below.›</span></span></span><span> 
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>main</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) CNG ⇒ (nat × nat ⇒ 'n list) ⇒ nat ⇒ nat ⇒ nat ⇒ (nat × nat ⇒ 'n list)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"main G T len i j = (let T' = T((i, j) := inner G T i 1 j) in
                            if i + j &lt; len then main G T' len (i + 1) j
                            else if j &lt; len then main G T' len 0 (j + 1)
                                 else T')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_image (less_than &lt;*lex*&gt; less_than) (λ(a, b, c, d, e). (c - e, c - (d + e)))"</span></span></span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>wf_inv_image</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>wf_lex_prod</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf_less_than</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>main.simps</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>main</span><span> </span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; j"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j ≤ length w"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i' j'. j' &lt; j ⟹ 1 ≤ j' ⟹ i' + j' ≤ length w ⟹ set(T(i', j')) = CYK G w i' j'"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i'. i' &lt; i ⟹ i' + j ≤ length w ⟹ set(T(i', j)) = CYK G w i' j"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 ≤ j'"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i' + j' ≤ length w"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set((main G T (length w) i j)(i', j')) = CYK G w i' j'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀len T' w. main G T len i j = T' ⟶ length w = len ⟶ 1 &lt; j ⟶ i + j ≤ len ⟶
      (∀j' &lt; j. ∀i'. 1 ≤ j' ⟶ i' + j' ≤ len ⟶ set(T(i', j')) = CYK G w i' j') ⟶
      (∀i' &lt; i. i' + j ≤ len ⟶ set(T(i', j)) = CYK G w i' j) ⟶
      (∀j' ≥ 1. ∀i'. i' + j' ≤ len ⟶ set(T'(i', j')) = CYK G w i' j')"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀len. ?P G T len i j"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span>G</span><span> </span><span>T</span><span> </span><span>len</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>main.induct</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>meta_spec</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>meta_mp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>G</span><span> </span><span>T</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>i'</span><span> </span><span>j'</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>w</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j &lt; length w ⟹ ?P G (T((i, j) := inner G T i 1 j)) (length w) (i + 1) j"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i + j &lt; length w ⟹ j &lt; length w ⟹ ?P G (T((i, j) := inner G T i 1 j)) (length w) 0 (j + 1)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; j"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j ≤ length w"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(1::nat) ≤ j'"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i' + j' ≤ length w"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀j' &lt; j. ∀i'. 1 ≤ j' ⟶ i' + j' ≤ length w ⟶ set(T(i', j')) = CYK G w i' j'"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>h</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i' &lt; i. i' + j ≤ length w ⟶ set(T(i', j)) = CYK G w i' j"</span></span></span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>inner</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set (inner G T i (Suc 0) j) = CYK G w i j"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_eqI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>inner</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>match_prods</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>CYK_eq2</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>X</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃l≥Suc 0. l &lt; j ∧ (∃A ∈ set(T(i, l)). ∃B ∈ set(T(i + l, j - l)). (X, Branch A B) ∈ set G)) =
          (∃A B. (X, Branch A B) ∈ set G ∧ (∃k. A ∈ CYK G w i k ∧ B ∈ CYK G w (i + k) (j - k) ∧ Suc 0 ≤ k ∧ k &lt; j))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L = ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>A</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>B</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>l</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>l</span><span> </span><span>A</span><span> </span><span>B</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 ≤ l"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"l &lt; j"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ set(T(i, l))"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ set(T(i + l, j - l))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i'</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j'</span><span class="delimiter">=</span><span>l</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set(T(i, l)) = CYK G w i l"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i'</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"i + l"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j'</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"j - l"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(T(i + l, j - l)) = CYK G w (i + l) (j - l)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>k</span><span> </span><span>l</span><span> </span><span>A</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ CYK G w i l ∧ B ∈ CYK G w (i + l) (j - l)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?R"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>k</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>A</span><span> </span><span>B</span><span> </span><span>k</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 ≤ k"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k &lt; j"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ CYK G w i k"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"B ∈ CYK G w (i + k) (j - k)"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(X, Branch A B) ∈ set G"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i'</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j'</span><span class="delimiter">=</span><span>k</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CYK G w i k = set(T(i, k))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>g</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i'</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"i + k"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j'</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"j - k"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CYK G w (i + k) (j - k) = set(T(i + k, j - k))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>k</span><span> </span><span>l</span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∈ set(T(i, k)) ∧ B ∈ set(T(i + k, j - k))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>m</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃A ∈ set(T(i, k)). ∃B ∈ set(T(i + k, j - k)). (X, Branch A B) ∈ set G"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* inner *)</span></span></span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set((main G T (length w) i j)(i', j')) = CYK G w i' j'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j = length w"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j = length w"</span></span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length w"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j &lt; length w"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>main.simps</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>i</span><span> </span><span>j</span><span class="delimiter">,</span><span> 
</span><span>          </span><span>rule</span><span> </span><span>b</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>w</span><span class="delimiter">=</span><span>w</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i'</span><span class="delimiter">=</span><span>i'</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j'</span><span class="delimiter">=</span><span>j'</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span> 
</span><span>          </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inner</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ i + j &lt; length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>j</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc j ≤ length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 ≤ j'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>f</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i' + j' ≤ length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>assumption</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i''</span><span> </span><span>j''</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>k</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j'' &lt; Suc j"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 ≤ j''"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i'' + j'' ≤ length w"</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(i'' = i ⟶ j'' ≠ j) ⟶ set(T(i'',j'')) = CYK G w i'' j''"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"j'' = j"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j'' = j"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i'' ≠ i"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i'' &lt; i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>n</span><span> </span><span>m</span><span> </span><span>h</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(T(i'', j)) = CYK G w i'' j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j'' ≠ j"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>k</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j'' &lt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>l</span><span> </span><span>m</span><span> </span><span>g</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(T(i'', j'')) = CYK G w i'' j''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ j &lt; length w"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = 0 ∧ j = length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>main.simps</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>j</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inner</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set (inner G T 0 (Suc 0) (length w)) = CYK G w 0 (length w)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; i' ⟶ set(T(i', j')) = CYK G w i' j'"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; i'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j' &lt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(T(i', j')) = CYK G w i' j'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j' ≠ length w ⟶ set(T(i', j')) = CYK G w i' j'"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j' ≠ length w "</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>j</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j' &lt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(T(i', j')) = CYK G w i' j'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j ≠ length w"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i + j &lt; length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>main.simps</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>i</span><span class="delimiter">,</span><span>
</span><span>         </span><span>rule</span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>w</span><span class="delimiter">=</span><span>w</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i'</span><span class="delimiter">=</span><span>i'</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j'</span><span class="delimiter">=</span><span>j'</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>refl</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 &lt; j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc(i + j) ≤ length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 ≤ j'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>f</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i' + j' ≤ length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>assumption</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i''</span><span> </span><span>j''</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j'' &lt; j"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 ≤ j''"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i'' + j'' ≤ length w"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>g</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(T(i'', j'')) = CYK G w i'' j''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i''</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>j</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i'' &lt; Suc i"</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(if i'' = i then inner G T i (Suc 0) j else T(i'', j)) = CYK G w i'' j"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>inner</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i'' ≠ i"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i'' &lt; i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>d</span><span> </span><span>h</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(T(i'', j)) = CYK G w i'' j"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span> 
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Initialisation phase"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Similarly to @{term "match_prods"} above, here we collect non-terminals from which
       the given terminal symbol can be derived.›</span></span></span><span> 
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>init_match</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) CNG ⇒ 't ⇒ 'n list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init_match [] t = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"init_match ((X, Branch A B)#ps) t = init_match ps t"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"init_match ((X, Leaf a)#ps) t = (if a = t then X # init_match ps t
                                        else init_match ps t)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init_match</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(X ∈ set(init_match G a)) = 
 ((X, Leaf a) ∈ set G)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>G</span><span> </span><span>a</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>init_match.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Representing the empty table."</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"emptyT = (λ(i, j). [])"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"The following function initialises the empty table for subwords of
      length $1$, i.e. each symbol occurring in the given word."</span></span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>init'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) CNG ⇒ 't list ⇒ nat ⇒ nat × nat ⇒ 'n list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init' G [] k = emptyT"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"init' G (t#ts) k = (init' G ts (k + 1))((k, 1) := init_match G t)"</span></span></span><span> 
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init'</span><span> </span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i + 1 ≤ length w"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(init' G w 0 (i, 1)) = CYK G w i 1"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. Suc i ≤ length w ⟶
      (∀k. set(init' G w k (k + i, Suc 0)) = CYK G w i (Suc 0))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. ?P i w ⟶ (∀k. ?Q i k w)"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>w</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>set_eqI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>init_match</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>w</span><span> </span><span>S</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((S, Leaf x) ∈ set G) = (S ∈ CYK G (x#w) 0 (Suc 0))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>CYK_eq1</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>w</span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. ?P i w ⟶ (∀k. ?Q i k w)"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i ≤ length w"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; i ⟶ (∀k. set(init' G w (Suc k) (k + i, Suc 0)) = CYK G (x#w) i (Suc 0))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>case_tac</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>CYK_eq1</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>subst</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>k</span><span> </span><span>j</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i = Suc j"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>a</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i</span><span class="delimiter">=</span><span>j</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Suc k"</span></span></span><span class="delimiter">]</span><span>
</span><span>   </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(init' G w (Suc k) (Suc k + j, Suc 0)) = CYK G w j (Suc 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"... = {S. (S, Leaf (w ! j)) ∈ set G}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>CYK_eq1</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(init' G w (Suc k) (Suc (k + j), Suc 0)) = {S. (S, Leaf (w ! j)) ∈ set G}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀k. ?Q i k w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>0</span><span class="delimiter">]</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The next version of initialization refines @{term "init'"} in that
      it takes additional account of the cases when the given word is 
      empty or contains a terminal symbol that does not have any matching 
      production (that is, @{term "init_match"} is an empty list). No initial 
      table is then needed as such words can immediately be rejected.›</span></span></span><span>  
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('n, 't) CNG ⇒ 't list ⇒ nat ⇒ (nat × nat ⇒ 'n list) option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"init G [] k = None"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"init G [t] k = (case (init_match G t) of
                        [] ⇒ None
                      | xs ⇒ Some(emptyT((k, 1) := xs)))"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"init G (t#ts) k = (case (init_match G t) of
                           [] ⇒ None
                         | xs ⇒ (case (init G ts (k + 1)) of
                                  None ⇒ None
                                | Some T ⇒ Some(T((k, 1) := xs))))"</span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init1</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"∀T. init G w k = Some T ⟶ 
     init' G w k = T"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>G</span><span> </span><span>w</span><span> </span><span>k</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>init.induct</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split_asm</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">+</span><span class="delimiter">,</span><span>
</span><span>   </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split_asm</span><span> </span><span>option.split_asm</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>ext</span><span class="delimiter">,</span><span> </span><span>clarsimp</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>init2</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"(init G w k = None) =
 (w = [] ∨ (∃a ∈ set w. init_match G a = []))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>G</span><span> </span><span>w</span><span> </span><span>k</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>init.induct</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split</span><span class="delimiter">,</span><span> 
</span><span>   </span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split</span><span> </span><span>option.split</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The overall procedure›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cyk G S w = (case init G w 0 of
                          None ⇒ False
                        | Some T ⇒ let len = length w in
                                     if len = 1 then mem S (T(0, 1))
                                     else let T' = main G T len 0 2 in
                                            mem S (T'(0, len)))"</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>cyk</span><span> </span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"cyk G S w = (w ∈ Lang G S)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cyk_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.split</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span class="delimiter">,</span><span>
</span><span>      </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>init2</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"w = [] ⟶ [] ∉ Lang G S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>Lang_no_Nil</span><span class="delimiter">,</span><span> </span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃x∈set w. init_match G x = []) ⟶ w ∉ Lang G S"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>Lang_term</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>init_match</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀T. init G w 0 = Some T ⟶ 
       ((length w = Suc 0 ⟶ S ∈ set(T(0, Suc 0))) ∧
        (length w ≠ Suc 0 ⟶ S ∈ set(main G T (length w) 0 2 (0, length w)))) =
       (w ∈ Lang G S)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀T. ?P T ⟶ ?L T = ?R"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>T</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?P T"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"init' G w 0 = T"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>init1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>init2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>disjI1</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"w ≠ []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>init2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>G</span><span class="delimiter">=</span><span>G</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>0</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>disjI1</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L (init' G w 0) = ?R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"length w = 1"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length w = Suc 0"</span></span></span><span>   
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ∈ set(init' G w 0 (0, Suc 0)) = ?R"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>init'</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>d</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>CYK_Lang</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length w ≠ Suc 0"</span></span></span><span>   
</span><span>   </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1 &lt; length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>w</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>d</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc(Suc 0) ≤ length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(S ∈ set(main G (init' G w 0) (length w) 0 2 (0, length w))) = (w ∈ Lang G S)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>main</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i'</span><span> </span><span>j'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"j' &lt; 2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 ≤ j'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"j' = 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i' + j' ≤ length w"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i' + 1 ≤ length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(init' G w 0 (i', 1)) = CYK G w i' 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>init'</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set(init' G w 0 (i', j')) = CYK G w i' j'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>d</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc 0 ≤ length w"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(S ∈ CYK G w 0 (length w)) = (w ∈ Lang G S)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CYK_Lang</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?L T = ?R"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="delimiter">[</span><span>code</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"let G = [(0::int, Branch 1 2), (0, Branch 2 3),
            (1, Branch 2 1), (1, Leaf ''a''),
            (2, Branch 3 3), (2, Leaf ''b''),
            (3, Branch 1 2), (3, Leaf ''a'')]
  in map (cyk G 0)
     [[''b'',''a'',''a'',''b'',''a''],
      [''b'',''a'',''b'',''a'']]"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>