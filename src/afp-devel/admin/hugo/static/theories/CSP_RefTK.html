<div id="Introduction">
<div class="head"><h1>Theory Introduction</h1>
<span class="command">theory</span> <span class="name">Introduction</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOLCF/HOLCF.html"><span class="name">HOLCF</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment">‚Äï‚Äπ ********************************************************************
 * Project         : CSP-RefTK - A Refinement Toolkit for HOL-CSP
 * Version         : 1.0
 *
 * Author          : Burkhart Wolff, Safouan Taha, Lina Ye.
 *
 * This file       : An Introduction
 *
 * Copyright (c) 2020 Universit√© Paris-Saclay, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπContext‚Ä∫</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Introduction</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HOLCF</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIntroduction‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
Communicating Sequential Processes CSP is a language 
to specify and verify patterns of interaction of concurrent systems.
Together with CCS and LOTOS, it belongs to the family of ‚àó‚Äπprocess algebras‚Ä∫. 
CSP's rich theory comprises denotational, operational and algebraic semantic facets 
and has influenced programming languages such as Limbo, Crystal, Clojure and
most notably Golang @{cite "donovan2015go"}. CSP has been applied in 
industry as a tool for specifying and verifying the concurrent aspects of hardware 
systems, such as the T9000 transputer @{cite "Barret95"}. 

The theory of CSP, in particular the denotational Failure/Divergence Denotational Semantics,
has been initially proposed in the book by Tony Hoare @{cite "Hoare:1985:CSP:3921"}, but evolved
substantially since @{cite "BrookesHR84" and "brookes-roscoe85" and "roscoe:csp:1998"}.

Verification of CSP properties has been centered around the notion of ‚àó‚Äπprocess refinement orderings‚Ä∫,
most notably ‚Äπ_‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub>_‚Ä∫ and ‚Äπ_‚äë_‚Ä∫. The latter turns the denotational domain of CSP into a Scott cpo 
@{cite "scott:cpo:1972"}, which yields semantics for the fixed point operator ‚ÄπŒºx. f(x)‚Ä∫ provided 
that ‚Äπf‚Ä∫ is continuous with respect to ‚Äπ_‚äë_‚Ä∫. Since it is possible to express deadlock-freeness and 
livelock-freeness as a refinement problem, the verification of properties has been reduced 
traditionally to a model-checking problem for a finite set of events ‚ÄπA‚Ä∫.

We are interested in verification techniques for arbitrary event sets ‚ÄπA‚Ä∫ or arbitrarily 
parameterized processes. Such processes can be used to model dense-timed processes, processes 
with dynamic thread creation, and processes with unbounded thread-local variables and buffers.
Events may even be higher-order objects such as functions or again processes, paving the way
for the modeling of re-programmable compute servers or dynamic distributed computing architectures.
However, this adds substantial complexity to the process theory: when it comes to study the 
interplay of different denotational models, refinement-orderings, and side-conditions for 
continuity, paper-and-pencil proofs easily reach their limits of precision. 

Several attempts have been undertaken to develop the formal theory of CSP in an interactive proof system, 
mostly in Isabelle/HOL @{cite "Camilleri91" and "tej.ea:corrected:1997" and  "IsobeRoggenbach2010"}. 
This work is based on the most recent instance in this line, HOL-CSP 2.0, which has been published 
as AFP submission  @{cite "HOL-CSP-AFP"} and whose development is hosted at 
üåê‚Äπhttps://gitlri.lri.fr/burkhart.wolff/hol-csp2.0‚Ä∫. 

The present AFP Module is an add-on on this work and develops some support for 
‚ñ∏ advanced induction schemes (mutual fixed-point Induction, K-induction),
‚ñ∏ bridge-Lemmas between the classical refinement relations in the FD-semantics,
  which allow for reduced refinement proof complexity in certain cases, and
‚ñ∏ a theory of explicit state normalisation which allows for proofs over certain
  communicating networks of arbitrary size.

\newpage
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe Global Architecture of CSP\_RefTk‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ
\begin{figure}[ht]
  \centering
  \includegraphics[width=0.60\textwidth]{figures/session_graph.pdf}
	\caption{The overall architecture: HOLCF, HOL-CSP, and CSP\_RefTk}
	\label{fig:fig1}
\end{figure}
‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe global architecture of CSP\_RefTk is shown in \autoref{fig:fig1}.
The entire package resides on: 
‚ñ∏ \&lt;^session&gt;‚ÄπHOL-Eisbach‚Ä∫ from the Isabelle/HOL distribution,
‚ñ∏ \&lt;^session&gt;‚ÄπHOLCF‚Ä∫ from the Isabelle/HOL distribution, and
‚ñ∏ \&lt;^session&gt;‚ÄπHOL-CSP‚Ä∫ 2.0 from the Isabelle Archive of Formal Proofs.

‚á§ The theories ‚ñ©‚ÄπAssertion_ext‚Ä∫ and ‚ñ©‚ÄπFixind_ext‚Ä∫ are extensions of the 
corresponding theories in \&lt;^session&gt;‚ÄπHOL-CSP‚Ä∫.‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="Assertions_ext">
<div class="head"><h1>Theory Assertions_ext</h1>
<span class="command">theory</span> <span class="name">Assertions_ext</span><br/>
<span class="keyword">imports</span> <a href="Assertions.html"><span class="name">Assertions</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment">‚Äï‚Äπ ******************************************************************** 
 * Project         : CSP-RefTK - A Refinement Toolkit for HOL-CSP
 * Version         : 1.0
 *
 * Author          : Burkhart Wolff, Safouan Taha, Lina Ye.
 *
 * This file       : Assertions on DF and LF and their Relations
 *
 * Copyright (c) 2020 Universit√© Paris-Saclay, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπBasic CSP\_RefTk-Theories‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Assertions_ext</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-CSP.Assertions"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπPreliminaries‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A = ((‚äì z ‚àà A ‚Üí DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) ‚äì SKIP)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>trans</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAll refinements definitions‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>le_ref_def</span><span class="delimiter">]</span><span> </span><span>trace_refine_def</span><span> </span><span>failure_refine_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>divergence_refine</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a process ‚áí 'a process ‚áí bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚äë<span class="hidden">‚á©</span><sub>D</sub>"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q ‚â° D Q ‚äÜ D P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>trace_divergence_refine</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a process ‚áí 'a process ‚áí bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub>"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q ‚â° P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q ‚àß P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπRelations between refinements‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_F_T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_subset_imp_T_subset</span><span> </span><span>failure_refine_def</span><span> </span><span>trace_refine_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FD_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> Q ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>failure_divergence_refine_def</span><span> </span><span>failure_refine_def</span><span> </span><span>le_ref_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FD_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> Q ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>divergence_refine_def</span><span> </span><span>failure_divergence_refine_def</span><span> </span><span>le_ref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DT_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DT_T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>F_D_FD</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>divergence_refine_def</span><span> </span><span>failure_divergence_refine_def</span><span> </span><span>failure_refine_def</span><span> </span><span>le_ref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>D_T_DT</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSome obvious refinements‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>bot_FD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ä• ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>bot_F</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ä• ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bot_D</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ä• ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bot_T</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ä• ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bot_DT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ä• ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FD_F</span><span> </span><span>FD_D</span><span> </span><span>le_F_T</span><span> </span><span>D_T_DT</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>STOP_leDT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> STOP"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>D_STOP</span><span> </span><span>D_T_DT</span><span> </span><span>Nil_elem_T</span><span> </span><span>T_STOP</span><span> </span><span>divergence_refine_def</span><span> </span><span>trace_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">‚Äï‚ÄπFor refinement proofs, we need admissibility and monotony starting with idempotency and 
  transitivity‚Ä∫</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπIdempotency‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idem_F</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>failure_refine_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idem_D</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idem_T</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>T</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idem_FD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>idem_DT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTransitivity‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q ‚üπ Q ‚äë<span class="hidden">‚á©</span><sub>F</sub> S ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>F</sub> S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>failure_refine_def</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q ‚üπ Q ‚äë<span class="hidden">‚á©</span><sub>D</sub> S ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>D</sub> S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>divergence_refine_def</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ Q ‚äë<span class="hidden">‚á©</span><sub>T</sub> S ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>T</sub> S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>trace_refine_def</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> Q ‚üπ Q ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> S ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>failure_divergence_refine_def</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_DT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ Q ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> S ‚üπ P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>trace_divergence_refine_def</span><span> </span><span>order_trans</span><span> </span><span>trans_D</span><span> </span><span>trans_T</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAdmissibility‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_F_adm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cont (u::('a::cpo) ‚áí 'b process) ‚üπ monofun v ‚üπ adm(Œªx. u x ‚äë<span class="hidden">‚á©</span><sub>F</sub> v x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont2contlubE</span><span> </span><span>adm_def</span><span> </span><span>failure_refine_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Y</span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"cont u"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"monofun v"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"chain Y"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÄi. F (v (Y i)) ‚äÜ F (u (Y i))"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>5</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" (a, b) ‚àà F (v (‚®Üx. Y x))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v (Y i)  ‚äë v (‚®Üi. Y i)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_ub_thelub</span><span> </span><span>monofunE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"F (v (‚®Üi. Y i)) ‚äÜ F (u (Y i))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>4</span><span> </span><span>le_approx_lemma_F</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b) ‚àà F (‚®Üi. u (Y i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_LUB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ch2ch_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>limproc_is_thelub</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ch2ch_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_T_adm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cont (u::('a::cpo) ‚áí 'b process) ‚üπ monofun v ‚üπ adm(Œªx. u x ‚äë<span class="hidden">‚á©</span><sub>T</sub> v x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont2contlubE</span><span> </span><span>adm_def</span><span> </span><span>trace_refine_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Y</span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"cont u"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"monofun v"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"chain Y"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÄi. T (v (Y i)) ‚äÜ T (u (Y i))"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>5</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" x ‚àà T (v (‚®Üi. Y i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v (Y i)  ‚äë v (‚®Üi. Y i)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_ub_thelub</span><span> </span><span>monofunE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"T (v (‚®Üi. Y i)) ‚äÜ T (u (Y i))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>4</span><span> </span><span>le_approx_lemma_T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà T (‚®Üi. u (Y i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T_LUB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ch2ch_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>limproc_is_thelub</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ch2ch_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_D_adm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cont (u::('a::cpo) ‚áí 'b process) ‚üπ monofun v ‚üπ adm(Œªx. u x ‚äë<span class="hidden">‚á©</span><sub>D</sub> v x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont2contlubE</span><span> </span><span>adm_def</span><span> </span><span>divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Y</span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"cont u"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"monofun v"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"chain Y"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÄi. D (v (Y i)) ‚äÜ D (u (Y i))"</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>5</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">" x ‚àà D (v (‚®Üi. Y i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"v (Y i)  ‚äë v (‚®Üi. Y i)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_ub_thelub</span><span> </span><span>monofunE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (v (‚®Üi. Y i)) ‚äÜ D (u (Y i))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>4</span><span> </span><span>le_approx1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà D (‚®Üi. u (Y i))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_LUB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ch2ch_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>limproc_is_thelub</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ch2ch_cont</span><span class="delimiter">[</span><span>OF</span><span> </span><span>1</span><span> </span><span>3</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span>5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>le_DT_adm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cont (u::('a::cpo) ‚áí 'b process) ‚üπ monofun v ‚üπ adm(Œªx. u x ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> v x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adm_conj</span><span class="delimiter">[</span><span>OF</span><span> </span><span>le_T_adm</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>v</span><span class="delimiter">]</span><span> </span><span>le_D_adm</span><span class="delimiter">[</span><span>of</span><span> </span><span>u</span><span> </span><span>v</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>le_FD_adm</span><span> </span><span class="delimiter">=</span><span> </span><span>le_adm</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπMonotonicity‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_det_D</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ü¶P ‚äë<span class="hidden">‚á©</span><sub>D</sub> P'; S ‚äë<span class="hidden">‚á©</span><sub>D</sub> S'‚üß ‚üπ (P ‚ñ° S) ‚äë<span class="hidden">‚á©</span><sub>D</sub> (P' ‚ñ° S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D_det</span><span> </span><span>Un_mono</span><span> </span><span>divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_det_T</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ü¶P ‚äë<span class="hidden">‚á©</span><sub>T</sub> P'; S ‚äë<span class="hidden">‚á©</span><sub>T</sub> S'‚üß ‚üπ (P ‚ñ° S) ‚äë<span class="hidden">‚á©</span><sub>T</sub> (P' ‚ñ° S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>T_det</span><span> </span><span>Un_mono</span><span> </span><span>trace_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>mono_det_DT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ü¶P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> P'; S ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> S'‚üß ‚üπ (P ‚ñ° S) ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> (P' ‚ñ° S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mono_det_FD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">=</span><span> </span><span>mono_det_FD</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment">‚Äï‚ÄπDeterministic choice monotony doesn't hold for ‚Äπ‚äë<span class="hidden">‚á©</span><sub>F</sub>‚Ä∫‚Ä∫</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_ndet_F</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ü¶P ‚äë<span class="hidden">‚á©</span><sub>F</sub> P'; S ‚äë<span class="hidden">‚á©</span><sub>F</sub> S'‚üß ‚üπ (P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>F</sub> (P' ‚äì S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>F_ndet</span><span> </span><span>Un_mono</span><span> </span><span>failure_refine_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_ndet_D</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ü¶P ‚äë<span class="hidden">‚á©</span><sub>D</sub> P'; S ‚äë<span class="hidden">‚á©</span><sub>D</sub> S'‚üß ‚üπ (P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>D</sub> (P' ‚äì S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D_ndet</span><span> </span><span>Un_mono</span><span> </span><span>divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_ndet_T</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ü¶P ‚äë<span class="hidden">‚á©</span><sub>T</sub> P'; S ‚äë<span class="hidden">‚á©</span><sub>T</sub> S'‚üß ‚üπ (P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>T</sub> (P' ‚äì S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>T_ndet</span><span> </span><span>Un_mono</span><span> </span><span>trace_refine_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>mono_ndet_DT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ü¶P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> P'; S ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> S'‚üß ‚üπ (P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> (P' ‚äì S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mono_ndet_FD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">=</span><span> 
</span><span>                 </span><span>mono_ndet_FD</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_ndet_F_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q ‚üπ (P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_ndet</span><span> </span><span>failure_refine_def</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_ndet_D_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q ‚üπ (P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>D_ndet</span><span> </span><span>divergence_refine_def</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_ndet_T_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ (P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>T_ndet</span><span> </span><span>trace_refine_def</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>mono_ndet_DT_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ (P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_ndet_F_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q ‚üπ (S ‚äì P) ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_ndet_D_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q ‚üπ (S ‚äì P) ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_ndet_T_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ (S ‚äì P) ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q"</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_ndet_DT_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ (S ‚äì P) ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span> </span><span>Ndet_commute</span><span class="delimiter">)</span><span> 
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> 
</span><span>mono_ndet_FD_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>             </span><span>mono_ndet_FD_left</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>mono_ndet_FD_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>             </span><span>mono_ndet_FD_right</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_ndet_det_FD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> (P ‚ñ° S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>det_id</span><span> </span><span>failure_divergence_refine_def</span><span> </span><span>mono_det_FD</span><span> </span><span>mono_ndet_FD_left</span><span> 
</span><span>            </span><span>mono_ndet_FD_right</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>mono_ndet_det_F</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>F</sub> (P ‚ñ° S)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_ndet_det_D</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>D</sub> (P ‚ñ° S)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_ndet_det_T</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>T</sub> (P ‚ñ° S)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_ndet_det_DT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(P ‚äì S) ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> (P ‚ñ° S)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FD_F</span><span> </span><span>FD_D</span><span> </span><span>le_F_T</span><span> </span><span>D_T_DT</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_seq_F_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚äë<span class="hidden">‚á©</span><sub>F</sub> S' ‚üπ (P `;` S) ‚äë<span class="hidden">‚á©</span><sub>F</sub> (P `;` S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>failure_refine_def</span><span> </span><span>F_seq</span><span> </span><span>append_single_T_imp_tickFree</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NF_ND</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_seq_D_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚äë<span class="hidden">‚á©</span><sub>D</sub> S' ‚üπ (P `;` S) ‚äë<span class="hidden">‚á©</span><sub>D</sub> (P `;` S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>divergence_refine_def</span><span> </span><span>D_seq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>mono_seq_T_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚äë<span class="hidden">‚á©</span><sub>T</sub> S' ‚üπ (P `;` S)  ‚äë<span class="hidden">‚á©</span><sub>T</sub> (P `;` S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trace_refine_def</span><span> </span><span>T_seq</span><span> </span><span>append_single_T_imp_tickFree</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>mono_seq_DT_right</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> S' ‚üπ (P `;` S)  ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> (P `;` S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_seq_DT_left</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> P' ‚üπ (P `;` S)  ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> (P' `;` S)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span> </span><span>divergence_refine_def</span><span> </span><span>trace_refine_def</span><span> </span><span>D_seq</span><span> </span><span>T_seq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Nil_elem_T</span><span> </span><span>Process.F_T</span><span> </span><span>T_F</span><span> </span><span>append.right_neutral</span><span> 
</span><span>            </span><span>is_processT5_S3</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="comment">‚Äï‚Äπleft sequence monotony doesn't hold for ‚Äπ‚äë<span class="hidden">‚á©</span><sub>F</sub>‚Ä∫, ‚Äπ‚äë<span class="hidden">‚á©</span><sub>D</sub>‚Ä∫ and ‚Äπ‚äë<span class="hidden">‚á©</span><sub>T</sub>‚Ä∫‚Ä∫</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>mono_seq_DT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> P' ‚üπ S ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> S' ‚üπ (P `;` S)  ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> (P' `;` S')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mono_seq_DT_left</span><span> </span><span>mono_seq_DT_right</span><span> </span><span>trans_DT</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mono_seq_FD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">=</span><span> </span><span>mono_seq_FD</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_mprefix_F_process</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx. P x ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q x ‚üπ Mprefix A P ‚äë<span class="hidden">‚á©</span><sub>F</sub> Mprefix A Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>failure_refine_def</span><span> </span><span>F_Mprefix</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_mprefix_D_process</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx. P x ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q x ‚üπ Mprefix A P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Mprefix A Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>divergence_refine_def</span><span> </span><span>D_Mprefix</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_mprefix_T_process</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx. P x ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q x ‚üπ Mprefix A P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Mprefix A Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trace_refine_def</span><span> </span><span>T_Mprefix</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>mono_mprefix_DT_process</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx. P x ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q x ‚üπ Mprefix A P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Mprefix A Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> 
</span><span>mono_mprefix_FD_process</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>                </span><span>mono_mprefix_FD</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_mprefix_DT_set</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚äÜ B ‚üπ Mprefix B P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Mprefix A P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_Mprefix</span><span> </span><span>D_Mprefix</span><span> </span><span>trace_divergence_refine_def</span><span> 
</span><span>                    </span><span>trace_refine_def</span><span> </span><span>divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>mono_mprefix_D_set</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚äÜ B ‚üπ Mprefix B P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Mprefix A P"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_mprefix_T_set</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚äÜ B ‚üπ Mprefix B P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Mprefix A P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DT_D</span><span> </span><span>DT_T</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment">‚Äï‚ÄπMprefix set monotony doesn't hold for ‚Äπ‚äë<span class="hidden">‚á©</span><sub>F</sub>‚Ä∫ and ‚Äπ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub>‚Ä∫ where it holds for deterministic choice‚Ä∫</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_hide_F</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q ‚üπ P \\ A ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q \\ A"</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hide_set_empty</span><span> </span><span>failure_refine_def</span><span> </span><span>F_hiding</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Un_commute</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>UnCI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>b</span><span> </span><span>t</span><span> </span><span>u</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a ‚àà A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f = rec_nat t (Œªi t. t @ [ev a])"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f (Suc i) = (f i) @ [ev a]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"strict_mono f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>strict_mono_def</span><span> </span><span>lift_Suc_mono_less_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t ‚àà range f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>old.nat.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>range_eqI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f i ‚àà D Q ‚àß tickFree (f i) ‚àß trace_hide (f i) (ev ` A) = (trace_hide t (ev ` A))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>1</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>AA</span><span> </span><span>a</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_processT7</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"f i"</span></span></span><span> </span><span>Q</span><span> </span><span class="string"><span class="delete"><span class="delete">"[ev a]"</span></span></span><span class="delimiter">]</span><span> </span><span>front_tickFree_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isInfHiddenRun f P A ‚àß t ‚àà range f"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>D_T</span><span> </span><span>F_subset_imp_T_subset</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>b</span><span> </span><span>u</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_subset_imp_T_subset</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_hide_T</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ P \\ A ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q \\ A"</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hide_set_empty</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>trace_refine_def</span><span> </span><span>T_hiding</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Un_commute</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>subsetI</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>UnCI</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>11</span><span class="delimiter">:</span><span class="delimiter">(</span><span>1</span><span> </span><span>t</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>tt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t ‚àà T P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Process.F_T</span><span> </span><span>subset_eq</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>11</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>inf_hidden</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span> </span><span>t</span><span> </span><span>P</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isInfHiddenRun f P A ‚àß t ‚àà range f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>11</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>t</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>11</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tt</span><span> </span><span>append_Nil2</span><span> </span><span>front_tickFree_Nil</span><span> </span><span>is_processT2_TR</span><span> 
</span><span>                </span><span>nonTickFree_n_frontTickFree</span><span> </span><span>tick_T_F</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Un_commute</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>21</span><span class="delimiter">:</span><span class="delimiter">(</span><span>1</span><span> </span><span>t</span><span> </span><span>u</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f = rec_nat t (Œªi t. t @ [ev a])"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>AA</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f (Suc i) = (f i) @ [ev a]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>B</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"strict_mono f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>strict_mono_def</span><span> </span><span>lift_Suc_mono_less_iff</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"t ‚àà range f"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>old.nat.simps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>range_eqI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f i ‚àà D Q ‚àß tickFree (f i) ‚àß trace_hide (f i) (ev ` A) = (trace_hide t (ev ` A))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>21</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>21</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>AA</span><span> </span><span>21</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_processT7</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"f i"</span></span></span><span> </span><span>Q</span><span> </span><span class="string"><span class="delete"><span class="delete">"[ev a]"</span></span></span><span class="delimiter">]</span><span> </span><span>front_tickFree_single</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span> </span><span>C</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"isInfHiddenRun f P A ‚àß t ‚àà range f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>21</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>D_T</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>21</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>22</span><span class="delimiter">:</span><span class="delimiter">(</span><span>2</span><span> </span><span>b</span><span> </span><span>u</span><span> </span><span>f</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_hide_DT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q ‚üπ P \\ A ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q \\ A"</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete"><span class="delete"><span class="delete">"P \\ A ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q \\ A"</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>trace_divergence_refine_def</span><span> </span><span>divergence_refine_def</span><span> 
</span><span>                    </span><span>trace_refine_def</span><span> </span><span>D_hiding</span><span> </span><span>T_hiding</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>DT_T</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>mono_hide_T</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>as</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mono_hide_FD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>                 </span><span>mono_hide_FD</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment">‚Äï‚ÄπObviously, Hide monotony doesn't hold for ‚Äπ‚äë<span class="hidden">‚á©</span><sub>D</sub>‚Ä∫‚Ä∫</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_sync_DT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> P' ‚üπ Q ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q' ‚üπ (P ‚ü¶ A ‚üß Q) ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> (P' ‚ü¶ A ‚üß Q')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>trace_divergence_refine_def</span><span> </span><span>divergence_refine_def</span><span> </span><span>trace_refine_def</span><span> </span><span>T_sync</span><span> </span><span>D_sync</span><span class="delimiter">)</span><span> 
</span><span>     </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mono_sync_FD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>                 </span><span>mono_sync_FD</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment">‚Äï‚Äπsynchronization monotony doesn't hold for ‚Äπ‚äë<span class="hidden">‚á©</span><sub>F</sub>‚Ä∫, ‚Äπ‚äë<span class="hidden">‚á©</span><sub>D</sub>‚Ä∫ and ‚Äπ‚äë<span class="hidden">‚á©</span><sub>T</sub>‚Ä∫‚Ä∫</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_mndet_F_process</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx‚ààA. P x ‚äë<span class="hidden">‚á©</span><sub>F</sub> Q x ‚üπ mndet A P ‚äë<span class="hidden">‚á©</span><sub>F</sub> mndet A Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A = {}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>failure_refine_def</span><span> </span><span>F_mndet</span><span> </span><span>write0_def</span><span> </span><span>F_Mprefix</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_mndet_D_process</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx‚ààA. P x ‚äë<span class="hidden">‚á©</span><sub>D</sub> Q x ‚üπ mndet A P ‚äë<span class="hidden">‚á©</span><sub>D</sub> mndet A Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A = {}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>divergence_refine_def</span><span> </span><span>D_mndet</span><span> </span><span>write0_def</span><span> </span><span>D_Mprefix</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mono_mndet_T_process</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx‚ààA. P x ‚äë<span class="hidden">‚á©</span><sub>T</sub> Q x ‚üπ mndet A P ‚äë<span class="hidden">‚á©</span><sub>T</sub> mndet A Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A = {}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>trace_refine_def</span><span> </span><span>T_mndet</span><span> </span><span>write0_def</span><span> </span><span>T_Mprefix</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>mono_mndet_DT_process</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄx‚ààA. P x ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Q x ‚üπ mndet A P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> mndet A Q"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>trace_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemmas</span></span><span> 
</span><span>mono_mndet_FD_process</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>              </span><span>mono_mndet_FD</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> 
</span><span>mono_mndet_FD_set</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>              </span><span>mndet_FD_subset</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>mono_mndet_F_set</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚â† {} ‚üπ A ‚äÜ B ‚üπ mndet B P ‚äë<span class="hidden">‚á©</span><sub>F</sub> mndet A P"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_mndet_D_set</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚â† {} ‚üπ A ‚äÜ B ‚üπ mndet B P ‚äë<span class="hidden">‚á©</span><sub>D</sub> mndet A P"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_mndet_T_set</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚â† {} ‚üπ A ‚äÜ B ‚üπ mndet B P ‚äë<span class="hidden">‚á©</span><sub>T</sub> mndet A P"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mono_mndet_DT_set</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚â† {} ‚üπ A ‚äÜ B ‚üπ mndet B P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> mndet A P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FD_F</span><span> </span><span>FD_D</span><span> </span><span>le_F_T</span><span> </span><span>D_T_DT</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> 
</span><span>Mprefix_refines_Mndet_FD</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>                          </span><span>Mprefix_refines_Mndet</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Mprefix_refines_Mndet_F</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mndet A P ‚äë<span class="hidden">‚á©</span><sub>F</sub> Mprefix A P"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Mprefix_refines_Mndet_D</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mndet A P ‚äë<span class="hidden">‚á©</span><sub>D</sub> Mprefix A P"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Mprefix_refines_Mndet_T</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mndet A P ‚äë<span class="hidden">‚á©</span><sub>T</sub> Mprefix A P"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Mprefix_refines_Mndet_DT</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mndet A P ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> Mprefix A P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FD_F</span><span> </span><span>FD_D</span><span> </span><span>le_F_T</span><span> </span><span>D_T_DT</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπReference processes and their unfolding rules‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>DF_def</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span> </span><span>RUN_def</span><span> </span><span>CHAOS_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a set ‚áí 'a process"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A ‚â° Œº X. (SKIP ‚äì STOP ‚äì (‚ñ° x ‚àà A ‚Üí X))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>DF_unfold</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RUN_unfold</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"RUN A = (‚ñ° z ‚àà A ‚Üí RUN A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>RUN_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>trans</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CHAOS_unfold</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS A = (STOP ‚äì (‚ñ° z ‚àà A ‚Üí CHAOS A))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CHAOS_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>trans</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>                                              
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A ‚â° SKIP ‚äì STOP ‚äì (‚ñ° x ‚àà A ‚Üí CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œõ X. (SKIP ‚äì STOP ‚äì (‚ñ° x ‚àà A ‚Üí X))"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπProcess events and reference processes events‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>events_of</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"events_of P ‚â° (‚ãÉt‚ààT P. {a. ev a ‚àà set t})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>events_DF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"events_of (DF A) = A"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>events_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ‚àà T (DF A) ‚üπ ev x ‚àà set t ‚üπ x ‚àà A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a # t ‚àà T (‚äìz‚ààA ‚Üí  DF A)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DF_unfold</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>aa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = ev aa ‚àß aa ‚àà A ‚àß t ‚àà T (DF A)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_mndet</span><span> </span><span>write0_def</span><span> </span><span>T_Mprefix</span><span> </span><span>T_STOP</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà A ‚üπ ‚àÉxa‚ààT (DF A). ev x ‚àà set xa"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>DF_unfold</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_mndet</span><span> </span><span>write0_def</span><span> </span><span>T_Mprefix</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_elem_T</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>events_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"events_of (DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) = A"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>events_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ‚àà T (DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) ‚üπ ev x ‚àà set t ‚üπ x ‚àà A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a # t ‚àà T ((‚äìz‚ààA ‚Üí  DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) ‚äì SKIP)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>aa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = ev aa ‚àß aa ‚àà A ‚àß t ‚àà T (DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_mndet</span><span> </span><span>write0_def</span><span> </span><span>T_Mprefix</span><span> </span><span>T_STOP</span><span> </span><span>T_SKIP</span><span> </span><span>T_ndet</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà A ‚üπ ‚àÉxa‚ààT (DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A). ev x ‚àà set xa"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_mndet</span><span> </span><span>write0_def</span><span> </span><span>T_Mprefix</span><span> </span><span>T_SKIP</span><span> </span><span>T_ndet</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_elem_T</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>events_RUN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"events_of (RUN A) = A"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>events_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ‚àà T (RUN A) ‚üπ ev x ‚àà set t ‚üπ x ‚àà A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a # t ‚àà T (‚ñ°z‚ààA ‚Üí  RUN A)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>RUN_unfold</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>aa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = ev aa ‚àß aa ‚àà A ‚àß t ‚àà T (RUN A)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_Mprefix</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà A ‚üπ ‚àÉxa‚ààT (RUN A). ev x ‚àà set xa"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>RUN_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>T_Mprefix</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_elem_T</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>events_CHAOS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"events_of (CHAOS A) = A"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>events_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ‚àà T (CHAOS A) ‚üπ ev x ‚àà set t ‚üπ x ‚àà A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a # t ‚àà T (STOP ‚äì (‚ñ° z ‚àà A ‚Üí CHAOS A))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CHAOS_unfold</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>aa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = ev aa ‚àß aa ‚àà A ‚àß t ‚àà T (CHAOS A)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_ndet</span><span> </span><span>T_Mprefix</span><span> </span><span>T_STOP</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà A ‚üπ ‚àÉxa‚ààT (CHAOS A). ev x ‚àà set xa"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>CHAOS_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_ndet</span><span> </span><span>T_Mprefix</span><span> </span><span>T_STOP</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_elem_T</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>events_CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"events_of (CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) = A"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>events_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>t</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t ‚àà T (CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) ‚üπ ev x ‚àà set t ‚üπ x ‚àà A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a # t ‚àà T (SKIP ‚äì STOP ‚äì (‚ñ° z ‚àà A ‚Üí CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>aa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = ev aa ‚àß aa ‚àà A ‚àß t ‚àà T (CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_ndet</span><span> </span><span>T_Mprefix</span><span> </span><span>T_STOP</span><span> </span><span>T_SKIP</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà A ‚üπ ‚àÉxa‚ààT (CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A). ev x ‚àà set xa"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_ndet</span><span> </span><span>T_Mprefix</span><span> </span><span>T_STOP</span><span> </span><span>T_SKIP</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Nil_elem_T</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.set_intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>events_div</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D(P) ‚â† {} ‚üπ  events_of (P) = UNIV"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>events_of_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>xa</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àà D P"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÉx‚ààT P. ev xa ‚àà set x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"tickFree x"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x@[ev xa] ‚àà T P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>NT_ND</span><span> </span><span>front_tickFree_single</span><span> </span><span>is_processT7</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(butlast x)@[ev xa] ‚àà T P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"1"</span></span></span><span> </span><span>D_T</span><span> </span><span>D_imp_front_tickFree</span><span> </span><span>append_single_T_imp_tickFree</span><span> </span><span>butlast_snoc</span><span> 
</span><span>                </span><span>front_tickFree_single</span><span> </span><span>nonTickFree_n_frontTickFree</span><span> </span><span>process_charn</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>DF_subset</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_subset_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚â† {} ‚üπ A ‚äÜ B ‚üπ DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> B ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>le_FD_adm</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>monofunI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_ndet_FD</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>mono_mndet_FD_process</span><span> </span><span>mono_mndet_FD_set</span><span> </span><span>trans_FD</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RUN_subset_DT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚äÜ B ‚üπ RUN B ‚äë<span class="hidden">‚á©</span><sub>D</sub><span class="hidden">‚á©</span><sub>T</sub> RUN A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>RUN_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>le_DT_adm</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>monofunI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>RUN_unfold</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>mono_mprefix_DT_process</span><span> </span><span>mono_mprefix_DT_set</span><span> </span><span>trans_DT</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CHAOS_subset_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚äÜ B ‚üπ CHAOS B ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> CHAOS A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>CHAOS_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>le_FD_adm</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>monofunI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>CHAOS_unfold</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>failure_divergence_refine_def</span><span> </span><span>le_ref_def</span><span> 
</span><span>                     </span><span>D_Mprefix</span><span> </span><span>D_ndet</span><span> </span><span>F_STOP</span><span> </span><span>F_Mprefix</span><span> </span><span>F_ndet</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_subset_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ‚äÜ B ‚üπ CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> B ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>le_FD_adm</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>monofunI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>failure_divergence_refine_def</span><span> </span><span>le_ref_def</span><span> 
</span><span>                     </span><span>D_Mprefix</span><span> </span><span>D_ndet</span><span> </span><span>F_STOP</span><span> </span><span>F_Mprefix</span><span> </span><span>F_ndet</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπRelations between refinements on reference processes‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CHAOS_has_all_tickFree_failures</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"tickFree a ‚üπ {x. ev x ‚àà set a} ‚äÜ A ‚üπ (a,b) ‚àà F (CHAOS A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>CHAOS_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>F_ndet</span><span> </span><span>F_STOP</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a0</span><span> </span><span>al</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tickFree al"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append.left_neutral</span><span> </span><span>append_Cons</span><span> </span><span>front_tickFree_charn</span><span> </span><span>front_tickFree_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>CHAOS_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>F_ndet</span><span> </span><span>F_STOP</span><span> </span><span>F_Mprefix</span><span> </span><span>events_of_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>event_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_has_all_failures</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(events_of P) ‚äÜ A"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A ‚äë<span class="hidden">‚á©</span><sub>F</sub> P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"front_tickFree a ‚üπ set a ‚äÜ (‚ãÉt‚ààT P. set t) ‚üπ (a,b) ‚àà F (CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>F_ndet</span><span> </span><span>F_STOP</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a0</span><span> </span><span>al</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"front_tickFree al"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append.left_neutral</span><span> </span><span>append_Cons</span><span> </span><span>front_tickFree_charn</span><span> </span><span>front_tickFree_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>F_ndet</span><span> </span><span>F_STOP</span><span> </span><span>F_SKIP</span><span> </span><span>F_Mprefix</span><span> </span><span>events_of_def</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"a0=tick"</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>front_tickFree_charn</span><span> 
</span><span>                    </span><span>front_tickFree_mono</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tickFree_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>event_set</span><span> </span><span>image_iff</span><span> </span><span>as</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>events_of_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>F_T</span><span> </span><span>SUP_upper</span><span> </span><span>failure_refine_def</span><span> </span><span>process_charn</span><span> </span><span>subrelI</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_has_all_failures_ev</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> (events_of P) ‚äë<span class="hidden">‚á©</span><sub>F</sub> P"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_has_all_failures_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV ‚äë<span class="hidden">‚á©</span><sub>F</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_has_all_failures</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_DF_refine_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A  ‚äë<span class="hidden">‚á©</span><sub>F</sub> DF A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>le_F_adm</span><span> </span><span>monofunI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>DF_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DF_RUN_refine_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DF A  ‚äë<span class="hidden">‚á©</span><sub>F</sub> RUN A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>DF_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>le_F_adm</span><span> </span><span>monofunI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>RUN_unfold</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Mprefix_refines_Mndet_F</span><span> </span><span>mono_mndet_F_process</span><span> </span><span>trans_F</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CHAOS_DF_refine_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS A  ‚äë<span class="hidden">‚á©</span><sub>F</sub> DF A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CHAOS_def</span><span> </span><span>DF_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>parallel_fix_ind</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monofunI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>le_F_adm</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>monofun_snd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>adm_def</span><span> </span><span>failure_refine_def</span><span> </span><span>F_mndet</span><span> 
</span><span>                                  </span><span>F_Mprefix</span><span> </span><span>write0_def</span><span> </span><span>F_ndet</span><span> </span><span>F_STOP</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_CHAOS_refine_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A  ‚äë<span class="hidden">‚á©</span><sub>F</sub> CHAOS A"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_refine_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A  ‚äë<span class="hidden">‚á©</span><sub>F</sub> DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_has_all_failures</span><span> </span><span>events_CHAOS</span><span> </span><span>events_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span> 
</span><span>                    </span><span>trans_F</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CHAOS_DF_refine_F</span><span> </span><span>DF_RUN_refine_F</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_free_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D(DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span> </span><span>fix_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ‚â° Œªi. iterate i‚ãÖ(Œõ x. (‚äìxa‚ààA ‚Üí  x) ‚äì SKIP)‚ãÖ‚ä•"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"chain Y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (Y (Suc i)) = {d. d ‚â† [] ‚àß hd d  ‚àà (ev ` A) ‚àß tl d ‚àà D(Y i)}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Y_def</span><span> </span><span>D_STOP</span><span> </span><span>D_SKIP</span><span> </span><span>D_mndet</span><span> </span><span>write0_def</span><span> </span><span>D_Mprefix</span><span> </span><span>D_ndet</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"d ‚àà D(Y i) ‚üπ length d ‚â• i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>d</span><span> </span><span>i</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>d</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Nitpick.size_list_simp</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÄ i. x ‚àà D (Y i)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ‚àâ D (Y (Suc (length x)))"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_n_not_le_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D (‚®Üi. Y i) = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_LUB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>limproc_is_thelub</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_free_DF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D(DF A) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A  ‚äë<span class="hidden">‚á©</span><sub>D</sub> DF A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>le_D_adm</span><span> </span><span>monofunI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>DF_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>divergence_refine_def</span><span> </span><span>div_free_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_free_CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D (CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A  ‚äë<span class="hidden">‚á©</span><sub>D</sub> CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>le_D_adm</span><span> </span><span>monofunI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x ‚äë<span class="hidden">‚á©</span><sub>D</sub> CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"((‚äìxa‚ààA ‚Üí  x) ‚äì SKIP) = (SKIP ‚äì SKIP ‚äì (‚äìxa‚ààA ‚Üí  x))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Ndet_commute</span><span> </span><span>ndet_id</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(SKIP ‚äì SKIP ‚äì (‚äìxa‚ààA ‚Üí  x)) ‚äë<span class="hidden">‚á©</span><sub>D</sub> (SKIP ‚äì STOP ‚äì (‚ñ°xa‚ààA ‚Üí CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>DT_D</span><span> </span><span>Mprefix_refines_Mndet_D</span><span> </span><span>STOP_leDT</span><span> </span><span>idem_D</span><span> 
</span><span>                </span><span>mono_mprefix_D_process</span><span> </span><span>mono_ndet_D</span><span> </span><span>trans_D</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((‚äìxa‚ààA ‚Üí  x) |-| SKIP) ‚äë<span class="hidden">‚á©</span><sub>D</sub> (SKIP |-| STOP |-| Mprefix A (Œªx. CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>divergence_refine_def</span><span> </span><span>div_free_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_free_CHAOS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D(CHAOS A) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A  ‚äë<span class="hidden">‚á©</span><sub>D</sub> CHAOS A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>le_D_adm</span><span> </span><span>monofunI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>CHAOS_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>divergence_refine_def</span><span> </span><span>div_free_CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_free_RUN</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D(RUN A) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS A  ‚äë<span class="hidden">‚á©</span><sub>D</sub> RUN A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CHAOS_def</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>le_D_adm</span><span> </span><span>monofunI</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>RUN_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>divergence_refine_def</span><span> </span><span>div_free_CHAOS</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_DF_refine_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A  ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> DF A"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>DF_RUN_refine_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DF A  ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> RUN A"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CHAOS_DF_refine_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS A  ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> DF A"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_CHAOS_refine_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A  ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> CHAOS A"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_refine_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A  ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_free_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>div_free_CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>div_free_DF</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>div_free_RUN</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>div_free_CHAOS</span><span class="delimiter">[</span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>F_D_FD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_DF_refine_F</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>F_D_FD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>DF_RUN_refine_F</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>F_D_FD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CHAOS_DF_refine_F</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> </span><span>F_D_FD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_CHAOS_refine_F</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>F_D_FD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_refine_F</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>A</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>divergence_refine_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>traces_CHAOS_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"T(CHAOS A) ‚äÜ {s. set s ‚äÜ ev ` A}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>sa</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà T (CHAOS A)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sa ‚àà set s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sa ‚àà ev ` A"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>CHAOS_unfold</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_ndet</span><span> </span><span>T_STOP</span><span> </span><span>T_Mprefix</span><span class="delimiter">)</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>traces_RUN_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"{s. set s ‚äÜ ev ` A} ‚äÜ T(RUN A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"set s ‚äÜ ev ` A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà T (RUN A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Nil_elem_T</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RUN_unfold</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_Mprefix</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>RUN_all_tickfree_traces1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"T(RUN A) = {s. set s ‚äÜ ev ` A}"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>DF_all_tickfree_traces1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"T(DF A) = {s. set s ‚äÜ ev ` A}"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CHAOS_all_tickfree_traces1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"T(CHAOS A) = {s. set s ‚äÜ ev ` A}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DF_RUN_refine_F</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>le_F_T</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>trace_refine_def</span><span class="delimiter">]</span><span>
</span><span>        </span><span>CHAOS_DF_refine_F</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>le_F_T</span><span class="delimiter">,</span><span>simplified</span><span> </span><span>trace_refine_def</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>traces_CHAOS_sub</span><span> </span><span>traces_RUN_sub</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>RUN_all_tickfree_traces2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tickFree s ‚üπ s ‚àà T(RUN UNIV)"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>DF_all_tickfree_traces2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tickFree s ‚üπ s ‚àà T(DF UNIV)"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CHAOS_all_tickfree_trace2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tickFree s ‚üπ s ‚àà T(CHAOS UNIV)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>tickFree_def</span><span> </span><span>RUN_all_tickfree_traces1</span><span> 
</span><span>                       </span><span>DF_all_tickfree_traces1</span><span> </span><span>CHAOS_all_tickfree_traces1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>event_set</span><span> </span><span>insertE</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>traces_CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"T(CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) ‚äÜ {s. front_tickFree s ‚àß set s ‚äÜ (ev ` A ‚à™ {tick})}"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>is_processT2_TR</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>sa</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà T (CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sa ‚àà set s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sa ‚àâ ev ` A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sa = tick"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_ndet</span><span> </span><span>T_STOP</span><span> </span><span>T_SKIP</span><span> </span><span>T_Mprefix</span><span class="delimiter">)</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>traces_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_sub</span><span class="delimiter">:</span><span> 
</span><span>                      </span><span class="string"><span class="delete"><span class="delete">"{s. front_tickFree s ‚àß set s ‚äÜ (ev ` A ‚à™ {tick})} ‚äÜ T(DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A::'a process)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"front_tickFree s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"set s ‚äÜ insert tick (ev ` A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"front_tickFree ((tick::'a event) # s) ‚üπ s = []"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>butlast_snoc</span><span> </span><span>front_tickFree_charn</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tickFree_Cons</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà T (DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Nil_elem_T</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A={}"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>T_Mprefix</span><span> </span><span>T_mndet</span><span> </span><span>write0_def</span><span> </span><span>T_SKIP</span><span> </span><span>T_ndet</span><span> </span><span>T_STOP</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>front_tickFree_charn</span><span> </span><span>front_tickFree_mono</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>front_tickFree_mono</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_all_front_tickfree_traces1</span><span class="delimiter">:</span><span> 
</span><span>                              </span><span class="string"><span class="delete"><span class="delete">"T(DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) = {s. front_tickFree s ‚àß set s ‚äÜ (ev ` A ‚à™ {tick})}"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_all_front_tickfree_traces1</span><span class="delimiter">:</span><span> 
</span><span>                              </span><span class="string"><span class="delete"><span class="delete">"T(CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> A) = {s. front_tickFree s ‚àß set s ‚äÜ (ev ` A ‚à™ {tick})}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_refine_F</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>le_F_T</span><span class="delimiter">,</span><span> </span><span>simplified</span><span> </span><span>trace_refine_def</span><span class="delimiter">]</span><span>
</span><span>        </span><span>traces_CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_sub</span><span> </span><span>traces_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_sub</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_all_front_tickfree_traces2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"front_tickFree s ‚üπ s ‚àà T(DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV)"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_all_front_tickfree_traces2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"front_tickFree s ‚üπ s ‚àà T(CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV)"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>tickFree_def</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_all_front_tickfree_traces1</span><span> 
</span><span>                      </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_all_front_tickfree_traces1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>event_set</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_has_all_traces</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV ‚äë<span class="hidden">‚á©</span><sub>T</sub> P"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_has_all_traces</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV ‚äë<span class="hidden">‚á©</span><sub>T</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>trace_refine_def</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_all_front_tickfree_traces2</span><span> </span><span>is_processT2_TR</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>trace_refine_def</span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_all_front_tickfree_traces2</span><span> </span><span>is_processT2_TR</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Properties">
<div class="head"><h1>Theory Properties</h1>
<span class="command">theory</span> <span class="name">Properties</span><br/>
<span class="keyword">imports</span> <a href="Assertions_ext.html"><span class="name">Assertions_ext</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment">‚Äï‚Äπ ******************************************************************** 
 * Project         : CSP-RefTK - A Refinement Toolkit for HOL-CSP
 * Version         : 1.0
 *
 * Author          : Burkhart Wolff, Safouan Taha, Lina Ye.
 *
 * This file       : Theorems on DF and LF
 *
 * Copyright (c) 2020 Universit√© Paris-Saclay, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************‚Ä∫</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Properties</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Assertions_ext"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDeadlock Free‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>deadlock_free_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deadlock_free_implies_div_free</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free P ‚üπ D P = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deadlock_free_def</span><span> </span><span>div_free_DF</span><span> </span><span>failure_divergence_refine_def</span><span> </span><span>le_ref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deadlock_free_implies_non_terminating</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free (P::'a process) ‚üπ ‚àÄs‚ààT P. tickFree s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>deadlock_free_def</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>FD_F</span><span class="delimiter">,</span><span> </span><span>drule</span><span> </span><span>le_F_T</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>trace_refine_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DF_all_tickfree_traces1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(UNIV::'a set)"</span></span></span><span class="delimiter">]</span><span> </span><span>tickFree_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>deadlock_free_v2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a process ‚áí bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 P ‚â° DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV ‚äë<span class="hidden">‚á©</span><sub>F</sub> P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deadlock_free_v2_is_right</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 (P::'a process) ‚ü∑ (‚àÄs‚ààT P. tickFree s ‚ü∂ (s, UNIV::'a event set) ‚àâ F P)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tickFree s ‚ü∂ (s, UNIV) ‚àâ F (DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a event list"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>F_mndet</span><span> </span><span>write0_def</span><span> </span><span>F_Mprefix</span><span> </span><span>F_ndet</span><span> </span><span>F_SKIP</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>F_mndet</span><span> </span><span>write0_def</span><span> </span><span>F_Mprefix</span><span> </span><span>F_ndet</span><span> </span><span>F_SKIP</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄs‚ààT P. tickFree s ‚ü∂ (s, UNIV) ‚àâ F P"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deadlock_free_v2_def</span><span> </span><span>failure_refine_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÄs‚ààT P. tickFree s ‚ü∂ (s, UNIV) ‚àâ F P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>as2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"front_tickFree s ‚üπ (‚àÉaa ‚àà UNIV. ev aa ‚àâ b) ‚üπ (s, b) ‚àà F (DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> (UNIV::'a set))"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>b</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_unfold</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>F_mndet</span><span> </span><span>write0_def</span><span> </span><span>F_Mprefix</span><span> </span><span>F_ndet</span><span> </span><span>F_SKIP</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>hda</span><span> </span><span>tla</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span> </span><span>fix_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>Y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ‚â° Œªi. iterate i‚ãÖ(Œõ x. (‚äìxa‚àà(UNIV::'a set) ‚Üí  x) ‚äì SKIP)‚ãÖ‚ä•"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"front_tickFree (hda # tla)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"front_tickFree tla ‚üπ (tla, b) ‚àà F (‚®Üi. Y i)"</span></span></span><span>
</span><span>             </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÉaa. ev aa ‚àâ b"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Y_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cc</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"chain Y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"front_tickFree tla ‚üπ ‚àÉaa‚ààUNIV. ev aa ‚àâ b ‚üπ(tla, b) ‚àà F (Y i)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_LUB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cc</span><span class="delimiter">]</span><span> </span><span>limproc_is_thelub</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cc</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Y_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"F(mndet UNIV (Œªx. Y i) ‚äì SKIP) ‚äÜ F (Y (Suc i))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"tla ‚â† [] ‚üπ hda ‚â† tick"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"front_tickFree tla"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>butlast_snoc</span><span> </span><span>front_tickFree_charn</span><span> 
</span><span>                      </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>tickFree_Cons</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span>front_tickFree_Nil</span><span> </span><span>front_tickFree_mono</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(hda#tla, b) ‚àà F (Y (Suc i))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f</span><span> </span><span>c</span><span> </span><span>e</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> </span><span>d</span><span class="delimiter">[</span><span>of</span><span> </span><span>i</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>F_mndet</span><span> </span><span>write0_def</span><span> </span><span>F_Mprefix</span><span> </span><span>Y_def</span><span> </span><span>F_ndet</span><span> </span><span>F_SKIP</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>event.exhaust</span><span class="delimiter">)</span><span class="delimiter">+</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(hda#tla, b) ‚àà F (Y 0)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>NF_ND</span><span> </span><span>cc</span><span> </span><span>g</span><span> </span><span>po_class.chainE</span><span> </span><span>proc_ord2a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(hda#tla, b) ‚àà F (‚®Üi. Y i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_LUB</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cc</span><span class="delimiter">]</span><span> </span><span>is_ub_thelub</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cc</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D_LUB_2</span><span> </span><span>cc</span><span> </span><span>g</span><span> </span><span>limproc_is_thelub</span><span> </span><span>po_class.chainE</span><span> </span><span>proc_ord2a</span><span> </span><span>process_charn</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>   
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>deadlock_free_v2_def</span><span> </span><span>failure_refine_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span>b</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>as3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s, b) ‚àà F P"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s ‚àà T P"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"front_tickFree s"</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_T</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as3</span><span> </span><span>is_processT2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, b) ‚àà F (DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"tickFree s"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>FT_True</span><span class="delimiter">:</span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s, UNIV) ‚àâ F P"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>as1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FT_True</span><span> </span><span>UNIV_I</span><span> </span><span>UNIV_eq_I</span><span> </span><span>a1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>as2</span><span> </span><span>as3</span><span> </span><span>emptyE</span><span> </span><span>event.exhaust</span><span> 
</span><span>                  </span><span>is_processT6_S1</span><span> </span><span>tickFree_implies_front_tickFree_single</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>FT_False</span><span class="delimiter">:</span><span> </span><span>False</span><span>                                                                 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>T_F_spec</span><span> </span><span>UNIV_witness</span><span> </span><span>a1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>append_single_T_imp_tickFree</span><span> 
</span><span>                  </span><span>as2</span><span> </span><span>emptyE</span><span> </span><span>is_processT5_S7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deadlock_free_v2_implies_div_free</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 P ‚üπ D P = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>F_T</span><span> </span><span>append_single_T_imp_tickFree</span><span> </span><span>deadlock_free_v2_is_right</span><span> </span><span>ex_in_conv</span><span> 
</span><span>            </span><span>nonTickFree_n_frontTickFree</span><span> </span><span>process_charn</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>deadlock_free_v2_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 P = DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>deadlock_free_v2_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deadlock_free_v2_implies_div_free</span><span> </span><span>FD_F</span><span> </span><span>F_D_FD</span><span> </span><span>deadlock_free_v2_def</span><span> </span><span>divergence_refine_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>all_events_refusal</span><span class="delimiter">:</span><span> 
</span><span>                        </span><span class="string"><span class="delete"><span class="delete">"(s, {tick} ‚à™ ev ` (events_of P)) ‚àà F P ‚üπ (s, UNIV::'a event set) ‚àà F P"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(s, {tick} ‚à™ ev ` events_of P) ‚àà F P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, UNIV) ‚àâ F P"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c ‚àâ {tick} ‚à™ ev ` events_of P ‚àß s @ [c] ‚àà T P"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_processT5_S1</span><span class="delimiter">[</span><span>of</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">"{tick} ‚à™ ev ` events_of P"</span></span></span><span> </span><span>P</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">"UNIV - ({tick} ‚à™ ev ` events_of P)"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span> </span><span>F_T</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>events_of_def</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, UNIV) ‚àà F P"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>deadlock_free_v2_is_right_wrt_events</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 (P::'a process) ‚ü∑ 
                                  (‚àÄs‚ààT P. tickFree s ‚ü∂ (s, {tick} ‚à™ ev ` (events_of P)) ‚àâ F P)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>deadlock_free_v2_is_right</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_events_refusal</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>is_processT4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deadlock_free_is_deadlock_free_v2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deadlock_free P ‚üπ deadlock_free_v2 P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_DF_refine_FD</span><span> </span><span>deadlock_free_def</span><span> </span><span>deadlock_free_v2_FD</span><span> </span><span>trans_FD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπNon-terminating Runs‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>non_terminating</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a process ‚áí bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"non_terminating P ‚â° RUN UNIV ‚äë<span class="hidden">‚á©</span><sub>T</sub> P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>non_terminating_refine_DF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating P = DF UNIV ‚äë<span class="hidden">‚á©</span><sub>T</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>non_terminating_refine_CHAOS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating P = CHAOS UNIV ‚äë<span class="hidden">‚á©</span><sub>T</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DF_all_tickfree_traces1</span><span> </span><span>RUN_all_tickfree_traces1</span><span> </span><span>CHAOS_all_tickfree_traces1</span><span> 
</span><span>                    </span><span>non_terminating_def</span><span> </span><span>trace_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_terminating_is_right</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating (P::'a process) ‚ü∑ (‚àÄs‚ààT P. tickFree s)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>non_terminating_def</span><span> </span><span>trace_refine_def</span><span> </span><span>tickFree_def</span><span> </span><span>RUN_all_tickfree_traces1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>non_terminating_def</span><span> </span><span>trace_refine_def</span><span> </span><span>RUN_all_tickfree_traces2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonterminating_implies_div_free</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating P ‚üπ D P = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>non_terminating_is_right</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>NT_ND</span><span> </span><span>equals0I</span><span> </span><span>front_tickFree_charn</span><span> </span><span>process_charn</span><span> </span><span>tickFree_Cons</span><span> </span><span>tickFree_append</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_terminating_implies_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating P ‚üπ CHAOS UNIV ‚äë<span class="hidden">‚á©</span><sub>F</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>non_terminating_is_right</span><span> </span><span>failure_refine_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CHAOS_has_all_tickFree_failures</span><span> </span><span>F_T</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>non_terminating_F</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating P = CHAOS UNIV ‚äë<span class="hidden">‚á©</span><sub>F</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>non_terminating_implies_F</span><span> </span><span>non_terminating_refine_CHAOS</span><span> </span><span>le_F_T</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>non_terminating_FD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating P = CHAOS UNIV ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>non_terminating_F</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_free_CHAOS</span><span> </span><span>nonterminating_implies_div_free</span><span> </span><span>FD_F</span><span> </span><span>F_D_FD</span><span> </span><span>divergence_refine_def</span><span> 
</span><span>        </span><span>non_terminating_F</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπLifelock Freeness‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>lifelock_free_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>lifelock_free_is_non_terminating</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lifelock_free P = non_terminating P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lifelock_free_def</span><span> </span><span>non_terminating_FD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>rule</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_free_divergence_refine</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"D P = {} ‚ü∑ CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV ‚äë<span class="hidden">‚á©</span><sub>D</sub> P"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"D P = {} ‚ü∑ CHAOS UNIV ‚äë<span class="hidden">‚á©</span><sub>D</sub> P"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"D P = {} ‚ü∑ RUN UNIV ‚äë<span class="hidden">‚á©</span><sub>D</sub> P"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"D P = {} ‚ü∑ DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV ‚äë<span class="hidden">‚á©</span><sub>D</sub> P"</span></span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"D P = {} ‚ü∑ DF UNIV ‚äë<span class="hidden">‚á©</span><sub>D</sub> P"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>div_free_CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span> </span><span>div_free_CHAOS</span><span> </span><span>div_free_RUN</span><span> </span><span>div_free_DF</span><span> </span><span>div_free_DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub></span><span> 
</span><span>                    </span><span>divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lifelock_free_v2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a process ‚áí bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"lifelock_free_v2 P ‚â° CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub> UNIV ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_free_is_lifelock_free_v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lifelock_free_v2 P ‚ü∑ D P = {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CHAOS<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_has_all_failures_Un</span><span> </span><span>FD_D</span><span> </span><span>F_D_FD</span><span> </span><span>div_free_divergence_refine</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>lifelock_free_v2_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lifelock_free_is_lifelock_free_v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lifelock_free P ‚üπ lifelock_free_v2 P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FD_D</span><span> </span><span>div_free_divergence_refine</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>div_free_is_lifelock_free_v2</span><span> </span><span>lifelock_free_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>deadlock_free_v2_is_lifelock_free_v2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 P ‚üπ lifelock_free_v2 P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>deadlock_free_v2_implies_div_free</span><span> </span><span>div_free_is_lifelock_free_v2</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπNew laws‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_terminating_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating P ‚üπ (P `;` Q) = P"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>non_terminating_is_right</span><span> </span><span>Process_eq_spec</span><span> </span><span>D_seq</span><span> </span><span>F_seq</span><span> </span><span>F_T</span><span> </span><span>is_processT7</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>process_charn</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>process_charn</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F_T</span><span> </span><span>is_processT5_S2a</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>D_T</span><span> </span><span>front_tickFree_Nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>non_terminating_inter</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating P ‚üπ lifelock_free_v2 Q ‚üπ non_terminating (P ‚ü¶C‚üß Q)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>non_terminating_is_right</span><span> </span><span>div_free_is_lifelock_free_v2</span><span> </span><span>T_sync</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>equals0D</span><span> </span><span>ftf_syn1</span><span> </span><span>ftf_syn21</span><span> </span><span>insertI1</span><span> </span><span>tickFree_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>NT_ND</span><span> </span><span>is_processT7_S</span><span> </span><span>tickFree_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>D_T</span><span> </span><span>empty_iff</span><span> </span><span>ftf_syn1</span><span> </span><span>ftf_syn21</span><span> </span><span>insertI1</span><span> </span><span>tickFree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Fix_ind_ext">
<div class="head"><h1>Theory Fix_ind_ext</h1>
<span class="command">theory</span> <span class="name">Fix_ind_ext</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOLCF/HOLCF.html"><span class="name">HOLCF</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment">‚Äï‚Äπ ********************************************************************
 * Project         : CSP-RefTK - A Refinement Toolkit for HOL-CSP
 * Version         : 1.0
 *
 * Author          : Burkhart Wolff, Safouan Taha, Lina Ye.
 *
 * This file       : More Fixpoint and k-Induction Schemata
 *
 * Copyright (c) 2020 Universit√© Paris-Saclay, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Advanced Induction Schemata ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Fix_ind_ext</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HOLCF</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπk-fixpoint-induction‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_k_induct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄi&lt;k. P i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄn<span class="hidden">‚á©</span><sub>0</sub>. (‚àÄi&lt;k. P (n<span class="hidden">‚á©</span><sub>0</sub>+i)) ‚ü∂ P (n<span class="hidden">‚á©</span><sub>0</sub>+k)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (n::nat)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>nat_less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; k"</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n-k"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>fix_ind</span><span> </span><span>fix_ind2</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fix_ind_k</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adm P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄi&lt;k. P (iterate i‚ãÖf‚ãÖ‚ä•)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄx. (‚àÄi&lt;k.  P (iterate i‚ãÖf‚ãÖx)) ‚üπ P (iterate k‚ãÖf‚ãÖx)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (fix‚ãÖf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fix_def2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>admD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>adm</span><span> </span><span>chain_iterate</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nat_k_induct</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>base_k_steps</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>add.commute</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>iterate_iterate</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nat_k_skip_induct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"k ‚â• 1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄi&lt;k. P i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄn<span class="hidden">‚á©</span><sub>0</sub>. P (n<span class="hidden">‚á©</span><sub>0</sub>) ‚ü∂ P (n<span class="hidden">‚á©</span><sub>0</sub>+k)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (n::nat)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>nat_less_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &lt; k"</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"n-k"</span></span></span><span class="delimiter">]</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fix_ind_k_skip</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>k</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>k_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"k ‚â• 1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adm P"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄi&lt;k. P (iterate i‚ãÖf‚ãÖ‚ä•)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄx. P x ‚üπ P (iterate k‚ãÖf‚ãÖx)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (fix‚ãÖf)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>fix_def2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>admD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>adm</span><span> </span><span>chain_iterate</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nat_k_skip_induct</span><span class="delimiter">[</span><span>of</span><span> </span><span>k</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>k_1</span><span> </span><span>base_k_steps</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>add.commute</span><span class="delimiter">,</span><span> </span><span>unfold</span><span> </span><span>iterate_iterate</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>parallel_fix_ind</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπParallel fixpoint-induction‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parallel_fix_ind_inc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adm (Œªx. P (fst x) (snd x))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>base_fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄy. P ‚ä• y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>base_snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄx. P x ‚ä•"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄx y. P x y ‚üπ P (G‚ãÖx) y ‚üπ P x (H‚ãÖy) ‚üπ P (G‚ãÖx) (H‚ãÖy)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (fix‚ãÖG) (fix‚ãÖH)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>adm'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"adm (case_prod P)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>split_def</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (iterate i‚ãÖG‚ãÖ‚ä•) (iterate j‚ãÖH‚ãÖ‚ä•)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>i</span><span> </span><span>j</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"i+j"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>i</span><span> </span><span>j</span><span> </span><span>rule</span><span class="delimiter">:</span><span>nat_less_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i'</span><span> </span><span>j'</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"i = Suc i'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>j</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"j = Suc j'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (iterate i'‚ãÖG‚ãÖ‚ä•) (iterate j'‚ãÖH‚ãÖ‚ä•)"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (iterate i'‚ãÖG‚ãÖ‚ä•) (iterate j‚ãÖH‚ãÖ‚ä•)"</span></span></span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (iterate i‚ãÖG‚ãÖ‚ä•) (iterate j'‚ãÖH‚ãÖ‚ä•)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1.hyps"</span></span></span><span> </span><span>add_strict_mono</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1.hyps"</span></span></span><span> </span><span>i</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1.hyps"</span></span></span><span> </span><span>j</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span>j</span><span> </span><span>step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>base_fst</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>j</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>base_snd</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄi. case_prod P (iterate i‚ãÖG‚ãÖ‚ä•, iterate i‚ãÖH‚ãÖ‚ä•)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"case_prod P (‚®Üi. (iterate i‚ãÖG‚ãÖ‚ä•, iterate i‚ãÖH‚ãÖ‚ä•))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>admD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>adm'</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (‚®Üi. iterate i‚ãÖG‚ãÖ‚ä•) (‚®Üi. iterate i‚ãÖH‚ãÖ‚ä•)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lub_Pair</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P (fix‚ãÖG) (fix‚ãÖH)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fix_def2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Process_norm">
<div class="head"><h1>Theory Process_norm</h1>
<span class="command">theory</span> <span class="name">Process_norm</span><br/>
<span class="keyword">imports</span> <a href="Properties.html"><span class="name">Properties</span></a> <a href="Fix_ind_ext.html"><span class="name">Fix_ind_ext</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment">‚Äï‚Äπ ********************************************************************
 * Project         : CSP-RefTK - A Refinement Toolkit for HOL-CSP
 * Version         : 1.0
 *
 * Author          : Burkhart Wolff, Safouan Taha, Lina Ye.
 *
 * This file       : A Normalization Theory
 *
 * Copyright (c) 2020 Universit√© Paris-Saclay, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Normalisation of Deterministic CSP Processes ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Process_norm</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Properties"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Fix_ind_ext"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπDeterministic normal-forms with explicit state‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P_dnorm Tr Up ‚â° (Œº X. (Œª s. ‚ñ° e ‚àà (Tr s) ‚Üí X (Up s e)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>P_dnorm</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶_,_‚üß"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dnorm_cont</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Tr</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state::type ‚áí 'event::type set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Up</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state ‚áí 'event ‚áí 'state"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cont (ŒªX. (Œªs. ‚ñ° e ‚àà (Tr s) ‚Üí X (Ur s e)))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cont ?f"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"cont (ŒªX. ?f X s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπInterleaving product lemma‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dnorm_inter</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Tr<span class="hidden">‚á©</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state<span class="hidden">‚á©</span><sub>1</sub>::type ‚áí 'event::type set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Tr<span class="hidden">‚á©</span><sub>2</sub></span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state<span class="hidden">‚á©</span><sub>2</sub>::type ‚áí 'event set"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Up<span class="hidden">‚á©</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state<span class="hidden">‚á©</span><sub>1</sub> ‚áí 'event ‚áí 'state<span class="hidden">‚á©</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Up<span class="hidden">‚á©</span><sub>2</sub></span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state<span class="hidden">‚á©</span><sub>2</sub> ‚áí 'event ‚áí 'state<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚â° P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr<span class="hidden">‚á©</span><sub>1</sub>,Up<span class="hidden">‚á©</span><sub>1</sub>‚üß"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚â° fix‚ãÖ(Œõ X. ?P X)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q ‚â° P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr<span class="hidden">‚á©</span><sub>2</sub>,Up<span class="hidden">‚á©</span><sub>2</sub>‚üß"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q ‚â° fix‚ãÖ(Œõ X. ?Q X)"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>indep</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ‚àÄs<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. Tr<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>1</sub> ‚à© Tr<span class="hidden">‚á©</span><sub>2</sub> s<span class="hidden">‚á©</span><sub>2</sub> = {}‚Ä∫</span></span></span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>Tr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tr ‚â° (Œª(s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>). Tr<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>1</sub> ‚à™ Tr<span class="hidden">‚á©</span><sub>2</sub> s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>Up</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Up ‚â° (Œª(s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>) e. if e ‚àà Tr<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>1</sub> then (Up<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>1</sub> e,s<span class="hidden">‚á©</span><sub>2</sub>)
                                else if e ‚àà Tr<span class="hidden">‚á©</span><sub>2</sub> s<span class="hidden">‚á©</span><sub>2</sub> then (s<span class="hidden">‚á©</span><sub>1</sub>, Up<span class="hidden">‚á©</span><sub>2</sub> s<span class="hidden">‚á©</span><sub>2</sub> e)
                                else (s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>))"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚â° P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr,Up‚üß"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚â° fix‚ãÖ(Œõ X. ?S X)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P s<span class="hidden">‚á©</span><sub>1</sub> ||| Q s<span class="hidden">‚á©</span><sub>2</sub>) = S (s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P = ?P P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œõ X. ?P X)"</span></span></span><span class="delimiter">]</span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q_rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q = ?Q Q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œõ X. ?Q X)"</span></span></span><span class="delimiter">]</span><span> </span><span>Q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S_rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S = ?S S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œõ X. ?S X)"</span></span></span><span class="delimiter">]</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dir1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. (P s<span class="hidden">‚á©</span><sub>1</sub> ||| Q s<span class="hidden">‚á©</span><sub>2</sub>) ‚äë S (s<span class="hidden">‚á©</span><sub>1</sub>, s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>P</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>Q</span><span class="delimiter">,</span><span> 
</span><span>        </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>parallel_fix_ind_inc</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œªx y. ‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. (x s<span class="hidden">‚á©</span><sub>1</sub> ||| y s<span class="hidden">‚á©</span><sub>2</sub>) ‚äë S (s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span>1</span><span>                                       
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>adm_all</span><span> </span><span>adm_below</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cont2cont_fun</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_fst</span><span class="delimiter">:</span><span class="delimiter">(</span><span>2</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Inter_commute</span><span> </span><span>app_strict</span><span> </span><span>minimal</span><span> </span><span>par_Int_bot</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_snd</span><span class="delimiter">:</span><span class="delimiter">(</span><span>3</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>par_Int_bot</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>4</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. ?C s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s<span class="hidden">‚á©</span><sub>1</sub></span><span> </span><span>s<span class="hidden">‚á©</span><sub>2</sub></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>mprefix_Par_Int</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>S_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Tr</span><span> </span><span>Up</span><span> </span><span>mprefix_Un_distr</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>mono_det_ref</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>indep</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>indep</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>     
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dir2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>.  S (s<span class="hidden">‚á©</span><sub>1</sub>, s<span class="hidden">‚á©</span><sub>2</sub>) ‚äë (P s<span class="hidden">‚á©</span><sub>1</sub> ||| Q s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>S</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œªx. ‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. x (s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>) ‚äë (P s<span class="hidden">‚á©</span><sub>1</sub> ||| Q s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span>1</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>adm_all</span><span> </span><span>adm_below</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>3</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. ?C s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s<span class="hidden">‚á©</span><sub>1</sub></span><span> </span><span>s<span class="hidden">‚á©</span><sub>2</sub></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_rec_sym</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Mprefix (Tr<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>1</sub>) (Œªe. P (Up<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>1</sub> e)) = P s<span class="hidden">‚á©</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P_rec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q_rec_sym</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Mprefix (Tr<span class="hidden">‚á©</span><sub>2</sub> s<span class="hidden">‚á©</span><sub>2</sub>) (Œªe. Q (Up<span class="hidden">‚á©</span><sub>2</sub> s<span class="hidden">‚á©</span><sub>2</sub> e)) = Q s<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Q_rec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Tr</span><span> </span><span>Up</span><span> </span><span>mprefix_Un_distr</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>P_rec</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>Q_rec</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>mprefix_Par_Int</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"{}"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>mono_det_ref</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Q_rec_sym</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>step</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>P_rec_sym</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">]</span><span> </span><span>indep</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dir1</span><span> </span><span>dir2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>below_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπSynchronous product lemma‚Ä∫</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dnorm_par</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Tr<span class="hidden">‚á©</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state<span class="hidden">‚á©</span><sub>1</sub>::type ‚áí 'event::type set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Tr<span class="hidden">‚á©</span><sub>2</sub></span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state<span class="hidden">‚á©</span><sub>2</sub>::type ‚áí 'event set"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Up<span class="hidden">‚á©</span><sub>1</sub></span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state<span class="hidden">‚á©</span><sub>1</sub> ‚áí 'event ‚áí 'state<span class="hidden">‚á©</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Up<span class="hidden">‚á©</span><sub>2</sub></span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state<span class="hidden">‚á©</span><sub>2</sub> ‚áí 'event ‚áí 'state<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚â° P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr<span class="hidden">‚á©</span><sub>1</sub>,Up<span class="hidden">‚á©</span><sub>1</sub>‚üß"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚â° fix‚ãÖ(Œõ X. ?P X)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q ‚â° P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr<span class="hidden">‚á©</span><sub>2</sub>,Up<span class="hidden">‚á©</span><sub>2</sub>‚üß"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Q ‚â° fix‚ãÖ(Œõ X. ?Q X)"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>Tr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tr ‚â° (Œª(s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>). Tr<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>1</sub> ‚à© Tr<span class="hidden">‚á©</span><sub>2</sub> s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>Up</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Up ‚â° (Œª(s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>) e. (Up<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>1</sub> e, Up<span class="hidden">‚á©</span><sub>2</sub> s<span class="hidden">‚á©</span><sub>2</sub> e))"</span></span></span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚â° P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr,Up‚üß"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"S ‚â° fix‚ãÖ(Œõ X. ?S X)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(P s<span class="hidden">‚á©</span><sub>1</sub> || Q s<span class="hidden">‚á©</span><sub>2</sub>) = S (s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P = ?P P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œõ X. ?P X)"</span></span></span><span class="delimiter">]</span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q_rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Q = ?Q Q"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œõ X. ?Q X)"</span></span></span><span class="delimiter">]</span><span> </span><span>Q</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>S_rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"S = ?S S"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œõ X. ?S X)"</span></span></span><span class="delimiter">]</span><span> </span><span>S</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dir1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. (P s<span class="hidden">‚á©</span><sub>1</sub> || Q s<span class="hidden">‚á©</span><sub>2</sub>) ‚äë S (s<span class="hidden">‚á©</span><sub>1</sub>, s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>P</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>Q</span><span class="delimiter">,</span><span> 
</span><span>        </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>parallel_fix_ind</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œªx y. ‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. (x s<span class="hidden">‚á©</span><sub>1</sub> || y s<span class="hidden">‚á©</span><sub>2</sub>) ‚äë S (s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span>1</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>adm_all</span><span> </span><span>adm_below</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cont2cont_fun</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span class="delimiter">:</span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>par_Int_bot</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>3</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. ?C s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s<span class="hidden">‚á©</span><sub>1</sub></span><span> </span><span>s<span class="hidden">‚á©</span><sub>2</sub></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>mprefix_Par_distr</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"UNIV"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>S_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Tr</span><span> </span><span>Up</span><span> </span><span>mprefix_Un_distr</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>step</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>     
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>dir2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>.  S (s<span class="hidden">‚á©</span><sub>1</sub>, s<span class="hidden">‚á©</span><sub>2</sub>) ‚äë (P s<span class="hidden">‚á©</span><sub>1</sub> || Q s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>S</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œªx. ‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. x (s<span class="hidden">‚á©</span><sub>1</sub>,s<span class="hidden">‚á©</span><sub>2</sub>) ‚äë (P s<span class="hidden">‚á©</span><sub>1</sub> || Q s<span class="hidden">‚á©</span><sub>2</sub>)"</span></span></span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span>1</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>adm_all</span><span> </span><span>adm_below</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>3</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄ s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. ?C s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s<span class="hidden">‚á©</span><sub>1</sub></span><span> </span><span>s<span class="hidden">‚á©</span><sub>2</sub></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_rec_sym</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Mprefix (Tr<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>1</sub>) (Œªe. P (Up<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>1</sub> e)) = P s<span class="hidden">‚á©</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P_rec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q_rec_sym</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Mprefix (Tr<span class="hidden">‚á©</span><sub>2</sub> s<span class="hidden">‚á©</span><sub>2</sub>) (Œªe. Q (Up<span class="hidden">‚á©</span><sub>2</sub> s<span class="hidden">‚á©</span><sub>2</sub> e)) = Q s<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Q_rec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C s<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Tr</span><span> </span><span>Up</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>P_rec</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>Q_rec</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>mprefix_Par_distr</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>C</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"UNIV"</span></span></span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>dir1</span><span> </span><span>dir2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>below_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπConsequences‚Ä∫</span></span></span><span>
</span><span class="comment">‚Äï‚Äπreachable states from one starting state‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>‚Ñú</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Tr</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state::type ‚áí 'event::type set"</span></span></span><span> 
</span><span>                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Up</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state ‚áí 'event ‚áí 'state"</span></span></span><span> 
</span><span>                </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s<span class="hidden">‚á©</span><sub>0</sub></span><span class="delimiter">::</span><span class="tfree">'state</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>rbase</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s<span class="hidden">‚á©</span><sub>0</sub> ‚àà ‚Ñú Tr Up s<span class="hidden">‚á©</span><sub>0</sub>"</span></span></span><span>
</span><span>      </span><span class="delimiter">|</span><span> </span><span>rstep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà ‚Ñú Tr Up s<span class="hidden">‚á©</span><sub>0</sub> ‚üπ e ‚àà Tr s  ‚üπ Up s e ‚àà ‚Ñú Tr Up s<span class="hidden">‚á©</span><sub>0</sub>"</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment">‚Äï‚ÄπDeadlock freeness‚Ä∫</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deadlock_free_dnorm_</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Tr</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state::type ‚áí 'event::type set"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Up</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'state ‚áí 'event ‚áí 'state"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s<span class="hidden">‚á©</span><sub>0</sub></span><span class="delimiter">::</span><span class="tfree">'state</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>non_reachable_sink</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄs ‚àà ‚Ñú Tr Up s<span class="hidden">‚á©</span><sub>0</sub>. Tr s ‚â† {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚â° P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr,Up‚üß"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚â° fix‚ãÖ(Œõ X. ?P X)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ‚àà ‚Ñú Tr Up s<span class="hidden">‚á©</span><sub>0</sub> ‚üπ deadlock_free_v2 (P s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>deadlock_free_v2_FD</span><span> </span><span>DF<span class="hidden">‚á©</span><sub>S</sub><span class="hidden">‚á©</span><sub>K</sub><span class="hidden">‚á©</span><sub>I</sub><span class="hidden">‚á©</span><sub>P</sub>_def</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>s</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adm (Œªa. ‚àÄx. x ‚àà ‚Ñú Tr Up s<span class="hidden">‚á©</span><sub>0</sub> ‚ü∂ a ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> P x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>le_FD_adm</span><span> </span><span>monofun_def</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state"</span></span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà ‚Ñú Tr Up s<span class="hidden">‚á©</span><sub>0</sub> ‚üπ ‚ä• ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> P s"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'state"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'event process"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P = ?P P"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œõ X. ?P X)"</span></span></span><span class="delimiter">]</span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"‚ãÄs. s ‚àà ‚Ñú Tr Up s<span class="hidden">‚á©</span><sub>0</sub> ‚üπ x ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> P s"</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span>   </span><span>2</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà ‚Ñú Tr Up s<span class="hidden">‚á©</span><sub>0</sub> "</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span>   </span><span>1</span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Œõ x. (‚äìxa‚ààUNIV ‚Üí  x) ‚äì SKIP)‚ãÖx ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> P s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>failure_divergence_refine_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>P_rec</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>trans_FD</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>failure_divergence_refine_def</span><span class="delimiter">,</span><span> 
</span><span>                       </span><span>rotated</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>Mprefix_refines_Mndet</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>CSP.mono_ndet_FD_left</span><span class="delimiter">)</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CSP.mono_ndet_FD_right</span><span> </span><span>rstep</span><span> </span><span>empty_not_UNIV</span><span> </span><span>mndet_distrib</span><span> </span><span>mono_mndet_FD</span><span> 
</span><span>              </span><span>non_reachable_sink</span><span> </span><span>sup_top_left</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>deadlock_free_dnorm</span><span> </span><span class="delimiter">=</span><span> </span><span>deadlock_free_dnorm_</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>rbase</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>
</div>
</div><div id="CopyBuffer_props">
<div class="head"><h1>Theory CopyBuffer_props</h1>
<span class="command">theory</span> <span class="name">CopyBuffer_props</span><br/>
<span class="keyword">imports</span> <a href="CopyBuffer.html"><span class="name">CopyBuffer</span></a> <a href="Properties.html"><span class="name">Properties</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment">‚Äï‚Äπ ********************************************************************
 * Project         : CSP-RefTK - A Refinement Toolkit for HOL-CSP
 * Version         : 1.0
 *
 * Author          : Burkhart Wolff, Safouan Taha, Lina Ye.
 *
 * This file       : The Copy-Buffer Example Revisited
 *
 * Copyright (c) 2020 Universit√© Paris-Saclay, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπExamples‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπCopyBuffer Refinement over an infinite alphabet‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span>     </span><span>CopyBuffer_props</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"HOL-CSP.CopyBuffer"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Properties"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ The Copy-Buffer vs. reference processes ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DF_COPY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(DF (range left ‚à™ range right)) ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> COPY"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>DF_def</span><span class="delimiter">,</span><span>rule</span><span> </span><span>fix_ind2</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>failure_divergence_refine_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adm (Œªa. a ‚â§ COPY)"</span></span></span><span>   </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>le_adm</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>monofunI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(‚äìxa‚àà range left ‚à™ range right ‚Üí ‚ä•) ‚â§ (‚äìxa‚àà range left ‚Üí  ‚ä•)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mndet_subset_FD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UNIV_I</span><span> </span><span>empty_iff</span><span> </span><span>imageI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(‚äìxa‚àà range left ‚Üí  ‚ä•) ‚â§ (left`?`x ‚Üí  ‚ä•)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>read_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Mprefix_refines_Mndet</span><span> </span><span>comp_apply</span><span> </span><span>dual_order.antisym</span><span> </span><span>mono_mprefix_FD</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚äìx‚ààrange left ‚à™ range right ‚Üí  ‚ä•) ‚â§ COPY"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span>  </span><span>1</span><span> </span><span>2</span><span> </span><span>COPY_rec</span><span> </span><span>bot_less1</span><span> </span><span>mono_read_FD</span><span> </span><span>order.trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>P</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'a channel process"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>  </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ‚â§ COPY"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>**</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚äìx‚ààrange left ‚à™ range right ‚Üí  P) ‚â§ COPY"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(‚äìxa‚àà range left ‚à™ range right ‚Üí  P) ‚â§ (‚äìxa‚àà range right ‚Üí  P)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mndet_subset_FD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UNIV_I</span><span> </span><span>Un_commute</span><span> </span><span>empty_iff</span><span> </span><span>imageI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(‚äìxa‚àà range right ‚Üí  P) ‚â§ (right`!`x ‚Üí  P)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mndet_subset_FD</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"{right x}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"range right"</span></span></span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>write_def</span><span> </span><span>write0_def</span><span> </span><span>mndet_unit</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ab</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(‚äìxa‚àà range left ‚à™ range right ‚Üí  P) ‚â§ (right`!`x ‚Üí  P)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>dual_order.trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(left`?`x ‚Üí (‚äìxa‚àà range left ‚à™ range right ‚Üí  P)) ‚â§ (left`?`x ‚Üí(right`!`x ‚Üí  P))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mono_read_FD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ãÄX. (‚äìxa‚àà range left ‚à™ range right ‚Üí X) ‚â§ (‚äìxa‚àà range left ‚Üí X)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mndet_subset_FD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UNIV_I</span><span> </span><span>empty_iff</span><span> </span><span>imageI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>5</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ãÄX. (‚äìxa‚àà range left ‚Üí X) ‚â§ (left`?`x ‚Üí X)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>read_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Mprefix_refines_Mndet</span><span> </span><span>comp_apply</span><span> </span><span>dual_order.antisym</span><span> </span><span>mono_mprefix_FD</span><span> </span><span>order_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span>4</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚äìxa‚àà range left ‚à™ range right ‚Üí  P)"</span></span></span><span class="delimiter">]</span><span> 
</span><span>         </span><span>5</span><span>  </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚äìxa‚àà range left ‚à™ range right ‚Üí  P)"</span></span></span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>6</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(‚äìxa‚àà range left ‚à™ range right ‚Üí 
                    (‚äìxa‚àà range left ‚à™ range right ‚Üí  P)) ‚â§ (left`?`x ‚Üí (right`!`x ‚Üí  P))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>dual_order.trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>*</span><span> </span><span>**</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>7</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(left`?`x ‚Üí (right`!`x ‚Üí  P)) ‚â§ (left`?`x ‚Üí (right`!`x ‚Üí  COPY))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mono_read_FD</span><span> </span><span>mono_write_FD</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚äìx‚ààrange left ‚à™ range right ‚Üí  ‚äìx‚ààrange left ‚à™ range right ‚Üí  P) ‚â§ COPY"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>6</span><span> </span><span>7</span><span>  </span><span>COPY_rec</span><span> </span><span>dual_order.trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ ... and abstract consequences ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>df_COPY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free COPY"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lf_COPY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lifelock_free COPY"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>DF_COPY</span><span> </span><span>DF_Univ_freeness</span><span> </span><span>UNIV_not_empty</span><span> </span><span>image_is_empty</span><span> </span><span>sup_eq_bot_iff</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>CHAOS_DF_refine_FD</span><span> </span><span>DF_COPY</span><span> </span><span>DF_Univ_freeness</span><span> </span><span>UNIV_not_empty</span><span> </span><span>deadlock_free_def</span><span> 
</span><span>            </span><span>image_is_empty</span><span> </span><span>lifelock_free_def</span><span> </span><span>sup_eq_bot_iff</span><span> </span><span>trans_FD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>df_v2_COPY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 COPY"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lf_v2_COPY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lifelock_free_v2 COPY"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nt_COPY</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating COPY"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>df_COPY</span><span> </span><span>deadlock_free_is_deadlock_free_v2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lf_COPY</span><span> </span><span>lifelock_free_is_lifelock_free_v2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lf_COPY</span><span> </span><span>lifelock_free_is_non_terminating</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DF_SYSTEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DF UNIV ‚äë<span class="hidden">‚á©</span><sub>F</sub><span class="hidden">‚á©</span><sub>D</sub> SYSTEM"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>DF_subset</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(range left ‚à™ range right)"</span></span></span><span> </span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>  </span><span>impl_refines_spec</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>le_approx_implies_le_ref</span><span class="delimiter">]</span><span> </span><span>DF_COPY</span><span> 
</span><span>  </span><span>failure_divergence_refine_def</span><span> </span><span>trans_FD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>df_SYSTEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free SYSTEM"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lf_SYSTEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lifelock_free SYSTEM"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DF_SYSTEM</span><span> </span><span>deadlock_free_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CHAOS_DF_refine_FD</span><span> </span><span>DF_SYSTEM</span><span> </span><span>lifelock_free_def</span><span> </span><span>trans_FD</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>df_v2_SYSTEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 SYSTEM"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lf_v2_SYSTEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lifelock_free_v2 SYSTEM"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nt_SYSTEM</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"non_terminating SYSTEM"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>df_SYSTEM</span><span> </span><span>deadlock_free_is_deadlock_free_v2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lf_SYSTEM</span><span> </span><span>lifelock_free_is_lifelock_free_v2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lf_SYSTEM</span><span> </span><span>lifelock_free_is_non_terminating</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="DiningPhilosophers">
<div class="head"><h1>Theory DiningPhilosophers</h1>
<span class="command">theory</span> <span class="name">DiningPhilosophers</span><br/>
<span class="keyword">imports</span> <a href="Process_norm.html"><span class="name">Process_norm</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment">‚Äï‚Äπ ********************************************************************
 * Project         : CSP-RefTK - A Refinement Toolkit for HOL-CSP
 * Version         : 1.0
 *
 * Author          : Burkhart Wolff, Safouan Taha, Lina Ye.
 *
 * This file       : Example on Structural Parameterisation: Dining Philosophers
 *
 * Copyright (c) 2020 Universit√© Paris-Saclay, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * TrHIS SOFTrWARE IS PROVIDED BY TrHE COPYRIGHTr HOLDERS AND CONTrRIBUTrORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTrIES, INCLUDING, BUTr NOTr
 * LIMITrED TrO, TrHE IMPLIED WARRANTrIES OF MERCHANTrABILITrY AND FITrNESS FOR
 * A PARTrICULAR PURPOSE ARE DISCLAIMED. IN NO EVENTr SHALL TrHE COPYRIGHTr
 * OWNER OR CONTrRIBUTrORS BE LIABLE FOR ANY DIRECTr, INDIRECTr, INCIDENTrAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTrIAL DAMAGES (INCLUDING, BUTr NOTr
 * LIMITrED TrO, PROCUREMENTr OF SUBSTrITrUTrE GOODS OR SERVICES; LOSS OF USE,
 * DATrA, OR PROFITrS; OR BUSINESS INTrERRUPTrION) HOWEVER CAUSED AND ON ANY
 * TrHEORY OF LIABILITrY, WHETrHER IN CONTrRACTr, STrRICTr LIABILITrY, OR TrORTr
 * (INCLUDING NEGLIGENCE OR OTrHERWISE) ARISING IN ANY WAY OUTr OF TrHE USE
 * OF TrHIS SOFTrWARE, EVEN IF ADVISED OF TrHE POSSIBILITrY OF SUCH DAMAGE.
 ******************************************************************************‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ Generalized Dining Philosophers ‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span>     </span><span>DiningPhilosophers</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">"Process_norm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπPreliminary lemmas for proof automation‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Suc_mod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 1 ‚üπ i ‚â† Suc i mod n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>mod_Suc</span><span> </span><span>mod_if</span><span> </span><span>mod_mod_trivial</span><span> </span><span>n_not_Suc_n</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>suc_mods</span><span> </span><span class="delimiter">=</span><span> </span><span>Suc_mod</span><span> </span><span>Suc_mod</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>l_suc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 1 ‚üπ ¬¨ n ‚â§ Suc 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minus_suc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"n &gt; 0 ‚üπ n - Suc 0 ‚â† n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>numeral_4_eq_4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"4 = Suc (Suc (Suc (Suc 0)))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>numeral_5_eq_5</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"5 = Suc (Suc (Suc (Suc (Suc 0))))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe dining processes definition‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>DiningPhilosophers</span><span> </span><span class="delimiter">=</span><span>
</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>N</span><span class="delimiter">::</span><span>nat</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>N_g1</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N &gt; 1"</span></span></span><span>  
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>dining_event</span><span>  </span><span class="delimiter">=</span><span> </span><span>picks</span><span> </span><span class="delimiter">(</span><span>phil</span><span class="delimiter">:</span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fork</span><span class="delimiter">:</span><span>nat</span><span class="delimiter">)</span><span> 
</span><span>                       </span><span class="delimiter">|</span><span> </span><span>putsdown</span><span> </span><span class="delimiter">(</span><span>phil</span><span class="delimiter">:</span><span>nat</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fork</span><span class="delimiter">:</span><span>nat</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>RPHIL</span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"nat ‚áí dining_event process"</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RPHIL i = (Œº X. (picks i i ‚Üí (picks i (i-1) ‚Üí (putsdown i (i-1) ‚Üí (putsdown i i ‚Üí X)))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LPHIL0</span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">"dining_event process"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LPHIL0 = (Œº X. (picks 0 (N-1) ‚Üí (picks 0 0 ‚Üí (putsdown 0 0 ‚Üí (putsdown 0 (N-1) ‚Üí X)))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FORK</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ‚áí dining_event process"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FORK i = (Œº X.   (picks i i ‚Üí (putsdown i i ‚Üí X)) 
                        ‚ñ° (picks ((i+1) mod N) i ‚Üí (putsdown ((i+1) mod N) i ‚Üí X)))"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"foldPHILs n ‚â° fold (Œª i P. P ||| RPHIL i) [1..&lt; n] (LPHIL0)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"foldFORKs n ‚â° fold (Œª i P. P ||| FORK i) [1..&lt; n] (FORK 0)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PHILs ‚â° foldPHILs N"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FORKs ‚â° foldFORKs N"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>FORKs_def2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FORKs = fold (Œª i P. P ||| FORK i) [0..&lt; N] SKIP"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>upt_rec</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Inter_commute</span><span> </span><span>Inter_skip1</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"N = 3 ‚üπ PHILs = (LPHIL0 ||| RPHIL 1 ||| RPHIL 2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>upt_rec</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>numeral_2_eq_2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>DINING</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"dining_event process"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DINING = (FORKs || PHILs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπUnfolding rules‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RPHIL_rec</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"RPHIL i = (picks i i ‚Üí (picks i (i-1) ‚Üí (putsdown i (i-1) ‚Üí (putsdown i i  ‚Üí RPHIL i))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>RPHIL_def</span><span> </span><span>write0_def</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>fix_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LPHIL0_rec</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"LPHIL0 = (picks 0 (N-1) ‚Üí (picks 0 0 ‚Üí (putsdown 0 0 ‚Üí (putsdown 0 (N-1) ‚Üí LPHIL0))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>LPHIL0_def</span><span> </span><span>write0_def</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>fix_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORK_rec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FORK i = (  (picks i i ‚Üí (putsdown i i ‚Üí (FORK i)))
                          ‚ñ° (picks ((i+1) mod N) i ‚Üí (putsdown ((i+1) mod N) i ‚Üí (FORK i))))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>FORK_def</span><span> </span><span>write0_def</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>fix_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπTranslation into normal form‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>N_pos</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"N &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span>neq0_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>N_pos_simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>suc_mods</span><span class="delimiter">[</span><span>OF</span><span> </span><span>N_g1</span><span class="delimiter">]</span><span> </span><span>l_suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>N_g1</span><span class="delimiter">]</span><span> </span><span>minus_suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>N_pos</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe one-fork process‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>fork_id</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>fork_state</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fork_transitions</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fork_id ‚áí fork_state ‚áí dining_event set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>f</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>f</sub> i s = (if s = 0        then {picks i i} ‚à™ {picks ((i+1) mod N) i}
                    else if s = 1   then {putsdown i i} 
                    else if s = 2   then {putsdown ((i+1) mod N) i}
                    else                 {})"</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Un_insert_right</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span>Un_insert_left</span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ev_fork_idx</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ‚àà Tr<span class="hidden">‚á©</span><sub>f</sub> i s ‚üπ fork e = i"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fork_state_update</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fork_id ‚áí fork_state ‚áí dining_event ‚áí fork_state"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>f</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>f</sub> i s e = ( if e = (picks i i)                   then 1 
                      else if e = (picks ((i+1) mod N) i)  then 2 
                      else                                      0 )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fork_id ‚áí fork_state ‚áí dining_event process"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i = P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr<span class="hidden">‚á©</span><sub>f</sub> i ,Up<span class="hidden">‚á©</span><sub>f</sub> i‚üß"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i = (Œª s. ‚ñ° e ‚àà (Tr<span class="hidden">‚á©</span><sub>f</sub> i s) ‚Üí FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i (Up<span class="hidden">‚á©</span><sub>f</sub> i s e))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œõ X. (Œªs. Mprefix (Tr<span class="hidden">‚á©</span><sub>f</sub> i s) (Œªe. X (Up<span class="hidden">‚á©</span><sub>f</sub> i s e)))"</span></span></span><span class="delimiter">]</span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORK_refines_FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i 0 ‚äë FORK i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k_skip</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>2</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œõ x.(Œªs. Mprefix (Tr<span class="hidden">‚á©</span><sub>f</sub> i s) (Œªe. x (Up<span class="hidden">‚á©</span><sub>f</sub> i s e)))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1::nat) ‚â§ 2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adm (Œªa. a 0 ‚äë FORK i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cont_fun</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄj&lt;2. (iterate j‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë FORK i"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>less_2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ãÄj. (j::nat) &lt; 2 = (j = 0 ‚à® j = 1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 0‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë FORK i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 1‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë FORK i"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>FORK_rec</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> 
</span><span>                    </span><span>fork_transitions_def</span><span> 
</span><span>                    </span><span>mprefix_Un_distr</span><span> </span><span>mono_det_ref</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>4</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 2‚ãÖ?f‚ãÖx) 0 ‚äë FORK i"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>FORK_rec</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>numeral_2_eq_2</span><span> 
</span><span>                  </span><span>fork_transitions_def</span><span> </span><span>fork_state_update_def</span><span> 
</span><span>                  </span><span>mprefix_Un_distr</span><span> </span><span>mono_det_ref</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_refines_FORK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FORK i ‚äë FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>FORK_def</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k_skip</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1::nat) ‚â§ 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adm (Œªa. a ‚äë FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>4</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"iterate 1‚ãÖ?f‚ãÖx ‚äë FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> 
</span><span>                     </span><span>fork_transitions_def</span><span> </span><span>fork_state_update_def</span><span> 
</span><span>                     </span><span>mprefix_Un_distr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fork_transitions_def</span><span> </span><span>fork_state_update_def</span><span> 
</span><span>                  </span><span>mprefix_Un_distr</span><span> </span><span>mono_det_ref</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_is_FORK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FORK i = FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FORK_refines_FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_refines_FORK</span><span> </span><span>below_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe all-forks process in normal form‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>forks_state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>forks_transitions</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ‚áí forks_state ‚áí dining_event set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>F</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>F</sub> n fs = (‚ãÉi&lt;n. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs!i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>forks_transitions_take</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>F</sub> n fs = Tr<span class="hidden">‚á©</span><sub>F</sub> n (take n fs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>forks_transitions_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>forks_state_update</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"forks_state ‚áí dining_event ‚áí forks_state"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>F</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>F</sub> fs e = (let i=(fork e) in fs[i:=(Up<span class="hidden">‚á©</span><sub>f</sub> i (fs!i) e)])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>forks_update_take</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"take n (Up<span class="hidden">‚á©</span><sub>F</sub> fs e) = Up<span class="hidden">‚á©</span><sub>F</sub> (take n fs) e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>forks_state_update_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>nat_less_le</span><span> </span><span>nat_neq_iff</span><span> </span><span>nth_take</span><span> </span><span>order_refl</span><span> </span><span>take_update_cancel</span><span> </span><span>take_update_swap</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ‚áí forks_state ‚áí dining_event process"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n = P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr<span class="hidden">‚á©</span><sub>F</sub> n ,Up<span class="hidden">‚á©</span><sub>F</sub>‚üß"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n = (Œª fs. ‚ñ° e ‚àà (Tr<span class="hidden">‚á©</span><sub>F</sub> n fs) ‚Üí FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (Up<span class="hidden">‚á©</span><sub>F</sub> fs e))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œõ X. (Œªfs. Mprefix (Tr<span class="hidden">‚á©</span><sub>F</sub> n fs) (Œªe. X (Up<span class="hidden">‚á©</span><sub>F</sub> fs e)))"</span></span></span><span class="delimiter">]</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 0 fs = STOP"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>forks_transitions_def</span><span> </span><span>Mprefix_STOP</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1_dir1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length fs &gt; 0 ‚üπ FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 1 fs ‚äë (FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 0 (fs!0))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span>          
</span><span>      </span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>fs</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span>  
</span><span>                                         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œõ x. (Œªfs. Mprefix (Tr<span class="hidden">‚á©</span><sub>F</sub> 1 fs) (Œªe. x (Up<span class="hidden">‚á©</span><sub>F</sub> fs e)))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>3</span><span> </span><span>X</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÉi&lt;Suc 0. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs ! i)) = Tr<span class="hidden">‚á©</span><sub>f</sub> 0 (fs ! 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>step</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>forks_state_update_def</span><span> </span><span>forks_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ev_fork_idx</span><span> </span><span>step.prems</span><span> </span><span>list_update_nonempty</span><span> </span><span>nth_list_update_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1_dir2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length fs &gt; 0 ‚üπ (FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 0 (fs!0)) ‚äë FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 1 fs"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>fs</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span> 
</span><span>                                         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œõ x. (Œªs. Mprefix (Tr<span class="hidden">‚á©</span><sub>f</sub> 0 s) (Œªe. x (Up<span class="hidden">‚á©</span><sub>f</sub> 0 s e)))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>3</span><span> </span><span>X</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(‚ãÉi&lt;Suc 0. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs ! i)) = Tr<span class="hidden">‚á©</span><sub>f</sub> 0 (fs ! 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>step</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>forks_state_update_def</span><span> </span><span>forks_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>ev_fork_idx</span><span> </span><span>step.prems</span><span> </span><span>list_update_nonempty</span><span> </span><span>nth_list_update_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length fs &gt; 0 ‚üπ (FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 0 (fs!0)) = FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 1 fs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1_dir1</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1_dir2</span><span> </span><span>below_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_unfold</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"0 &lt; n ‚üπ length fs = Suc n ‚üπ 
                              FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (Suc n) fs = (FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (butlast fs)|||(FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (fs!n)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>below_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; n ‚üπ length fs = Suc n ‚üπ 
                               FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (Suc n) fs ‚äë (FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (butlast fs)|||FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (fs!n))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span> 
</span><span>        </span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>fs</span><span> 
</span><span>               </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span> 
</span><span>                              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œõ x. (Œªfs. Mprefix (Tr<span class="hidden">‚á©</span><sub>F</sub> (Suc n) fs) (Œªe. x (Up<span class="hidden">‚á©</span><sub>F</sub> fs e)))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>3</span><span> </span><span>X</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>indep</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÄs<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. Tr<span class="hidden">‚á©</span><sub>F</sub> n s<span class="hidden">‚á©</span><sub>1</sub> ‚à© Tr<span class="hidden">‚á©</span><sub>f</sub> n s<span class="hidden">‚á©</span><sub>2</sub> = {}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>forks_transitions_def</span><span> </span><span>fork_transitions_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>indep</span><span> </span><span>dnorm_inter</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>fix_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>forks_transitions_def</span><span> </span><span>Un_commute</span><span> </span><span>lessThan_Suc</span><span> </span><span>nth_butlast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fork e = n"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Up<span class="hidden">‚á©</span><sub>F</sub> fs e)"</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>1</span><span> </span><span>a</span><span> </span><span>butlast_list_update</span><span> </span><span>forks_state_update_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>1</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>ev_fork_idx</span><span> </span><span>lessThan_iff</span><span> </span><span>less_not_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>e</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"e ‚àâ Tr<span class="hidden">‚á©</span><sub>f</sub> n (fs ! n)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ev_fork_idx</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>F</sub> fs e ! n = fs ! n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>2</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>ev_fork_idx</span><span> </span><span>forks_state_update_def</span><span> </span><span>nth_list_update_neq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>F</sub> (butlast fs) e = butlast (Up<span class="hidden">‚á©</span><sub>F</sub> fs e)"</span></span></span><span>       
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>forks_state_update_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>butlast_conv_take</span><span> </span><span>forks_state_update_def</span><span> </span><span>forks_update_take</span><span> </span><span>length_list_update</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Up<span class="hidden">‚á©</span><sub>F</sub> fs e)"</span></span></span><span class="delimiter">]</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>forks_state_update_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>indep</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÄs<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. Tr<span class="hidden">‚á©</span><sub>F</sub> n s<span class="hidden">‚á©</span><sub>1</sub> ‚à© Tr<span class="hidden">‚á©</span><sub>f</sub> n s<span class="hidden">‚á©</span><sub>2</sub> = {}"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>forks_transitions_def</span><span> </span><span>fork_transitions_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; n ‚üπ length fs = Suc n ‚üπ 
                              (FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (butlast fs)|||FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (fs!n)) ‚äë FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (Suc n) fs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>indep</span><span> </span><span>dnorm_inter</span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œªa. 0 &lt; n ‚ü∂ (‚àÄx. length x = Suc n ‚ü∂ a (butlast x, x ! n) ‚äë FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (Suc n) x)"</span></span></span><span class="delimiter">,</span><span> 
</span><span>        </span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span class="delimiter">:</span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>2</span><span> </span><span>X</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span> </span><span>subst</span><span> </span><span>fix_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>forks_transitions_def</span><span> 
</span><span>                                                          </span><span>Un_commute</span><span> </span><span>lessThan_Suc</span><span> </span><span>nth_butlast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fork e = n"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Up<span class="hidden">‚á©</span><sub>F</sub> fs e)"</span></span></span><span class="delimiter">]</span><span>        
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>1</span><span> </span><span>a</span><span> </span><span>butlast_list_update</span><span> </span><span>forks_state_update_def</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>ev_fork_idx</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>e</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>F</sub> (butlast fs) e = butlast (Up<span class="hidden">‚á©</span><sub>F</sub> fs e)"</span></span></span><span>       
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>forks_state_update_def</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>butlast_conv_take</span><span> </span><span>forks_state_update_def</span><span> </span><span>forks_update_take</span><span> </span><span>length_list_update</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Up<span class="hidden">‚á©</span><sub>F</sub> fs e)"</span></span></span><span class="delimiter">]</span><span> </span><span>a</span><span> </span><span>forks_state_update_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ft</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; n ‚üπ FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (replicate n 0) = foldFORKs n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_unfold</span><span> </span><span>FORK<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_is_FORK</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_le_D</span><span> </span><span>butlast_snoc</span><span> </span><span>replicate_Suc</span><span> </span><span>replicate_append_same</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1</span><span> </span><span>One_nat_def</span><span> </span><span>leI</span><span> </span><span>length_replicate</span><span> </span><span>less_Suc0</span><span> </span><span>nth_replicate</span><span> </span><span>replicate_Suc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>FORKs_is_FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> N (replicate N 0) = FORKs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ft</span><span> </span><span>N_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe one-philosopher process in normal form:‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>phil_id</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>phil_state</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rphil_transitions</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"phil_id ‚áí phil_state ‚áí dining_event set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i s = ( if      s = 0  then {picks i i}
                     else if s = 1  then {picks i (i-1)}
                     else if s = 2  then {putsdown i (i-1)} 
                     else if s = 3  then {putsdown i i}
                     else                {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lphil0_transitions</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"phil_state ‚áí dining_event set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s = ( if s = 0       then {picks 0 (N-1)}
                     else if s = 1  then {picks 0 0}
                     else if s = 2  then {putsdown 0 0} 
                     else if s = 3  then {putsdown 0 (N-1)}
                     else                {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>rphil_phil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ‚àà Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i s ‚üπ phil e = i"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lphil0_phil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ‚àà Tr<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s ‚üπ phil e = 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>rphil_transitions_def</span><span> </span><span>lphil0_transitions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>rphil_state_update</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fork_id ‚áí fork_state ‚áí dining_event ‚áí fork_state"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i s e = ( if e = (picks i i)               then 1 
                       else if e = (picks i (i-1))      then 2
                       else if e = (putsdown i (i-1))   then 3
                       else                                  0 )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lphil0_state_update</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fork_state ‚áí dining_event ‚áí fork_state"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s e = ( if e = (picks 0 (N-1))         then 1
                     else if e = (picks 0 0)        then 2 
                     else if e = (putsdown 0 0)     then 3
                     else                                0 )"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fork_id ‚áí fork_state ‚áí dining_event process"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i = P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i,Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i‚üß"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"fork_state ‚áí dining_event process"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> = P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub>,Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub>‚üß"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i = (Œª s. ‚ñ° e ‚àà (Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i s) ‚Üí RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i (Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i s e))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œõ X. (Œªs. Mprefix (Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i s) (Œªe. X (Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i s e)))"</span></span></span><span class="delimiter">]</span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> = (Œª s. ‚ñ° e ‚àà (Tr<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s) ‚Üí LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s e))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œõ X. (Œªs. Mprefix (Tr<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s) (Œªe. X (Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s e)))"</span></span></span><span class="delimiter">]</span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RPHIL_refines_RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i 0 ‚äë RPHIL i"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k_skip</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>4</span><span> 
</span><span>                                 </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œõ x. (Œªs. Mprefix (Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i s) (Œªe. x (Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i s e)))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1::nat) ‚â§ 4"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adm (Œªa. a 0 ‚äë RPHIL i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cont_fun</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄj&lt;4. (iterate j‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë RPHIL i"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>less_2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ãÄj. (j::nat) &lt; 4 = (j = 0 ‚à® j = 1  ‚à® j = 2  ‚à® j = 3)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 0‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë RPHIL i"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 1‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë RPHIL i"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RPHIL_rec</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>rphil_transitions_def</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 2‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë RPHIL i"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RPHIL_rec</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>write0_def</span><span> </span><span>rphil_transitions_def</span><span> 
</span><span>                    </span><span>rphil_state_update_def</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 3‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë RPHIL i"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RPHIL_rec</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>numeral_3_eq_3</span><span> </span><span>write0_def</span><span> </span><span>rphil_transitions_def</span><span> 
</span><span>                    </span><span>rphil_state_update_def</span><span> </span><span>mono_mprefix_ref</span><span> </span><span>minus_suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i_pos</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>4</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 4‚ãÖ?f‚ãÖx) 0 ‚äë RPHIL i"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RPHIL_rec</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>numeral_4_eq_4</span><span> </span><span>rphil_transitions_def</span><span> </span><span>rphil_state_update_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>minus_suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i_pos</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>minus_suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i_pos</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LPHIL0_refines_LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 0 ‚äë LPHIL0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span>
</span><span>      </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k_skip</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>4</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œõ x. (Œªs. Mprefix (Tr<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s) (Œªe. x (Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s e)))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1::nat) ‚â§ 4"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adm (Œªa. a 0 ‚äë LPHIL0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cont_fun</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"‚àÄj&lt;4. (iterate j‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë LPHIL0"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>less_2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚ãÄj. (j::nat) &lt; 4 = (j = 0 ‚à® j = 1  ‚à® j = 2  ‚à® j = 3)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 0‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë LPHIL0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 1‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë LPHIL0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>LPHIL0_rec</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>lphil0_transitions_def</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 2‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë LPHIL0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>LPHIL0_rec</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>numeral_2_eq_2</span><span> </span><span>write0_def</span><span> </span><span>lphil0_transitions_def</span><span> 
</span><span>                    </span><span>lphil0_state_update_def</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 3‚ãÖ?f‚ãÖ‚ä•) 0 ‚äë LPHIL0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>LPHIL0_rec</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>numeral_3_eq_3</span><span> </span><span>write0_def</span><span> </span><span>lphil0_transitions_def</span><span> 
</span><span>                    </span><span>lphil0_state_update_def</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>4</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(iterate 4‚ãÖ?f‚ãÖx) 0 ‚äë LPHIL0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>LPHIL0_rec</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>numeral_4_eq_4</span><span> </span><span>lphil0_transitions_def</span><span> 
</span><span>                  </span><span>lphil0_state_update_def</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_refines_RPHIL</span><span class="delimiter">:</span><span>   
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i_pos</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &gt; 0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"RPHIL i ‚äë RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>RPHIL_def</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k_skip</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1::nat) ‚â§ 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adm (Œªa. a ‚äë RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>4</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>rphil_transitions_def</span><span> </span><span>rphil_state_update_def</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>rphil_transitions_def</span><span> </span><span>rphil_state_update_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>minus_suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i_pos</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>rphil_transitions_def</span><span> </span><span>rphil_state_update_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>minus_suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i_pos</span><span class="delimiter">]</span><span class="delimiter">)</span><span>    
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>rphil_transitions_def</span><span> </span><span>rphil_state_update_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>minus_suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i_pos</span><span class="delimiter">]</span><span class="delimiter">)</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>minus_suc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i_pos</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_refines_LPHIL0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LPHIL0 ‚äë LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 0"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>LPHIL0_def</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k_skip</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(1::nat) ‚â§ 1"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"adm (Œªa. a ‚äë LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>3</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>4</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"iterate 1‚ãÖ?f‚ãÖx ‚äë LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>lphil0_transitions_def</span><span> </span><span>lphil0_state_update_def</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>lphil0_transitions_def</span><span> </span><span>lphil0_state_update_def</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>lphil0_transitions_def</span><span> </span><span>lphil0_state_update_def</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>write0_def</span><span> </span><span>lphil0_transitions_def</span><span> </span><span>lphil0_state_update_def</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_is_RPHIL</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &gt; 0 ‚üπ RPHIL i = RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> i 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>RPHIL_refines_RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_refines_RPHIL</span><span> </span><span>below_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_is_LPHIL0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"LPHIL0 = LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 0"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LPHIL0_refines_LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_refines_LPHIL0</span><span> </span><span>below_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe normal form for the global philosopher network‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>phils_state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>phils_transitions</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ‚áí phils_state ‚áí dining_event set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>P</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>P</sub> n ps = Tr<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> (ps!0) ‚à™ (‚ãÉi‚àà{1..&lt; n}. Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i (ps!i))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>phils_phil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; n ‚üπ e ‚àà Tr<span class="hidden">‚á©</span><sub>P</sub> n s ‚üπ phil e &lt; n"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>phils_transitions_def</span><span> </span><span>lphil0_phil</span><span> </span><span>rphil_phil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phils_transitions_take</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; n ‚üπ Tr<span class="hidden">‚á©</span><sub>P</sub> n ps = Tr<span class="hidden">‚á©</span><sub>P</sub> n (take n ps)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>phils_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>phils_state_update</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"phils_state ‚áí dining_event ‚áí phils_state"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>P</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>P</sub> ps e = (let i=(phil e) in if i = 0 then ps[i:=(Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> (ps!i) e)] 
                                       else          ps[i:=(Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i (ps!i) e)])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>phils_update_take</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"take n (Up<span class="hidden">‚á©</span><sub>P</sub> ps e) = Up<span class="hidden">‚á©</span><sub>P</sub> (take n ps) e"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>e</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>phils_state_update_def</span><span> </span><span>lphil0_state_update_def</span><span> 
</span><span>                              </span><span>rphil_state_update_def</span><span> </span><span>take_update_swap</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ‚áí phils_state ‚áí dining_event process"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n = P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr<span class="hidden">‚á©</span><sub>P</sub> n,Up<span class="hidden">‚á©</span><sub>P</sub>‚üß"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n = (Œª ps. ‚ñ° e ‚àà (Tr<span class="hidden">‚á©</span><sub>P</sub> n ps) ‚Üí PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (Up<span class="hidden">‚á©</span><sub>P</sub> ps e))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œõ X. (Œªps. Mprefix (Tr<span class="hidden">‚á©</span><sub>P</sub> n ps) (Œªe. X (Up<span class="hidden">‚á©</span><sub>P</sub> ps e)))"</span></span></span><span class="delimiter">]</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1_dir1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ps &gt; 0 ‚üπ PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 1 ps ‚äë (LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (ps!0))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span>
</span><span>      </span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>ps</span><span> 
</span><span>             </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span> 
</span><span>                            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œõ x. (Œªps. Mprefix (Tr<span class="hidden">‚á©</span><sub>P</sub> 1 ps) (Œªe. x (Up<span class="hidden">‚á©</span><sub>P</sub> ps e)))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>3</span><span> </span><span>X</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>phils_state_update_def</span><span> </span><span>phils_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ps[0 := Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> (ps ! 0) e]"</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lphil0_transitions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1_dir2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ps &gt; 0 ‚üπ (LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (ps!0)) ‚äë PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 1 ps"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>ps</span><span> </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span> 
</span><span>                                         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œõ x. (Œªs. Mprefix (Tr<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s) (Œªe. x (Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> s e)))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>3</span><span> </span><span>X</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_rec</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>phils_state_update_def</span><span> </span><span>phils_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"ps[0 := Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> (ps ! 0) e]"</span></span></span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lphil0_transitions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ps &gt; 0 ‚üπ PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> 1 ps = (LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (ps!0))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1_dir1</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1_dir2</span><span> </span><span>below_antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_unfold</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>n_pos</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"0 &lt; n"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ps = Suc n ‚üπ 
                            PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (Suc n) ps = (PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (butlast ps)|||(RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (ps!n)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>below_antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ps = Suc n ‚üπ PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (Suc n) ps ‚äë (PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (butlast ps)|||RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (ps!n))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span> 
</span><span>        </span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>ps</span><span> 
</span><span>               </span><span>rule</span><span class="delimiter">:</span><span>fix_ind_k</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>k</span><span class="delimiter">=</span><span>1</span><span> 
</span><span>                              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œõ x. (Œªps. Mprefix (Tr<span class="hidden">‚á©</span><sub>P</sub> (Suc n) ps) (Œªe. x (Up<span class="hidden">‚á©</span><sub>P</sub> ps e)))"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>adm</span><span class="delimiter">:</span><span>1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base_k_steps</span><span class="delimiter">:</span><span>2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="delimiter">(</span><span>3</span><span> </span><span>X</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>indep</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÄs<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. Tr<span class="hidden">‚á©</span><sub>P</sub> n s<span class="hidden">‚á©</span><sub>1</sub> ‚à© Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> n s<span class="hidden">‚á©</span><sub>2</sub> = {}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>phils_phil</span><span> </span><span>rphil_phil</span><span> </span><span>n_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tra</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(Tr<span class="hidden">‚á©</span><sub>P</sub> (Suc n) ps) =(Tr<span class="hidden">‚á©</span><sub>P</sub> n (butlast ps) ‚à™ Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> n (ps ! n))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>n_pos</span><span> </span><span>phils_transitions_def</span><span> </span><span>nth_butlast</span><span> </span><span>Suc_leI</span><span> 
</span><span>                        </span><span>atLeastLessThanSuc</span><span> </span><span>Un_commute</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>indep</span><span> </span><span>dnorm_inter</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>fix_eq</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>tra</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>P</sub> ps e ! n = ps ! n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>phils_phil</span><span> </span><span>phils_state_update_def</span><span> </span><span>step</span><span> </span><span>n_pos</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"phil e"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exists_least_iff</span><span> </span><span>nth_list_update_neq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>P</sub> (butlast ps) e = butlast (Up<span class="hidden">‚á©</span><sub>P</sub> ps e)"</span></span></span><span>       
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"phil e"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>phils_state_update_def</span><span> </span><span>butlast_list_update</span><span> 
</span><span>                                          </span><span>lphil0_state_update_def</span><span> </span><span>rphil_state_update_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length (Up<span class="hidden">‚á©</span><sub>P</sub> ps e) = Suc n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>length_list_update</span><span> </span><span>phils_state_update_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Up<span class="hidden">‚á©</span><sub>P</sub> ps e)"</span></span></span><span class="delimiter">]</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span>e</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length (Up<span class="hidden">‚á©</span><sub>P</sub> ps e) = Suc n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>step</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>length_list_update</span><span> </span><span>phils_state_update_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Up<span class="hidden">‚á©</span><sub>P</sub> ps e)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>e</span><span class="delimiter">]</span><span> </span><span>n_pos</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>butlast_list_update</span><span> </span><span>rphil_phil</span><span> </span><span>phils_state_update_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>disjoint_iff_not_equal</span><span> </span><span>indep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>indep</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"‚àÄs<span class="hidden">‚á©</span><sub>1</sub> s<span class="hidden">‚á©</span><sub>2</sub>. Tr<span class="hidden">‚á©</span><sub>P</sub> n s<span class="hidden">‚á©</span><sub>1</sub> ‚à© Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> n s<span class="hidden">‚á©</span><sub>2</sub> = {}"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>phils_phil</span><span> </span><span>rphil_phil</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>n_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ps = Suc n ‚üπ (PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (butlast ps)|||RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (ps!n)) ‚äë PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (Suc n) ps"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>indep</span><span> </span><span>dnorm_inter</span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>fix_ind</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>        </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Œªa. ‚àÄx. length x = Suc n ‚ü∂ a (butlast x, x ! n) ‚äë PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> (Suc n) x"</span></span></span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">,</span><span> 
</span><span>        </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span> </span><span>base</span><span> </span><span>step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>base</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cont_fun</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>X</span><span> </span><span>ps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>tra</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(Tr<span class="hidden">‚á©</span><sub>P</sub> (Suc n) ps) =(Tr<span class="hidden">‚á©</span><sub>P</sub> n (butlast ps) ‚à™ Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> n (ps ! n))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>n_pos</span><span> </span><span>phils_transitions_def</span><span> </span><span>nth_butlast</span><span> 
</span><span>                        </span><span>Suc_leI</span><span> </span><span>atLeastLessThanSuc</span><span> </span><span>Un_commute</span><span> </span><span>Un_assoc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>indep</span><span> </span><span>dnorm_inter</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>fix_eq</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>tra</span><span class="delimiter">)</span><span>     
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>mono_mprefix_ref</span><span class="delimiter">,</span><span> </span><span>safe</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>P</sub> ps e ! n = ps ! n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>phils_phil</span><span> </span><span>phils_state_update_def</span><span> </span><span>step</span><span> </span><span>n_pos</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"phil e"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>exists_least_iff</span><span> </span><span>nth_list_update_neq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>P</sub> (butlast ps) e = butlast (Up<span class="hidden">‚á©</span><sub>P</sub> ps e)"</span></span></span><span>       
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"phil e"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>phils_state_update_def</span><span> </span><span>butlast_list_update</span><span> 
</span><span>                                          </span><span>lphil0_state_update_def</span><span> </span><span>rphil_state_update_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length (Up<span class="hidden">‚á©</span><sub>P</sub> ps e) = Suc n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>step</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_list_update</span><span> </span><span>phils_state_update_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Up<span class="hidden">‚á©</span><sub>P</sub> ps e)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>e</span><span class="delimiter">]</span><span> </span><span>c</span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length (Up<span class="hidden">‚á©</span><sub>P</sub> ps e) = Suc n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_list_update</span><span> </span><span>phils_state_update_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Up<span class="hidden">‚á©</span><sub>P</sub> ps e)"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>e</span><span class="delimiter">]</span><span> </span><span>n_pos</span><span> 
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>butlast_list_update</span><span> </span><span>rphil_phil</span><span> </span><span>phils_state_update_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>disjoint_iff_not_equal</span><span> </span><span>indep</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"0 &lt; n ‚üπ PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (replicate n 0) = foldPHILs n"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>n</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_unfold</span><span> </span><span>LPHIL0<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_is_LPHIL0</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_le_eq</span><span> </span><span>butlast.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>butlast_snoc</span><span> </span><span>RPHIL<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_is_RPHIL</span><span>
</span><span>                    </span><span>nat_neq_iff</span><span> </span><span>replicate_append_same</span><span> </span><span>replicate_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>leI</span><span> </span><span>length_replicate</span><span> </span><span>less_Suc0</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_1</span><span> </span><span>nth_Cons_0</span><span> </span><span>replicate_Suc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>PHILs_is_PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> N (replicate N 0) = PHILs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>pt</span><span> </span><span>N_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπThe complete process system under normal form‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dining_transitions</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ‚áí phils_state √ó forks_state ‚áí dining_event set"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>D</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Tr<span class="hidden">‚á©</span><sub>D</sub> n = (Œª(ps,fs). (Tr<span class="hidden">‚á©</span><sub>P</sub> n ps) ‚à© (Tr<span class="hidden">‚á©</span><sub>F</sub> n fs))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>dining_state_update</span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"phils_state √ó forks_state ‚áí dining_event ‚áí phils_state √ó forks_state"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>D</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>D</sub> = (Œª(ps,fs) e. (Up<span class="hidden">‚á©</span><sub>P</sub> ps e, Up<span class="hidden">‚á©</span><sub>F</sub> fs e))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat ‚áí phils_state √ó forks_state ‚áí dining_event process"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n = P<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶Tr<span class="hidden">‚á©</span><sub>D</sub> n, Up<span class="hidden">‚á©</span><sub>D</sub>‚üß"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ltsDining_rec</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n = (Œª s. ‚ñ° e ‚àà (Tr<span class="hidden">‚á©</span><sub>D</sub> n s) ‚Üí DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> n (Up<span class="hidden">‚á©</span><sub>D</sub> s e))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fix_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Œõ X. (Œªs. Mprefix (Tr<span class="hidden">‚á©</span><sub>D</sub> n s) (Œªe. X (Up<span class="hidden">‚á©</span><sub>D</sub> s e)))"</span></span></span><span class="delimiter">]</span><span> </span><span>DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DINING_is_DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"DINING = DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> N (replicate N 0, replicate N 0)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> N (replicate N 0, replicate N 0) = 
                                        (PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> N (replicate N 0) || FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub> N (replicate N 0))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span>PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span>FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> </span><span>dining_transitions_def</span><span> 
</span><span>              </span><span>dining_state_update_def</span><span> </span><span>dnorm_par</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>PHILs_is_PHILs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span> </span><span>FORKs_is_FORKs<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span> </span><span>DINING_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>par_comm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπAnd finally: Philosophers may dine ! Always !‚Ä∫</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>lphil_states</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> r e = 0 ‚à® Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> r e = 1 ‚à® Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> r e = 2 ‚à® Up<span class="hidden">‚á©</span><sub>l</sub><span class="hidden">‚á©</span><sub>p</sub> r e = 3"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rphil_states</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i r e = 0 ‚à® Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i r e = 1 ‚à® Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i r e = 2 ‚à® Up<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i r e = 3"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lphil0_state_update_def</span><span> </span><span>rphil_state_update_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dining_events</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"e ‚àà Tr<span class="hidden">‚á©</span><sub>D</sub> N s ‚üπ 
        (‚àÉi‚àà{1..&lt;N}. e = picks i i ‚à® e = picks i (i-1)  ‚à® e = putsdown i i ‚à® e = putsdown i (i-1)) 
     ‚à® (e = picks 0 0 ‚à® e = picks 0 (N-1) ‚à® e = putsdown 0 0 ‚à® e = putsdown 0 (N-1))"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>dining_transitions_def</span><span> </span><span>phils_transitions_def</span><span> </span><span>rphil_transitions_def</span><span> 
</span><span>                    </span><span>lphil0_transitions_def</span><span> </span><span>split</span><span class="delimiter">:</span><span>prod.splits</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inv_dining ps fs ‚â°      
            (‚àÄi. Suc i &lt; N ‚ü∂  ((fs!(Suc i) = 1) ‚ü∑ ps!Suc i ‚â† 0)) ‚àß (fs!(N-1) = 2 ‚ü∑ ps!0 ‚â† 0)
          ‚àß (‚àÄi &lt; N - 1.                 fs!i = 2 ‚ü∑  ps!Suc i = 2)  ‚àß   (fs!0 = 1 ‚ü∑ ps!0 = 2)
          ‚àß (‚àÄi &lt; N. fs!i = 0 ‚à® fs!i = 1 ‚à® fs!i = 2) 
          ‚àß (‚àÄi &lt; N. ps!i = 0 ‚à® ps!i = 1 ‚à® ps!i = 2 ‚à® ps!i = 3)
          ‚àß length fs = N ‚àß length ps = N"</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_DINING</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ‚àà ‚Ñú (Tr<span class="hidden">‚á©</span><sub>D</sub> N) Up<span class="hidden">‚á©</span><sub>D</sub> (replicate N 0, replicate N 0) ‚üπ inv_dining (fst s) (snd s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>‚Ñú.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>rbase</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_dining_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>dining_transitions_def</span><span> </span><span>phils_transitions_def</span><span> </span><span>forks_transitions_def</span><span>
</span><span>                 </span><span>lphil0_transitions_def</span><span> </span><span>rphil_transitions_def</span><span> </span><span>fork_transitions_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rstep</span><span> </span><span>s</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rstep</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>dining_transitions_def</span><span> </span><span>phils_transitions_def</span><span> </span><span>forks_transitions_def</span><span>
</span><span>                       </span><span>lphil0_transitions_def</span><span> </span><span>rphil_transitions_def</span><span> </span><span>fork_transitions_def</span><span>
</span><span>                       </span><span>lphil0_state_update_def</span><span> </span><span>rphil_state_update_def</span><span> </span><span>fork_state_update_def</span><span> 
</span><span>                       </span><span>dining_state_update_def</span><span> </span><span>phils_state_update_def</span><span> </span><span>forks_state_update_def</span><span> 
</span><span>                   </span><span>split</span><span class="delimiter">:</span><span>if_splits</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_dining_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>goal_cases</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>ps</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nth_list_update</span><span class="delimiter">)</span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>ps</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nth_list_update</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>ps</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>4</span><span> </span><span>ps</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nth_list_update</span><span class="delimiter">)</span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>5</span><span> </span><span>ps</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>6</span><span> </span><span>ps</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nth_list_update</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>7</span><span> </span><span>ps</span><span> </span><span>fs</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nth_list_update</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span>  </span><span>auto</span><span class="delimiter">[</span><span>1</span><span class="delimiter">]</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>N_pos</span><span> </span><span>Suc_pred</span><span> </span><span>less_antisym</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span>zero_neq_numeral</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>8</span><span> </span><span>ps</span><span> </span><span>fs</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nth_list_update</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"8"</span></span></span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>zero_neq_one</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>9</span><span> </span><span>ps</span><span> </span><span>fs</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nth_list_update</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>N_pos</span><span> </span><span>Suc_pred</span><span> </span><span>less_antisym</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>n_not_Suc_n</span><span> </span><span>numeral_2_eq_2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>10</span><span> </span><span>ps</span><span> </span><span>fs</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nth_list_update</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>impI</span><span> </span><span>conjI</span><span> </span><span>allI</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="string"><span class="delete"><span class="delete">"10"</span></span></span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"10"</span></span></span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>n_not_Suc_n</span><span> </span><span>numeral_2_eq_2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inv_implies_DF</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"inv_dining ps fs ‚üπ Tr<span class="hidden">‚á©</span><sub>D</sub> N (ps, fs) ‚â† {}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>inv_dining_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>dining_transitions_def</span><span> </span><span>phils_transitions_def</span><span> </span><span>forks_transitions_def</span><span>
</span><span>                 </span><span>lphil0_transitions_def</span><span>
</span><span>             </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span> </span><span>prod.splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>conjE</span><span class="delimiter">,</span><span> </span><span>intro</span><span> </span><span>conjI</span><span> </span><span>impI</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"putsdown 0 (N - Suc 0) ‚àà (‚ãÉi&lt;N. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs ! i))"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>2</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"putsdown 0 0 ‚àà (‚ãÉi&lt;N. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs ! i))"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span class="delimiter">)</span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>3</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fs!0 = 0 ‚üπ picks 0 0 ‚àà (‚ãÉi&lt;N. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs ! i))"</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ps!1 = 2 ‚üπ putsdown 1 0 ‚àà (‚ãÉx‚àà{Suc 0..&lt;N}. Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> x (ps ! x))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>rphil_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fs!0 = 2 ‚üπ putsdown 1 0 ‚àà Tr<span class="hidden">‚á©</span><sub>f</sub> 0 (fs ! 0)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fs!0 ‚â† 0 ‚üπ ps!1 = 2"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>N_pos</span><span> </span><span>N_pos_simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>One_nat_def</span><span> </span><span>diff_is_0_eq</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fs!0 ‚â† 0 ‚üπ fs!0 = 2"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"fs!0 = 0"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fork_transitions_def</span><span> </span><span>Un_insert_left</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span>b2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>d</span><span class="delimiter">]</span><span> </span><span>N_pos</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>4</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>N_pos</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>41</span><span class="delimiter">:</span><span>1</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fs!0 = 0 *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>4</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>N_g1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>411</span><span class="delimiter">:</span><span>1</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fs!1 = 0 *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>411</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ps!1 = 0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>N_g1</span><span> </span><span>One_nat_def</span><span> </span><span>neq0_conv</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>411</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"picks 1 1 ‚àà (‚ãÉi&lt;N. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs ! i))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>N_g1</span><span> </span><span>Int_Collect</span><span> </span><span>One_nat_def</span><span> </span><span>lessThan_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>411</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ps!1 = 0 ‚üπ picks 1 1 ‚àà (‚ãÉi‚àà{Suc 0..&lt;N}. Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i (ps ! i))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>rphil_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>411</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>412</span><span class="delimiter">:</span><span>2</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fs!1 = 1 *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ps!1 = 1 ‚à® ps!1 = 3"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>N_g1</span><span> </span><span>One_nat_def</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>412</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>disjE</span><span class="delimiter">,</span><span> </span><span>goal_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>4121</span><span class="delimiter">:</span><span>1</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ps!1 = 1 *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>4121</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"picks 1 0 ‚àà (‚ãÉi&lt;N. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs ! i))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>Int_Collect</span><span> </span><span>N_g1</span><span> </span><span>N_pos</span><span> </span><span>One_nat_def</span><span> </span><span>lessThan_iff</span><span> </span><span>mod_less</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>4121</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"picks 1 0 ‚àà (‚ãÉi‚àà{Suc 0..&lt;N}. Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i (ps ! i))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>rphil_transitions_def</span><span class="delimiter">)</span><span>         
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>4121</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b1</span><span> </span><span>b2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>4122</span><span class="delimiter">:</span><span>2</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ps!1 = 3 *)</span></span></span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>4122</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"putsdown 1 1 ‚àà (‚ãÉi&lt;N. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs ! i))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span class="delimiter">)</span><span>  
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>4122</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>b4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"putsdown 1 1 ‚àà (‚ãÉi‚àà{Suc 0..&lt;N}. Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i (ps ! i))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>rphil_transitions_def</span><span class="delimiter">)</span><span>           
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>b3</span><span> </span><span>b4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>413</span><span class="delimiter">:</span><span>3</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fs!1 = 2 *)</span></span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"N = 2"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>413</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span>413</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ps!2 = 2"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>N_g1</span><span> </span><span>Suc_1</span><span> </span><span>Suc_diff_1</span><span> </span><span>nat_neq_iff</span><span> </span><span>not_gr0</span><span> </span><span>zero_less_diff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span>413</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"putsdown 2 1 ‚àà (‚ãÉi&lt;N. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs ! i))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>linarith</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span>413</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ps!2 = 2 ‚üπ putsdown 2 1 ‚àà (‚ãÉi‚àà{Suc 0..&lt;N}. Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i (ps ! i))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>rphil_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>413</span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c0</span><span> </span><span>c1</span><span> </span><span>c2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>42</span><span class="delimiter">:</span><span>2</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fs!0 = 1 *)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>43</span><span class="delimiter">:</span><span>3</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* fs!0 = 2*)</span></span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>43</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ps!1 = 2"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>One_nat_def</span><span> </span><span>gr0I</span><span class="delimiter">)</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>43</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"putsdown 1 0 ‚àà (‚ãÉi&lt;N. Tr<span class="hidden">‚á©</span><sub>f</sub> i (fs ! i))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fork_transitions_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>43</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ps!1 = 2 ‚üπ putsdown 1 0 ‚àà (‚ãÉi‚àà{Suc 0..&lt;N}. Tr<span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>p</sub> i (ps ! i))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>rphil_transitions_def</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>N_g1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>43</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>d0</span><span> </span><span>d1</span><span> </span><span>d2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>5</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>5</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>DF_DINING</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"deadlock_free_v2 DINING"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>DINING_is_DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub></span><span> </span><span>DINING<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inv_DINING</span><span> </span><span>inv_implies_DF</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>deadlock_free_dnorm</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="Conclusion">
<div class="head"><h1>Theory Conclusion</h1>
<span class="command">theory</span> <span class="name">Conclusion</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOLCF/HOLCF.html"><span class="name">HOLCF</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment">‚Äï‚Äπ ******************************************************************** 
 * Project         : CSP-RefTK - A Refinement Toolkit for HOL-CSP
 * Version         : 1.0
 *
 * Author          : Burkhart Wolff, Safouan Taha, Lina Ye.
 *
 * This file       : Conclusion
 *
 * Copyright (c) 2020 Universit√© Paris-Saclay, France
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *
 *     * Redistributions in binary form must reproduce the above
 *       copyright notice, this list of conditions and the following
 *       disclaimer in the documentation and/or other materials provided
 *       with the distribution.
 *
 *     * Neither the name of the copyright holders nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************‚Ä∫</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">chapter</span></span><span class="cartouche"><span class="delete"><span class="delete">‚ÄπConclusion‚Ä∫</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Conclusion</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HOLCF</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‚Äπ We presented a formalisation of the most comprehensive semantic model for CSP, a 'classical' 
language for the specification and analysis of concurrent systems studied in a rich body of 
literature. For this purpose, we ported @{cite "tej.ea:corrected:1997"} to a modern version
of Isabelle, restructured the proofs, and extended the resulting theory of the language 
substantially. The result HOL-CSP 2 has been submitted to the Isabelle AFP @{cite "HOL-CSP-AFP"}, 
thus a fairly sustainable format accessible to other researchers and tools.

We developed a novel set of deadlock - and livelock inference proof principles based on 
classical and denotational characterizations. In particular, we formally investigated the relations
between different refinement notions in the presence of deadlock - and livelock; an area where
traditional CSP literature skates over the nitty-gritty details. Finally, we demonstrated how to
exploit these results for deadlock/livelock analysis of protocols.

We put a large body of abstract CSP laws and induction principles together to form
concrete verification technologies for generalized classical problems, which have been considered
so far from the perspective of data-independence or structural parametricity. The underlying novel
principle of ``trading rich structure against rich state'' allows one to convert processes 
into classical transition systems for which established invariant techniques become applicable.

Future applications of HOL-CSP 2 could comprise a combination with model checkers, where our theory
with its derived rules can be used to certify the output of a model-checker over CSP. In our experience,
labelled transition systems generated by model checkers may be used to steer inductions or to construct
the normalized processes ‚ÄπP<span class="hidden">‚á©</span><sub>n</sub><span class="hidden">‚á©</span><sub>o</sub><span class="hidden">‚á©</span><sub>r</sub><span class="hidden">‚á©</span><sub>m</sub>‚ü¶œÑ<span class="hidden">‚á©</span><sub>,</sub>œÖ‚üß‚Ä∫ automatically, thus combining efficient finite reasoning 
over finite sub-systems with globally infinite systems in a logically safe way. 
‚Ä∫</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span></pre>
</div>
</div>