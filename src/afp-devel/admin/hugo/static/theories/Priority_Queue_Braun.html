<div id="Priority_Queue_Braun">
<div class="head">
<h1>Theory Priority_Queue_Braun</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Priority Queues Based on Braun Trees"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Priority_Queue_Braun
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Tree_Multiset.html">HOL-Library.Tree_Multiset</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Pattern_Aliases.html">HOL-Library.Pattern_Aliases</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Data_Structures/Priority_Queue_Specs.html">HOL-Data_Structures.Priority_Queue_Specs</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Data_Structures/Braun_Tree.html">HOL-Data_Structures.Braun_Tree</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Introduction"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Braun, Rem and Hoogerwoord \cite{BraunRem,Hoogerwoord} used
specific balanced binary trees, often called Braun trees (where in
each node with subtrees $l$ and $r$, $size(r) \le size(l) \le
size(r)+1$), to implement flexible arrays. Paulson \cite{Paulson}
(based on code supplied by Okasaki)
implemented priority queues via Braun trees. This theory verifies
Paulsons's implementation, with small simplifications.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Direct proof of logarithmic height. Also follows from the fact that Braun
trees are balanced (proved in the base theory).›</span></span>

<span class="keyword1" id="Priority_Queue_Braun-height_size_braun"><span class="command">lemma</span></span> height_size_braun<span class="main">:</span> <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> <span class="numeral">2</span> <span class="main">^</span> <span class="main">(</span>height <span class="free">t</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> size <span class="free">t</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Node <span class="skolem">t1</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"height <span class="skolem">t1</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Node <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"<span class="numeral">2</span> <span class="main">^</span> <span class="skolem">n</span> <span class="main">≤</span> size <span class="skolem">t1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Node <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> Suc Node <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> max_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Get Minimum"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">get_min</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder tree <span class="main">⇒</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">get_min</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span>"</span></span>

<span class="keyword1" id="Priority_Queue_Braun-get_min"><span class="command">lemma</span></span> get_min<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> heap <span class="free">t</span><span class="main">;</span>  <span class="free">t</span> <span class="main">≠</span> Leaf <span class="main">⟧</span> <span class="main">⟹</span> get_min <span class="free">t</span> <span class="main">=</span> Min_mset <span class="main">(</span>mset_tree <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_Min_iff neq_Leaf_iff<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Insertion›</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">open</span></span><span class="main">)</span> insert

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">insert</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">insert</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> Leaf <span class="main">=</span> Node Leaf <span class="free"><span class="bound"><span class="entity">a</span></span></span> Leaf"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">insert</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span>
 <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> Node <span class="main">(</span><span class="free">insert</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">else</span> Node <span class="main">(</span><span class="free">insert</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Priority_Queue_Braun-size_insert"><span class="command">lemma</span></span> size_insert<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"size<span class="main">(</span>insert <span class="free">x</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> size <span class="free">t</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Priority_Queue_Braun-mset_insert"><span class="command">lemma</span></span> mset_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"mset_tree<span class="main">(</span>insert <span class="free">x</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span> <span class="main">+</span> mset_tree <span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-set_insert"><span class="command">lemma</span></span> set_insert<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"set_tree<span class="main">(</span>insert <span class="free">x</span> <span class="free">t</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>set_tree <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mset_insert <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> set_mset_tree<span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-braun_insert"><span class="command">lemma</span></span> braun_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> braun<span class="main">(</span>insert <span class="free">x</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Priority_Queue_Braun-heap_insert"><span class="command">lemma</span></span> heap_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"heap <span class="free">t</span> <span class="main">⟹</span> heap<span class="main">(</span>insert <span class="free">x</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span>  <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ball_Un<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Deletion›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Slightly simpler definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">text</span></span> <span class="raw_text"><span class="raw_text">del_left</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
which avoids the need to appeal to the Braun invariant.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">del_left</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">*</span> <span class="tfree">'a</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">del_left</span> <span class="main">(</span>Node Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">del_left</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">l'</span><span class="main">)</span> <span class="main">=</span> <span class="free">del_left</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">in</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span>Node <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">l'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Priority_Queue_Braun-del_left_mset_plus"><span class="command">lemma</span></span> del_left_mset_plus<span class="main">:</span>
  <span class="quoted"><span class="quoted">"del_left <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">t'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">≠</span> Leaf
  <span class="main">⟹</span> mset_tree <span class="free">t</span> <span class="main">=</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span> <span class="main">+</span> mset_tree <span class="free">t'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">t'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> del_left.induct<span class="main"><span class="keyword3">;</span></span>
    <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-del_left_mset"><span class="command">lemma</span></span> del_left_mset<span class="main">:</span>
  <span class="quoted"><span class="quoted">"del_left <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">t'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">≠</span> Leaf
  <span class="main">⟹</span> <span class="free">x</span> <span class="main">∈#</span> mset_tree <span class="free">t</span> <span class="main">∧</span> mset_tree <span class="free">t'</span> <span class="main">=</span> mset_tree <span class="free">t</span> <span class="main">-</span> <span class="main">{#</span><span class="free">x</span><span class="main">#}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> del_left_mset_plus<span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-del_left_set"><span class="command">lemma</span></span> del_left_set<span class="main">:</span>
  <span class="quoted"><span class="quoted">"del_left <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">t'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">≠</span> Leaf <span class="main">⟹</span> set_tree <span class="free">t</span> <span class="main">=</span> <span class="main">{</span><span class="free">x</span><span class="main">}</span> <span class="main">∪</span> set_tree <span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> del_left_mset_plus <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> set_mset_tree<span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-del_left_heap"><span class="command">lemma</span></span> del_left_heap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"del_left <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">t'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">≠</span> Leaf <span class="main">⟹</span> heap <span class="free">t</span> <span class="main">⟹</span> heap <span class="free">t'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">t'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> del_left.induct<span class="main"><span class="keyword3">;</span></span>
    <span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> del_left_set<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equalityD2<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-del_left_size"><span class="command">lemma</span></span> del_left_size<span class="main">:</span>
  <span class="quoted"><span class="quoted">"del_left <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">t'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">≠</span> Leaf <span class="main">⟹</span> size <span class="free">t</span> <span class="main">=</span> size <span class="free">t'</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">t'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> del_left.induct<span class="main"><span class="keyword3">;</span></span>
    <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-del_left_braun"><span class="command">lemma</span></span> del_left_braun<span class="main">:</span>
  <span class="quoted"><span class="quoted">"del_left <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">t'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">≠</span> Leaf <span class="main">⟹</span> braun <span class="free">t</span> <span class="main">⟹</span> braun <span class="free">t'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">t'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> del_left.induct<span class="main"><span class="keyword3">;</span></span>
    <span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> del_left_size<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> pattern_aliases
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Slightly simpler definition: <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>_›</span></span></span></span> instead of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> Leaf<span class="antiquote"><span class="antiquote">}</span></span></span></span> because of Braun invariant.›</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>sequential<span class="main">)</span> <span class="entity">sift_down</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder tree <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">sift_down</span> Leaf <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> Node Leaf <span class="free"><span class="bound"><span class="entity">a</span></span></span> Leaf"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">sift_down</span> <span class="main">(</span>Node Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> Leaf <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> Node <span class="main">(</span>Node Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span> Leaf<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> Leaf
   <span class="keyword1">else</span> Node <span class="main">(</span>Node Leaf <span class="free"><span class="bound"><span class="entity">a</span></span></span> Leaf<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> Leaf<span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">sift_down</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span> <span class="main">=:</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span> <span class="main">=:</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span>
   <span class="keyword1">then</span> Node <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span> <span class="keyword1">then</span> Node <span class="main">(</span><span class="free">sift_down</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span>
        <span class="keyword1">else</span> Node <span class="free"><span class="bound"><span class="entity">t1</span></span></span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span> <span class="main">(</span><span class="free">sift_down</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">termination</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">%</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">r</span><span class="main">)</span><span class="main">.</span> size <span class="bound">l</span> <span class="main">+</span> size <span class="bound">r</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Priority_Queue_Braun-size_sift_down"><span class="command">lemma</span></span> size_sift_down<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun<span class="main">(</span>Node <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> size<span class="main">(</span>sift_down <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> size <span class="free">l</span> <span class="main">+</span> size <span class="free">r</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sift_down.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-braun_sift_down"><span class="command">lemma</span></span> braun_sift_down<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun<span class="main">(</span>Node <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> braun<span class="main">(</span>sift_down <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sift_down.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> size_sift_down Let_def<span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-mset_sift_down"><span class="command">lemma</span></span> mset_sift_down<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun<span class="main">(</span>Node <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> mset_tree<span class="main">(</span>sift_down <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">{#</span><span class="free">a</span><span class="main">#}</span> <span class="main">+</span> <span class="main">(</span>mset_tree <span class="free">l</span> <span class="main">+</span> mset_tree <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sift_down.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-set_sift_down"><span class="command">lemma</span></span> set_sift_down<span class="main">:</span> <span class="quoted"><span class="quoted">"braun<span class="main">(</span>Node <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span>
  <span class="main">⟹</span> set_tree<span class="main">(</span>sift_down <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="free">a</span><span class="main">}</span> <span class="main">∪</span> <span class="main">(</span>set_tree <span class="free">l</span> <span class="main">∪</span> set_tree <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">drule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">set_mset</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> mset_sift_down<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-heap_sift_down"><span class="command">lemma</span></span> heap_sift_down<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun<span class="main">(</span>Node <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> heap <span class="free">l</span> <span class="main">⟹</span> heap <span class="free">r</span> <span class="main">⟹</span> heap<span class="main">(</span>sift_down <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">a</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sift_down.induct<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_sift_down ball_Un Let_def<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">del_min</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">del_min</span> Leaf <span class="main">=</span> Leaf"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">del_min</span> <span class="main">(</span>Node Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> Leaf"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">del_min</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">l'</span><span class="main">)</span> <span class="main">=</span> del_left <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">in</span> sift_down <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">y</span> <span class="bound">l'</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Priority_Queue_Braun-braun_del_min"><span class="command">lemma</span></span> braun_del_min<span class="main">:</span> <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> braun<span class="main">(</span>del_min <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> del_min.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> braun_sift_down
  <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> del_left_size del_left_braun<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Priority_Queue_Braun-heap_del_min"><span class="command">lemma</span></span> heap_del_min<span class="main">:</span> <span class="quoted"><span class="quoted">"heap <span class="free">t</span> <span class="main">⟹</span> braun <span class="free">t</span> <span class="main">⟹</span> heap<span class="main">(</span>del_min <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> del_min.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> heap_sift_down
  <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> del_left_size del_left_braun del_left_heap<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Priority_Queue_Braun-size_del_min"><span class="command">lemma</span></span> size_del_min<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"braun <span class="free">t</span>"</span></span> <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"size<span class="main">(</span>del_min <span class="free">t</span><span class="main">)</span> <span class="main">=</span> size <span class="free">t</span> <span class="main">-</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> del_min.cases<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>3 <span class="skolem">ll</span> <span class="skolem">b</span> <span class="skolem">lr</span> <span class="skolem">a</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">y</span> <span class="skolem">l'</span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"del_left <span class="main">(</span>Node <span class="skolem">ll</span> <span class="skolem">b</span> <span class="skolem">lr</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">l'</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">"size<span class="main">(</span>sift_down <span class="skolem">r</span> <span class="skolem">y</span> <span class="skolem">l'</span><span class="main">)</span> <span class="main">=</span> size <span class="free">t</span> <span class="main">-</span> <span class="main">1</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> size_sift_down<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> del_left_size del_left_braun<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">insert</span> assms<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun-mset_del_min"><span class="command">lemma</span></span> mset_del_min<span class="main">:</span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"braun <span class="free">t</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≠</span> Leaf"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"mset_tree<span class="main">(</span>del_min <span class="free">t</span><span class="main">)</span> <span class="main">=</span> mset_tree <span class="free">t</span> <span class="main">-</span> <span class="main">{#</span>get_min <span class="free">t</span><span class="main">#}</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> del_min.cases<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="main">(</span>3 <span class="skolem">ll</span> <span class="skolem">b</span> <span class="skolem">lr</span> <span class="skolem">a</span> <span class="skolem">r</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"mset_tree<span class="main">(</span>sift_down <span class="skolem">r</span> <span class="skolem">y</span> <span class="skolem">l'</span><span class="main">)</span> <span class="main">=</span> mset_tree <span class="free">t</span> <span class="main">-</span> <span class="main">{#</span><span class="skolem">a</span><span class="main">#}</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> del<span class="main">:</span> <span class="quoted"><span class="quoted">"del_left <span class="main">(</span>Node <span class="skolem">ll</span> <span class="skolem">b</span> <span class="skolem">lr</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">y</span><span class="main">,</span><span class="skolem">l'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="skolem">l'</span>
    <span class="keyword1"><span class="command">using</span></span> assms del_left_mset<span class="main">[</span><span class="operator">OF</span> del<span class="main">]</span> del_left_size<span class="main">[</span><span class="operator">OF</span> del<span class="main">]</span>
      del_left_braun<span class="main">[</span><span class="operator">OF</span> del<span class="main">]</span> del_left_mset_plus<span class="main">[</span><span class="operator">OF</span> del<span class="main">]</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> mset_sift_down<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span> del_left_mset_plus<span class="main"><span class="main">[</span></span><span class="operator">OF</span> del<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Last step: prove all axioms of the priority queue specification:›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> braun<span class="main">:</span> Priority_Queue
<span class="keyword2"><span class="keyword">where</span></span> empty <span class="main">=</span> <span class="quoted">Leaf</span> <span class="keyword2"><span class="keyword">and</span></span> is_empty <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="bound">h</span> <span class="main">=</span> Leaf"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> insert <span class="main">=</span> <span class="quoted">insert</span> <span class="keyword2"><span class="keyword">and</span></span> del_min <span class="main">=</span> <span class="quoted">del_min</span>
<span class="keyword2"><span class="keyword">and</span></span> get_min <span class="main">=</span> <span class="quoted">get_min</span> <span class="keyword2"><span class="keyword">and</span></span> invar <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">h</span><span class="main">.</span> braun <span class="bound">h</span> <span class="main">∧</span> heap <span class="bound">h</span>"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> mset <span class="main">=</span> <span class="quoted">mset_tree</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 3 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mset_insert<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 4 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mset_del_min<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 5 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> get_min mset_tree.simps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 6 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 7 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_insert braun_insert<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 8 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_del_min braun_del_min<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Priority_Queue_Braun2">
<div class="head">
<h1>Theory Priority_Queue_Braun2</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Priority Queues Based on Braun Trees 2"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Priority_Queue_Braun2
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Priority_Queue_Braun.html">Priority_Queue_Braun</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This is the version verified by Jean-Christophe Filliâtre with the help of the Why3 system
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹http://toccata.lri.fr/gallery/braun_trees.en.html›</span></span>.
Only the deletion function (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>del_min2›</span></span></span></span> below) differs from Paulson's version.
But the difference turns out to be minor --- see below.›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Function <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>del_min2›</span></span></span></span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">le_root</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">le_root</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> Leaf <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> value <span class="free"><span class="bound"><span class="entity">t</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">replace_min</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">replace_min</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> le_root <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">&amp;</span> le_root <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">then</span> Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>
   <span class="keyword1">else</span>
     <span class="keyword1">let</span> <span class="bound">a</span> <span class="main">=</span> value <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">in</span>
     <span class="keyword1">if</span> le_root <span class="bound">a</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">then</span> Node <span class="main">(</span><span class="free">replace_min</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="bound">a</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>
     <span class="keyword1">else</span> Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">(</span>value <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">replace_min</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder tree <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">merge</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> Leaf <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">merge</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="keyword1">then</span> Node <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="main">(</span><span class="free">merge</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span>
    <span class="keyword1">else</span> <span class="keyword1">let</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">l'</span><span class="main">)</span> <span class="main">=</span> del_left <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span>
         <span class="keyword1">in</span> Node <span class="main">(</span>replace_min <span class="bound">x</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="bound">l'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">del_min2</span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">del_min2</span> Leaf <span class="main">=</span> Leaf"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">del_min2</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> merge <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">"Correctness Proof"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹It turns out that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> replace_min<span class="antiquote"><span class="antiquote">}</span></span></span></span> is just <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> sift_down<span class="antiquote"><span class="antiquote">}</span></span></span></span> in disguise:›</span></span>

<span class="keyword1" id="Priority_Queue_Braun2-replace_min_sift_down"><span class="command">lemma</span></span> replace_min_sift_down<span class="main">:</span> <span class="quoted"><span class="quoted">"braun <span class="main">(</span>Node <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> replace_min <span class="free">x</span> <span class="main">(</span>Node <span class="free">l</span> <span class="free">a</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> sift_down <span class="free">l</span> <span class="free">x</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sift_down.induct<span class="main">)</span><span class="main">(</span><span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This means that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> del_min2<span class="antiquote"><span class="antiquote">}</span></span></span></span> is merely a slight optimization of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> del_min<span class="antiquote"><span class="antiquote">}</span></span></span></span>:
instead of calling <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> del_left<span class="antiquote"><span class="antiquote">}</span></span></span></span> right away, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> merge<span class="antiquote"><span class="antiquote">}</span></span></span></span> can take advantage of the case
where the smaller element is at the root of the left heap and can be moved up without complications.
However, on average this is just the case on the first level.›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> merge<span class="antiquote"><span class="antiquote">}</span></span></span></span>:›</span></span>

<span class="keyword1" id="Priority_Queue_Braun2-mset_tree_merge"><span class="command">lemma</span></span> mset_tree_merge<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> mset_tree<span class="main">(</span>merge <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> mset_tree <span class="free">l</span> <span class="main">+</span> mset_tree <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge.induct<span class="main">)</span>
  <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def tree.set_sel<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> mset_sift_down replace_min_sift_down
        <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> replace_min.simps <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> del_left_mset <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun2-heap_merge"><span class="command">lemma</span></span> heap_merge<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> braun <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span><span class="main">;</span> heap <span class="free">l</span><span class="main">;</span> heap <span class="free">r</span> <span class="main">⟧</span> <span class="main">⟹</span> heap<span class="main">(</span>merge <span class="free">l</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">l1</span> <span class="skolem">a1</span> <span class="skolem">r1</span> <span class="skolem">l2</span> <span class="skolem">a2</span> <span class="skolem">r2</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">a1</span> <span class="main">≤</span> <span class="skolem">a2</span>"</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> 2 <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ball_Un mset_tree_merge <span class="quasi_keyword">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> set_mset_tree<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> <span class="skolem">a1</span> <span class="main">≤</span> <span class="skolem">a2</span>"</span></span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?l</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Node <span class="skolem">l1</span> <span class="skolem">a1</span> <span class="skolem">r1</span>"</span></span> <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"Node <span class="skolem">l2</span> <span class="skolem">a2</span> <span class="skolem">r2</span>"</span></span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"braun <span class="var">?r</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.prems"</span><span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">l'</span></span> <span class="keyword2"><span class="keyword">where</span></span> dl<span class="main">:</span> <span class="quoted"><span class="quoted">"del_left <span class="var">?l</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">l'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> surj_pair<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> del_left_heap<span class="main">[</span><span class="operator">OF</span> this _ <span class="quoted">"2.prems"</span><span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"heap <span class="skolem">l'</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">have</span></span> hr<span class="main">:</span> <span class="quoted"><span class="quoted">"heap<span class="main">(</span>replace_min <span class="skolem">x</span> <span class="var">?r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹braun <span class="var">?r</span>›</span></span> <span class="quoted">"2.prems"</span><span class="main">(</span>3<span class="main">)</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_sift_down neq_Leaf_iff replace_min_sift_down <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> replace_min.simps<span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> 0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set_tree <span class="var">?l</span><span class="main">.</span> <span class="skolem">a2</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"2.prems"</span><span class="main">(</span>2<span class="main">)</span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">a1</span> <span class="main">≤</span> <span class="skolem">a2</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ball_Un<span class="main">)</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"set_tree <span class="skolem">l'</span> <span class="main">⊆</span> set_tree <span class="var">?l</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> set_tree <span class="var">?l</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> del_left_mset<span class="main">[</span><span class="operator">OF</span> dl<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> set_mset_tree <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>in_diffD <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> union_iff<span class="main">)</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> 1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set_tree <span class="skolem">l'</span><span class="main">.</span> <span class="skolem">a2</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> set_tree <span class="var">?r</span><span class="main">.</span> <span class="skolem">a2</span> <span class="main">≤</span> <span class="bound">x</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹heap <span class="var">?r</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">a1</span> <span class="main">≤</span> <span class="skolem">a2</span>›</span></span> dl <span class="quoted"><span class="quoted">‹heap<span class="main">(</span>replace_min <span class="skolem">x</span> <span class="var">?r</span><span class="main">)</span>›</span></span> <span class="quoted"><span class="quoted">‹heap <span class="skolem">l'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">∈</span> set_tree <span class="var">?l</span>›</span></span> 0 1 <span class="quoted"><span class="quoted">‹braun <span class="var">?r</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mset_sift_down replace_min_sift_down <span class="quasi_keyword">simp</span> <span class="quasi_keyword">flip</span><span class="main"><span class="main">:</span></span> set_mset_tree
              <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> replace_min.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 3 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Priority_Queue_Braun2-del_left_braun_size"><span class="command">lemma</span></span> del_left_braun_size<span class="main">:</span>
  <span class="quoted"><span class="quoted">"del_left <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">t'</span><span class="main">)</span> <span class="main">⟹</span> braun <span class="free">t</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">≠</span> Leaf <span class="main">⟹</span> braun <span class="free">t'</span> <span class="main">∧</span> size <span class="free">t</span> <span class="main">=</span> size <span class="free">t'</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> del_left_braun del_left_size<span class="main">)</span>

<span class="keyword1" id="Priority_Queue_Braun2-braun_size_merge"><span class="command">lemma</span></span> braun_size_merge<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> braun<span class="main">(</span>merge <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">∧</span> size<span class="main">(</span>merge <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> size <span class="free">l</span> <span class="main">+</span> size <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> size_sift_down braun_sift_down replace_min_sift_down
           <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> replace_min.simps
           <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> del_left_braun_size <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Last step: prove all axioms of the priority queue specification:›</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> braun<span class="main">:</span> Priority_Queue
<span class="keyword2"><span class="keyword">where</span></span> empty <span class="main">=</span> <span class="quoted">Leaf</span> <span class="keyword2"><span class="keyword">and</span></span> is_empty <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">h</span><span class="main">.</span> <span class="bound">h</span> <span class="main">=</span> Leaf"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> insert <span class="main">=</span> <span class="quoted">insert</span> <span class="keyword2"><span class="keyword">and</span></span> del_min <span class="main">=</span> <span class="quoted">del_min2</span>
<span class="keyword2"><span class="keyword">and</span></span> get_min <span class="main">=</span> <span class="quoted">get_min</span> <span class="keyword2"><span class="keyword">and</span></span> invar <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">h</span><span class="main">.</span> braun <span class="bound">h</span> <span class="main">∧</span> heap <span class="bound">h</span>"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> mset <span class="main">=</span> <span class="quoted">mset_tree</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 3 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mset_insert<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 4 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> mset_tree_merge neq_Leaf_iff<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 5 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> get_min mset_tree.simps<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 6 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 7 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_insert braun_insert<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> 8 <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> heap_merge braun_size_merge neq_Leaf_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Sorting_Braun">
<div class="head">
<h1>Theory Sorting_Braun</h1>
</div>
<pre class="source"><span class="comment1">(* Authors: Tobias Nipkow and Thomas Sewell *)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">"Sorting via Priority Queues Based on Braun Trees"</span></span>

<span class="keyword1"><span class="command">theory</span></span> Sorting_Braun
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Priority_Queue_Braun.html">Priority_Queue_Braun</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This theory is about sorting algorithms based on heaps.
Algorithm A can be found here
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹http://www.csse.canterbury.ac.nz/walter.guttmann/publications/0005.pdf›</span></span> on p. 54.
(published here <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹http://www.jucs.org/doi?doi=10.3217/jucs-009-02-0173›</span></span>)
Not really the classic heap sort but a mixture of heap sort and merge sort.
The algorithm (B) in Larry's book comes closer to the classic heap sort:
<span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹https://www.cl.cam.ac.uk/~lp15/MLbook/programs/sample7.sml›</span></span>.

Both algorithms have two phases:
build a heap from a list, then extract the elements of the heap into a sorted list.
›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span><span class="main">(</span>input<span class="main">)</span>
  <span class="quoted"><span class="quoted">"<span class="free">nlog2</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">==</span> nat<span class="main">(</span>ceiling<span class="main">(</span>log <span class="numeral">2</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Phase 1: List to Tree›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Algorithm A does this naively, in $O(n lg n)$ fashion and generates a Braun tree:›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">heap_of_A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">heap_of_A</span> <span class="main">[]</span> <span class="main">=</span> Leaf"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">heap_of_A</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> insert <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span><span class="free">heap_of_A</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span>"</span></span>

<span class="comment1">(* just for testing
definition
  shuffle100 :: "nat list"
  where
  "shuffle100 = [50 :: nat, 7, 77, 15, 42, 82, 87, 68, 69, 29, 43, 24, 84, 12, 35, 30, 95, 45, 14, 47, 54, 66, 96, 71, 98, 4, 22, 0, 92, 86, 34, 33, 57, 91, 20, 13, 64, 73, 70, 8, 85, 40, 16, 18, 81, 99, 63, 41, 56, 72, 79, 48, 78, 52, 25, 49, 65, 90, 26, 76, 3, 59, 74, 58, 46, 38, 61, 94, 75, 11, 88, 31, 53, 17, 44, 89, 39, 93, 62, 5, 1, 21, 6, 55, 83, 28, 37, 60, 19, 67, 23, 97, 51, 10, 27, 32, 2, 36, 9, 80]"

value "heap_of_A shuffle100"
*)</span>

<span class="keyword1" id="Sorting_Braun-heap_heap_of_A"><span class="command">lemma</span></span> heap_heap_of_A<span class="main">:</span> <span class="quoted"><span class="quoted">"heap <span class="main">(</span>heap_of_A <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_insert<span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-braun_heap_of_A"><span class="command">lemma</span></span> braun_heap_of_A<span class="main">:</span> <span class="quoted"><span class="quoted">"braun <span class="main">(</span>heap_of_A <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> braun_insert<span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-mset_tree_heap_of_A"><span class="command">lemma</span></span> mset_tree_heap_of_A<span class="main">:</span> <span class="quoted"><span class="quoted">"mset_tree <span class="main">(</span>heap_of_A <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mset_insert<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Running time is n*log n, which we can approximate with height.›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_insert</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_insert</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> Leaf <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_insert</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span>
 <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">&lt;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">+</span> <span class="free">t_insert</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">else</span> <span class="main">1</span> <span class="main">+</span> <span class="free">t_insert</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_heap_of_A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> list <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_heap_of_A</span> <span class="main">[]</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_heap_of_A</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">=</span> t_insert <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span>heap_of_A <span class="free"><span class="bound"><span class="entity">as</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="free">t_heap_of_A</span> <span class="free"><span class="bound"><span class="entity">as</span></span></span>"</span></span>

<span class="keyword1" id="Sorting_Braun-t_insert_height"><span class="command">lemma</span></span> t_insert_height<span class="main">:</span>
  <span class="quoted"><span class="quoted">"t_insert <span class="free">x</span> <span class="free">t</span> <span class="main">≤</span> height <span class="free">t</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> max_Suc_Suc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> le_max_iff_disj<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Sorting_Braun-height_insert_ge"><span class="command">lemma</span></span> height_insert_ge<span class="main">:</span>
  <span class="quoted"><span class="quoted">"height <span class="free">t</span> <span class="main">≤</span> height <span class="main">(</span>insert <span class="free">x</span> <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_max_iff_disj<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> less_imp_le_nat less_le_trans not_le_imp_less<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Sorting_Braun-t_heap_of_A_bound"><span class="command">lemma</span></span> t_heap_of_A_bound<span class="main">:</span>
  <span class="quoted"><span class="quoted">"t_heap_of_A <span class="free">xs</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">*</span> <span class="main">(</span>height <span class="main">(</span>heap_of_A <span class="free">xs</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Cons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>

  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?lhs</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"t_insert <span class="skolem">x</span> <span class="main">(</span>heap_of_A <span class="skolem">xs</span><span class="main">)</span> <span class="main">+</span> t_heap_of_A <span class="skolem">xs</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> Cons
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> height_insert_ge<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"heap_of_A <span class="skolem">xs</span>"</span></span> <span class="quoted"><span class="skolem">x</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> t_insert_height<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="quoted">"heap_of_A <span class="skolem">xs</span>"</span></span><span class="main">]</span>

  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> order_trans<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> height_insert_ge<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Sorting_Braun-size_heap_of_A"><span class="command">lemma</span></span> size_heap_of_A<span class="main">:</span>
  <span class="quoted"><span class="quoted">"size <span class="main">(</span>heap_of_A <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> length <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> arg_cong<span class="main">[</span><span class="operator">OF</span> mset_tree_heap_of_A<span class="main">,</span> <span class="operator">of</span> <span class="quoted">size</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Sorting_Braun-t_heap_of_A_log_bound"><span class="command">lemma</span></span> t_heap_of_A_log_bound<span class="main">:</span>
  <span class="quoted"><span class="quoted">"t_heap_of_A <span class="free">xs</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">*</span> <span class="main">(</span>nlog2 <span class="main">(</span>length <span class="free">xs</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> t_heap_of_A_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span>
    acomplete_if_braun<span class="main">[</span><span class="operator">OF</span> braun_heap_of_A<span class="main">,</span> <span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> height_acomplete size1_size size_heap_of_A<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Algorithm B mimics heap sort more closely by building heaps bottom up in a balanced way:›</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">heapify</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> list <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">*</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">heapify</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">(</span>Leaf<span class="main">,</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">heapify</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span>
	 <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">heapify</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span>
		    <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">zs</span><span class="main">)</span> <span class="main">=</span> <span class="free">heapify</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="bound">ys</span>
	  <span class="keyword1">in</span> <span class="main">(</span>sift_down <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">r</span><span class="main">,</span> <span class="bound">zs</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The result should be a Braun tree:›</span></span>

<span class="keyword1" id="Sorting_Braun-heapify_snd"><span class="command">lemma</span></span> heapify_snd<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">⟹</span> snd <span class="main">(</span>heapify <span class="free">n</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> drop <span class="free">n</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> measure_induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">length</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">n</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Suc_le_length_iff case_prod_beta<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">n</span></span><span class="main"><span class="main">.</span></span> drop <span class="bound"><span class="bound">n</span></span> <span class="skolem"><span class="skolem">xs</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem"><span class="skolem">xs</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Sorting_Braun-heapify_snd_tup"><span class="command">lemma</span></span> heapify_snd_tup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"heapify <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">⟹</span> <span class="free">ys</span> <span class="main">=</span> drop <span class="free">n</span> <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> heapify_snd<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-heapify_correct"><span class="command">lemma</span></span> heapify_correct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">⟹</span> heapify <span class="free">n</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="free">t</span><span class="main">,</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟹</span>
    size <span class="free">t</span> <span class="main">=</span> <span class="free">n</span> <span class="main">∧</span> heap <span class="free">t</span> <span class="main">∧</span> braun <span class="free">t</span> <span class="main">∧</span> mset_tree <span class="free">t</span> <span class="main">=</span> mset <span class="main">(</span>take <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">n</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> heapify.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">n</span> <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>

  <span class="keyword1"><span class="command">note</span></span> len <span class="main">=</span> <span class="quoted">"2.prems"</span><span class="main">(</span>1<span class="main">)</span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t1</span></span> <span class="skolem"><span class="skolem">ys1</span></span> <span class="keyword2"><span class="keyword">where</span></span> h1<span class="main">:</span> <span class="quoted"><span class="quoted">"heapify <span class="main">(</span>Suc <span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">t1</span><span class="main">,</span> <span class="skolem">ys1</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prod_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">t2</span></span> <span class="skolem"><span class="skolem">ys2</span></span> <span class="keyword2"><span class="keyword">where</span></span> h2<span class="main">:</span> <span class="quoted"><span class="quoted">"heapify <span class="main">(</span><span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="skolem">ys1</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">t2</span><span class="main">,</span> <span class="skolem">ys2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prod_eq_iff<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> len <span class="keyword1"><span class="command">have</span></span> le1<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">≤</span> length <span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">note</span></span> ys1 <span class="main">=</span> heapify_snd_tup<span class="main">[</span><span class="operator">OF</span> h1 le1<span class="main">]</span>
  <span class="keyword1"><span class="command">from</span></span> len <span class="keyword1"><span class="command">have</span></span> le2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">≤</span> length <span class="skolem">ys1</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ys1<span class="main">)</span>

  <span class="keyword1"><span class="command">note</span></span> app_hyps <span class="main">=</span> <span class="quoted">"2.hyps"</span><span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> le1 h1<span class="main">]</span>
    <span class="quoted">"2.hyps"</span><span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> refl h1<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">simplified</span><span class="main">,</span> <span class="operator">OF</span> le2 h2<span class="main">]</span>

  <span class="keyword1"><span class="command">hence</span></span> braun<span class="main">:</span> <span class="quoted"><span class="quoted">"braun <span class="main">(</span>Node <span class="skolem">t1</span> <span class="skolem">x</span> <span class="skolem">t2</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">linarith</span><span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> eq<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">+</span> Suc <span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">=</span> <span class="skolem">n</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">have</span></span> msets<span class="main">:</span>
    <span class="quoted"><span class="quoted">"mset <span class="main">(</span>take <span class="main">(</span>Suc <span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="skolem">xs</span><span class="main">)</span> <span class="main">+</span> mset <span class="main">(</span>take <span class="main">(</span><span class="skolem">n</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="skolem">ys1</span><span class="main">)</span> <span class="main">=</span> mset <span class="main">(</span>take <span class="skolem">n</span> <span class="skolem">xs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> append_take_drop_id<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> n<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"Suc <span class="skolem"><span class="skolem">n</span></span> <span class="keyword1"><span class="keyword1">div</span></span> <span class="numeral"><span class="numeral">2</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> t<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"take <span class="skolem"><span class="skolem">n</span></span> <span class="skolem"><span class="skolem">xs</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span>
        <span class="operator">subst</span> mset_append<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> take_drop min_absorb1 le1 eq ys1<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"2.prems"</span> app_hyps msets <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> h1 h2 le2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> size_sift_down<span class="main"><span class="main">[</span></span><span class="operator">OF</span> braun<span class="main"><span class="main">]</span></span>
                       braun_sift_down<span class="main"><span class="main">[</span></span><span class="operator">OF</span> braun<span class="main"><span class="main">]</span></span>
                       mset_sift_down<span class="main"><span class="main">[</span></span><span class="operator">OF</span> braun<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_sift_down<span class="main"><span class="main">[</span></span><span class="operator">OF</span> braun<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Sorting_Braun-braun_heapify"><span class="command">lemma</span></span> braun_heapify<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">⟹</span> braun <span class="main">(</span>fst <span class="main">(</span>heapify <span class="free">n</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"heapify <span class="free">n</span> <span class="free">xs</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span><span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> heapify_correct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-heap_heapify"><span class="command">lemma</span></span> heap_heapify<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">⟹</span> heap <span class="main">(</span>fst <span class="main">(</span>heapify <span class="free">n</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"heapify <span class="free">n</span> <span class="free">xs</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span><span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> heapify_correct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-mset_heapify"><span class="command">lemma</span></span> mset_heapify<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">⟹</span> mset_tree <span class="main">(</span>fst <span class="main">(</span>heapify <span class="free">n</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> mset <span class="main">(</span>take <span class="free">n</span> <span class="free">xs</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"heapify <span class="free">n</span> <span class="free">xs</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">drule</span><span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> heapify_correct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The running time of heapify is linear.
  (similar to <span class="antiquoted"><span class="antiquoted"><span class="operator"><span class="operator">🌐</span></span>‹https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap›</span></span>)

This is an interesting result, so we embark on this exercise
to prove it the hard way.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> pattern_aliases
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="main">(</span>sequential<span class="main">)</span> <span class="entity">t_sift_down</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder tree <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_sift_down</span> Leaf <span class="free"><span class="bound"><span class="entity">a</span></span></span> Leaf <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_sift_down</span> <span class="main">(</span>Node Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span> Leaf<span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> Leaf <span class="main">=</span> <span class="numeral">2</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_sift_down</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span> <span class="main">=:</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span> <span class="main">=:</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span><span class="main">)</span> <span class="main">=</span>
  <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span>
   <span class="keyword1">then</span> <span class="main">1</span>
   <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x1</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">x2</span></span></span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">+</span> <span class="free">t_sift_down</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span>
        <span class="keyword1">else</span> <span class="main">1</span> <span class="main">+</span> <span class="free">t_sift_down</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">termination</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">relation</span> <span class="quoted"><span class="quoted">"measure <span class="main">(</span><span class="main">%</span><span class="main">(</span><span class="bound">l</span><span class="main">,</span><span class="bound">a</span><span class="main">,</span><span class="bound">r</span><span class="main">)</span><span class="main">.</span> size <span class="bound">l</span> <span class="main">+</span> size <span class="bound">r</span><span class="main">)</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_heapify</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> list <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_heapify</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_heapify</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">#</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span>
	 <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">l</span><span class="main">,</span> <span class="bound">ys</span><span class="main">)</span> <span class="main">=</span> heapify <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span>
        <span class="bound">t1</span> <span class="main">=</span> <span class="free">t_heapify</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span>
        <span class="main">(</span><span class="bound">r</span><span class="main">,</span> <span class="bound">zs</span><span class="main">)</span> <span class="main">=</span> heapify <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="bound">ys</span><span class="main">;</span>
		    <span class="bound">t2</span> <span class="main">=</span> <span class="free">t_heapify</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="bound">ys</span>
	  <span class="keyword1">in</span> <span class="main">1</span> <span class="main">+</span> <span class="bound">t1</span> <span class="main">+</span> <span class="bound">t2</span> <span class="main">+</span> t_sift_down <span class="bound">l</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">r</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Sorting_Braun-t_sift_down_height"><span class="command">lemma</span></span> t_sift_down_height<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> t_sift_down <span class="free">l</span> <span class="free">x</span> <span class="free">r</span> <span class="main">≤</span> height <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> t_sift_down.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-sift_down_height"><span class="command">lemma</span></span> sift_down_height<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> height <span class="main">(</span>sift_down <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">≤</span> height <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> sift_down.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Let_def<span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-braun_height_r_le"><span class="command">lemma</span></span> braun_height_r_le<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">⟹</span> height <span class="free">r</span> <span class="main">≤</span> height <span class="free">l</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> acomplete_optimal<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> acomplete_if_braun<span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-braun_height_l_le"><span class="command">lemma</span></span> braun_height_l_le<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"braun <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"height <span class="free">l</span> <span class="main">≤</span> Suc <span class="main">(</span>height <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> b acomplete_if_braun<span class="main">[</span><span class="operator">OF</span> b<span class="main">]</span> min_height_le_height<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">r</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> acomplete_def<span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-braun_height_node_eq"><span class="command">lemma</span></span> braun_height_node_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> b<span class="main">:</span> <span class="quoted"><span class="quoted">"braun <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"height <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> Suc <span class="main">(</span>height <span class="free">l</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> b braun_height_r_le<span class="main">[</span><span class="operator">OF</span> b<span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_def<span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-t_heapify_induct"><span class="command">lemma</span></span> t_heapify_induct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">⟹</span> t_heapify <span class="free">i</span> <span class="free">xs</span> <span class="main">+</span> height <span class="main">(</span>fst <span class="main">(</span>heapify <span class="free">i</span> <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">5</span> <span class="main">*</span> <span class="free">i</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> t_heapify.induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">vs</span><span class="main">)</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">i</span> <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>

  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l</span></span> <span class="skolem"><span class="skolem">ys</span></span> <span class="keyword2"><span class="keyword">where</span></span> h1<span class="main">:</span> <span class="quoted"><span class="quoted">"heapify <span class="main">(</span>Suc <span class="skolem">i</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="skolem">xs</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prod_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> hyps1 <span class="main">=</span> <span class="quoted">"2.hyps"</span><span class="main">[</span><span class="operator">OF</span> h1<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator"><span class="operator">symmetric</span></span><span class="main"><span class="main"><span class="main">]</span></span></span> refl<span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="skolem"><span class="skolem">zs</span></span> <span class="keyword2"><span class="keyword">where</span></span> h2<span class="main">:</span> <span class="quoted"><span class="quoted">"heapify <span class="main">(</span><span class="skolem">i</span> <span class="keyword1">div</span> <span class="numeral">2</span><span class="main">)</span> <span class="skolem">ys</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">r</span><span class="main">,</span> <span class="skolem">zs</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prod_eq_iff<span class="main">)</span>

  <span class="keyword1"><span class="command">from</span></span> <span class="quoted">"2.prems"</span> heapify_snd_tup<span class="main">[</span><span class="operator">OF</span> h1<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> le1<span class="main">:</span> <span class="quoted"><span class="quoted">"Suc <span class="skolem">i</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">≤</span> length <span class="skolem">xs</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> le2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">≤</span> length <span class="skolem">xs</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> le4<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="keyword1">div</span> <span class="numeral">2</span> <span class="main">≤</span> length <span class="skolem">ys</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>

  <span class="keyword1"><span class="command">note</span></span> hyps2 <span class="main">=</span> hyps1<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> le1<span class="main">]</span> hyps1<span class="main">(</span>2<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> refl h2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> refl le4<span class="main">]</span>

  <span class="keyword1"><span class="command">note</span></span> prem <span class="main">=</span> add_le_mono<span class="main">[</span><span class="operator">OF</span> add_le_mono<span class="main"><span class="main">[</span></span><span class="operator">OF</span> hyps2<span class="main"><span class="main">]</span></span> order_refl<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="numeral">3</span></span><span class="main"><span class="main">]</span></span><span class="main">]</span>

  <span class="keyword1"><span class="command">from</span></span> heapify_correct<span class="main">[</span><span class="operator">OF</span> le1 h1<span class="main">]</span> heapify_correct<span class="main">[</span><span class="operator">OF</span> le4 h2<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> braun<span class="main">:</span> <span class="quoted"><span class="quoted">"braun <span class="main">⟨</span><span class="skolem">l</span><span class="main">,</span> <span class="skolem">x</span><span class="main">,</span> <span class="skolem">r</span><span class="main">⟩</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> t_sift_l<span class="main">:</span>
    <span class="quoted"><span class="quoted">"t_sift_down <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">r</span> <span class="main">≤</span> height <span class="skolem">l</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> t_sift_down_height<span class="main">[</span><span class="operator">OF</span> braun<span class="main">]</span> braun_height_r_le<span class="main">[</span><span class="operator">OF</span> braun<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">from</span></span> t_sift_down_height<span class="main">[</span><span class="operator">OF</span> braun<span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> height_sift_r<span class="main">:</span>
    <span class="quoted"><span class="quoted">"height <span class="main">(</span>sift_down <span class="skolem">l</span> <span class="skolem">x</span> <span class="skolem">r</span><span class="main">)</span> <span class="main">≤</span> height <span class="skolem">r</span> <span class="main">+</span> <span class="numeral">2</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> sift_down_height<span class="main">[</span><span class="operator">OF</span> braun<span class="main">]</span> braun_height_l_le<span class="main">[</span><span class="operator">OF</span> braun<span class="main">]</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

  <span class="keyword1"><span class="command">from</span></span> h1 h2 t_sift_l height_sift_r <span class="quoted">"2.prems"</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> order_trans<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> prem<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> mult_le_cancel1 add_mult_distrib2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Sorting_Braun-t_heapify_bound"><span class="command">lemma</span></span> t_heapify_bound<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> length <span class="free">xs</span> <span class="main">⟹</span> t_heapify <span class="free">i</span> <span class="free">xs</span> <span class="main">≤</span> <span class="numeral">5</span> <span class="main">*</span> <span class="free">i</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> t_heapify_induct<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Phase 2: Heap to List›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Algorithm A extracts (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>list_of_A›</span></span></span></span>) the list by removing the root and merging the children:›</span></span>


<span class="comment1">(* For termination of ‹merge› only: *)</span>
<span class="keyword1" id="Sorting_Braun-size_prod_measure"><span class="command">lemma</span></span> size_prod_measure<span class="main">[</span><span class="operator">measure_function</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"is_measure <span class="free">f</span> <span class="main">⟹</span> is_measure <span class="free">g</span> <span class="main">⟹</span> is_measure <span class="main">(</span>size_prod <span class="free">f</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> is_measure_trivial<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">merge</span> Leaf <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t2</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">merge</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> Leaf <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">merge</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="keyword1">then</span> Node <span class="main">(</span><span class="free">merge</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span><span class="main">)</span>
    <span class="keyword1">else</span> Node <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="main">(</span><span class="free">merge</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(* Merging does not preserve braun: *)</span>
<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"merge <span class="main">⟨</span><span class="main">⟨⟩</span><span class="main">,</span> <span class="main">0</span><span class="main">::</span>int<span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span> <span class="main">⟨</span><span class="main">⟨⟩</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span> <span class="main">=</span> <span class="main">⟨</span><span class="main">⟨⟩</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">⟨</span><span class="main">⟨⟩</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">⟨⟩</span><span class="main">⟩</span><span class="main">⟩</span>"</span></span>

<span class="keyword1" id="Sorting_Braun-merge_size"><span class="command">lemma</span></span> merge_size<span class="main">[</span><span class="operator">termination_simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"size <span class="main">(</span>merge <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> size <span class="free">l</span> <span class="main">+</span> size <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">list_of_A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">list_of_A</span> Leaf <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">list_of_A</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">#</span> <span class="free">list_of_A</span> <span class="main">(</span>merge <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"list_of_A <span class="main">(</span>heap_of_A <span class="free">shuffle100</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Sorting_Braun-set_tree_merge"><span class="command">lemma</span></span> set_tree_merge<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set_tree <span class="main">(</span>merge <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> set_tree <span class="free">l</span> <span class="main">∪</span> set_tree <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-mset_tree_merge"><span class="command">lemma</span></span> mset_tree_merge<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mset_tree <span class="main">(</span>merge <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">=</span> mset_tree <span class="free">l</span> <span class="main">+</span> mset_tree <span class="free">r</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-merge_heap"><span class="command">lemma</span></span> merge_heap<span class="main">:</span>
  <span class="quoted"><span class="quoted">"heap <span class="free">l</span> <span class="main">⟹</span> heap <span class="free">r</span> <span class="main">⟹</span> heap <span class="main">(</span>merge <span class="free">l</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">r</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> ball_Un<span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-set_list_of_A"><span class="command">lemma</span></span> set_list_of_A<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"set <span class="main">(</span>list_of_A <span class="free">t</span><span class="main">)</span> <span class="main">=</span> set_tree <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_of_A.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-mset_list_of_A"><span class="command">lemma</span></span> mset_list_of_A<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"mset <span class="main">(</span>list_of_A <span class="free">t</span><span class="main">)</span> <span class="main">=</span> mset_tree <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_of_A.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-sorted_list_of_A"><span class="command">lemma</span></span> sorted_list_of_A<span class="main">:</span>
  <span class="quoted"><span class="quoted">"heap <span class="free">t</span> <span class="main">⟹</span> sorted <span class="main">(</span>list_of_A <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> list_of_A.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> merge_heap<span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-sortedA"><span class="command">lemma</span></span> sortedA<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>list_of_A <span class="main">(</span>heap_of_A <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_heap_of_A sorted_list_of_A<span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-msetA"><span class="command">lemma</span></span> msetA<span class="main">:</span> <span class="quoted"><span class="quoted">"mset <span class="main">(</span>list_of_A <span class="main">(</span>heap_of_A <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">xs</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mset_tree_heap_of_A<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Does <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>list_of_A›</span></span></span></span> take time $O(n lg n)$? Although <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>merge›</span></span></span></span> does not preserve <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>braun›</span></span></span></span>,
it cannot increase the height of the heap.›</span></span>

<span class="keyword1" id="Sorting_Braun-merge_height"><span class="command">lemma</span></span> merge_height<span class="main">:</span>
  <span class="quoted"><span class="quoted">"height <span class="main">(</span>merge <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">≤</span>  Suc <span class="main">(</span>max <span class="main">(</span>height <span class="free">l</span><span class="main">)</span> <span class="main">(</span>height <span class="free">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> merge.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">corollary</span></span> merge_height_display<span class="main">:</span>
  <span class="quoted"><span class="quoted">"height <span class="main">(</span>merge <span class="free">l</span> <span class="free">r</span><span class="main">)</span> <span class="main">≤</span> height <span class="main">(</span>Node <span class="free">l</span> <span class="free">x</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> merge_height <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_merge</span> Leaf <span class="free"><span class="bound"><span class="entity">t2</span></span></span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_merge</span> <span class="free"><span class="bound"><span class="entity">t1</span></span></span> Leaf <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_merge</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span><span class="main">)</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span><span class="main">)</span> <span class="main">=</span>
   <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">a1</span></span></span> <span class="main">≤</span> <span class="free"><span class="bound"><span class="entity">a2</span></span></span> <span class="keyword1">then</span> <span class="main">1</span> <span class="main">+</span> <span class="free">t_merge</span> <span class="free"><span class="bound"><span class="entity">l1</span></span></span> <span class="free"><span class="bound"><span class="entity">r1</span></span></span>
    <span class="keyword1">else</span> <span class="main">1</span> <span class="main">+</span> <span class="free">t_merge</span> <span class="free"><span class="bound"><span class="entity">l2</span></span></span> <span class="free"><span class="bound"><span class="entity">r2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_list_of_A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_list_of_A</span> Leaf <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_list_of_A</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> t_merge <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main">+</span> <span class="free">t_list_of_A</span> <span class="main">(</span>merge <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Sorting_Braun-t_merge_height"><span class="command">lemma</span></span> t_merge_height<span class="main">:</span>
  <span class="quoted"><span class="quoted">"t_merge <span class="free">l</span> <span class="free">r</span> <span class="main">≤</span> max <span class="main">(</span>height <span class="free">l</span><span class="main">)</span> <span class="main">(</span>height <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> t_merge.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-t_list_of_A_induct"><span class="command">lemma</span></span> t_list_of_A_induct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"height <span class="free">t</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">⟹</span> t_list_of_A <span class="free">t</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> <span class="free">n</span> <span class="main">*</span> size <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> t_list_of_A.induct<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> meta_mp<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> merge_height<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> merge_size<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> l<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">l</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> r<span class="main"><span class="main">=</span></span><span class="quoted"><span class="improper">r</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> t_merge_height<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">linarith</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Sorting_Braun-t_list_of_A_bound"><span class="command">lemma</span></span> t_list_of_A_bound<span class="main">:</span>
  <span class="quoted"><span class="quoted">"t_list_of_A <span class="free">t</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> height <span class="free">t</span> <span class="main">*</span> size <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> t_list_of_A_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-t_list_of_A_log_bound"><span class="command">lemma</span></span> t_list_of_A_log_bound<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> t_list_of_A <span class="free">t</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> nlog2 <span class="main">(</span>size <span class="free">t</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> size <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">using</span></span> t_list_of_A_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">t</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> height_acomplete acomplete_if_braun size1_size<span class="main">)</span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"t_list_of_A <span class="main">(</span>heap_of_A <span class="free">shuffle100</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">theorem</span></span> t_sortA<span class="main">:</span>
  <span class="quoted"><span class="quoted">"t_heap_of_A <span class="free">xs</span> <span class="main">+</span> t_list_of_A <span class="main">(</span>heap_of_A <span class="free">xs</span><span class="main">)</span> <span class="main">≤</span> <span class="numeral">3</span> <span class="main">*</span> length <span class="free">xs</span> <span class="main">*</span> <span class="main">(</span>nlog2 <span class="main">(</span>length <span class="free">xs</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="main">_</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> t_heap_of_A_log_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> t_list_of_A_log_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"heap_of_A <span class="free">xs</span>"</span></span><span class="main">,</span> <span class="operator">OF</span> braun_heap_of_A<span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> size_heap_of_A<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Running time of algorithm B:›</span></span>

<span class="comment1">(* Unfortunately this can only be proven to terminate conditionally.
   To make it unconditional would require a total specification of
   sift_down, which would be complex and differ substantially from
   Paulson's presentation.  *)</span>
<span class="keyword1"><span class="command">function</span></span> <span class="entity">list_of_B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> tree <span class="main">⇒</span> <span class="tfree">'a</span> list"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">list_of_B</span> Leaf <span class="main">=</span> <span class="main">[]</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">list_of_B</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">#</span> <span class="free">list_of_B</span> <span class="main">(</span>del_min <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>

<span class="keyword1" id="Sorting_Braun-list_of_B_braun_ptermination"><span class="command">lemma</span></span> list_of_B_braun_ptermination<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> list_of_B_dom <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> measure_induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">size</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> accpI<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> list_of_B_rel.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> size_del_min braun_del_min<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> list_of_B_braun_simps
    <span class="main">=</span> list_of_B.psimps<span class="main">[</span><span class="operator">OF</span> list_of_B_braun_ptermination<span class="main">]</span>

<span class="keyword1" id="Sorting_Braun-mset_list_of_B"><span class="command">lemma</span></span> mset_list_of_B<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> mset <span class="main">(</span>list_of_B <span class="free">t</span><span class="main">)</span> <span class="main">=</span> mset_tree <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> measure_induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">size</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_of_B_braun_simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> size_del_min braun_del_min mset_del_min<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Sorting_Braun-set_list_of_B"><span class="command">lemma</span></span> set_list_of_B<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> set <span class="main">(</span>list_of_B <span class="free">t</span><span class="main">)</span> <span class="main">=</span> set_tree <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> set_mset_mset<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> mset_list_of_B<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-sorted_list_of_B"><span class="command">lemma</span></span> sorted_list_of_B<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> heap <span class="free">t</span> <span class="main">⟹</span> sorted <span class="main">(</span>list_of_B <span class="free">t</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> measure_induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">size</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> list_of_B_braun_simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> set_list_of_B braun_del_min size_del_min heap_del_min<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> set_mset_tree<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> mset_del_min <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> set_mset_tree<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">heap_of_B</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> fst <span class="main">(</span>heapify <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Sorting_Braun-sortedB"><span class="command">lemma</span></span> sortedB<span class="main">:</span> <span class="quoted"><span class="quoted">"sorted <span class="main">(</span>list_of_B <span class="main">(</span>heap_of_B <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_of_B_def braun_heapify heap_heapify sorted_list_of_B<span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-msetB"><span class="command">lemma</span></span> msetB<span class="main">:</span> <span class="quoted"><span class="quoted">"mset <span class="main">(</span>list_of_B <span class="main">(</span>heap_of_B <span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> mset <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> heap_of_B_def braun_heapify mset_heapify mset_list_of_B<span class="main">)</span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_del_left</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_del_left</span> <span class="main">(</span>Node Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_del_left</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">l'</span><span class="main">)</span> <span class="main">=</span> del_left <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">in</span> <span class="numeral">2</span> <span class="main">+</span> <span class="free">t_del_left</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fun</span></span> <span class="entity">t_del_min</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>linorder tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_del_min</span> Leaf <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_del_min</span> <span class="main">(</span>Node Leaf <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_del_min</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span><span class="bound">l'</span><span class="main">)</span> <span class="main">=</span> del_left <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">in</span> t_del_left <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">+</span> t_sift_down <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="bound">y</span> <span class="bound">l'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">t_list_of_B</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>linorder<span class="main">)</span> tree <span class="main">⇒</span> nat"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="quoted"><span class="quoted">"<span class="free">t_list_of_B</span> Leaf <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="main">|</span>
<span class="quoted"><span class="quoted">"<span class="free">t_list_of_B</span> <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">1</span> <span class="main">+</span> t_del_min <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">+</span> <span class="free">t_list_of_B</span> <span class="main">(</span>del_min <span class="main">(</span>Node <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">pat_completeness</span> <span class="operator">auto</span>

<span class="keyword1" id="Sorting_Braun-t_del_left_bound"><span class="command">lemma</span></span> t_del_left_bound<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">≠</span> Leaf <span class="main">⟹</span> t_del_left <span class="free">t</span> <span class="main">≤</span> <span class="numeral">2</span> <span class="main">*</span> height <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> t_del_left.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">atomize</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">full</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> prod_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nat_mult_max_right le_max_iff_disj<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Sorting_Braun-del_left_height"><span class="command">lemma</span></span> del_left_height<span class="main">:</span>
  <span class="quoted"><span class="quoted">"del_left <span class="free">t</span> <span class="main">=</span> <span class="main">(</span><span class="free">v</span><span class="main">,</span> <span class="free">t'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">t</span> <span class="main">≠</span> Leaf <span class="main">⟹</span> height <span class="free">t'</span> <span class="main">≤</span> height <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">v</span></span> <span class="quoted"><span class="free">t'</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> del_left.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">atomize</span><span class="main"><span class="main">(</span></span><span class="quasi_keyword">full</span><span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.splits<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Sorting_Braun-t_del_min_bound"><span class="command">lemma</span></span> t_del_min_bound<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> t_del_min <span class="free">t</span> <span class="main">≤</span> <span class="numeral">3</span> <span class="main">*</span> height <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> t_del_min.cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> del_left_braun<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> del_left_size<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> del_left_height<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">rule</span> add_le_mono t_del_left_bound t_sift_down_height <span class="main"><span class="keyword3">|</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> max_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Sorting_Braun-t_list_of_B_braun_ptermination"><span class="command">lemma</span></span> t_list_of_B_braun_ptermination<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> t_list_of_B_dom <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> measure_induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">size</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> accpI<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> t_list_of_B_rel.cases<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> size_del_min braun_del_min<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> t_list_of_B_braun_simps
    <span class="main">=</span> t_list_of_B.psimps<span class="main">[</span><span class="operator">OF</span> t_list_of_B_braun_ptermination<span class="main">]</span>

<span class="keyword1" id="Sorting_Braun-del_min_height"><span class="command">lemma</span></span> del_min_height<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> height <span class="main">(</span>del_min <span class="free">t</span><span class="main">)</span> <span class="main">≤</span> height <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> del_min.cases<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> prod.split<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> del_left_braun<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> del_left_size<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> del_left_height<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> sift_down_height<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Sorting_Braun-t_list_of_B_induct"><span class="command">lemma</span></span> t_list_of_B_induct<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> height <span class="free">t</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">⟹</span> t_list_of_B <span class="free">t</span> <span class="main">≤</span> <span class="numeral">3</span> <span class="main">*</span> <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> size <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> measure_induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">size</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"del_min <span class="improper">x</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> spec<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> del_min_height<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_list_of_B_braun_simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> l x' r<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> braun_del_min size_del_min<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> order_trans<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="main">(</span><span class="operator">rule</span> add_le_mono t_del_min_bound <span class="main"><span class="keyword3">|</span></span> <span class="operator">assumption</span> <span class="main"><span class="keyword3">|</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span><span class="main"><span class="keyword3">[</span></span>1<span class="main"><span class="keyword3">]</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Sorting_Braun-t_list_of_B_bound"><span class="command">lemma</span></span> t_list_of_B_bound<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> t_list_of_B <span class="free">t</span> <span class="main">≤</span> <span class="numeral">3</span> <span class="main">*</span> <span class="main">(</span>height <span class="free">t</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> size <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> t_list_of_B_induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Sorting_Braun-t_list_of_B_log_bound"><span class="command">lemma</span></span> t_list_of_B_log_bound<span class="main">:</span>
  <span class="quoted"><span class="quoted">"braun <span class="free">t</span> <span class="main">⟹</span> t_list_of_B <span class="free">t</span> <span class="main">≤</span> <span class="numeral">3</span> <span class="main">*</span> <span class="main">(</span>nlog2 <span class="main">(</span>size <span class="free">t</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">*</span> size <span class="free">t</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule</span> t_list_of_B_bound<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> height_acomplete acomplete_if_braun size1_size<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">t_heap_of_B</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> length <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">+</span> t_heapify <span class="main">(</span>length <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Sorting_Braun-t_heap_of_B_bound"><span class="command">lemma</span></span> t_heap_of_B_bound<span class="main">:</span>
  <span class="quoted"><span class="quoted">"t_heap_of_B <span class="free">xs</span> <span class="main">≤</span> <span class="numeral">6</span> <span class="main">*</span> length <span class="free">xs</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> t_heap_of_B_def order_trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> t_heapify_bound<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> size_heapify <span class="main">=</span> arg_cong<span class="main">[</span><span class="operator">OF</span> mset_heapify<span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted">size</span><span class="main">,</span> <span class="operator">simplified</span><span class="main">]</span>

<span class="keyword1"><span class="command">theorem</span></span> t_sortB<span class="main">:</span>
  <span class="quoted"><span class="quoted">"t_heap_of_B <span class="free">xs</span> <span class="main">+</span> t_list_of_B <span class="main">(</span>heap_of_B <span class="free">xs</span><span class="main">)</span>
    <span class="main">≤</span> <span class="numeral">3</span> <span class="main">*</span> length <span class="free">xs</span> <span class="main">*</span> <span class="main">(</span>nlog2 <span class="main">(</span>length <span class="free">xs</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="numeral">3</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="main">_</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">≤</span> <span class="var">?lhs</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> t_heap_of_B_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">xs</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">note</span></span> t_list_of_B_log_bound<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"heap_of_B <span class="free">xs</span>"</span></span><span class="main">]</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> size_heapify braun_heapify heap_of_B_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">field_simps</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(* One suspects that algorithm A is actually faster, despite being
algorithmically slower on the construction of the heap. The operation
merge needs to allocate one constructor per level of the heap,
as opposed to del_min, which needs three, so the extraction is probably
much faster. Not sure how to validate that.

value "t_list_of_B (heap_of
  [50 :: nat, 7, 77, 15, 42, 82, 87, 68, 69, 29, 43, 24, 84, 12, 35, 30, 95, 45, 14, 47, 54, 66, 96, 71, 98, 4, 22, 0, 92, 86, 34, 33, 57, 91, 20, 13, 64, 73, 70, 8, 85, 40, 16, 18, 81, 99, 63, 41, 56, 72, 79, 48, 78, 52, 25, 49, 65, 90, 26, 76, 3, 59, 74, 58, 46, 38, 61, 94, 75, 11, 88, 31, 53, 17, 44, 89, 39, 93, 62, 5, 1, 21, 6, 55, 83, 28, 37, 60, 19, 67, 23, 97, 51, 10, 27, 32, 2, 36, 9, 80]
)"
 *)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>