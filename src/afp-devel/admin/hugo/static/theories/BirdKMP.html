<div id="HOLCF_ROOT">
<div class="head">
<h1>Theory HOLCF_ROOT</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> HOLCF_ROOT
<span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../HOLCF-Prelude/HOLCF_Prelude.html">HOLCF-Prelude.HOLCF_Prelude</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Extra HOLCF›</span></span>

<span class="keyword1" id="HOLCF_ROOT-lfp_fusion"><span class="command">lemma</span></span> lfp_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">g</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">h</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> parallel_fix_ind<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 2 <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">x</span> <span class="skolem">y</span><span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">g</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> <span class="skolem">y</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">g</span> <span class="keyword1">oo</span> <span class="free">f</span> <span class="main">=</span> <span class="free">h</span> <span class="keyword1">oo</span> <span class="free">g</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">h</span><span class="main">⋅</span><span class="skolem">y</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="HOLCF_ROOT-predE"><span class="command">lemma</span></span> predE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>strict<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="main">|</span> <span class="main">(</span>FF<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> FF<span class="main">)</span>"</span></span> <span class="main">|</span> <span class="main">(</span>TT<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> TT<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> flat_codom<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">p</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> x<span class="main"><span class="main">=</span></span><span class="quoted"><span class="main">⊥</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-retraction_cfcomp_strict"><span class="command">lemma</span></span> retraction_cfcomp_strict<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span> <span class="main">=</span> ID"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms retraction_strict <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-match_Pair_csplit"><span class="command">lemma</span></span> match_Pair_csplit<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"match_Pair<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">k</span> <span class="main">=</span> <span class="free">k</span><span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemmas</span></span> oo_assoc <span class="main">=</span> assoc_oo <span class="comment1">―‹Normalize name›</span>

<span class="keyword1" id="HOLCF_ROOT-If_cancel"><span class="command">lemma</span></span> If_cancel<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="keyword1">else</span> <span class="free">x</span><span class="main">)</span> <span class="main">=</span> seq<span class="main">⋅</span><span class="free">b</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="HOLCF_ROOT-seq_below"><span class="command">lemma</span></span> seq_below<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"seq<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span> <span class="main">⊑</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> seq_conv_if<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-seq_strict_distr"><span class="command">lemma</span></span> seq_strict_distr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> seq<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>seq<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-strictify_below"><span class="command">lemma</span></span> strictify_below<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"strictify<span class="main">⋅</span><span class="free">f</span> <span class="main">⊑</span> <span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> strictify_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_below_iff<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-If_distr"><span class="command">lemma</span></span> If_distr<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">f</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">;</span> cont <span class="free">f</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">f</span> <span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">f</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">f</span> <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span>cont <span class="free">t'</span><span class="main">;</span> cont <span class="free">e'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">t'</span> <span class="keyword1">else</span> <span class="free">e'</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">t'</span> <span class="free">x</span> <span class="keyword1">else</span> <span class="free">e'</span> <span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">t'''</span> <span class="keyword1">else</span> <span class="free">e'''</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">t'''</span><span class="main">⋅</span><span class="free">x</span> <span class="keyword1">else</span> <span class="free">e'''</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">g</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">;</span> cont <span class="free">g</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">g</span> <span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">t''</span> <span class="keyword1">else</span> <span class="free">e''</span><span class="main">)</span> <span class="free">y</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">g</span> <span class="free">t''</span> <span class="free">y</span> <span class="keyword1">else</span> <span class="free">g</span> <span class="free">e''</span> <span class="free">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">b</span></span></span></span></span></span></span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="HOLCF_ROOT-If2_split_asm"><span class="command">lemma</span></span> If2_split_asm<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>If2 <span class="free">Q</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">¬</span><span class="main">(</span><span class="free">Q</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="main">¬</span><span class="free">P</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="free">Q</span> <span class="main">=</span> TT <span class="main">∧</span> <span class="main">¬</span><span class="free">P</span> <span class="free">x</span> <span class="main">∨</span> <span class="free">Q</span> <span class="main">=</span> FF <span class="main">∧</span> <span class="main">¬</span><span class="free">P</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">Q</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> If2_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> If2_splits <span class="main">=</span> split_If2 If2_split_asm

<span class="keyword1" id="HOLCF_ROOT-If2_cont"><span class="command">lemma</span></span> If2_cont<span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">cont2cont</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="free">e</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> If2 <span class="main">(</span><span class="free">i</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">t</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">e</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> If2_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="HOLCF_ROOT-If_else_FF"><span class="command">lemma</span></span> If_else_FF<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="keyword1">else</span> FF<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="keyword1">andalso</span> <span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="HOLCF_ROOT-If_then_TT"><span class="command">lemma</span></span> If_then_TT<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> TT <span class="keyword1">else</span> <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span> <span class="keyword1">orelse</span> <span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="HOLCF_ROOT-If_cong"><span class="command">lemma</span></span> If_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> <span class="free">b'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span><span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> TT <span class="main">⟹</span> <span class="free">t</span> <span class="main">=</span> <span class="free">t'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">=</span> FF <span class="main">⟹</span> <span class="free">e</span> <span class="main">=</span> <span class="free">e'</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">If</span> <span class="free">b'</span> <span class="keyword1">then</span> <span class="free">t'</span> <span class="keyword1">else</span> <span class="free">e'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="HOLCF_ROOT-If_tr"><span class="command">lemma</span></span> If_tr<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">If</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">e</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">(</span><span class="free">b</span> <span class="keyword1">andalso</span> <span class="free">t</span><span class="main">)</span> <span class="keyword1">orelse</span> <span class="main">(</span>neg<span class="main">⋅</span><span class="free">b</span> <span class="keyword1">andalso</span> <span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="HOLCF_ROOT-If_andalso"><span class="command">lemma</span></span> If_andalso<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">If</span> <span class="free">p</span> <span class="keyword1">andalso</span> <span class="free">q</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">e</span> <span class="main">=</span> <span class="keyword1">If</span> <span class="free">p</span> <span class="keyword1">then</span> <span class="keyword1">If</span> <span class="free">q</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">e</span> <span class="keyword1">else</span> <span class="free">e</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">p</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="HOLCF_ROOT-If_else_absorb"><span class="command">lemma</span></span> If_else_absorb<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">e</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">c</span> <span class="main">=</span> TT <span class="main">⟹</span> <span class="free">e</span> <span class="main">=</span> <span class="free">t</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">If</span> <span class="free">c</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">e</span> <span class="main">=</span> <span class="free">e</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">c</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-andalso_cong"><span class="command">lemma</span></span> andalso_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">P</span> <span class="main">=</span> <span class="free">P'</span><span class="main">;</span> <span class="free">P'</span> <span class="main">=</span> TT <span class="main">⟹</span> <span class="free">Q</span> <span class="main">=</span> <span class="free">Q'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="keyword1">andalso</span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">P'</span> <span class="keyword1">andalso</span> <span class="free">Q'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">P</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="HOLCF_ROOT-andalso_weaken_left"><span class="command">lemma</span></span> andalso_weaken_left<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">=</span> TT <span class="main">⟹</span> <span class="free">Q</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">=</span> FF <span class="main">⟹</span> <span class="free">Q</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">Q</span> <span class="main">≠</span> FF"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">=</span> <span class="main">(</span><span class="free">Q</span> <span class="keyword1">andalso</span> <span class="free">P</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">P</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">Q</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-orelse_cong"><span class="command">lemma</span></span> orelse_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">P</span> <span class="main">=</span> <span class="free">P'</span><span class="main">;</span> <span class="free">P'</span> <span class="main">=</span> FF <span class="main">⟹</span> <span class="free">Q</span> <span class="main">=</span> <span class="free">Q'</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">P</span> <span class="keyword1">orelse</span> <span class="free">Q</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">P'</span> <span class="keyword1">orelse</span> <span class="free">Q'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">P</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="HOLCF_ROOT-orelse_conv"><span class="command">lemma</span></span> orelse_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="keyword1">orelse</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> TT <span class="main">∨</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> FF <span class="main">∧</span> <span class="free">y</span> <span class="main">=</span> TT<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">x</span> <span class="keyword1">orelse</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> FF <span class="main">∧</span> <span class="free">y</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="HOLCF_ROOT-csplit_cfun2"><span class="command">lemma</span></span> csplit_cfun2<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="free">F</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">F</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>x<span class="main">,</span> y<span class="main">)</span><span class="main">.</span> <span class="free">F</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff prod_cont_iff<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-csplit_cfun3"><span class="command">lemma</span></span> csplit_cfun3<span class="main">:</span> <span class="quoted"><span class="quoted">"cont <span class="free">F</span> <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">F</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>x<span class="main">,</span> y<span class="main">,</span> z<span class="main">)</span><span class="main">.</span> <span class="free">F</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff prod_cont_iff<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">convol</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>cpo <span class="main">→</span> <span class="tfree">'b</span><span class="main">::</span>cpo<span class="main">)</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'c</span><span class="main">::</span>cpo<span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> <span class="main">×</span> <span class="tfree">'c</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">convol</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> f g x<span class="main">.</span> <span class="main">(</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">,</span> <span class="bound">g</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">convol_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>cpo <span class="main">→</span> <span class="tfree">'b</span><span class="main">::</span>cpo<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'c</span><span class="main">::</span>cpo<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> <span class="main">×</span> <span class="tfree">'c</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">&amp;&amp;</span>"</span> 65<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="free">&amp;&amp;</span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> convol<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">g</span></span></span>"</span></span>

<span class="keyword1" id="HOLCF_ROOT-convol_strict"><span class="command">lemma</span></span> convol_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"convol<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> convol_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="HOLCF_ROOT-convol_simp"><span class="command">lemma</span></span> convol_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">&amp;&amp;</span> <span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">x</span><span class="main">,</span> <span class="free">g</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> convol_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_prod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>cpo <span class="main">→</span> <span class="tfree">'c</span><span class="main">::</span>cpo<span class="main">)</span> <span class="main">→</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">::</span>cpo <span class="main">→</span> <span class="tfree">'d</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span> <span class="main">×</span> <span class="tfree">'d</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">map_prod</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> f g <span class="main">(</span>x<span class="main">,</span> y<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">,</span> <span class="bound">g</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">map_prod_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'c</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'d</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span> <span class="main">×</span> <span class="tfree">'d</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infix</span></span> <span class="quoted">"<span class="keyword1">**</span>"</span> 65<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main"><span class="free">**</span></span> <span class="free"><span class="bound"><span class="entity">g</span></span></span> <span class="main">≡</span> map_prod<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">g</span></span></span>"</span></span>

<span class="keyword1" id="HOLCF_ROOT-map_prod_cfcomp"><span class="command">lemma</span></span> map_prod_cfcomp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">**</span> <span class="free">m</span><span class="main">)</span> <span class="keyword1">oo</span> <span class="main">(</span><span class="free">g</span> <span class="main">**</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span> <span class="main">**</span> <span class="main">(</span><span class="free">m</span> <span class="keyword1">oo</span> <span class="free">n</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> map_prod_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-map_prod_ID"><span class="command">lemma</span></span> map_prod_ID<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"ID <span class="main">**</span> ID <span class="main">=</span> ID"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> map_prod_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-map_prod_app"><span class="command">lemma</span></span> map_prod_app<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">f</span> <span class="main">**</span> <span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> <span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">,</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> map_prod_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-map_prod_cfst"><span class="command">lemma</span></span> map_prod_cfst<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cfst <span class="keyword1">oo</span> <span class="main">(</span><span class="free">f</span> <span class="main">**</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span> <span class="keyword1">oo</span> cfst"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-map_prod_csnd"><span class="command">lemma</span></span> map_prod_csnd<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"csnd <span class="keyword1">oo</span> <span class="main">(</span><span class="free">f</span> <span class="main">**</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span> <span class="keyword1">oo</span> csnd"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Extra HOLCF Prelude. ›</span></span>

<span class="keyword1" id="HOLCF_ROOT-eq_strict"><span class="command">lemma</span></span> eq_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span><span class="main">::</span>Eq_strict<span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-Integer_le_both_plus_1"><span class="command">lemma</span></span> Integer_le_both_plus_1<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">m</span> <span class="main">::</span> <span class="quoted">Integer</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="main">(</span><span class="free">m</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> le<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="free">n</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-plus_eq_MkI_conv"><span class="command">lemma</span></span> plus_eq_MkI_conv<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">l</span> <span class="main">+</span> <span class="free">n</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="free">m</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">l'</span> <span class="bound">n'</span><span class="main">.</span> <span class="free">l</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="bound">l'</span> <span class="main">∧</span> <span class="free">n</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="bound">n'</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">=</span> <span class="bound">l'</span> <span class="main">+</span> <span class="bound">n'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">l</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="HOLCF_ROOT-lt_defined"><span class="command">lemma</span></span> lt_defined<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">Integer</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> TT <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> FF <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="HOLCF_ROOT-le_defined"><span class="command">lemma</span></span> le_defined<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted">Integer</span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> TT <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
    <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> FF <span class="main">⟹</span> <span class="main">(</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">y</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Induction on <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Integer›</span></span></span></span>, following the setup for the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>int›</span></span></span></span> type.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">Integer_ge_less_than</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int <span class="main">⇒</span> <span class="main">(</span>Integer <span class="main">×</span> Integer<span class="main">)</span> set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">Integer_ge_less_than</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="bound">z'</span><span class="main">,</span> MkI<span class="main">⋅</span><span class="bound">z</span><span class="main">)</span> <span class="main">|</span><span class="bound">z</span> <span class="bound">z'</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">d</span></span></span> <span class="main">≤</span> <span class="bound">z'</span> <span class="main">∧</span> <span class="bound">z'</span> <span class="main">&lt;</span> <span class="bound">z</span><span class="main">}</span>"</span></span>

<span class="keyword1" id="HOLCF_ROOT-wf_Integer_ge_less_than"><span class="command">lemma</span></span> wf_Integer_ge_less_than<span class="main">:</span> <span class="quoted"><span class="quoted">"wf <span class="main">(</span>Integer_ge_less_than <span class="free">d</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> wf_subset<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"Integer_ge_less_than <span class="free">d</span> <span class="main">⊆</span> measure <span class="main">(</span><span class="main">λ</span><span class="bound">z</span><span class="main">.</span> nat <span class="main">(</span><span class="keyword1">if</span> <span class="bound">z</span> <span class="main">=</span> <span class="main">⊥</span> <span class="keyword1">then</span> <span class="free">d</span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">THE</span> <span class="bound">z'</span><span class="main">.</span> <span class="bound">z</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="bound">z'</span><span class="main">)</span> <span class="main">-</span> <span class="free">d</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> Integer_ge_less_than_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Element equality \label{sec:equality} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

To avoid many extraneous headaches that take us far away from the
interesting parts of our derivation, we assume that the elements of
the pattern and text are drawn from a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ‹pcpo›<span class="antiquote"><span class="antiquote">}</span></span></span></span>
where, if the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹eq›<span class="antiquote"><span class="antiquote">}</span></span></span></span> function on this type is
given defined arguments, then its result is defined and coincides with
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="main"><span class="main">(=)</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Note this effectively restricts us to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">class</span></span> ‹flat›<span class="antiquote"><span class="antiquote">}</span></span></span></span>
element types; see <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] ‹\S4.12›
"Paulson:1987"<span class="antiquote"><span class="antiquote">}</span></span></span></span> for a discussion.

›</span></span>

<span class="keyword1"><span class="command">class</span></span> Eq_def <span class="main">=</span> Eq_eq <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> eq_defined<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">y</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> eq<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="HOLCF_ROOT-eq_bottom_iff"><span class="command">lemma</span></span> eq_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>eq<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="free">y</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> eq_defined <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="HOLCF_ROOT-eq_defined_reflD"><span class="command">lemma</span></span> eq_defined_reflD<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>eq<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">a</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>TT <span class="main">=</span> eq<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">a</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">a</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> eq<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">a</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">using</span></span> eq_refl <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="HOLCF_ROOT-eq_FF"><span class="command">lemma</span></span> eq_FF<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>FF <span class="main">=</span> eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">≠</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> FF<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">≠</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Exh_tr dist_eq_tr<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> eq_TT_dest eq_bottom_iff eq_self_neq_FF'<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="HOLCF_ROOT-eq_TT"><span class="command">lemma</span></span> eq_TT<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>TT <span class="main">=</span> eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> local.eq_TT_dest<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instance</span></span> Integer <span class="main">::</span> <span class="quoted">Eq_def</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">standard</span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Recursive let bindings›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">verbatim</span></span> <span class="raw_text"><span class="raw_text">‹
Title: HOL/HOLCF/ex/Letrec.thy
Author: Brian Huffman
›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>

See \S\ref{sec:KMP:final_version} for an example use.

›</span></span>

<span class="keyword1"><span class="command">definition</span></span>
  <span class="entity">CLetrec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pcpo <span class="main">→</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">::</span>pcpo<span class="main">)</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">CLetrec</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> F<span class="main">.</span> prod.snd <span class="main">(</span><span class="bound">F</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">μ</span> <span class="bound">x</span><span class="main">.</span> prod.fst <span class="main">(</span><span class="bound">F</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">nonterminal</span></span> recbinds <span class="keyword2"><span class="keyword">and</span></span> recbindt <span class="keyword2"><span class="keyword">and</span></span> recbind

<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_recbind"</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"logic <span class="main">⇒</span> logic <span class="main">⇒</span> recbind"</span></span>         <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span>_ <span class="keyword1">=</span><span class="keyword3">/ </span>_<span class="keyword3">)</span>"</span> 10<span class="main">)</span>
  <span class="quoted">""</span>          <span class="main">::</span> <span class="quoted"><span class="quoted">"recbind <span class="main">⇒</span> recbindt"</span></span>               <span class="main">(</span><span class="quoted">"_"</span><span class="main">)</span>
  <span class="quoted">"_recbindt"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"recbind <span class="main">⇒</span> recbindt <span class="main">⇒</span> recbindt"</span></span>   <span class="main">(</span><span class="quoted">"_<span class="keyword1">,</span><span class="keyword3">/ </span>_"</span><span class="main">)</span>
  <span class="quoted">""</span>          <span class="main">::</span> <span class="quoted"><span class="quoted">"recbindt <span class="main">⇒</span> recbinds"</span></span>              <span class="main">(</span><span class="quoted">"_"</span><span class="main">)</span>
  <span class="quoted">"_recbinds"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"recbindt <span class="main">⇒</span> recbinds <span class="main">⇒</span> recbinds"</span></span>  <span class="main">(</span><span class="quoted">"_<span class="keyword1">;</span><span class="keyword3">/ </span>_"</span><span class="main">)</span>
  <span class="quoted">"_Letrec"</span>   <span class="main">::</span> <span class="quoted"><span class="quoted">"recbinds <span class="main">⇒</span> logic <span class="main">⇒</span> logic"</span></span>        <span class="main">(</span><span class="quoted">"<span class="keyword3">(</span><span class="keyword1">Letrec</span> <span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword3">/ </span><span class="keyword1">in</span> <span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword3">)</span>"</span> 10<span class="main">)</span>

<span class="keyword1"><span class="command">translations</span></span>
  <span class="main">(</span>recbindt<span class="main">)</span> <span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">a</span><span class="main">,</span> <span class="main">(</span><span class="free">y</span><span class="main">,</span><span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span><span class="main">,</span><span class="free">bs</span><span class="main">)</span>"</span> <span class="main">==</span> <span class="main">(</span>recbindt<span class="main">)</span> <span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">,</span><span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">,</span><span class="free">bs</span><span class="main">)</span>"</span>
  <span class="main">(</span>recbindt<span class="main">)</span> <span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">a</span><span class="main">,</span> <span class="free">y</span> <span class="main">=</span> <span class="free">b</span>"</span>          <span class="main">==</span> <span class="main">(</span>recbindt<span class="main">)</span> <span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">,</span><span class="free">y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">b</span><span class="main">)</span>"</span>

<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"_Letrec <span class="main">(</span>_recbinds <span class="free">b</span> <span class="free">bs</span><span class="main">)</span> <span class="free">e</span>"</span> <span class="main">==</span> <span class="quoted">"_Letrec <span class="free">b</span> <span class="main">(</span>_Letrec <span class="free">bs</span> <span class="free">e</span><span class="main">)</span>"</span>
  <span class="quoted">"<span class="keyword1">Letrec</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">a</span> <span class="keyword1">in</span> <span class="main">(</span><span class="free">e</span><span class="main">,</span><span class="free">es</span><span class="main">)</span>"</span>    <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> CLetrec<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> xs<span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">e</span><span class="main">,</span><span class="free">es</span><span class="main">)</span><span class="main">)</span>"</span>
  <span class="quoted">"<span class="keyword1">Letrec</span> <span class="free">xs</span> <span class="main">=</span> <span class="free">a</span> <span class="keyword1">in</span> <span class="free">e</span>"</span>         <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> CLetrec<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> xs<span class="main">.</span> <span class="main">(</span><span class="free">a</span><span class="main">,</span><span class="free">e</span><span class="main">)</span><span class="main">)</span>"</span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="Theory_Of_Lists">
<div class="head">
<h1>Theory Theory_Of_Lists</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Theory_Of_Lists
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="HOLCF_ROOT.html">HOLCF_ROOT</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Strict lists \label{sec:theory_of_lists} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Head- and tail-strict lists. Many technical Isabelle details are
lifted from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>HOLCF-Prelude.Data_List›</span></span></span></span>; names follow
HOL, prefixed with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>s›</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">domain</span></span> <span class="tfree">'a</span> slist <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">[:</span></span></span>_<span class="keyword1"><span class="keyword1"><span class="keyword1">:]</span></span></span>"</span><span class="main">)</span> <span class="main">=</span>
  snil <span class="main">(</span><span class="quoted">"<span class="keyword1">[::]</span>"</span><span class="main">)</span>
<span class="main">|</span> scons <span class="main">(</span>shead <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span><span class="main">)</span> <span class="main">(</span>stail <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> slist"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">:#</span>"</span> 65<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-scons_strict"><span class="command">lemma</span></span> scons_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"scons<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-shead_bottom_iff"><span class="command">lemma</span></span> shead_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>shead<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-stail_bottom_iff"><span class="command">lemma</span></span> stail_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>stail<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-match_snil_match_scons_slist_case"><span class="command">lemma</span></span> match_snil_match_scons_slist_case<span class="main">:</span> <span class="quoted"><span class="quoted">"match_snil<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">k1</span> <span class="main">+++</span> match_scons<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">k2</span> <span class="main">=</span> slist_case<span class="main">⋅</span><span class="free">k1</span><span class="main">⋅</span><span class="free">k2</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-slist_bottom'"><span class="command">lemma</span></span> slist_bottom'<span class="main">:</span> <span class="quoted"><span class="quoted">"slist_case<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slist_bottom"><span class="command">lemma</span></span> slist_bottom<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"slist_case<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff slist_bottom'<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slist_case_distr"><span class="command">lemma</span></span> slist_case_distr<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>slist_case<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> slist_case<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x xs<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"slist_case<span class="main">⋅</span><span class="free">g'</span><span class="main">⋅</span><span class="free">h'</span><span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">z</span> <span class="main">=</span> slist_case<span class="main">⋅</span><span class="main">(</span><span class="free">g'</span><span class="main">⋅</span><span class="free">z</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x xs<span class="main">.</span> <span class="free">h'</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">⋅</span><span class="free">z</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">xs</span></span></span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-slist_case_cong"><span class="command">lemma</span></span> slist_case_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">xs'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs'</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">=</span> <span class="free">n'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">⟦</span><span class="free">xs'</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">:#</span> <span class="bound">ys</span><span class="main">;</span> <span class="bound">y</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">c</span> <span class="bound">y</span> <span class="bound">ys</span> <span class="main">=</span> <span class="free">c'</span> <span class="bound">y</span> <span class="bound">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">c</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">c'</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"slist_case<span class="main">⋅</span><span class="free">n</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x xs<span class="main">.</span> <span class="free">c</span> <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> slist_case<span class="main">⋅</span><span class="free">n'</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x xs<span class="main">.</span> <span class="free">c'</span> <span class="bound">x</span> <span class="bound">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">xs'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> prod_cont_iff<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Section syntax for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹scons›<span class="antiquote"><span class="antiquote">}</span></span></span></span> ala Haskell.

›</span></span>

<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_scons_section"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">'(:#')</span>"</span><span class="main">)</span>
  <span class="quoted">"_scons_section_left"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">'(</span>_<span class="keyword1">:#')</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"<span class="main">(</span><span class="free">x</span><span class="main">:#)</span>"</span> <span class="main">==</span> <span class="quoted">"<span class="main">(</span><span class="keyword1">CONST</span> Rep_cfun<span class="main">)</span> <span class="main">(</span><span class="keyword1">CONST</span> scons<span class="main">)</span> <span class="free">x</span>"</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">scons_section_right</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">'(:#</span>_<span class="keyword1">')</span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main"><span class="free">(:#</span></span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main"><span class="free">)</span></span> <span class="main">≡</span> <span class="keyword1">Λ</span> x<span class="main">.</span> <span class="bound">x</span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_strict_list"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"args <span class="main">⇒</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1">[:</span><span class="keyword3">(</span>_<span class="keyword3">)</span><span class="keyword1">:]</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"<span class="main">[:</span><span class="free">x</span><span class="main">,</span> <span class="free">xs</span><span class="main">:]</span>"</span> <span class="main">==</span> <span class="quoted">"<span class="free">x</span> <span class="main">:#</span> <span class="main">[:</span><span class="free">xs</span><span class="main">:]</span>"</span>
  <span class="quoted">"<span class="main">[:</span><span class="free">x</span><span class="main">:]</span>"</span> <span class="main">==</span> <span class="quoted">"<span class="free">x</span> <span class="main">:#</span> <span class="main">[::]</span>"</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Class instances.

›</span></span>

<span class="keyword1"><span class="command">instantiation</span></span> slist <span class="main">::</span> <span class="main">(</span><span class="quoted">Eq</span><span class="main">)</span> <span class="quoted">Eq_strict</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity"><span class="class_parameter">eq_slist</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> tr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eq_slist</span><span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> TT"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">eq_slist</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> FF"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">eq_slist</span><span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span> FF"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">eq_slist</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>eq<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">andalso</span> <span class="free">eq_slist</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">instance</span></span> <span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">subst</span> eq_slist.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">subst</span> eq_slist.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">instance</span></span> slist <span class="main">::</span> <span class="main">(</span><span class="quoted">Eq_sym</span><span class="main">)</span> <span class="quoted">Eq_sym</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">ys</span> <span class="main">=</span> eq<span class="main">⋅</span><span class="skolem">ys</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> snil
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> scons
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_sym<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instance</span></span> slist <span class="main">::</span> <span class="main">(</span><span class="quoted">Eq_equiv</span><span class="main">)</span> <span class="quoted">Eq_equiv</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">zs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">≠</span> FF"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">ys</span> <span class="main">=</span> TT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="skolem">ys</span><span class="main">⋅</span><span class="skolem">zs</span> <span class="main">=</span> TT"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">zs</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">ys</span></span> <span class="quoted"><span class="skolem">zs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">ys</span> <span class="skolem">zs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="skolem">zs</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> eq_trans <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">zs</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instance</span></span> slist <span class="main">::</span> <span class="main">(</span><span class="quoted">Eq_eq</span><span class="main">)</span> <span class="quoted">Eq_eq</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">≠</span> FF"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">ys</span> <span class="main">=</span> TT"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="skolem">ys</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">instance</span></span> slist <span class="main">::</span> <span class="main">(</span><span class="quoted">Eq_def</span><span class="main">)</span> <span class="quoted">Eq_def</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="skolem">ys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="skolem">ys</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">a</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Theory_Of_Lists-slist_eq_TT_snil"><span class="command">lemma</span></span> slist_eq_TT_snil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq<span class="main">:]</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">(</span>eq<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-slist_eq_FF_snil"><span class="command">lemma</span></span> slist_eq_FF_snil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq<span class="main">:]</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> FF<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="bound">ys</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">:#</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
        <span class="quoted"><span class="quoted">"<span class="main">(</span>eq<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> FF<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span> <span class="bound">ys</span><span class="main">.</span> <span class="bound">y</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">=</span> <span class="bound">y</span> <span class="main">:#</span> <span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Some of the usual reasoning infrastructure ›</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">slistmem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">slistmem</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">slistmem</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">slistmem</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-slistmem_bottom1"><span class="command">lemma</span></span> slistmem_bottom1<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> slistmem <span class="free">x</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span><span class="main">::</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> slistmem.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slistmem_bottom2"><span class="command">lemma</span></span> slistmem_bottom2<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> slistmem <span class="main">⊥</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">rule</span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="main">⊥</span><span class="main">::</span><span class="tfree">'a</span>"</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> slistmem.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slistmem_nil"><span class="command">lemma</span></span> slistmem_nil<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">¬</span> slistmem <span class="free">x</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> slistmem.cases<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slistmem_scons"><span class="command">lemma</span></span> slistmem_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"slistmem <span class="free">x</span> <span class="main">(</span><span class="free">y</span> <span class="main">:#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">∨</span> <span class="main">(</span>slistmem <span class="free">x</span> <span class="free">ys</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">y</span> <span class="main">∨</span> slistmem <span class="free">x</span> <span class="free">ys</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"slistmem <span class="free">x</span> <span class="main">(</span><span class="free">y</span> <span class="main">:#</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"<span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">:#</span> <span class="free">ys</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">y</span></span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> slistmem.induct<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> slistmem.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> slistmem.intros<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">⇒</span> <span class="tfree">'a</span> set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sset</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span><span class="main">.</span> slistmem <span class="bound">x</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">}</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sset_simp"><span class="command">lemma</span></span> sset_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sset <span class="main">⊥</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"sset <span class="main">[::]</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> sset <span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">x</span> <span class="main">(</span>sset <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> sset_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> slistmem.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> slistmem.intros<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sset_defined"><span class="command">lemma</span></span> sset_defined<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> sset <span class="free">xs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms sset_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1" id="Theory_Of_Lists-sset_below"><span class="command">lemma</span></span> sset_below<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">∈</span> sset <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">⊑</span> <span class="free">ys</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">x</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">∈</span> sset <span class="free">xs</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">⊑</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">y</span> <span class="skolem">ys</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Some of the usual operations ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

A variety of functions on lists. Drawn from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
"Bird:1987"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> ‹<a href="../../HOL/HOL/List.html"></a><a href="../../HOL/HOL/List.html">HOL.List</a>›<span class="antiquote"><span class="antiquote">}</span></span></span></span> and
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> ‹<a href="../HOLCF-Prelude/Data_List.html"></a><a href="../HOLCF-Prelude/Data_List.html">HOLCF-Prelude.Data_List</a>›<span class="antiquote"><span class="antiquote">}</span></span></span></span>. The definitions vary because,
for instance, the strictness of some of those in
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">theory</span></span> ‹<a href="../HOLCF-Prelude/Data_List.html"></a><a href="../HOLCF-Prelude/Data_List.html">HOLCF-Prelude.Data_List</a>›<span class="antiquote"><span class="antiquote">}</span></span></span></span> correspond neither to those in
Haskell nor Bird's expectations (specifically <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>stails›</span></span></span></span>,
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>inits›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sscanl›</span></span></span></span>).

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">snull</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> tr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">snull</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> TT"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">snull</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> FF"</span></span>

<span class="keyword1" id="Theory_Of_Lists-snull_strict"><span class="command">lemma</span></span> snull_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"snull<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-snull_bottom_iff"><span class="command">lemma</span></span> snull_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>snull<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-snull_FF_conv"><span class="command">lemma</span></span> snull_FF_conv<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>snull<span class="main">⋅</span><span class="free">xxs</span> <span class="main">=</span> FF<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="free">xxs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">xxs</span> <span class="main">=</span> <span class="bound">x</span> <span class="main">:#</span> <span class="bound">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xxs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-snull_TT_conv"><span class="command">lemma</span></span> snull_TT_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>snull<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-snull_eq_snil"><span class="command">lemma</span></span> snull_eq_snil<span class="main">:</span> <span class="quoted"><span class="quoted">"snull<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">smap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'b</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">smap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span><span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">smap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free">smap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-smap_strict"><span class="command">lemma</span></span> smap_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-smap_bottom_iff"><span class="command">lemma</span></span> smap_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>sset <span class="free">xs</span><span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-smap_is_snil_conv"><span class="command">lemma</span></span> smap_is_snil_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> <span class="main">[::]</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-smap_strict_scons"><span class="command">lemma</span></span> smap_strict_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span> <span class="main">:#</span> smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-smap_ID'"><span class="command">lemma</span></span> smap_ID'<span class="main">:</span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span>ID<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-smap_ID"><span class="command">lemma</span></span> smap_ID<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span>ID <span class="main">=</span> ID"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff smap_ID'<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-smap_cong"><span class="command">lemma</span></span> smap_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">xs'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> sset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="free">f'</span><span class="main">⋅</span><span class="free">xs'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs'</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-smap_smap'"><span class="command">lemma</span></span> smap_smap'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>smap<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-smap_smap"><span class="command">lemma</span></span> smap_smap<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">f</span> <span class="keyword1">oo</span> smap<span class="main">⋅</span><span class="free">g</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sset_smap"><span class="command">lemma</span></span> sset_smap<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> sset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sset <span class="main">(</span>smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">|</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> sset <span class="free">xs</span> <span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-shead_smap_distr"><span class="command">lemma</span></span> shead_smap_distr<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">∈</span>sset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"shead<span class="main">⋅</span><span class="main">(</span>smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>shead<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sappend</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sappend</span><span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">sappend</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free">sappend</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sappend_syn</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> slist <span class="main">⇒</span> <span class="tfree">'a</span> slist <span class="main">⇒</span> <span class="tfree">'a</span> slist"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixr</span></span> <span class="quoted">"<span class="keyword1">:@</span>"</span> 65<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main"><span class="free">:@</span></span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≡</span> sappend<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sappend_strict"><span class="command">lemma</span></span> sappend_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sappend<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-sappend_strict2"><span class="command">lemma</span></span> sappend_strict2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">:@</span> <span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sappend_bottom_iff"><span class="command">lemma</span></span> sappend_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sappend_scons"><span class="command">lemma</span></span> sappend_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">:@</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sappend_assoc"><span class="command">lemma</span></span> sappend_assoc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">:@</span> <span class="free">zs</span> <span class="main">=</span> <span class="free">xs</span> <span class="main">:@</span> <span class="main">(</span><span class="free">ys</span> <span class="main">:@</span> <span class="free">zs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sappend_snil_id_left"><span class="command">lemma</span></span> sappend_snil_id_left<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sappend<span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> ID"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sappend_snil_id_right"><span class="command">lemma</span></span> sappend_snil_id_right<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">:@</span> <span class="main">[::]</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-snil_append_iff"><span class="command">lemma</span></span> snil_append_iff<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">⟷</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-smap_sappend"><span class="command">lemma</span></span> smap_sappend<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">:@</span> smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-stail_sappend"><span class="command">lemma</span></span> stail_sappend<span class="main">:</span> <span class="quoted"><span class="quoted">"stail<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="keyword1">of</span> <span class="main">[::]</span> <span class="main">⇒</span> stail<span class="main">⋅</span><span class="free">ys</span> <span class="main">|</span> <span class="bound">z</span> <span class="main">:#</span> <span class="bound">zs</span> <span class="main">⇒</span> <span class="bound">zs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-stail_append2"><span class="command">lemma</span></span> stail_append2<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[::]</span> <span class="main">⟹</span> stail<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> stail<span class="main">⋅</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-slist_case_snoc"><span class="command">lemma</span></span> slist_case_snoc<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> slist_case<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span> <span class="main">=</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span>shead<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>stail<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sall</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> tr<span class="main">)</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> tr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sall</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> TT"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">sall</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">andalso</span> <span class="free">sall</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sall_strict"><span class="command">lemma</span></span> sall_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sall<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-sall_const_TT"><span class="command">lemma</span></span> sall_const_TT<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sall<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> TT<span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sall_const_TT_conv"><span class="command">lemma</span></span> sall_const_TT_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sall<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> TT<span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-sall_TT"><span class="command">lemma</span></span> sall_TT<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sall<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">x</span><span class="main">∈</span>sset <span class="free">xs</span><span class="main">.</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> TT<span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sfilter</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> tr<span class="main">)</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sfilter</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">sfilter</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">If</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free">sfilter</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="free">sfilter</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_strict"><span class="command">lemma</span></span> sfilter_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_bottom_iff"><span class="command">lemma</span></span> sfilter_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>sset <span class="free">xs</span><span class="main">.</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">use</span> trE <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sset_sfilter"><span class="command">lemma</span></span> sset_sfilter<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> sset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sset <span class="main">(</span>sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span><span class="bound">x</span> <span class="main">|</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> sset <span class="free">xs</span> <span class="main">∧</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> TT<span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_strict_scons"><span class="command">lemma</span></span> sfilter_strict_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">If</span> <span class="free">p</span><span class="main">⋅</span><span class="free">x</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="main">:#</span> sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span> <span class="keyword1">else</span> sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_scons_let"><span class="command">lemma</span></span> sfilter_scons_let<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">let</span> <span class="bound">xs'</span> <span class="main">=</span> sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span> <span class="keyword1">in</span> <span class="keyword1">If</span> <span class="free">p</span><span class="main">⋅</span><span class="free">x</span> <span class="keyword1">then</span> <span class="free">x</span> <span class="main">:#</span> <span class="bound">xs'</span> <span class="keyword1">else</span> <span class="bound">xs'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> Let_def <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_sappend"><span class="command">lemma</span></span> sfilter_sappend<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">:@</span> sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_const_FF"><span class="command">lemma</span></span> sfilter_const_FF<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> FF<span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_const_FF_conv"><span class="command">lemma</span></span> sfilter_const_FF_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> FF<span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_const_TT"><span class="command">lemma</span></span> sfilter_const_TT<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> TT<span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_cong"><span class="command">lemma</span></span> sfilter_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">xs'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> sset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> <span class="free">p'</span><span class="main">⋅</span><span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> sfilter<span class="main">⋅</span><span class="free">p'</span><span class="main">⋅</span><span class="free">xs'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs'</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_snil_conv"><span class="command">lemma</span></span> sfilter_snil_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">⟷</span> sall<span class="main">⋅</span><span class="main">(</span>neg <span class="keyword1">oo</span> <span class="free">p</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_sfilter'"><span class="command">lemma</span></span> sfilter_sfilter'<span class="main">:</span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="free">q</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">q</span><span class="main">⋅</span><span class="bound">x</span> <span class="keyword1">andalso</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">from</span></span> scons<span class="main">(</span>1<span class="main">,</span> 2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">q</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main">)</span>
       <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> If_distr If_andalso scons<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> sfilter_bottom_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_sfilter"><span class="command">lemma</span></span> sfilter_sfilter<span class="main">:</span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">p</span> <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="free">q</span> <span class="main">=</span> sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="free">q</span><span class="main">⋅</span><span class="bound">x</span> <span class="keyword1">andalso</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff sfilter_sfilter'<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_smap'"><span class="command">lemma</span></span> sfilter_smap'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">p</span><span class="main">⋅</span><span class="main">(</span>smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="free">p</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> slist.con_rews<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> smap.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> smap_strict<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sfilter_smap"><span class="command">lemma</span></span> sfilter_smap<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="free">p</span> <span class="keyword1">oo</span> smap<span class="main">⋅</span><span class="free">f</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="free">f</span> <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="main">(</span><span class="free">p</span> <span class="keyword1">oo</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff sfilter_smap'<span class="main">)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sfoldl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">::</span>pcpo <span class="main">→</span> <span class="tfree">'b</span><span class="main">::</span>domain <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'b</span><span class="main">:]</span> <span class="main">→</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sfoldl</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">sfoldl</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">sfoldl</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sfoldl_strict"><span class="command">lemma</span></span> sfoldl_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-sfoldl_strict_f"><span class="command">lemma</span></span> sfoldl_strict_f<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sfoldl_cong"><span class="command">lemma</span></span> sfoldl_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">xs'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">=</span> <span class="free">z'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">z</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> sset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">z</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="bound">z</span><span class="main">⋅</span><span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> sfoldl<span class="main">⋅</span><span class="free">f'</span><span class="main">⋅</span><span class="free">z'</span><span class="main">⋅</span><span class="free">xs'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs'</span></span> <span class="quoted"><span class="free">z</span></span> <span class="quoted"><span class="free">z'</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-sfoldl_sappend"><span class="command">lemma</span></span> sfoldl_sappend<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> sfoldl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>sfoldl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">z</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sfoldr</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">::</span>pcpo <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'b</span><span class="main">:]</span> <span class="main">→</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sfoldr</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">sfoldr</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free">sfoldr</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sfoldr_strict"><span class="command">lemma</span></span> sfoldr_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sfoldr<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sconcat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sconcat</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">sconcat</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:@</span> <span class="free">sconcat</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sconcat_strict"><span class="command">lemma</span></span> sconcat_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sconcat<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-sconcat_scons"><span class="command">lemma</span></span> sconcat_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sconcat<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">:@</span> sconcat<span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sconcat_sfoldl_aux"><span class="command">lemma</span></span> sconcat_sfoldl_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span>sappend<span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">z</span> <span class="main">:@</span> sconcat<span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">z</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sconcat_sfoldl"><span class="command">lemma</span></span> sconcat_sfoldl<span class="main">:</span> <span class="quoted"><span class="quoted">"sconcat <span class="main">=</span> sfoldl<span class="main">⋅</span>sappend<span class="main">⋅</span><span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff sconcat_sfoldl_aux<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sconcat_sappend"><span class="command">lemma</span></span> sconcat_sappend<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sconcat<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> sconcat<span class="main">⋅</span><span class="free">xs</span> <span class="main">:@</span> sconcat<span class="main">⋅</span><span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">slength</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> Integer"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">slength</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">0</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">slength</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">slength</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">+</span> <span class="main">1</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-slength_strict"><span class="command">lemma</span></span> slength_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-slength_bottom_iff"><span class="command">lemma</span></span> slength_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-slength_ge_0"><span class="command">lemma</span></span> slength_ge_0<span class="main">:</span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="free">n</span> <span class="main">⟹</span> <span class="free">n</span> <span class="main">≥</span> <span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def plus_eq_MkI_conv<span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-slengthE"><span class="command">lemma</span></span> slengthE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="main">⋀</span><span class="bound">n</span><span class="main">.</span> <span class="main">⟦</span>slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="bound">n</span><span class="main">;</span> <span class="main">0</span> <span class="main">≤</span> <span class="bound">n</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">Q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Integer.exhaust slength_bottom_iff slength_ge_0<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slength_0_conv"><span class="command">lemma</span></span> slength_0_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">0</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="main">0</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="main">0</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> snull<span class="main">⋅</span><span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">0</span> <span class="main">=</span> snull<span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_Integer_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-le_slength_0"><span class="command">lemma</span></span> le_slength_0<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>le<span class="main">⋅</span><span class="main">0</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="free">xs</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> slength_ge_0 zero_Integer_def<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-lt_slength_0"><span class="command">lemma</span></span> lt_slength_0<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">0</span> <span class="main">=</span> FF"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> zero_Integer_def one_Integer_def <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slength_smap"><span class="command">lemma</span></span> slength_smap<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="main">(</span>smap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> slength<span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-slength_sappend"><span class="command">lemma</span></span> slength_sappend<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">+</span> slength<span class="main">⋅</span><span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slength_sfoldl_aux"><span class="command">lemma</span></span> slength_sfoldl_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> i <span class="main">_</span><span class="main">.</span> <span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">z</span> <span class="main">+</span> slength<span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">z</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="dynamic"><span class="dynamic">ac_simps</span></span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slength_sfoldl"><span class="command">lemma</span></span> slength_sfoldl<span class="main">:</span> <span class="quoted"><span class="quoted">"slength <span class="main">=</span> sfoldl<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> i <span class="main">_</span><span class="main">.</span> <span class="bound">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="main">0</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff slength_sfoldl_aux<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-le_slength_plus"><span class="command">lemma</span></span> le_slength_plus<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">n</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="free">n</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">+</span> <span class="free">n</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">n</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">srev</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">srev</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">srev</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">srev</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-srev_strict"><span class="command">lemma</span></span> srev_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"srev<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-srev_bottom_iff"><span class="command">lemma</span></span> srev_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>srev<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-srev_scons"><span class="command">lemma</span></span> srev_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"srev<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> srev<span class="main">⋅</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-srev_sappend"><span class="command">lemma</span></span> srev_sappend<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"srev<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> srev<span class="main">⋅</span><span class="free">ys</span> <span class="main">:@</span> srev<span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-srev_srev_ident"><span class="command">lemma</span></span> srev_srev_ident<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"srev<span class="main">⋅</span><span class="main">(</span>srev<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-srev_cases"><span class="command">lemma</span></span> srev_cases<span class="main">[</span><span class="operator">case_names</span> bottom snil ssnoc<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">ys</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">y</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="bound">ys</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">xs</span> <span class="main">=</span> <span class="bound">ys</span> <span class="main">:@</span> <span class="main">[:</span><span class="bound">y</span><span class="main">:]</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> slist.exhaust srev.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> srev_scons srev_srev_ident srev_strict<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-srev_induct"><span class="command">lemma</span></span> srev_induct<span class="main">[</span><span class="operator">case_names</span> bottom snil ssnoc<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">[::]</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">xs</span><span class="main">.</span> <span class="main">⟦</span><span class="bound">x</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="bound">xs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">P</span> <span class="bound">xs</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span><span class="bound">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="bound">x</span><span class="main">:]</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>srev<span class="main">⋅</span><span class="main">(</span>srev<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> slist.induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"srev<span class="main"><span class="main"><span class="main">⋅</span></span></span><span class="free"><span class="free"><span class="free">xs</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Theory_Of_Lists-sfoldr_conv_sfoldl"><span class="command">lemma</span></span> sfoldr_conv_sfoldl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="comment1">―‹<span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>f›</span></span> must be strict in the accumulator.›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfoldr<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> sfoldl<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> acc x<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">acc</span><span class="main">)</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="main">(</span>srev<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">z</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">stake</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Integer <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="comment1">―‹ Note: strict in both parameters. ›</span>
  <span class="quoted"><span class="quoted">"<span class="free">stake</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">stake</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">stake</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">If</span> le<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">⋅</span><span class="main">0</span> <span class="keyword1">then</span> <span class="main">[::]</span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free">stake</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-stake_strict"><span class="command">lemma</span></span> stake_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"stake<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"stake<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-stake_bottom_iff"><span class="command">lemma</span></span> stake_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>stake<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">i</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">i</span></span></span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-stake_0"><span class="command">lemma</span></span> stake_0<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> stake<span class="main">⋅</span><span class="main">0</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> stake<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">0</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
  <span class="quoted"><span class="quoted">"stake<span class="main">⋅</span><span class="main">0</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">⊑</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_Integer_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-stake_scons"><span class="command">lemma</span></span> stake_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="main">1</span><span class="main">⋅</span><span class="free">i</span> <span class="main">=</span> TT <span class="main">⟹</span> stake<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">:#</span> stake<span class="main">⋅</span><span class="main">(</span><span class="free">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span>
    <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-take_MkI_scons"><span class="command">lemma</span></span> take_MkI_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">&lt;</span> <span class="free">n</span> <span class="main">⟹</span> stake<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">n</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">:#</span> stake<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-stake_numeral_scons"><span class="command">lemma</span></span> stake_numeral_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> stake<span class="main">⋅</span><span class="main">1</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span>"</span></span>
  <span class="quoted"><span class="quoted">"stake<span class="main">⋅</span><span class="main">(</span>numeral <span class="main">(</span>Num.Bit0 <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">:#</span> stake<span class="main">⋅</span><span class="main">(</span>numeral <span class="main">(</span>Num.BitM <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"stake<span class="main">⋅</span><span class="main">(</span>numeral <span class="main">(</span>Num.Bit1 <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span> <span class="main">:#</span> stake<span class="main">⋅</span><span class="main">(</span>numeral <span class="main">(</span>Num.Bit0 <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def numeral_Integer_eq<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-stake_all"><span class="command">lemma</span></span> stake_all<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">i</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stake<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits if_splits <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_defined<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-stake_all_triv"><span class="command">lemma</span></span> stake_all_triv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stake<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> stake_all<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-stake_append"><span class="command">lemma</span></span> stake_append<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stake<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> stake<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">:@</span> stake<span class="main">⋅</span><span class="main">(</span><span class="free">i</span> <span class="main">-</span> slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_Integer_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits  <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sdrop</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Integer <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="comment1">―‹ Note: strict in both parameters. ›</span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sdrop</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> le<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">⋅</span><span class="main">0</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">else</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> <span class="main">[::]</span> <span class="main">⇒</span> <span class="main">[::]</span> <span class="main">|</span> <span class="bound">y</span> <span class="main">:#</span> <span class="bound">ys</span> <span class="main">⇒</span> <span class="free">sdrop</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="bound">ys</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_strict"><span class="command">lemma</span></span> sdrop_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_bottom_iff"><span class="command">lemma</span></span> sdrop_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sdrop<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">i</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.unfold<span class="main">)</span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.unfold<span class="main">)</span> <span class="operator">fastforce</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_snil"><span class="command">lemma</span></span> sdrop_snil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_snil_conv"><span class="command">lemma</span></span> sdrop_snil_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sdrop<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">i</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_0"><span class="command">lemma</span></span> sdrop_0<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="main">0</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">0</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_Integer_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_pos"><span class="command">lemma</span></span> sdrop_pos<span class="main">:</span>
  <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="main">0</span> <span class="main">=</span> FF <span class="main">⟹</span> sdrop<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="keyword1">of</span> <span class="main">[::]</span> <span class="main">⇒</span> <span class="main">[::]</span> <span class="main">|</span> <span class="bound">y</span> <span class="main">:#</span> <span class="bound">ys</span> <span class="main">⇒</span> sdrop<span class="main">⋅</span><span class="main">(</span><span class="free">i</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="bound">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_neg"><span class="command">lemma</span></span> sdrop_neg<span class="main">:</span>
  <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="main">0</span> <span class="main">=</span> TT <span class="main">⟹</span> sdrop<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_numeral_scons"><span class="command">lemma</span></span> sdrop_numeral_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> sdrop<span class="main">⋅</span><span class="main">1</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> sdrop<span class="main">⋅</span><span class="main">(</span>numeral <span class="main">(</span>Num.Bit0 <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sdrop<span class="main">⋅</span><span class="main">(</span>numeral <span class="main">(</span>Num.BitM <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> sdrop<span class="main">⋅</span><span class="main">(</span>numeral <span class="main">(</span>Num.Bit1 <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sdrop<span class="main">⋅</span><span class="main">(</span>numeral <span class="main">(</span>Num.Bit0 <span class="free">k</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.simps<span class="main"><span class="keyword3">,</span></span>
    <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def numeral_Integer_eq<span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_sappend"><span class="command">lemma</span></span> sdrop_sappend<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> sdrop<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">:@</span> sdrop<span class="main">⋅</span><span class="main">(</span><span class="free">i</span> <span class="main">-</span> slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_Integer_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="skolem">i</span><span class="main">⋅</span><span class="main">0</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">;</span></span>
        <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def sdrop_neg sdrop_pos add.commute diff_diff_add
                <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_all"><span class="command">lemma</span></span> sdrop_all<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">i</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">;</span></span>
        <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits if_splits <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_defined<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slength_sdrop"><span class="command">lemma</span></span> slength_sdrop<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">If</span> le<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="main">0</span> <span class="keyword1">then</span> slength<span class="main">⋅</span><span class="free">xs</span> <span class="keyword1">else</span> <span class="keyword1">If</span> le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">i</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">-</span> <span class="free">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> zero_Integer_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_not_snilD"><span class="command">lemma</span></span> sdrop_not_snilD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">[::]</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> TT <span class="main">∧</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> sdrop.unfold<span class="main"><span class="keyword3">,</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def not_le sdrop_all <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_sappend_same"><span class="command">lemma</span></span> sdrop_sappend_same<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">subst</span> sdrop.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sscanl</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'b</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sscanl</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">:#</span> <span class="main">[::]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">sscanl</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">z</span></span></span> <span class="main">:#</span> <span class="free">sscanl</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">z</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sscanl_strict"><span class="command">lemma</span></span> sscanl_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sscanl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"sscanl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-sscanl_cong"><span class="command">lemma</span></span> sscanl_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="free">xs'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">z</span> <span class="main">=</span> <span class="free">z'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">z</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> sset <span class="free">xs</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">z</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="bound">z</span><span class="main">⋅</span><span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sscanl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> sscanl<span class="main">⋅</span><span class="free">f'</span><span class="main">⋅</span><span class="free">z'</span><span class="main">⋅</span><span class="free">xs'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs'</span></span> <span class="quoted"><span class="free">z</span></span> <span class="quoted"><span class="free">z'</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-sscanl_lfp_fusion'"><span class="command">lemma</span></span> sscanl_lfp_fusion'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">acc</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">acc</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="bound">acc</span><span class="main">)</span><span class="main">⋅</span><span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span>sscanl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sscanl<span class="main">⋅</span><span class="free">f'</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="free">z</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">z</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sscanl_lfp_fusion"><span class="command">lemma</span></span> sscanl_lfp_fusion<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">acc</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">acc</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="bound">acc</span><span class="main">)</span><span class="main">⋅</span><span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">g</span> <span class="keyword1">oo</span> sscanl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span> <span class="main">=</span> sscanl<span class="main">⋅</span><span class="free">f'</span><span class="main">⋅</span><span class="main">(</span><span class="free">g</span><span class="main">⋅</span><span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff sscanl_lfp_fusion'<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sscanl_ww_fusion'"><span class="command">lemma</span></span> sscanl_ww_fusion'<span class="main">:</span> <span class="comment1">―‹ Worker/wrapper <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">cite</span> [cite_macro=citep] "GillHutton:2009" <span class="quasi_keyword">and</span> "Gammie:2011"<span class="antiquote">}</span></span> specialised to <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ‹sscanl›<span class="antiquote">}</span></span> ›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'c</span> <span class="main">→</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ww<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="main">=</span> ID"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">z</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">unwrap</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span><span class="main">⋅</span><span class="bound">z</span><span class="main">)</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span><span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span><span class="main">⋅</span><span class="bound">z</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sscanl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="free">wrap</span><span class="main">⋅</span><span class="main">(</span>sscanl<span class="main">⋅</span><span class="free">f'</span><span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span><span class="main">⋅</span><span class="free">z</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">z</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff retraction_cfcomp_strict <span class="main"><span class="keyword3">|</span></span> <span class="operator">metis</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-sscanl_ww_fusion"><span class="command">lemma</span></span> sscanl_ww_fusion<span class="main">:</span> <span class="comment1">―‹ Worker/wrapper <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">cite</span> [cite_macro=citep] "GillHutton:2009" <span class="quasi_keyword">and</span> "Gammie:2011"<span class="antiquote">}</span></span> specialised to <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ‹sscanl›<span class="antiquote">}</span></span> ›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">wrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">unwrap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">z</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'c</span> <span class="main">→</span> <span class="tfree">'a</span>"</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">→</span> <span class="tfree">'c</span> <span class="main">→</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ww<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">wrap</span> <span class="keyword1">oo</span> <span class="free">unwrap</span> <span class="main">=</span> ID"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> wb<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">z</span> <span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">unwrap</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span><span class="main">⋅</span><span class="bound">z</span><span class="main">)</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">f'</span><span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span><span class="main">⋅</span><span class="main">(</span><span class="free">wrap</span><span class="main">⋅</span><span class="bound">z</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sscanl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="free">wrap</span> <span class="keyword1">oo</span> sscanl<span class="main">⋅</span><span class="free">f'</span><span class="main">⋅</span><span class="main">(</span><span class="free">unwrap</span><span class="main">⋅</span><span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff sscanl_ww_fusion'<span class="main">)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sinits</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sinits</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">:#</span> <span class="main">[::]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">sinits</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">:#</span> smap<span class="main">⋅</span><span class="main">(</span>scons<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">sinits</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sinits_strict"><span class="command">lemma</span></span> sinits_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sinits<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_bottom_iff"><span class="command">lemma</span></span> sinits_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sinits<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_not_snil"><span class="command">lemma</span></span> sinits_not_snil<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sinits<span class="main">⋅</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_empty_bottom"><span class="command">lemma</span></span> sinits_empty_bottom<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sset <span class="main">(</span>sinits<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_scons"><span class="command">lemma</span></span> sinits_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sinits<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">:#</span> smap<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#)</span><span class="main">⋅</span><span class="main">(</span>sinits<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_length"><span class="command">lemma</span></span> sinits_length<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="main">(</span>sinits<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_snoc"><span class="command">lemma</span></span> sinits_snoc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sinits<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span> <span class="main">=</span> sinits<span class="main">⋅</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_foldr'"><span class="command">lemma</span></span> sinits_foldr'<span class="main">:</span> <span class="comment1">―‹ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">cite</span> [cite_macro=citet] ‹p30› "Bird:1987"<span class="antiquote">}</span></span> ›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sinits<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> sfoldr<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x xs<span class="main">.</span> <span class="main">[:</span><span class="main">[::]</span><span class="main">:]</span> <span class="main">:@</span> smap<span class="main">⋅</span><span class="main">(</span><span class="bound">x</span> <span class="main">:#)</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">[:</span><span class="main">[::]</span><span class="main">:]</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_sscanl'"><span class="command">lemma</span></span> sinits_sscanl'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="main">(</span>sfoldl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>sinits<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sscanl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">z</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> smap_cong <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oo_def eta_cfun<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_sscanl"><span class="command">lemma</span></span> sinits_sscanl<span class="main">:</span> <span class="comment1">―‹ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">cite</span> [cite_macro=citet] ‹Lemma~5› "Bird:1987"<span class="antiquote">}</span></span>, <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">cite</span> [cite_macro=citet] ‹p118 ``the scan lemma''› "Bird:PearlsofFAD:2010"<span class="antiquote">}</span></span> ›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="main">(</span>sfoldl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span><span class="main">)</span> <span class="keyword1">oo</span> sinits <span class="main">=</span> sscanl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sinits_sscanl' cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_all"><span class="command">lemma</span></span> sinits_all<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span> <span class="main">∈</span> sset <span class="main">(</span>sinits<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">stails</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">stails</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">:#</span> <span class="main">[::]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">stails</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">:#</span> <span class="free">stails</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-stails_strict"><span class="command">lemma</span></span> stails_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stails<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-stails_bottom_iff"><span class="command">lemma</span></span> stails_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>stails<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-stails_not_snil"><span class="command">lemma</span></span> stails_not_snil<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stails<span class="main">⋅</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-stails_scons"><span class="command">lemma</span></span> stails_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"stails<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">:#</span> stails<span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-stails_slength"><span class="command">lemma</span></span> stails_slength<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="main">(</span>stails<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">+</span> <span class="main">1</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-stails_snoc"><span class="command">lemma</span></span> stails_snoc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stails<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> ys<span class="main">.</span> <span class="bound">ys</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>stails<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">:@</span> <span class="main">[:</span><span class="main">[::]</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-stails_sfoldl'"><span class="command">lemma</span></span> stails_sfoldl'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stails<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> sfoldl<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> xs x<span class="main">.</span> smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> ys<span class="main">.</span> <span class="bound">ys</span> <span class="main">:@</span> <span class="main">[:</span><span class="bound">x</span><span class="main">:]</span><span class="main">)</span><span class="main">⋅</span><span class="bound">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="main">[::]</span><span class="main">:]</span><span class="main">)</span><span class="main">⋅</span><span class="main">[:</span><span class="main">[::]</span><span class="main">:]</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> srev_induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-stails_sfoldl"><span class="command">lemma</span></span> stails_sfoldl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stails <span class="main">=</span> sfoldl<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> xs x<span class="main">.</span> smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> ys<span class="main">.</span> <span class="bound">ys</span> <span class="main">:@</span> <span class="main">[:</span><span class="bound">x</span><span class="main">:]</span><span class="main">)</span><span class="main">⋅</span><span class="bound">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="main">[::]</span><span class="main">:]</span><span class="main">)</span><span class="main">⋅</span><span class="main">[:</span><span class="main">[::]</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff stails_sfoldl'<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-stails_all"><span class="command">lemma</span></span> stails_all<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">xs</span> <span class="main">∈</span> sset <span class="main">(</span>stails<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">selem</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>Eq_def <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> tr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">selem</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> FF"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">selem</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>eq<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">orelse</span> <span class="free">selem</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-selem_strict"><span class="command">lemma</span></span> selem_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"selem<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-selem_bottom_iff"><span class="command">lemma</span></span> selem_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>selem<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">[::]</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-selem_sappend"><span class="command">lemma</span></span> selem_sappend<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"selem<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>selem<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">xs</span> <span class="keyword1">orelse</span> selem<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-elem_TT"><span class="command">lemma</span></span> elem_TT<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>selem<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> sset <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> sset_defined<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-elem_FF"><span class="command">lemma</span></span> elem_FF<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>selem<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> FF<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">∨</span> <span class="main">(</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∉</span> sset <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-selem_snil_stails"><span class="command">lemma</span></span> selem_snil_stails<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"selem<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="main">(</span>stails<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sconcatMap</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'b</span><span class="main">:]</span><span class="main">)</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'b</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sconcatMap</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> sconcat <span class="keyword1">oo</span> smap<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sconcatMap_strict"><span class="command">lemma</span></span> sconcatMap_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-sconcatMap_snil"><span class="command">lemma</span></span> sconcatMap_snil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-sconcatMap_scons"><span class="command">lemma</span></span> sconcatMap_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> sconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span> <span class="main">:@</span> sconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sconcatMap.unfold<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sconcatMap_bottom_iff"><span class="command">lemma</span></span> sconcatMap_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>sconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">∈</span>sset <span class="free">xs</span><span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sconcatMap_sappend"><span class="command">lemma</span></span> sconcatMap_sappend<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> sconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">:@</span> sconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sconcatMap_monad_laws"><span class="command">lemma</span></span> sconcatMap_monad_laws<span class="main">:</span>
  <span class="quoted"><span class="quoted">"sconcatMap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> <span class="main">[:</span><span class="bound">x</span><span class="main">:]</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
  <span class="quoted"><span class="quoted">"sconcatMap<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span>sconcatMap<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">=</span> sconcatMap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> sconcatMap<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">supto</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"Integer <span class="main">→</span> Integer <span class="main">→</span> <span class="main">[:</span>Integer<span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">supto</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> le<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span> <span class="main">:#</span> <span class="free">supto</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">j</span></span></span> <span class="keyword1">else</span> <span class="main">[::]</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-upto_strict"><span class="command">lemma</span></span> upto_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"supto<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"supto<span class="main">⋅</span><span class="free">m</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-supto_is_snil_conv"><span class="command">lemma</span></span> supto_is_snil_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span> <span class="main">=</span> <span class="main">[::]</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">j</span> <span class="main">&lt;</span> <span class="free">i</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">[::]</span> <span class="main">=</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">j</span> <span class="main">&lt;</span> <span class="free">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> supto.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-supto_simp"><span class="command">lemma</span></span> supto_simp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> <span class="free">i</span> <span class="main">⟹</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">j</span> <span class="main">⟹</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="free">i</span> <span class="main">:#</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"supto<span class="main">⋅</span><span class="main">0</span><span class="main">⋅</span><span class="main">0</span> <span class="main">=</span> <span class="main">[:</span><span class="main">0</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> supto.simps<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-supto_defined"><span class="command">lemma</span></span> supto_defined<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="free">i</span> <span class="free">j</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">-</span> <span class="free">i</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">d</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">-</span> <span class="free">i</span> <span class="main">=</span> int <span class="skolem">d</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="free">i</span> <span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">d</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">d</span> <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">d</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> le<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">from</span></span> Suc<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> this<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> le <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">d</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">-</span> <span class="free">i</span> <span class="main">=</span> <span class="main">-</span> int <span class="skolem">d</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≤</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">=</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="free">i</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="free">i</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">arith</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Theory_Of_Lists-supto_bottom_iff"><span class="command">lemma</span></span> supto_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>supto<span class="main">⋅</span><span class="free">i</span><span class="main">⋅</span><span class="free">j</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">i</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="free">j</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">j</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-supto_snoc"><span class="command">lemma</span></span> supto_snoc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">j</span> <span class="main">⟹</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span> <span class="main">=</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">-</span><span class="main">1</span><span class="main">)</span> <span class="main">:@</span> <span class="main">[:</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"nat<span class="main">(</span><span class="free">j</span> <span class="main">-</span> <span class="free">i</span><span class="main">)</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">k</span> <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">k</span> <span class="main">=</span> nat <span class="main">(</span><span class="skolem">j</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">&lt;</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">linarith</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">from</span></span> this<span class="main">(</span>2<span class="main">)</span> Suc.hyps<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> this<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> Suc<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Theory_Of_Lists-slength_supto"><span class="command">lemma</span></span> slength_supto<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="main">(</span><span class="keyword1">if</span> <span class="free">j</span> <span class="main">&lt;</span> <span class="free">i</span> <span class="keyword1">then</span> <span class="main">0</span> <span class="keyword1">else</span> <span class="free">j</span> <span class="main">-</span> <span class="free">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="free">i</span> <span class="free">j</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">-</span> <span class="free">i</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">d</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">-</span> <span class="free">i</span> <span class="main">=</span> int <span class="skolem">d</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="free">i</span> <span class="free">j</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">d</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">d</span> <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">d</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> le<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">from</span></span> Suc<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> this<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> le <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">d</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">-</span> <span class="free">i</span> <span class="main">=</span> <span class="main">-</span> int <span class="skolem">d</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≤</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">=</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="free">i</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">&lt;</span> <span class="free">i</span>"</span></span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?P</span> <span class="free">i</span> <span class="free">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">arith</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Theory_Of_Lists-sset_supto"><span class="command">lemma</span></span> sset_supto<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sset <span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{</span>MkI<span class="main">⋅</span><span class="bound">k</span> <span class="main">|</span><span class="bound">k</span><span class="main">.</span> <span class="free">i</span> <span class="main">≤</span> <span class="bound">k</span> <span class="main">∧</span> <span class="bound">k</span> <span class="main">≤</span> <span class="free">j</span><span class="main">}</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"sset <span class="main">(</span><span class="var">?u</span> <span class="free">i</span> <span class="free">j</span><span class="main">)</span> <span class="main">=</span> <span class="var">?R</span> <span class="free">i</span> <span class="free">j</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">-</span> <span class="free">i</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>nonneg <span class="skolem">k</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">k</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">i</span></span> <span class="quoted"><span class="free">j</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">k</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">j</span> <span class="main">-</span> <span class="main">(</span><span class="skolem">i</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> int <span class="skolem">k</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> Suc<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> *<span class="main">]</span> <span class="keyword1"><span class="command">have</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"sset <span class="main">(</span><span class="var">?u</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">=</span> <span class="var">?R</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">from</span></span> * <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≤</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sset <span class="main">(</span><span class="var">?u</span> <span class="skolem">i</span> <span class="skolem">j</span><span class="main">)</span> <span class="main">=</span> sset <span class="main">(</span>MkI<span class="main">⋅</span><span class="skolem">i</span> <span class="main">:#</span> <span class="var">?u</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> insert <span class="main">(</span>MkI<span class="main">⋅</span><span class="skolem">i</span><span class="main">)</span> <span class="main">(</span><span class="var">?R</span> <span class="main">(</span><span class="skolem">i</span><span class="main">+</span><span class="main">1</span><span class="main">)</span> <span class="skolem">j</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> IH<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?R</span> <span class="skolem">i</span> <span class="skolem">j</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">i</span> <span class="main">≤</span> <span class="skolem">j</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-supto_split1"><span class="command">lemma</span></span> supto_split1<span class="main">:</span> <span class="comment1">―‹From <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>HOL.List›</span></span>›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">j</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≤</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="free">j</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">:@</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">j</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> int_ge_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">l</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> supto_simp<span class="main">(</span>2<span class="main">)</span> supto_snoc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-supto_split2"><span class="command">lemma</span></span> supto_split2<span class="main">:</span> <span class="comment1">―‹From <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>HOL.List›</span></span>›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">j</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≤</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">j</span><span class="main">)</span> <span class="main">:@</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="free">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">+</span> <span class="main">1</span> <span class="main">≤</span> <span class="free">k</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> supto_split1<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> j<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free">j</span></span></span> <span class="main"><span class="main"><span class="main">+</span></span></span> <span class="main"><span class="main"><span class="main">1</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> k<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">k</span></span></span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_Integer_def<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_Integer_def not_le<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Theory_Of_Lists-supto_split3"><span class="command">lemma</span></span> supto_split3<span class="main">:</span> <span class="comment1">―‹From <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>HOL.List›</span></span>›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">i</span> <span class="main">≤</span> <span class="free">j</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≤</span> <span class="free">k</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">k</span><span class="main">)</span> <span class="main">=</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="free">j</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">:@</span> MkI<span class="main">⋅</span><span class="free">j</span> <span class="main">:#</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="free">j</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms supto_simp<span class="main">(</span>2<span class="main">)</span> supto_split1 <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> one_Integer_def plus_MkI_MkI<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sinits_stake'"><span class="command">lemma</span></span> sinits_stake'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sinits<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> i<span class="main">.</span> stake<span class="main">⋅</span><span class="bound">i</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">0</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> srev_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ssnoc <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def stake_all
                <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> supto_simp
                   <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> smap_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-stails_sdrop'"><span class="command">lemma</span></span> stails_sdrop'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stails<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> i<span class="main">.</span> sdrop<span class="main">⋅</span><span class="bound">i</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">0</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> srev_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ssnoc <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def sdrop_all
                <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> supto_simp
                   <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> arg_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> smap_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> sdrop_neg<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_elem_stails"><span class="command">lemma</span></span> sdrop_elem_stails<span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">i</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">∈</span> sset <span class="main">(</span>stails<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> stails_sdrop' zero_Integer_def one_Integer_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
   <span class="main">(</span><span class="operator">metis</span> add.left_neutral le_MkI_MkI le_cases not_less sdrop_all sdrop_neg zero_Integer_def zless_imp_add1_zle<span class="main">)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">slast</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">slast</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">slast</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> <span class="main">[::]</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">|</span> <span class="bound">y</span> <span class="main">:#</span> <span class="bound">ys</span> <span class="main">⇒</span> <span class="free">slast</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-slast_strict"><span class="command">lemma</span></span> slast_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"slast<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-slast_singleton"><span class="command">lemma</span></span> slast_singleton<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"slast<span class="main">⋅</span><span class="main">[:</span><span class="free">x</span><span class="main">:]</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-slast_sappend_ssnoc"><span class="command">lemma</span></span> slast_sappend_ssnoc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"slast<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">sbutlast</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sbutlast</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">sbutlast</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="keyword1">of</span> <span class="main">[::]</span> <span class="main">⇒</span> <span class="main">[::]</span> <span class="main">|</span> <span class="bound">y</span> <span class="main">:#</span> <span class="bound">ys</span> <span class="main">⇒</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free">sbutlast</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-sbutlast_strict"><span class="command">lemma</span></span> sbutlast_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"sbutlast<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-sbutlast_sappend_ssnoc"><span class="command">lemma</span></span> sbutlast_sappend_ssnoc<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sbutlast<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">y</span> <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">prefix</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> tr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">prefix</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">prefix</span><span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">=</span> TT"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">prefix</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> FF"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">prefix</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>eq<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="keyword1">andalso</span> <span class="free">prefix</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">ys</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Theory_Of_Lists-prefix_strict"><span class="command">lemma</span></span> prefix_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_bottom_iff"><span class="command">lemma</span></span> prefix_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">a</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_definedD"><span class="command">lemma</span></span> prefix_definedD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_refl"><span class="command">lemma</span></span> prefix_refl<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_refl_conv"><span class="command">lemma</span></span> prefix_refl_conv<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_of_snil"><span class="command">lemma</span></span>  prefix_of_snil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">case</span> <span class="free">xs</span> <span class="keyword1">of</span> <span class="main">[::]</span> <span class="main">⇒</span> TT <span class="main">|</span> <span class="bound">x</span> <span class="main">:#</span> <span class="bound">xs</span> <span class="main">⇒</span> FF<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_singleton_TT"><span class="command">lemma</span></span> prefix_singleton_TT<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> TT <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∃</span><span class="bound">zs</span><span class="main">.</span> <span class="bound">zs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> <span class="free">x</span> <span class="main">:#</span> <span class="bound">zs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_singleton_FF"><span class="command">lemma</span></span> prefix_singleton_FF<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> FF <span class="main">⟷</span> <span class="main">(</span><span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="main">(</span><span class="free">ys</span> <span class="main">=</span> <span class="main">[::]</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">z</span> <span class="bound">zs</span><span class="main">.</span> <span class="bound">z</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="bound">zs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">ys</span> <span class="main">=</span> <span class="bound">z</span> <span class="main">:#</span> <span class="bound">zs</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">≠</span> <span class="bound">z</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_FF_not_snilD"><span class="command">lemma</span></span> prefix_FF_not_snilD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> FF"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">[::]</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_slength"><span class="command">lemma</span></span> prefix_slength<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">ys</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">ys</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">a</span> <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> le_plus_1<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_slength_strengthen"><span class="command">lemma</span></span> prefix_slength_strengthen<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="main">(</span>le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">ys</span><span class="main">)</span> <span class="keyword1">andalso</span> prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> andalso_weaken_left<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prefix_slength<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_scons_snil"><span class="command">lemma</span></span> prefix_scons_snil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">≠</span> TT"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-scons_prefix_scons"><span class="command">lemma</span></span> scons_prefix_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>prefix<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">y</span> <span class="main">:#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> TT<span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span>eq<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">y</span> <span class="main">=</span> TT <span class="main">∧</span> prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> TT<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">∧</span> <span class="free">y</span> <span class="main">:#</span> <span class="free">ys</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span><span class="main">)</span> <span class="operator">auto</span>

<span class="keyword1" id="Theory_Of_Lists-append_prefixD"><span class="command">lemma</span></span> append_prefixD<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="free">zs</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">zs</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">zs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">zs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> prefix.simps<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">zs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> prefix.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> prefix_scons_snil sappend_scons scons_prefix_scons slist.exhaust<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-same_prefix_prefix"><span class="command">lemma</span></span> same_prefix_prefix<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="free">zs</span><span class="main">)</span> <span class="main">=</span> prefix<span class="main">⋅</span><span class="free">ys</span><span class="main">⋅</span><span class="free">zs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">zs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bool.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> bool.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False_False <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Theory_Of_Lists-eq_prefix_TT"><span class="command">lemma</span></span> eq_prefix_TT<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">ys</span></span></span></span></span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-prefix_eq_FF"><span class="command">lemma</span></span> prefix_eq_FF<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> FF"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> FF"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">ys</span></span></span></span></span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-prefix_slength_eq"><span class="command">lemma</span></span> prefix_slength_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="main">(</span>eq<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">ys</span><span class="main">)</span> <span class="keyword1">andalso</span> prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_Integer_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-stake_slength_plus_1"><span class="command">lemma</span></span> stake_slength_plus_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"stake<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">y</span> <span class="main">:#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> <span class="free">y</span> <span class="main">:#</span> stake<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bool.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> bool.exhaust bool.exhaust<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
   <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-sdrop_slength_plus_1"><span class="command">lemma</span></span> sdrop_slength_plus_1<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">y</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">y</span> <span class="main">:#</span> <span class="free">ys</span><span class="main">)</span> <span class="main">=</span> sdrop<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sdrop.simps<span class="main"><span class="keyword3">;</span></span>
    <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">ys</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span>
    <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>

<span class="keyword1" id="Theory_Of_Lists-eq_take_length_prefix"><span class="command">lemma</span></span> eq_take_length_prefix<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> eq<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span>stake<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>snil <span class="skolem">ys</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span> <span class="skolem">ys</span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> IH <span class="main">=</span> this
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">ys</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> bottom
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False
        <span class="keyword1"><span class="command">using</span></span> le_slength_plus<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quoted"><span class="main">1</span></span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> snil <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> False <span class="keyword2"><span class="keyword">and</span></span> IH<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">z</span> <span class="skolem">zs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">using</span></span> False <span class="keyword2"><span class="keyword">and</span></span> IH<span class="main">(</span>1<span class="main">,</span>2<span class="main">)</span> IH<span class="main">(</span>3<span class="main">)</span><span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="skolem">zs</span></span><span class="main">]</span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stake_slength_plus_1 monofun_cfun_arg<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Theory_Of_Lists-prefix_sdrop_slength"><span class="command">lemma</span></span> prefix_sdrop_slength<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">:@</span> sdrop<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> <span class="free">ys</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">ys</span></span></span></span></span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sdrop_slength_plus_1<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Theory_Of_Lists-prefix_sdrop_prefix_eq"><span class="command">lemma</span></span> prefix_sdrop_prefix_eq<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">ys</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eq<span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">ys</span><span class="main">)</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> eq<span class="main">⋅</span><span class="free">ys</span><span class="main">⋅</span><span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">ys</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper"><span class="quoted"><span class="improper">ys</span></span></span></span></span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sdrop_slength_plus_1<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div><div id="KMP">
<div class="head">
<h1>Theory KMP</h1>
</div>
<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> KMP
<span class="keyword2"><span class="keyword">imports</span></span>
  <a href="Theory_Of_Lists.html">Theory_Of_Lists</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">hide_const</span></span> abs

<span class="comment1">(*&gt;*)</span>
<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹ Knuth-Morris-Pratt matching according to Bird \label{sec:KMP} ›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Step 1: Specification \label{sec:KMP:specification} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We begin with the specification of string matching given by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] ‹Chapter~16›
"Bird:PearlsofFAD:2010"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. (References to ``Bird'' in the following are to this text.) Note that
we assume <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹eq›<span class="antiquote"><span class="antiquote">}</span></span></span></span> has some nice properties (see \S\ref{sec:equality}) and
use strict lists.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">endswith</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> tr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">endswith</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span> selem<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="keyword1">oo</span> stails"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">matches</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span>Integer<span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">matches</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span> smap<span class="main">⋅</span>slength <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="main">(</span>endswith<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span> <span class="keyword1">oo</span> sinits"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Bird describes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"matches<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">xs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> as returning ``a list of integers <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p›</span></span></span></span> such that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pat›</span></span></span></span> is a
suffix of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"stake<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">p</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">xs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.''

The following examples illustrate this behaviour:

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"matches<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">[:</span><span class="main">0</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> matches.unfold endswith.unfold <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"matches<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="main">[:</span><span class="numeral">10</span><span class="main">::</span>Integer<span class="main">,</span> <span class="numeral">20</span><span class="main">,</span> <span class="numeral">30</span><span class="main">:]</span> <span class="main">=</span> <span class="main">[:</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="numeral">2</span><span class="main">,</span> <span class="numeral">3</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> matches.unfold endswith.unfold <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"matches<span class="main">⋅</span><span class="main">[:</span><span class="main">1</span><span class="main">::</span>Integer<span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">:]</span><span class="main">⋅</span><span class="main">[:</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">,</span><span class="numeral">3</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="numeral">2</span><span class="main">:]</span> <span class="main">=</span> <span class="main">[:</span><span class="numeral">7</span><span class="main">,</span> <span class="numeral">10</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> matches.unfold endswith.unfold
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sfilter_scons_let <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> sfilter_strict_scons sfilter.simps<span class="main">)</span>

<span class="keyword1" id="KMP-endswith_strict"><span class="command">lemma</span></span> endswith_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"endswith<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"endswith<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="KMP-matches_strict"><span class="command">lemma</span></span> matches_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"matches<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"matches<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Bird's strategy for deriving KMP from this specification is encoded in the following lemmas:
if we can rewrite <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹endswith›<span class="antiquote"><span class="antiquote">}</span></span></span></span> as a composition of a predicate with a
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹sfoldl›<span class="antiquote"><span class="antiquote">}</span></span></span></span>, then we can rewrite <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹matches›<span class="antiquote"><span class="antiquote">}</span></span></span></span> into a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹sscanl›<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1" id="KMP-fork_sfoldl"><span class="command">lemma</span></span> fork_sfoldl<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="free">f1</span><span class="main">⋅</span><span class="free">z1</span> <span class="main">&amp;&amp;</span> sfoldl<span class="main">⋅</span><span class="free">f2</span><span class="main">⋅</span><span class="free">z2</span> <span class="main">=</span> sfoldl<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>a<span class="main">,</span> b<span class="main">)</span> z<span class="main">.</span> <span class="main">(</span><span class="free">f1</span><span class="main">⋅</span><span class="bound">a</span><span class="main">⋅</span><span class="bound">z</span><span class="main">,</span> <span class="free">f2</span><span class="main">⋅</span><span class="bound">b</span><span class="main">⋅</span><span class="bound">z</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">z1</span><span class="main">,</span> <span class="free">z2</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">z1</span></span> <span class="quoted"><span class="free">z2</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="KMP-smap_sfilter_split_cfcomp"><span class="command">lemma</span></span> smap_sfilter_split_cfcomp<span class="main">:</span> <span class="comment1">―‹ Bird (16.4) ›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">f</span> <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="main">(</span><span class="free">p</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> smap<span class="main">⋅</span>cfst <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="main">(</span><span class="free">p</span> <span class="keyword1">oo</span> csnd<span class="main">)</span> <span class="keyword1">oo</span> smap<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="main">&amp;&amp;</span> <span class="free">g</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="KMP-Bird_strategy"><span class="command">lemma</span></span> Bird_strategy<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> endswith<span class="main">:</span> <span class="quoted"><span class="quoted">"endswith<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> <span class="free">p</span> <span class="keyword1">oo</span> sfoldl<span class="main">⋅</span><span class="free">op</span><span class="main">⋅</span><span class="free">z</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">step</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>n<span class="main">,</span> x<span class="main">)</span> y<span class="main">.</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="free">op</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="comment1">―‹ We can reasonably expect the predicate to be strict ›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"matches<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> smap<span class="main">⋅</span>cfst <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="main">(</span><span class="free">p</span> <span class="keyword1">oo</span> csnd<span class="main">)</span> <span class="keyword1">oo</span> sscanl<span class="main">⋅</span><span class="free">step</span><span class="main">⋅</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="free">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> matches.simps assoc_oo endswith<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> smap_sfilter_split_cfcomp<span class="main"><span class="keyword3">,</span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">fact</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> slength_sfoldl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fork_sfoldl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oo_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sinits_sscanl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fold</span> step<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Bird proceeds by reworking <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹endswith›<span class="antiquote"><span class="antiquote">}</span></span></span></span> into the form required by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] "Bird_strategy"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
This is eased by an alternative definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹endswith›<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1" id="KMP-sfilter_supto"><span class="command">lemma</span></span> sfilter_supto<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">d</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> le<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">n</span> <span class="main">-</span> <span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">d</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">n</span><span class="main">)</span><span class="main">)</span>
       <span class="main">=</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="keyword1">if</span> <span class="free">m</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">-</span> <span class="free">d</span> <span class="keyword1">then</span> <span class="free">n</span> <span class="main">-</span> <span class="free">d</span> <span class="keyword1">else</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">n</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?sfilterp</span><span class="main">⋅</span><span class="var">?suptomn</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">≤</span> <span class="free">n</span> <span class="main">-</span> <span class="free">d</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> True assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?sfilterp</span><span class="main">⋅</span><span class="var">?suptomn</span> <span class="main">=</span> <span class="var">?sfilterp</span><span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">d</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">:@</span> supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">d</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">n</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> supto_split1 <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> True assms <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?sfilterp</span><span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="free">m</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="free">n</span> <span class="main">-</span> <span class="free">d</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">[::]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sfilter_cong<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> refl<span class="main"><span class="main"><span class="main">]</span></span></span> sfilter_const_TT<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> trans<span class="main"><span class="main">[</span></span><span class="operator">OF</span> sfilter_cong<span class="main"><span class="main"><span class="main">[</span></span></span><span class="operator">OF</span> refl<span class="main"><span class="main"><span class="main">]</span></span></span> sfilter_const_TT<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="KMP-endswith_eq_sdrop"><span class="command">lemma</span></span> endswith_eq_sdrop<span class="main">:</span> <span class="quoted"><span class="quoted">"endswith<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> eq<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">-</span> slength<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bool.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> bool.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False_False <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"endswith<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">xs</span>"</span></span><span class="main"><span class="keyword3">;</span></span>
        <span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> endswith.simps cfcomp2 stails_sdrop'<span class="main"><span class="keyword3">;</span></span>
        <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-endswith_def2"><span class="command">lemma</span></span> endswith_def2<span class="main">:</span>  <span class="comment1">―‹ Bird p127 ›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"endswith<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> eq<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>shead<span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> prefix<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>stails<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bool.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> bool.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False_False
  <span class="keyword1"><span class="command">from</span></span> False_False <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">patl</span></span> <span class="skolem"><span class="skolem">xsl</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="skolem">xsl</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="skolem">xsl</span>"</span></span> <span class="quoted"><span class="quoted">"slength<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="skolem">patl</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="skolem">patl</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> Integer.exhaust slength_bottom_iff slength_ge_0<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?patl_xsl</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="keyword1">if</span> <span class="skolem">patl</span> <span class="main">≤</span> <span class="skolem">xsl</span> <span class="keyword1">then</span> <span class="skolem">xsl</span> <span class="main">-</span> <span class="skolem">patl</span> <span class="keyword1">else</span> <span class="main">0</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rhs</span> <span class="main">=</span> eq<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>shead<span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span> <span class="keyword1">andalso</span> prefix<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>stails<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> prefix_slength_strengthen<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> eq<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>shead<span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> prefix<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>stails<span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sfilter_sfilter'<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> eq<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>shead<span class="main">⋅</span><span class="main">(</span>smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> k<span class="main">.</span> sdrop<span class="main">⋅</span><span class="bound">k</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> k<span class="main">.</span> prefix<span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="bound">k</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> k<span class="main">.</span> le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="bound">k</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="skolem">patl</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">0</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="skolem">xsl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="skolem">xsl</span>›</span></span> <span class="quoted"><span class="quoted">‹slength<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="skolem">patl</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> stails_sdrop' sfilter_smap' cfcomp1 zero_Integer_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> eq<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>shead<span class="main">⋅</span><span class="main">(</span>smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> k<span class="main">.</span> sdrop<span class="main">⋅</span><span class="bound">k</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> k<span class="main">.</span> prefix<span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="bound">k</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> k<span class="main">.</span> le<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="skolem">xsl</span> <span class="main">-</span> <span class="bound">k</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="skolem">patl</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">0</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="skolem">xsl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="skolem">xsl</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> sfilter_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> p'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">Λ</span></span></span> x<span class="main"><span class="main"><span class="main">.</span></span></span> le<span class="main"><span class="main"><span class="main">⋅</span></span></span><span class="main"><span class="main"><span class="main">(</span></span></span>MkI<span class="main"><span class="main"><span class="main">⋅</span></span></span><span class="skolem"><span class="skolem"><span class="skolem">xsl</span></span></span> <span class="main"><span class="main"><span class="main">-</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span><span class="main"><span class="main"><span class="main">⋅</span></span></span><span class="main"><span class="main"><span class="main">(</span></span></span>MkI<span class="main"><span class="main"><span class="main">⋅</span></span></span><span class="skolem"><span class="skolem"><span class="skolem">patl</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="keyword1">If</span> prefix<span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="var">?patl_xsl</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">pat</span>
                  <span class="keyword1">then</span> eq<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="var">?patl_xsl</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>
                  <span class="keyword1">else</span> eq<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>shead<span class="main">⋅</span><span class="main">(</span>smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> k<span class="main">.</span> sdrop<span class="main">⋅</span><span class="bound">k</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> prefix<span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="var">?patl_xsl</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="skolem">xsl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> False_False <span class="quoted"><span class="quoted">‹<span class="main">0</span> <span class="main">≤</span> <span class="skolem">xsl</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">0</span> <span class="main">≤</span> <span class="skolem">patl</span>›</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> sfilter_supto<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If_distr one_Integer_def<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?lhs</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="keyword1">If</span> <span class="var">?c</span> <span class="keyword1">then</span> <span class="main">_</span> <span class="keyword1">else</span> <span class="var">?else</span> <span class="main">=</span> <span class="main">_</span>"</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="var"><span class="quoted"><span class="var">?c</span></span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> TT <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="skolem">xsl</span>›</span></span> <span class="quoted"><span class="quoted">‹slength<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> MkI<span class="main">⋅</span><span class="skolem">patl</span>›</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> endswith_eq_sdrop sdrop_neg zero_Integer_def<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> FF <span class="comment1">―‹ Recursive case: the lists generated by <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>supto›</span></span> are too short ›</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?else</span> <span class="main">=</span> shead<span class="main">⋅</span><span class="main">(</span>smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> eq<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> prefix<span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="var">?patl_xsl</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="skolem">xsl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> FF <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> shead_smap_distr<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"eq<span class="main"><span class="main"><span class="main">⋅</span></span></span><span class="free"><span class="free"><span class="free">pat</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfcomp1<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> shead<span class="main">⋅</span><span class="main">(</span>smap<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> seq<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span>FF<span class="main">)</span><span class="main">⋅</span><span class="main">(</span>sfilter<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x<span class="main">.</span> prefix<span class="main">⋅</span><span class="main">(</span>sdrop<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>supto<span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="main">(</span><span class="var">?patl_xsl</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>MkI<span class="main">⋅</span><span class="skolem">xsl</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> False_False * <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> smap_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1"><span class="keyword1">Λ</span></span></span> x<span class="main"><span class="main"><span class="main">.</span></span></span> seq<span class="main"><span class="main"><span class="main">⋅</span></span></span><span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">⋅</span></span></span>FF"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">from</span></span> * FF <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?lhs</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> 0 0 <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> shead_smap_distr seq_conv_if endswith_eq_sdrop zero_Integer_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> prefix_FF_not_snilD<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>full_types<span class="main"><span class="main">)</span></span> le_MkI_MkI linorder_not_less order_refl prefix_FF_not_snilD sdrop_all zless_imp_add1_zle<span class="main">)</span>
       <span class="keyword1"><span class="command">using</span></span> FF <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> add.left_neutral le_MkI_MkI linorder_not_less order_refl prefix_FF_not_snilD sdrop_0<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> sdrop_all zero_Integer_def zless_imp_add1_zle<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> FF <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> False_False<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Bird then generalizes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹sfilter<span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span><span class="keyword1"><span class="keyword1">Λ</span></span> x<span class="main"><span class="main">.</span></span> prefix<span class="main"><span class="main">⋅</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">)</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> stails›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">split</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
where ``<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>split⋅pat⋅xs›</span></span></span></span> splits <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pat›</span></span></span></span> into two lists <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>us›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>vs›</span></span></span></span> so that
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">us</span></span> <span class="main"><span class="main">:@</span></span> <span class="free"><span class="free">vs</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">pat</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>us›</span></span></span></span> is the longest suffix of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>xs›</span></span></span></span> that is a prefix of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pat›</span></span></span></span>.''

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">split</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="comment1">―‹ Bird p128 ›</span>
<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">split</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> prefix<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">,</span> sdrop<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">split</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>stail<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="KMP-split_strict"><span class="command">lemma</span></span> split_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"split<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="KMP-split_bottom_iff"><span class="command">lemma</span></span> split_bottom_iff<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">∨</span> <span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">subst</span> split.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="KMP-split_snil"><span class="command">lemma</span></span> split_snil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> <span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free">pat</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="KMP-split_pattern"><span class="command">lemma</span></span> split_pattern<span class="main">:</span> <span class="comment1">―‹ Bird p128, observation ›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="free">vs</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">us</span> <span class="main">:@</span> <span class="free">vs</span> <span class="main">=</span> <span class="free">pat</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">us</span></span> <span class="quoted"><span class="free">vs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> snil <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> split.unfold<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> split.unfold<span class="main">)</span>
       <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prefix_sdrop_slength <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1" id="KMP-endswith_split"><span class="command">lemma</span></span> endswith_split<span class="main">:</span> <span class="comment1">―‹ Bird p128, after defining <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>split›</span></span> ›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"endswith<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> snull <span class="keyword1">oo</span> csnd <span class="keyword1">oo</span> split<span class="main">⋅</span><span class="free">pat</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"endswith<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="main">(</span>snull <span class="keyword1">oo</span> csnd <span class="keyword1">oo</span> split<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> endswith_def2
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> split.unfold<span class="main">)</span>
         <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> prefix_sdrop_prefix_eq <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> If_distr snull_eq_snil <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> snull_eq_snil endswith.simps<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="KMP-split_length_lt"><span class="command">lemma</span></span> split_length_lt<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>prod.fst <span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="free">xs</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> split.unfold<span class="main">)</span>
       <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> one_Integer_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> lt_trans<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>p›</span></span></span></span> required by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] "Bird_strategy"<span class="antiquote"><span class="antiquote">}</span></span></span></span> is therefore <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>snull oo csnd›</span></span></span></span>. It
remains to find <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>op›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>z›</span></span></span></span> such that:

<span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹split<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">[::]</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">z</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
<span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹split<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span><span class="free"><span class="free">xs</span></span> <span class="main"><span class="main">:@</span></span> <span class="main"><span class="main">[:</span></span><span class="free"><span class="free">x</span></span><span class="main"><span class="main">:]</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> <span class="free"><span class="free">op</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span>split<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">xs</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">x</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>

›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

so that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹split <span class="main"><span class="main">=</span></span> sfoldl<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">op</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">z</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

We obtain <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">z</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">[::]</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">pat</span></span><span class="main"><span class="main">)</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> directly from the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹split›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Bird derives <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>op›</span></span></span></span> on the basis of this crucial observation:

›</span></span>

<span class="keyword1" id="KMP-split_snoc"><span class="command">lemma</span></span> split_snoc<span class="main">:</span> <span class="comment1">―‹ Bird p128 ›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span> <span class="main">=</span> split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 3<span class="main"><span class="main">)</span></span> split.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI impI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> split.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> split.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> append_prefixD<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="comment1">―‹ Bird p129 ›</span>
  <span class="entity">op</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">op</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span>
     <span class="main">(</span>     <span class="keyword1">If</span> prefix<span class="main">⋅</span><span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span><span class="main">,</span> stail<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>
      <span class="keyword1">else</span> <span class="keyword1">If</span> snull<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span>
      <span class="keyword1">else</span> <span class="free">op</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>split<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>stail<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">)</span>"</span></span>

<span class="keyword1" id="KMP-op_strict"><span class="command">lemma</span></span> op_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"op<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">usvs</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Bird demonstrates that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op›<span class="antiquote"><span class="antiquote">}</span></span></span></span> is partially correct wrt <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹split›<span class="antiquote"><span class="antiquote">}</span></span></span></span>, i.e.,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"op<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span>split<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">xs</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">x</span></span> <span class="main"><span class="main">⊑</span></span> split<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span><span class="free"><span class="free">xs</span></span> <span class="main"><span class="main">:@</span></span> <span class="main"><span class="main">[:</span></span><span class="free"><span class="free">x</span></span><span class="main"><span class="main">:]</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. For total correctness we
essentially prove that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op›<span class="antiquote"><span class="antiquote">}</span></span></span></span> terminates on well-defined arguments with an inductive argument.

›</span></span>

<span class="keyword1" id="KMP-op_induct"><span class="command">lemma</span></span> op_induct<span class="main">[</span><span class="operator">case_names</span> step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">usvs</span><span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="tfree">'b</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">usvs</span><span class="main">.</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">usvs'</span><span class="main">.</span> lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="bound">usvs'</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="bound">usvs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> TT <span class="main">⟹</span> <span class="free">P</span> <span class="bound">usvs'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">usvs</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">usvs</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">usvs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> wf_induct<span class="main">)</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?r</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="main">(</span><span class="bound">usvs'</span><span class="main">,</span> <span class="bound">usvs</span><span class="main">)</span> <span class="main">|</span><span class="main">(</span><span class="bound">usvs</span> <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">(</span><span class="bound">usvs'</span> <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="tfree">'b</span><span class="main">)</span><span class="main">.</span> lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="bound">usvs'</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="bound">usvs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> TT <span class="main">}</span>"</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"wf <span class="var">?r</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> wf_subset<span class="main"><span class="main">[</span></span><span class="operator">OF</span> wf_inv_image<span class="main"><span class="main"><span class="main">[</span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">λ</span></span><span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="bound"><span class="main"><span class="bound">_</span></span></span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">.</span></span> slength<span class="main"><span class="main">⋅</span></span><span class="bound"><span class="bound">x</span></span>"</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="operator">OF</span> wf_subset<span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span><span class="operator">OF</span> wf_Integer_ge_less_than<span class="main"><span class="main"><span class="main"><span class="main"><span class="main">[</span></span></span></span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> d<span class="main"><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">=</span></span></span></span></span></span><span class="quoted"><span class="main"><span class="quoted"><span class="main">0</span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span></span><span class="main"><span class="main"><span class="main"><span class="main">]</span></span></span></span><span class="main"><span class="main"><span class="main">]</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?rslen</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">{</span> <span class="main">(</span>slength<span class="main">⋅</span><span class="bound">us'</span><span class="main">,</span> slength<span class="main">⋅</span><span class="bound">us</span><span class="main">)</span> <span class="main">|</span><span class="main">(</span><span class="bound">us</span> <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> <span class="main">(</span><span class="bound">us'</span> <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span><span class="main">.</span> lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="bound">us'</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="bound">us</span><span class="main">)</span> <span class="main">=</span> TT <span class="main">}</span>"</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rslen</span> <span class="main">⊆</span> Integer_ge_less_than <span class="main">0</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> Integer_ge_less_than_def zero_Integer_def<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Integer.exhaust dist_eq_tr<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> dist_eq_tr<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> lt_Integer_bottom_iff lt_MkI_MkI slength_ge_0<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?r</span> <span class="main">⊆</span> inv_image <span class="var">?rslen</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="main"><span class="bound">_</span></span><span class="main">)</span><span class="main">.</span> slength<span class="main">⋅</span><span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 0 3<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">usvs</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">usvs'</span><span class="main">.</span> <span class="main">(</span><span class="bound">usvs'</span><span class="main">,</span> <span class="skolem">usvs</span><span class="main">)</span> <span class="main">∈</span> <span class="var">?r</span> <span class="main">⟶</span> <span class="free">P</span> <span class="bound">usvs'</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="skolem">usvs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> step<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">metis</span> eq_fst_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="KMP-op_induct'"><span class="command">lemma</span></span> op_induct'<span class="main">[</span><span class="operator">case_names</span> step<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">us</span><span class="main">.</span> <span class="main">(</span><span class="main">⋀</span><span class="bound">us'</span><span class="main">.</span> lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="bound">us'</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="bound">us</span><span class="main">)</span> <span class="main">=</span> TT <span class="main">⟹</span> <span class="free">P</span> <span class="bound">us'</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">P</span> <span class="bound">us</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">us</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> op_induct<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free"><span class="free">P</span></span></span> <span class="main"><span class="main"><span class="main">∘</span></span></span> prod.fst"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> usvs<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">(</span></span></span><span class="free"><span class="free"><span class="free">us</span></span></span><span class="main"><span class="main"><span class="main">,</span></span></span> <span class="skolem"><span class="skolem"><span class="skolem">vs</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">for</span></span></span></span> <span class="skolem"><span class="skolem"><span class="skolem">vs</span></span></span><span class="main"><span class="main"><span class="main">::</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">unit</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step<span class="main">)</span>

<span class="keyword1" id="KMP-split_snoc_op"><span class="command">lemma</span></span> split_snoc_op<span class="main">:</span>
  <span class="quoted"><span class="quoted">"split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">xs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span> <span class="main">=</span> op<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="quoted">"split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">xs</span>"</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> op_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">xs</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bool.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> bool.exhaust bool.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> False_False_False
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">us</span></span> <span class="skolem"><span class="skolem">vs</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">us</span><span class="main">,</span> <span class="skolem">vs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">from</span></span> False_False_False * <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">(</span><span class="skolem">us</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span><span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> prefix<span class="main">⋅</span><span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">⋅</span><span class="skolem">vs</span>"</span></span>
      <span class="keyword1"><span class="command">using</span></span> split_pattern same_prefix_prefix sappend_bottom_iff <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
    <span class="keyword1"><span class="command">from</span></span> False_False_False * **
    <span class="keyword1"><span class="command">have</span></span> ***<span class="main">:</span> <span class="quoted"><span class="quoted">"sdrop<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span><span class="skolem">us</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> stail<span class="main">⋅</span><span class="skolem">vs</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">(</span><span class="skolem">us</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">)</span><span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> TT"</span></span>
      <span class="keyword1"><span class="command">using</span></span> sdrop_sappend_same<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> xs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"<span class="skolem">us</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span>"</span></span><span class="main">]</span> that
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> split_pattern<span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> False_False_False * ** *** <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> split_snoc<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> split.unfold<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> op.unfold<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> snull_FF_conv <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step split_length_lt<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="KMP-split_sfoldl_op"><span class="command">lemma</span></span> split_sfoldl_op<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="main">(</span>op<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free">pat</span><span class="main">)</span> <span class="main">=</span> split<span class="main">⋅</span><span class="free">pat</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xs</span>
    <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> srev_induct<span class="main">)</span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_snoc_op<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="KMP-matches_op"><span class="command">lemma</span></span> matches_op<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"matches<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> smap<span class="main">⋅</span>cfst <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="main">(</span>snull <span class="keyword1">oo</span> csnd <span class="keyword1">oo</span> csnd<span class="main">)</span>
                                <span class="keyword1">oo</span> sscanl<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>n<span class="main">,</span> usvs<span class="main">)</span> x<span class="main">.</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> op<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="bound">usvs</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free">pat</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xs</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> oo_assoc<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Bird_strategy<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> endswith_split split_sfoldl_op oo_assoc<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] "split_sfoldl_op"<span class="antiquote"><span class="antiquote">}</span></span></span></span> we can rewrite <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op›<span class="antiquote"><span class="antiquote">}</span></span></span></span> into a more perspicuous form
that exhibits how KMP handles the failure of the text to continue matching the pattern:

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span>
  <span class="entity">op'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">op'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span>
     <span class="main">(</span>     <span class="keyword1">If</span> prefix<span class="main">⋅</span><span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span><span class="main">,</span> stail<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="comment1">― ‹ continue matching ›</span>
      <span class="keyword1">else</span> <span class="keyword1">If</span> snull<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="keyword1">then</span> <span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span> <span class="comment1">― ‹ fail at the start of the pattern: discard <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>x›</span></span> ›</span>
      <span class="keyword1">else</span> sfoldl<span class="main">⋅</span><span class="main">(</span><span class="free">op'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>stail<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span><span class="main">)</span> <span class="comment1">― ‹ fail later: discard <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>shead⋅us›</span></span> and determine where to restart ›</span>
     <span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Intuitively if <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span> continues the pattern match then we
extend the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹split›<span class="antiquote"><span class="antiquote">}</span></span></span></span> of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pat›</span></span></span></span>
recorded in <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>us›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>vs›</span></span></span></span>.  Otherwise we
need to find a prefix of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pat›</span></span></span></span> to continue matching
with. If we have yet to make any progress (i.e., <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>us =
[::]›</span></span></span></span>) we restart with the entire <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pat›</span></span></span></span> (aka
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>z›</span></span></span></span>) and discard <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x›</span></span></span></span>.  Otherwise, because a
match cannot begin with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">us</span></span> <span class="main"><span class="main">:@</span></span> <span class="main"><span class="main">[:</span></span><span class="free"><span class="free">x</span></span><span class="main"><span class="main">:]</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, we <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
‹split›<span class="antiquote"><span class="antiquote">}</span></span></span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pat›</span></span></span></span> (aka <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>z›</span></span></span></span>) by
iterating <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op'›<span class="antiquote"><span class="antiquote">}</span></span></span></span> over <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">‹stail<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">us</span></span> <span class="main"><span class="main">:@</span></span> <span class="main"><span class="main">[:</span></span><span class="free"><span class="free">x</span></span><span class="main"><span class="main">:]</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.  The remainder of the
development is about memoising this last computation.

This is not yet the full KMP algorithm as it lacks what we call the
`K' optimisation, which we add in \S\ref{sec:KMP:data_refinement}.
Note that a termination proof for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> "op'"<span class="antiquote"><span class="antiquote">}</span></span></span></span> in HOL is tricky due
to its use of higher-order nested recursion via <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
‹sfoldl›<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1" id="KMP-op'_strict"><span class="command">lemma</span></span> op'_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"op'<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op'<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op'<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">usvs</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="KMP-sfoldl_op'_strict"><span class="command">lemma</span></span> sfoldl_op'_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"op'<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>sfoldl<span class="main">⋅</span><span class="main">(</span>op'<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">⊥</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> srev_induct<span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-op'_op"><span class="command">lemma</span></span> op'_op<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"op'<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">usvs</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> op<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">usvs</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bool.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> bool.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True_False <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> op'.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> op.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False_False <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">usvs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> op_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">usvs</span> <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="main">(</span>op'<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> sfoldl<span class="main">⋅</span><span class="main">(</span>op<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
         <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="skolem">usvs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> TT"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xs</span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> srev_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ssnoc <span class="skolem">x'</span> <span class="skolem">xs'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> ssnoc<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">xs'</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="skolem">usvs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
        <span class="keyword1"><span class="command">using</span></span> lt_slength_0<span class="main">(</span>2<span class="main">)</span> lt_trans <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> step<span class="main">(</span>2<span class="main">)</span> ssnoc<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">xs'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="skolem">usvs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
        <span class="keyword1"><span class="command">using</span></span> lt_trans split_length_lt <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> 10 0<span class="main">)</span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ssnoc.hyps split_sfoldl_op split_snoc_op step<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">from</span></span> step.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> op'.unfold<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> op.unfold<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> snull_FF_conv split_sfoldl_op<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> * <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> split_sfoldl_op step split_length_lt<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Step 2: Data refinement and the `K' optimisation \label{sec:KMP:data_refinement} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Bird memoises the restart computation in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op'›<span class="antiquote"><span class="antiquote">}</span></span></span></span> in two steps.  The first reifies
the control structure of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op'›<span class="antiquote"><span class="antiquote">}</span></span></span></span> into a non-wellfounded tree, which we discuss here. The
second increases the sharing in this tree; see \S\ref{sec:KMP:increase_sharing}.

Briefly, we cache the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹sfoldl<span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span>op'<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span><span class="main"><span class="main">[::]</span></span><span class="main"><span class="main">,</span></span> <span class="free"><span class="free">pat</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span>stail<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">us</span></span> <span class="main"><span class="main">:@</span></span> <span class="main"><span class="main">[:</span></span><span class="free"><span class="free">x</span></span><span class="main"><span class="main">:]</span></span><span class="main"><span class="main">)</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
computation in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op'›<span class="antiquote"><span class="antiquote">}</span></span></span></span> by finding a ``representation'' type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'t</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
for the ``abstract'' type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">‹<span class="main"><span class="main">[:</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">::</span></span>Eq_def<span class="main"><span class="main">:]</span></span> <span class="main"><span class="main">×</span></span> <span class="main"><span class="main">[:</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">:]</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, a
pair of functions <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">rep</span></span> <span class="main"><span class="main">::</span></span> <span class="main"><span class="main">[:</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">::</span></span>Eq_def<span class="main"><span class="main">:]</span></span> <span class="main"><span class="main">×</span></span> <span class="main"><span class="main">[:</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">:]</span></span> <span class="main"><span class="main">→</span></span> <span class="tfree"><span class="tfree">'t</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">abs</span></span> <span class="main"><span class="main">::</span></span> <span class="tfree"><span class="tfree">'t</span></span> <span class="main"><span class="main">→</span></span> <span class="main"><span class="main">[:</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">::</span></span>Eq_def<span class="main"><span class="main">:]</span></span> <span class="main"><span class="main">×</span></span> <span class="main"><span class="main">[:</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">:]</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">abs</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> <span class="free"><span class="free">rep</span></span> <span class="main"><span class="main">=</span></span> ID›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, and then
finding a derived form of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op'›<span class="antiquote"><span class="antiquote">}</span></span></span></span> that works on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="tfree"><span class="tfree">'t</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> rather
than <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">[:</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">::</span></span>Eq_def<span class="main"><span class="main">:]</span></span> <span class="main"><span class="main">×</span></span> <span class="main"><span class="main">[:</span></span><span class="tfree"><span class="tfree">'a</span></span><span class="main"><span class="main">:]</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. We also take the opportunity to add the `K' optimisation in the form of the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">next</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
function.

As such steps are essentially <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹deus ex machina›<span class="antiquote"><span class="antiquote">}</span></span></span></span>, we try to provide some intuition
after showing the new definitions.

›</span></span>

<span class="keyword1"><span class="command">domain</span></span> <span class="tfree">'a</span> tree <span class="comment1">―‹ Bird p130 ›</span>
  <span class="main">=</span> Null
  <span class="main">|</span> Node <span class="main">(</span>label <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> left <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span><span class="main">)</span> <span class="main">(</span><span class="keyword2"><span class="keyword">lazy</span></span> right <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span><span class="main">)</span> <span class="comment1">―‹ Strict in the label <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">typ</span> <span class="quoted">"<span class="tfree">'a</span>"</span><span class="antiquote">}</span></span> ›</span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword1" id="KMP-tree_injects'"><span class="command">lemma</span></span> tree_injects'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="comment1">―‹ An unconditional form of @{thm [source] tree.injects}. ›</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>Node<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="free">a'</span><span class="main">⋅</span><span class="free">l'</span><span class="main">⋅</span><span class="free">r'</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">a</span> <span class="main">=</span> <span class="free">a'</span> <span class="main">∧</span> <span class="main">(</span><span class="free">a</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟶</span> <span class="free">l</span> <span class="main">=</span> <span class="free">l'</span> <span class="main">∧</span> <span class="free">r</span> <span class="main">=</span> <span class="free">r'</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1" id="KMP-match_Null_match_Node_tree_case"><span class="command">lemma</span></span> match_Null_match_Node_tree_case<span class="main">:</span> <span class="quoted"><span class="quoted">"match_Null<span class="main">⋅</span><span class="free">t</span><span class="main">⋅</span><span class="free">k1</span> <span class="main">+++</span> match_Node<span class="main">⋅</span><span class="free">t</span><span class="main">⋅</span><span class="free">k2</span> <span class="main">=</span> tree_case<span class="main">⋅</span><span class="free">k1</span><span class="main">⋅</span><span class="free">k2</span><span class="main">⋅</span><span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-match_Node_mplus_match_Node"><span class="command">lemma</span></span> match_Node_mplus_match_Node<span class="main">:</span> <span class="quoted"><span class="quoted">"match_Node<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">k1</span> <span class="main">+++</span> match_Node<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="free">k2</span> <span class="main">=</span> match_Node<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> v l r<span class="main">.</span> <span class="free">k1</span><span class="main">⋅</span><span class="bound">v</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">r</span> <span class="main">+++</span> <span class="free">k2</span><span class="main">⋅</span><span class="bound">v</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1" id="KMP-tree_case_distr"><span class="command">lemma</span></span> tree_case_distr<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span>tree_case<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">h</span><span class="main">⋅</span><span class="free">t</span><span class="main">)</span> <span class="main">=</span> tree_case<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x l r<span class="main">.</span> <span class="free">f</span><span class="main">⋅</span><span class="main">(</span><span class="free">h</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">t</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>tree_case<span class="main">⋅</span><span class="free">g'</span><span class="main">⋅</span><span class="free">h'</span><span class="main">⋅</span><span class="free">t</span><span class="main">)</span><span class="main">⋅</span><span class="free">z</span> <span class="main">=</span> tree_case<span class="main">⋅</span><span class="main">(</span><span class="free">g'</span><span class="main">⋅</span><span class="free">z</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> x l r<span class="main">.</span> <span class="free">h'</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">r</span><span class="main">⋅</span><span class="free">z</span><span class="main">)</span><span class="main">⋅</span><span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="main"><span class="improper">[</span></span><span class="main"><span class="main">!</span></span><span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">t</span></span></span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-tree_case_cong"><span class="command">lemma</span></span> tree_case_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">t</span> <span class="main">=</span> <span class="free">t'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">t'</span> <span class="main">=</span> Null <span class="main">⟹</span> <span class="free">n</span> <span class="main">=</span> <span class="free">n'</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">v</span> <span class="bound">l</span> <span class="bound">r</span><span class="main">.</span> <span class="main">⟦</span><span class="free">t'</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="bound">v</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">r</span><span class="main">;</span> <span class="bound">v</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">c</span> <span class="bound">v</span> <span class="bound">l</span> <span class="bound">r</span> <span class="main">=</span> <span class="free">c'</span> <span class="bound">v</span> <span class="bound">l</span> <span class="bound">r</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">.</span> <span class="free">c</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">.</span> <span class="free">c'</span> <span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree_case<span class="main">⋅</span><span class="free">n</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> v l r<span class="main">.</span> <span class="free">c</span> <span class="bound">v</span> <span class="bound">l</span> <span class="bound">r</span><span class="main">)</span><span class="main">⋅</span><span class="free">t</span> <span class="main">=</span> tree_case<span class="main">⋅</span><span class="free">n'</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> v l r<span class="main">.</span> <span class="free">c'</span> <span class="bound">v</span> <span class="bound">l</span> <span class="bound">r</span><span class="main">)</span><span class="main">⋅</span><span class="free">t'</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">t</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">t'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> prod_cont_iff<span class="main">)</span>

<span class="keyword1" id="KMP-tree_take_smaller"><span class="command">lemma</span></span> tree_take_smaller<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"tree_take <span class="free">i</span><span class="main">⋅</span><span class="free">t</span> <span class="main">=</span> tree_take <span class="free">i</span><span class="main">⋅</span><span class="free">u</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">j</span> <span class="main">≤</span> <span class="free">i</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree_take <span class="free">j</span><span class="main">⋅</span><span class="free">t</span> <span class="main">=</span> tree_take <span class="free">j</span><span class="main">⋅</span><span class="free">u</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> min.orderE tree.take_take<span class="main">)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">tree_map'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">→</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">→</span> <span class="tfree">'a</span> tree <span class="main">→</span> <span class="tfree">'b</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">tree_map'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span>Null <span class="main">=</span> Null"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">tree_map'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">a</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">tree_map'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">tree_map'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="KMP-tree_map'_strict"><span class="command">lemma</span></span> tree_map'_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tree_map'<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span>

<span class="keyword1" id="KMP-tree_map'_ID'"><span class="command">lemma</span></span> tree_map'_ID'<span class="main">:</span> <span class="quoted"><span class="quoted">"tree_map'<span class="main">⋅</span>ID<span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> <span class="free">xs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-tree_map'_ID"><span class="command">lemma</span></span> tree_map'_ID<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"tree_map'<span class="main">⋅</span>ID <span class="main">=</span> ID"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff tree_map'_ID'<span class="main">)</span>

<span class="keyword1" id="KMP-tree_map'_strict_scons"><span class="command">lemma</span></span> tree_map'_strict_scons<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree_map'<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free">a</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="free">a</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>tree_map'<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">l</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>tree_map'<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">a</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1" id="KMP-tree_map'_comp'"><span class="command">lemma</span></span> tree_map'_comp'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree_map'<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="main">(</span>tree_map'<span class="main">⋅</span><span class="free">g</span><span class="main">⋅</span><span class="free">t</span><span class="main">)</span> <span class="main">=</span> tree_map'<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span><span class="main">⋅</span><span class="free">t</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-tree_map'_comp"><span class="command">lemma</span></span> tree_map'_comp<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">f</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree_map'<span class="main">⋅</span><span class="free">f</span> <span class="keyword1">oo</span> tree_map'<span class="main">⋅</span><span class="free">g</span> <span class="main">=</span> tree_map'<span class="main">⋅</span><span class="main">(</span><span class="free">f</span> <span class="keyword1">oo</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="KMP-tree_unique"><span class="command">lemma</span></span> tree_unique<span class="main">:</span> <span class="comment1">―‹ Adapted from @{cite [cite_macro=citet] "Matthews:1999"} for \emph{contractive functions}. ›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> tree"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> xfx<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">i</span> <span class="bound">t</span> <span class="bound">u</span><span class="main">.</span> tree_take <span class="bound">i</span><span class="main">⋅</span><span class="bound">t</span> <span class="main">=</span> tree_take <span class="bound">i</span><span class="main">⋅</span><span class="bound">u</span>
                      <span class="main">⟹</span> tree_take <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">t</span><span class="main">)</span> <span class="main">=</span> tree_take <span class="main">(</span>Suc <span class="bound">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">f</span><span class="main">⋅</span><span class="bound">u</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="free">f</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> tree.take_lemma<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tree_take <span class="skolem">i</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> tree_take <span class="skolem">i</span><span class="main">⋅</span><span class="main">(</span>fix<span class="main">⋅</span><span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">i</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span> <span class="keyword1"><span class="command">from</span></span> xfx f<span class="main">[</span><span class="operator">OF</span> Suc<span class="main">,</span> <span class="operator">folded</span> fix_eq<span class="main">]</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="quoted">"<span class="entity">next</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">next</span><span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">t</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">t</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">next</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span>Null <span class="main">=</span> Null"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">next</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="main">[::]</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="main">[::]</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">next</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">If</span> eq<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">else</span> Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="comment1">―‹ Bird p131 ``an even simpler form'', with the `K' optimisation ›</span>
    <span class="entity">root2</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">op2</span>    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">rep2</span>   <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">left2</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">right2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">root2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span> <span class="free">rep2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">op2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">root2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span>
   <span class="free">op2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> prefix<span class="main">⋅</span><span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span><span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">else</span> <span class="free">op2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">rep2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">=</span> Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free">left2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">right2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">left2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">=</span> next<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">⋅</span>Null"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">left2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">=</span> next<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">⋅</span><span class="main">(</span>sfoldl<span class="main">⋅</span><span class="main">(</span><span class="free">op2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">root2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">)</span>"</span></span> <span class="comment1">―‹ Note the use of <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">‹<span class="free">op2</span>›</span><span class="antiquote">}</span></span> and <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ‹next›<span class="antiquote">}</span></span>. ›</span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">right2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="main">[::]</span><span class="main">)</span> <span class="main">=</span> Null"</span></span> <span class="comment1">―‹ Unreachable ›</span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">right2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">rep2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">:]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">abs2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">abs2</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">usvs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">matches2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span>Integer<span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">matches2</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span> smap<span class="main">⋅</span>cfst <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="main">(</span>snull <span class="keyword1">oo</span> csnd <span class="keyword1">oo</span> abs2 <span class="keyword1">oo</span> csnd<span class="main">)</span>
                                     <span class="keyword1">oo</span> sscanl<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>n<span class="main">,</span> x<span class="main">)</span> y<span class="main">.</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> op2<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> root2<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

\begin{figure}
  \centering
  \begin{tikzpicture}[
    shorten &gt;=1pt,
    node distance=1.5cm,
    on grid,
    auto,
    initial text=,
    thick,
    accepting/.style = {rectangle,minimum size=0.3cm}
    ]
    \node[state,accepting] (q_0i)                     {};
    \node[state,initial]   (q_0)  [right=of q_0i]     {$q_0$};
    \node[state]           (q_1)  [right=of q_0]      {$q_1$};
    \node[state]           (q_2)  [right=of q_1]      {$q_2$};
    \node[state]           (q_3)  [right=of q_2]      {$q_3$};
    \node[state]           (q_4)  [right=of q_3]      {$q_4$};
    \node[state,double]    (q_5)  [right=of q_4]      {$q_5$};
    \node[state,accepting] (q_5r) [right=of q_5]      {};

    \path[-&gt;] (q_0) edge [bend left] node [above]       {0} (q_1)
              (q_1) edge [bend left] node [above]       {1} (q_2)
              (q_2) edge [bend left] node [above]       {0} (q_3)
              (q_3) edge [bend left] node [above]       {0} (q_4)
              (q_4) edge [bend left] node [above]       {1} (q_5)
              (q_5) edge [bend left] node [above]       {*} (q_5r);

    \path[-&gt;] (q_0) edge [bend right]               (q_0i)
              (q_1) edge [bend left]                (q_0)
              (q_2) edge [bend left]                (q_0)  % MP
              (q_2) edge [bend left,color=red]      (q_0i) % K opt
              (q_3) edge [bend left]                (q_1)
              (q_4) edge [bend left]                (q_1)  % MP
              (q_4) edge [bend left,color=red]      (q_0)  % K opt
              (q_5) edge [bend left]                (q_2);
  \end{tikzpicture}
  \caption{An example from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
    ‹\S2.1› "CrochemoreRytter:2002"<span class="antiquote"><span class="antiquote">}</span></span></span></span>. The MP tree for the
    pattern $01001$ is drawn in black: right transitions are labelled
    with a symbol, whereas left transitions are unlabelled. The two
    `K'-optimised left transitions are shown in red. The boxes denote
    <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹Null›<span class="antiquote"><span class="antiquote">}</span></span></span></span>. The root node is $q_0$.}
  \label{fig:example_tree}
\end{figure}

This tree can be interpreted as a sort of automaton\footnote{<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span>
[cite_macro=citet] ‹\S3.1› "Bird:2012"<span class="antiquote"><span class="antiquote">}</span></span></span></span> suggests it can
be thought of as a doubly-linked list, following <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span>
[cite_macro=citet] "TakeichiAkama:1990"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.)}, where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
‹op2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> goes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹right›<span class="antiquote"><span class="antiquote">}</span></span></span></span> if the pattern
continues with the next element of the text, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
‹left›<span class="antiquote"><span class="antiquote">}</span></span></span></span> otherwise, to determine how much of a prefix of
the pattern could still be in play.  Figure~\ref{fig:example_tree}
visualises such an automaton for the pattern $01001$, used by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span>
[cite_macro=citet] ‹\S2.1› "CrochemoreRytter:2002"<span class="antiquote"><span class="antiquote">}</span></span></span></span> to
illustrate the difference between Morris-Pratt (MP) and
Knuth-Morris-Pratt (KMP) preprocessing as we discuss below.  Note that
these are not the classical Mealy machines that correspond to regular
expressions, where all outgoing transitions are labelled with symbols.

The following lemma shows how our sample automaton is encoded as a non-wellfounded tree.

›</span></span>

<span class="keyword1" id="KMP-concrete_tree_KMP"><span class="command">lemma</span></span> concrete_tree_KMP<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"root2<span class="main">⋅</span><span class="main">[:</span><span class="main">0</span><span class="main">::</span>Integer<span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span>
      <span class="main">=</span> <span class="main">(</span><span class="keyword1">μ</span> <span class="bound">q0</span><span class="main">.</span> Node<span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="main">[:</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span>
                     <span class="main">⋅</span>Null
                     <span class="main">⋅</span><span class="main">(</span><span class="keyword1">μ</span> <span class="bound">q1</span><span class="main">.</span> Node<span class="main">⋅</span><span class="main">(</span><span class="main">[:</span><span class="main">0</span><span class="main">:]</span><span class="main">,</span> <span class="main">[:</span><span class="main">1</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span>
                          <span class="main">⋅</span><span class="bound">q0</span>
                          <span class="main">⋅</span><span class="main">(</span><span class="keyword1">μ</span> <span class="bound">q2</span><span class="main">.</span> Node<span class="main">⋅</span><span class="main">(</span><span class="main">[:</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span><span class="main">,</span> <span class="main">[:</span><span class="main">0</span><span class="main">,</span> <span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span>
                               <span class="main">⋅</span>Null <span class="comment1">―‹ K optimisation: MP <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>q0›</span></span> ›</span>
                               <span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="main">[:</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="main">0</span><span class="main">:]</span><span class="main">,</span> <span class="main">[:</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">:]</span><span class="main">)</span>
                                     <span class="main">⋅</span><span class="bound">q1</span>
                                     <span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="main">[:</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">:]</span><span class="main">,</span> <span class="main">[:</span><span class="main">1</span><span class="main">:]</span><span class="main">)</span>
                                          <span class="main">⋅</span><span class="bound">q0</span> <span class="comment1">―‹ K optimisation: MP <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>q1›</span></span> ›</span>
                                          <span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="main">[:</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">0</span><span class="main">,</span><span class="main">1</span><span class="main">:]</span><span class="main">,</span> <span class="main">[::]</span><span class="main">)</span><span class="main">⋅</span><span class="bound">q2</span><span class="main">⋅</span>Null<span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> fix<span class="main">⋅</span><span class="var">?F</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> tree_unique<span class="main">)</span> <span class="comment1">✐<span class="quoted">‹tag invisible›</span></span>
  <span class="keyword1"><span class="command">note</span></span> rep2.simps<span class="main">[</span><span class="operator">simp</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?F</span><span class="main">⋅</span><span class="var">?lhs</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> tree_unique<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> tree_unique<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> conjI<span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> i t u<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> t u i<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> t u i<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Suc_n_not_le_n linear tree_take_smaller<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parallel_fix_ind<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> i t u x y<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> i<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Suc_n_not_le_n linear tree_take_smaller<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> i<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> i<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Suc_n_not_le_n linear tree_take_smaller<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="main">::</span> <span class="quoted">nat</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span> <span class="skolem">u</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">[:</span>Integer<span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span>Integer<span class="main">:]</span><span class="main">)</span> tree"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"tree_take <span class="skolem">i</span><span class="main">⋅</span><span class="skolem">t</span> <span class="main">=</span> tree_take <span class="skolem">i</span><span class="main">⋅</span><span class="skolem">u</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"tree_take <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="var">?F</span><span class="main">⋅</span><span class="skolem">t</span><span class="main">)</span> <span class="main">=</span> tree_take <span class="main">(</span>Suc <span class="skolem">i</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="var">?F</span><span class="main">⋅</span><span class="skolem">u</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parallel_fix_ind<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">i</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Suc_n_not_le_n linear tree_take_smaller<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parallel_fix_ind<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> j t0 t1<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">j</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> j<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">j</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Suc_n_not_le_n linear tree_take_smaller<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> j<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">j</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">intro</span> conjI<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Suc_n_not_le_n linear tree_take_smaller<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> j<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">j</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">meson</span> Suc_n_not_le_n linear tree_take_smaller<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The sharing that we expect from a lazy (call-by-need) evaluator is here implied by the use of
nested fixed points.

The KMP preprocessor is expressed by the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹left2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> function, where <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> is used
to match the pattern against itself; the use of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹matches2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> (``the driver'')
is responsible for matching the (preprocessed) pattern against the text. This formally cashes in
an observation by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] ‹\S5› "vanderWoude:1989"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, that these two algorithms
are essentially the same, which has eluded other presentations\footnote{For instance, contrast
our shared use of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> with the separated \texttt{match}
and \texttt{rematch} functions of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] ‹Figure~1› "AgerDanvyRohde:2006"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.}.

Bird uses <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹Null›<span class="antiquote"><span class="antiquote">}</span></span></span></span> on a left path to signal to the driver that it should discard the
current element of the text and restart matching from the beginning of the pattern (i.e,
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹root2›<span class="antiquote"><span class="antiquote">}</span></span></span></span>). This is a step towards the removal of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">us</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in \S\ref{sec:KMP:step8}.

Note that the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹Null›<span class="antiquote"><span class="antiquote">}</span></span></span></span> at the end of the rightmost path is unreachable: the rightmost
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹Node›<span class="antiquote"><span class="antiquote">}</span></span></span></span> has <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">vs</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">[::]</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and therefore <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> always takes the left branch.

The `K' optimisation is perhaps best understood by example. Consider
the automaton in Figure~\ref{fig:example_tree}, and a text beginning
with \texttt{011}. Using the MP (black) transitions we take the path
$\rightarrow q_0 \stackrel{{\mathtt{0}}}{\rightarrow} q_1
\stackrel{\mathtt{1}}{\rightarrow} \overbrace{q_2 \rightarrow q_0
\rightarrow \Box}$. Now, due to the failure of the comparison of the
current element of the text (\texttt{1}) at $q_2$, we can predict that
the (identical) comparison at node $q_0$ will fail as well, and
therefore have $q_2$ left-branch directly to $\Box$. This saves a
comparison in the driver at the cost of another in the preprocessor
(in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹next›<span class="antiquote"><span class="antiquote">}</span></span></span></span>). These optimisations are the red
arrows in the diagram, and can in general save an arbitrary number of
driver comparisons; consider the pattern $\mathtt{1}^n$ for instance.

More formally, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹next›<span class="antiquote"><span class="antiquote">}</span></span></span></span> ensures that the heads of
the suffixes of the pattern (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">vs</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) on consecutive
labels on left paths are distinct; see below for a proof of this fact
in our setting, and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] ‹\S3.3.4›
"Gusfield:1997"<span class="antiquote"><span class="antiquote">}</span></span></span></span> for a classical account. Unlike Bird's suggestion
(p134), our <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹next›<span class="antiquote"><span class="antiquote">}</span></span></span></span> function is not recursive.

We note in passing that while MP only allows <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Null›</span></span></span></span> on
the left of the root node, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Null›</span></span></span></span> can be on the left of
any KMP node except for the rightmost
(i.e., the one that signals a complete pattern match) where no optimisation is possible.

We proceed with the formalities of the data refinement.

›</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> root2_op2_rep2_left2_right2_def<span class="main">:</span> <span class="comment1">― ‹ Obtain the definition of these functions as a single fixed point ›</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> root2  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op2    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> rep2   <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> left2  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> right2 <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>
   <span class="main">=</span> fix<span class="main">⋅</span><span class="var">?F</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> op2_def root2_def rep2_def left2_def right2_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="KMP-abs2_strict"><span class="command">lemma</span></span> abs2_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"abs2<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"abs2<span class="main">⋅</span>Null <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="KMP-next_strict"><span class="command">lemma</span></span> next_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"next<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"next<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"next<span class="main">⋅</span><span class="main">(</span><span class="free">x</span> <span class="main">:#</span> <span class="free">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">⊥</span><span class="main">)</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fixrec_simp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">us</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fixrec_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="KMP-next_Null"><span class="command">lemma</span></span> next_Null<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
<span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"next<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span>Null <span class="main">=</span> Null"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-next_snil"><span class="command">lemma</span></span> next_snil<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"next<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">[::]</span><span class="main">)</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">[::]</span><span class="main">)</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-op2_rep2_left2_right2_strict"><span class="command">lemma</span></span> op2_rep2_left2_right2_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"op2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">⊥</span><span class="main">)</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free">usvs</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"left2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="main">⊥</span><span class="main">,</span> <span class="free">vs</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"left2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"right2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">⊥</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fixrec_simp</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">us</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">usvs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fixrec_simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fixrec_simp</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">us</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fixrec_simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fixrec_simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="KMP-snd_abs_root2_bottom"><span class="command">lemma</span></span> snd_abs_root2_bottom<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"prod.snd <span class="main">(</span>abs2<span class="main">⋅</span><span class="main">(</span>root2<span class="main">⋅</span><span class="main">⊥</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> root2.unfold rep2.unfold<span class="main">)</span>

<span class="keyword1" id="KMP-abs_rep2_ID'"><span class="command">lemma</span></span> abs_rep2_ID'<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"abs2<span class="main">⋅</span><span class="main">(</span>rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">usvs</span><span class="main">)</span> <span class="main">=</span> <span class="free">usvs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">usvs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">subst</span> rep2.unfold<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1" id="KMP-abs_rep2_ID"><span class="command">lemma</span></span> abs_rep2_ID<span class="main">:</span> <span class="quoted"><span class="quoted">"abs2 <span class="keyword1">oo</span> rep2<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> ID"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>

<span class="keyword1" id="KMP-rep2_snoc_right2"><span class="command">lemma</span></span> rep2_snoc_right2<span class="main">:</span> <span class="comment1">―‹ Bird p131 ›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">⋅</span><span class="free">vs</span> <span class="main">=</span> TT"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">,</span> stail<span class="main">⋅</span><span class="free">vs</span><span class="main">)</span> <span class="main">=</span> right2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="free">vs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1" id="KMP-not_prefix_op2_next"><span class="command">lemma</span></span> not_prefix_op2_next<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> FF"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"op2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span>rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">usvs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> op2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">usvs</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">us</span></span> <span class="skolem"><span class="skolem">vs</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">usvs</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">us</span><span class="main">,</span> <span class="skolem">vs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main"><span class="keyword3">;</span></span>
        <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep2.simps prefix_singleton_FF If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Bird's appeal to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>foldl_fusion›</span></span></span></span> (p130) is too weak to
justify this data refinement as his condition (iii) requires the
worker functions to coincide on all representation values. Concretely
he asks that:

\begin{center}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"rep2<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span>op<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span>abs2<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">t</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">x</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">=</span></span> op2<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">t</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">x</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> ―‹Bird (17.2)›
\end{center}

where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t›</span></span></span></span> is an arbitrary tree. This does not hold for junk representations
such as:

\begin{center}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">t</span></span> <span class="main"><span class="main">=</span></span> Node<span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">[::]</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">⋅</span></span>Null<span class="main"><span class="main">⋅</span></span>Null›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{center}

Using worker/wrapper fusion <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citep]
"GillHutton:2009" <span class="quasi_keyword"><span class="quasi_keyword">and</span></span> "Gammie:2011"<span class="antiquote"><span class="antiquote">}</span></span></span></span> specialised to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
‹sscanl›<span class="antiquote"><span class="antiquote">}</span></span></span></span> (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source] "sscanl_ww_fusion"<span class="antiquote"><span class="antiquote">}</span></span></span></span>) we only
need to establish this identity for valid representations, i.e., when
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>t›</span></span></span></span> lies under the image of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>rep2›</span></span></span></span>. In
pictures, we show that this diagram commutes:

\begin{center}
  \begin{tikzcd}[column sep=8em]
    usvs \arrow[r, "<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Λ usvs. op⋅pat⋅usvs⋅x›</span></span></span></span>"] \arrow[d, "<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>rep2⋅pat›</span></span></span></span>"] &amp; usvs' \arrow[d, "<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>rep2⋅pat›</span></span></span></span>"] \\
    t \arrow[r, "<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Λ usvs. op2⋅pat⋅usvs⋅x ›</span></span></span></span>"]                         &amp; t'
  \end{tikzcd}
\end{center}

Clearly this result self-composes: after an initial <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">‹rep2<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> step, we can repeatedly simulate
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op›<span class="antiquote"><span class="antiquote">}</span></span></span></span> steps with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> steps.

›</span></span>

<span class="keyword1" id="KMP-op_op2_refinement"><span class="command">lemma</span></span> op_op2_refinement<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>op<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">usvs</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">=</span> op2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">usvs</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">usvs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> bool.exhaust<span class="main"><span class="main">[</span></span><span class="operator">case_product</span> bool.exhaust<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> False_False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">usvs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">usvs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> op_induct<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">usvs</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">us</span></span> <span class="skolem"><span class="skolem">vs</span></span> <span class="keyword2"><span class="keyword">where</span></span> usvs<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">usvs</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">us</span><span class="main">,</span> <span class="skolem">vs</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
    <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="main">(</span>op2<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root2<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">us</span><span class="main">)</span> <span class="main">=</span> TT"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xs</span>
    <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> srev_induct<span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ssnoc <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> ssnoc<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">)</span> <span class="keyword1"><span class="command">have</span></span> IH<span class="main">:</span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="main">(</span>op2<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root2<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">xs</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">-</span> <span class="main">(</span><span class="operator">rule</span> ssnoc<span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> lt_trans <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> lt_slength_0<span class="main">)</span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">us'</span></span> <span class="skolem"><span class="skolem">vs'</span></span> <span class="keyword2"><span class="keyword">where</span></span> us'vs'<span class="main">:</span> <span class="quoted"><span class="quoted">"split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">us'</span><span class="main">,</span> <span class="skolem">vs'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> ssnoc<span class="main">(</span>1<span class="main">,</span>2<span class="main">,</span>4<span class="main">)</span> usvs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> split_sfoldl_op<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> IH<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> step<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">simplified</span> abs_rep2_ID'<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">using</span></span> lt_trans split_length_lt split_sfoldl_op <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span><span class="main"><span class="keyword3">+</span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> root2.unfold<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
    <span class="keyword1"><span class="command">have</span></span> **<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="keyword1">If</span> snull<span class="main">⋅</span><span class="skolem">us</span> <span class="keyword1">then</span> rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free">pat</span><span class="main">)</span> <span class="keyword1">else</span> rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>op<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>stail<span class="main">⋅</span><span class="skolem">us</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">x</span><span class="main">)</span>
            <span class="main">=</span> op2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>left2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">us</span><span class="main">,</span> <span class="skolem">vs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">[:</span><span class="skolem">x</span><span class="main">:]</span><span class="main">⋅</span><span class="skolem">vs</span> <span class="main">=</span> FF"</span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> snil <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> next_Null op2.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> prefix.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> prefix_FF_not_snilD root2.simps<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">u'</span> <span class="skolem">us'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> scons <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">us'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">us</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
        <span class="keyword1"><span class="command">using</span></span> split_length_lt <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> usvs that scons this <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> * step<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">simplified</span> abs_rep2_ID'<span class="main"><span class="main">]</span></span> not_prefix_op2_next<span class="main">)</span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">usvs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> usvs <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> rep2.unfold<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> op2.unfold<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> op.unfold<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If_distr rep2_snoc_right2 ** <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> If_cong<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rep2.unfold<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Therefore the result of this data refinement is extensionally equal to
the specification:

›</span></span>

<span class="keyword1" id="KMP-data_refinement"><span class="command">lemma</span></span> data_refinement<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"matches <span class="main">=</span> matches2"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">intro</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">pat</span> <span class="skolem">xs</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"matches<span class="main">⋅</span><span class="skolem">pat</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> matches2<span class="main">⋅</span><span class="skolem">pat</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> True <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> matches2.simps<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> matches2.simps
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> matches_op<span class="main">)</span> <span class="comment1">―‹ Continue with previous derivation. ›</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sscanl_ww_fusion<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> wrap<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"ID <span class="main"><span class="main">**</span></span> abs2"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> unwrap<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"ID <span class="main"><span class="main">**</span></span> rep2<span class="main"><span class="main">⋅</span></span><span class="skolem"><span class="skolem">pat</span></span>"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> f'<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="keyword1"><span class="keyword1">Λ</span></span> <span class="main"><span class="main">(</span></span>n<span class="main"><span class="main">,</span></span> x<span class="main"><span class="main">)</span></span> y<span class="main"><span class="main">.</span></span> <span class="main"><span class="main">(</span></span><span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">+</span></span> <span class="main"><span class="main">1</span></span><span class="main"><span class="main">,</span></span> op2<span class="main"><span class="main">⋅</span></span><span class="skolem"><span class="skolem">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">⋅</span></span><span class="bound"><span class="bound">y</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> abs_rep2_ID<span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> op_op2_refinement<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oo_assoc sfilter_smap root2.unfold<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oo_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

This computation can be thought of as a pair coroutines with a
producer (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹root2›<span class="antiquote"><span class="antiquote">}</span></span></span></span>/<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹rep2›<span class="antiquote"><span class="antiquote">}</span></span></span></span>)
/ consumer (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op2›<span class="antiquote"><span class="antiquote">}</span></span></span></span>) structure. It turns out that
laziness is not essential (see \S\ref{sec:implementations}), though it
does depend on being able to traverse incompletely defined trees.

The key difficulty in defining this computation in HOL using present
technology is that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> is neither terminating
nor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span> ‹friendly›<span class="antiquote"><span class="antiquote">}</span></span></span></span> in the terminology of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
"BlanchetteEtAl:2017"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

While this representation works for automata with this sort of
structure, it is unclear how general it is; in particular it may not
work so well if <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹left›<span class="antiquote"><span class="antiquote">}</span></span></span></span> branches can go forward
as well as back. See also the commentary in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet]
"HinzeJeuring:2001"<span class="antiquote"><span class="antiquote">}</span></span></span></span>, who observe that sharing is easily lost, and so
it is probably only useful in ``closed'' settings like the present
one, unless the language is extended in unusual ways <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span>
[cite_macro=citep] "JeanninEtAl:2017"<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

\label{thm:k_property}

We conclude by proving that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹rep2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> produces
trees that have the `K' property, viz that labels on consecutive nodes
on a left path do not start with the same symbol. This also
establishes the productivity of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹root2›<span class="antiquote"><span class="antiquote">}</span></span></span></span>. The
pattern of proof used here -- induction nested in coinduction --
recurs in \S\ref{sec:KMP:increase_sharing}.

›</span></span>

<span class="keyword1"><span class="command">coinductive</span></span> <span class="entity">K</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq<span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">K</span> Null"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">K</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">;</span> <span class="free">K</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">;</span>
     <span class="main">⋀</span><span class="bound">v</span> <span class="bound">vs</span><span class="main">.</span> csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">=</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="main">=</span> Null <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v'</span> <span class="bound">vs'</span><span class="main">.</span> csnd<span class="main">⋅</span><span class="main">(</span>label<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="bound">v'</span> <span class="main">:#</span> <span class="bound">vs'</span> <span class="main">∧</span> eq<span class="main">⋅</span><span class="bound">v</span><span class="main">⋅</span><span class="bound">v'</span> <span class="main">=</span> FF<span class="main">)</span>
   <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">K</span> <span class="main">(</span>Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> K.intros<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main">!</span></span></span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="KMP-sfoldl_op2_root2_rep2_split"><span class="command">lemma</span></span> sfoldl_op2_root2_rep2_split<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"sfoldl<span class="main">⋅</span><span class="main">(</span>op2<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root2<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> srev_induct<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ssnoc <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> ssnoc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> split_sfoldl_op<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> op_op2_refinement<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> root2.unfold<span class="main">)</span>

<span class="keyword1" id="KMP-K_rep2"><span class="command">lemma</span></span> K_rep2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">us</span> <span class="main">:@</span> <span class="free">vs</span> <span class="main">=</span> <span class="free">pat</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"K <span class="main">(</span>rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="free">vs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">us</span></span> <span class="quoted"><span class="free">vs</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>K <span class="skolem">us</span> <span class="skolem">vs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">us</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">vs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> op_induct'<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">us</span><span class="main">)</span>
    <span class="keyword1"><span class="command">from</span></span> step.prems <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span><span class="main">)</span>
      <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> snil <span class="keyword1"><span class="command">with</span></span> step.prems <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep2.simps<span class="main">)</span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">u'</span> <span class="skolem">us'</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> scons <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span>
      <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">usl</span></span> <span class="skolem"><span class="skolem">vsl</span></span> <span class="keyword2"><span class="keyword">where</span></span> splitl<span class="main">:</span> <span class="quoted"><span class="quoted">"split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">us'</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">usl</span><span class="main">,</span> <span class="skolem">vsl</span><span class="main">)</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">usl</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vsl</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">usl</span> <span class="main">:@</span> <span class="skolem">vsl</span> <span class="main">=</span> <span class="free">pat</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> hide_lams<span class="main"><span class="main">)</span></span> Rep_cfun_strict1 prod.collapse sappend_strict sappend_strict2 split_pattern<span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> scons <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">l</span></span> <span class="skolem"><span class="skolem">r</span></span> <span class="keyword2"><span class="keyword">where</span></span> r<span class="main">:</span> <span class="quoted"><span class="quoted">"rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">us</span><span class="main">,</span> <span class="skolem">vs</span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span><span class="skolem">us</span><span class="main">,</span> <span class="skolem">vs</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">l</span><span class="main">⋅</span><span class="skolem">r</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rep2.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">us</span> <span class="bound">vs</span><span class="main">.</span> <span class="skolem">l</span> <span class="main">=</span> rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="bound">us</span><span class="main">,</span> <span class="bound">vs</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">us</span> <span class="main">:@</span> <span class="bound">vs</span> <span class="main">=</span> <span class="free">pat</span><span class="main">)</span> <span class="main">∨</span> K <span class="skolem">l</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> snil <span class="keyword1"><span class="command">with</span></span> scons splitl r <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep2.simps sfoldl_op2_root2_rep2_split<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> scons
        <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">=</span> <span class="skolem">u'</span> <span class="main">:#</span> <span class="skolem">us'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u'</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us'</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> r splitl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep2.simps sfoldl_op2_root2_rep2_split<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vsl</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">usl</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> sfoldl_op2_root2_rep2_split <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> ul' usl'<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cut_tac</span> us'<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"prod.fst <span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="improper">usl'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> vs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"prod.snd <span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="improper">usl'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> step<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> split_pattern<span class="main">)</span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv lt_trans slength.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> split_length_lt step.prems<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> sfoldl_op2_root2_rep2_split<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> b l r<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">b</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep2.simps<span class="main">)</span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> rep2.simps <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> split_pattern<span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">:@</span> <span class="skolem">vs</span> <span class="main">=</span> <span class="free">pat</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> r
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">∃</span><span class="bound">usr</span> <span class="bound">vsr</span><span class="main">.</span> <span class="skolem">r</span> <span class="main">=</span> rep2<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="bound">usr</span><span class="main">,</span> <span class="bound">vsr</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">usr</span> <span class="main">:@</span> <span class="bound">vsr</span> <span class="main">=</span> <span class="free">pat</span><span class="main">)</span> <span class="main">∨</span> K <span class="skolem">r</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep2.simps<span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">l</span> <span class="main">=</span> Null <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">v'</span> <span class="bound">vs'</span><span class="main">.</span> csnd<span class="main">⋅</span><span class="main">(</span>label<span class="main">⋅</span><span class="skolem">l</span><span class="main">)</span> <span class="main">=</span> <span class="bound">v'</span> <span class="main">:#</span> <span class="bound">vs'</span> <span class="main">∧</span> eq<span class="main">⋅</span><span class="skolem">v</span><span class="main">⋅</span><span class="bound">v'</span> <span class="main">=</span> FF<span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vs</span> <span class="main">=</span> <span class="skolem">v</span> <span class="main">:#</span> <span class="skolem">vs'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">v</span> <span class="skolem">vs'</span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vsl</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> snil <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">:@</span> <span class="skolem">vs</span> <span class="main">=</span> <span class="free">pat</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">=</span> <span class="skolem">u'</span> <span class="main">:#</span> <span class="skolem">us'</span>›</span></span> splitl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> split_length_lt<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> pat<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">pat</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> xs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="skolem">us'</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> slengthE <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> one_Integer_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits<span class="main">)</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> scons
        <span class="keyword1"><span class="command">from</span></span> splitl <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">usl</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">us'</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> fst_conv fst_strict split_bottom_iff split_length_lt<span class="main">)</span>
        <span class="keyword1"><span class="command">with</span></span> scons <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">=</span> <span class="skolem">u'</span> <span class="main">:#</span> <span class="skolem">us'</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">u'</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us'</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> r splitl <span class="quoted"><span class="quoted">‹<span class="skolem">vs</span> <span class="main">=</span> <span class="skolem">v</span> <span class="main">:#</span> <span class="skolem">vs'</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">using</span></span> step<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="operator">OF</span> _ <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span><span class="main">,</span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> us'<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"prod.fst <span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">us'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> vs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="quoted">"prod.snd <span class="main">(</span>split<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">us'</span><span class="main">)</span>"</span></span><span class="main">]</span>
          <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> rep2.simps sfoldl_op2_root2_rep2_split If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">vsl</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">note</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span>
      <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">theorem</span></span> K_root2<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"K <span class="main">(</span>root2<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">unfolding</span></span> root2.unfold <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> K_rep2<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The remaining steps are as follows:

<span class="antiquoted"><span class="antiquoted">▪</span></span> 3. introduce an accumulating parameter (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>grep›</span></span></span></span>).
<span class="antiquoted"><span class="antiquoted">▪</span></span> 4. inline <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>rep›</span></span></span></span> and simplify.
<span class="antiquoted"><span class="antiquoted">▪</span></span> 5. simplify to Bird's ``simpler forms.''
<span class="antiquoted"><span class="antiquoted">▪</span></span> 6. memoise <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>left›</span></span></span></span>.
<span class="antiquoted"><span class="antiquoted">▪</span></span> 7. simplify, unfold <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>prefix›</span></span></span></span>.
<span class="antiquoted"><span class="antiquoted">▪</span></span> 8. discard <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>us›</span></span></span></span>.
<span class="antiquoted"><span class="antiquoted">▪</span></span> 9. factor out <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>pat›</span></span></span></span>.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Step 3: Introduce an accumulating parameter (grep) ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Next we prepare for the second memoization step (\S\ref{sec:KMP:increase_sharing})
by introducing an accumulating parameter to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹rep2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> that supplies the value of the left
subtree.

We retain <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹rep2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> as a wrapper for now, and inline <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹right2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> to speed up
simplification.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="comment1">―‹ Bird p131 / p132 ›</span>
    <span class="entity">root3</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">op3</span>    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">rep3</span>   <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">grep3</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">root3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span> <span class="free">rep3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">op3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">root3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span>
   <span class="free">op3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> prefix<span class="main">⋅</span><span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span><span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">else</span> <span class="free">op3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="comment1">―‹ Inline <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ‹left2›<span class="antiquote">}</span></span>, factor out <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ‹next›<span class="antiquote">}</span></span>. ›</span>
  <span class="quoted"><span class="quoted">"<span class="free">rep3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">=</span> <span class="free">grep3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">case</span> cfst<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="keyword1">of</span> <span class="main">[::]</span> <span class="main">⇒</span> Null <span class="main">|</span> <span class="bound">u</span> <span class="main">:#</span> <span class="bound">us</span> <span class="main">⇒</span> sfoldl<span class="main">⋅</span><span class="main">(</span><span class="free">op3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">root3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="bound">us</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span>"</span></span>
<span class="main">|</span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>  <span class="comment1">―‹ <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ‹rep2›<span class="antiquote">}</span></span> with <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ‹left2›<span class="antiquote">}</span></span> abstracted, <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">const</span> ‹right2›<span class="antiquote">}</span></span> inlined. ›</span>
  <span class="quoted"><span class="quoted">"<span class="free">grep3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">=</span> Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">case</span> csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="keyword1">of</span>
          <span class="main">[::]</span> <span class="main">⇒</span> Null
        <span class="main">|</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⇒</span> <span class="free">rep3</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="bound">v</span><span class="main">:]</span><span class="main">,</span> <span class="bound">vs</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> root3_op3_rep3_grep3_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> root3  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op3    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> rep3   <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep3  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>
   <span class="main">=</span> fix<span class="main">⋅</span><span class="var">?F</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root3_def op3_def rep3_def grep3_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="KMP-r3_2"><span class="command">lemma</span></span> r3_2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>root<span class="main">,</span> op<span class="main">,</span> rep<span class="main">,</span> grep<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">root</span><span class="main">,</span> <span class="bound">op</span><span class="main">,</span> <span class="bound">rep</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>
   <span class="main">(</span> root3  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op3    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> rep3   <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep3  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>
 <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>root<span class="main">,</span> op<span class="main">,</span> rep<span class="main">,</span> left<span class="main">,</span> right<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">root</span><span class="main">,</span> <span class="bound">op</span><span class="main">,</span> <span class="bound">rep</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>
   <span class="main">(</span> root2  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op2    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> rep2   <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> left2  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> right2 <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root2_op2_rep2_left2_right2_def root3_op3_rep3_grep3_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> match_snil_match_scons_slist_case match_Null_match_Node_tree_case slist_case_distr tree_case_distr<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fix_cprod fix_const<span class="main">)</span> <span class="comment1">―‹ Very slow. Sensitive to tuple order due to the asymmetry of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>fix_cprod›</span></span>. ›</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> slist_case_distr<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Step 4: Inline rep ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We further simplify by inlining <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹rep3›<span class="antiquote"><span class="antiquote">}</span></span></span></span> into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹root3›<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹grep3›<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span>
    <span class="entity">root4</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">op4</span>    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">grep4</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">root4</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span> <span class="free">grep4</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">op4</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">root4</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span>
   <span class="free">op4</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> prefix<span class="main">⋅</span><span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span><span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">else</span> <span class="free">op4</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">grep4</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">=</span> Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">case</span> csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="keyword1">of</span>
          <span class="main">[::]</span> <span class="main">⇒</span> Null
        <span class="main">|</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⇒</span> <span class="free">grep4</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">case</span> cfst<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="bound">v</span><span class="main">:]</span> <span class="keyword1">of</span>
              <span class="main">[::]</span> <span class="main">⇒</span> Null <span class="comment1">―‹ unreachable ›</span>
            <span class="main">|</span> <span class="bound">u</span> <span class="main">:#</span> <span class="bound">us</span> <span class="main">⇒</span> sfoldl<span class="main">⋅</span><span class="main">(</span><span class="free">op4</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">root4</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="bound">us</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="bound">v</span><span class="main">:]</span><span class="main">,</span> <span class="bound">vs</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> root4_op4_grep4_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> root4  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op4    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep4  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>
   <span class="main">=</span> fix<span class="main">⋅</span><span class="var">?F</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root4_def op4_def grep4_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="KMP-fix_syn4_permute"><span class="command">lemma</span></span> fix_syn4_permute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">X1</span><span class="main">,</span> <span class="bound">X2</span><span class="main">,</span> <span class="bound">X3</span><span class="main">,</span> <span class="bound">X4</span><span class="main">)</span><span class="main">.</span> <span class="free">F1</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">X1</span><span class="main">,</span> <span class="bound">X2</span><span class="main">,</span> <span class="bound">X3</span><span class="main">,</span> <span class="bound">X4</span><span class="main">)</span><span class="main">.</span> <span class="free">F2</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">X1</span><span class="main">,</span> <span class="bound">X2</span><span class="main">,</span> <span class="bound">X3</span><span class="main">,</span> <span class="bound">X4</span><span class="main">)</span><span class="main">.</span> <span class="free">F3</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cont <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">X1</span><span class="main">,</span> <span class="bound">X2</span><span class="main">,</span> <span class="bound">X3</span><span class="main">,</span> <span class="bound">X4</span><span class="main">)</span><span class="main">.</span> <span class="free">F4</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"fix_syn <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">X1</span><span class="main">,</span> <span class="bound">X2</span><span class="main">,</span> <span class="bound">X3</span><span class="main">,</span> <span class="bound">X4</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">F1</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">,</span> <span class="free">F2</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">,</span> <span class="free">F3</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">,</span> <span class="free">F4</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">)</span><span class="main">)</span>
      <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x1</span><span class="main">,</span> <span class="bound">x2</span><span class="main">,</span> <span class="bound">x4</span><span class="main">,</span> <span class="bound">x3</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">x1</span><span class="main">,</span> <span class="bound">x2</span><span class="main">,</span> <span class="bound">x3</span><span class="main">,</span> <span class="bound">x4</span><span class="main">)</span><span class="main">)</span>
            <span class="main">(</span>fix_syn <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">X1</span><span class="main">,</span> <span class="bound">X2</span><span class="main">,</span> <span class="bound">X4</span><span class="main">,</span> <span class="bound">X3</span><span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="free">F1</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">,</span> <span class="free">F2</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">,</span> <span class="free">F4</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">,</span> <span class="free">F3</span> <span class="bound">X1</span> <span class="bound">X2</span> <span class="bound">X3</span> <span class="bound">X4</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> parallel_fix_ind<span class="main">)</span> <span class="main">(</span><span class="operator">use</span> assms <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main">:</span> prod_cont_iff›</span><span class="main">)</span>

<span class="keyword1" id="KMP-r4_3"><span class="command">lemma</span></span> r4_3<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> root4  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op4    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep4  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>
 <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>root<span class="main">,</span> op<span class="main">,</span> rep<span class="main">,</span> grep<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">root</span><span class="main">,</span> <span class="bound">op</span><span class="main">,</span> <span class="bound">grep</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>
   <span class="main">(</span> root3  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op3    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> rep3   <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep3  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root3_op3_rep3_grep3_def root4_op4_grep4_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> slist_case_distr match_Null_match_Node_tree_case tree_case_distr eta_cfun<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> fix_syn4_permute<span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> fix_cprod fix_const<span class="main">)</span> <span class="comment1">―‹ Slow ›</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Step 5: Simplify to Bird's ``simpler forms'' ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The remainder of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹left2›<span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹grep4›<span class="antiquote"><span class="antiquote">}</span></span></span></span> can be simplified by transforming the
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">text</span></span> <span class="raw_text"><span class="raw_text">"case"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> scrutinee from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"cfst<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">usvs</span></span> <span class="main"><span class="main">:@</span></span> <span class="main"><span class="main">[:</span></span><span class="free"><span class="free">v</span></span><span class="main"><span class="main">:]</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"cfst<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">usvs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span>
    <span class="entity">root5</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">op5</span>    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">grep5</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">root5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span> <span class="free">grep5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">op5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">root5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span>
   <span class="free">op5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> prefix<span class="main">⋅</span><span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span><span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">else</span> <span class="free">op5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">grep5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">=</span> Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">case</span> csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="keyword1">of</span>
          <span class="main">[::]</span> <span class="main">⇒</span> Null
        <span class="main">|</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⇒</span> <span class="free">grep5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">case</span> cfst<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="keyword1">of</span> <span class="comment1">― ‹ was <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">‹cfst<span class="main">⋅</span><span class="free">usvs</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">v</span><span class="main">:]</span>›</span><span class="antiquote">}</span></span> ›</span>
              <span class="main">[::]</span> <span class="main">⇒</span> <span class="free">root5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span>
            <span class="main">|</span> <span class="bound">u</span> <span class="main">:#</span> <span class="bound">us</span> <span class="main">⇒</span> sfoldl<span class="main">⋅</span><span class="main">(</span><span class="free">op5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">root5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">us</span> <span class="main">:@</span> <span class="main">[:</span><span class="bound">v</span><span class="main">:]</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="bound">v</span><span class="main">:]</span><span class="main">,</span> <span class="bound">vs</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> root5_op5_grep5_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> root5  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op5    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep5  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>
   <span class="main">=</span> fix<span class="main">⋅</span><span class="var">?F</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root5_def op5_def grep5_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="KMP-op5_grep5_strict"><span class="command">lemma</span></span> op5_grep5_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">⊥</span><span class="main">)</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free">usvs</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"grep5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fixrec_simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">us</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">usvs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fixrec_simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="KMP-r5_4"><span class="command">lemma</span></span> r5_4<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> root5  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op5    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep5  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>
 <span class="main">=</span> <span class="main">(</span> root4  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op4    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep4  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root4_op4_grep4_def root5_op5_grep5_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> slist_case_distr slist_case_snoc stail_sappend <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> slist_case_cong<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Step 6: Memoize left \label{sec:KMP:increase_sharing} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The last substantial step is to memoise the computation of the left subtrees by tying the knot.

Note this makes the computation of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>us›</span></span></span></span> in the tree redundant; we remove it in \S\ref{sec:KMP:step8}.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="comment1">―‹ Bird p132 ›</span>
    <span class="entity">root6</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">op6</span>    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">grep6</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">root6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span> <span class="free">grep6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">op6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">root6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span>
   <span class="free">op6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> prefix<span class="main">⋅</span><span class="main">[:</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">:]</span><span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">else</span> <span class="free">op6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">grep6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">=</span> Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="keyword1">case</span> csnd<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="keyword1">of</span>
          <span class="main">[::]</span> <span class="main">⇒</span> Null
        <span class="main">|</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⇒</span> <span class="free">grep6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free">op6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="bound">v</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">usvs</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="bound">v</span><span class="main">:]</span><span class="main">,</span> <span class="bound">vs</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> root6_op6_grep6_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> root6  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op6    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep6  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>
   <span class="main">=</span> fix<span class="main">⋅</span><span class="var">?F</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root6_def op6_def grep6_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="KMP-op6_grep6_strict"><span class="command">lemma</span></span> op6_grep6_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="main">⊥</span><span class="main">)</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free">usvs</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"grep6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fixrec_simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">us</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">usvs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fixrec_simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Intuitively this step cashes in the fact that, in the context of
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹grep6<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">l</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">usvs</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">"sfoldl<span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span>op6<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span>root6<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">)</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">us</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is
equal to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">l</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.

Connecting this step with the previous one is not simply a matter of
equational reasoning; we can see this by observing that the right
subtree of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹grep5<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">l</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">usvs</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
does not depend on <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">l</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> whereas that of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span>
<span class="quoted"><span class="quoted">‹grep6<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">l</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">usvs</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> does, and therefore
these cannot be extensionally equal. Furthermore the computations of
the corresponding <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">root</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>s do not proceed in
lockstep: consider the computation of the left subtree.

For our purposes it is enough to show that the trees <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
‹root5›<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹root6›<span class="antiquote"><span class="antiquote">}</span></span></span></span> are equal,
from which it follows that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">"op6 <span class="main"><span class="main">=</span></span> op5"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> by induction on its
tree argument. The equality is established by exhibiting a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">emph</span></span>
‹tree bisimulation›<span class="antiquote"><span class="antiquote">}</span></span></span></span> (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> tree_bisim<span class="antiquote"><span class="antiquote">}</span></span></span></span>) that relates
the corresponding ``producer'' <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>grep›</span></span></span></span> functions. Such a
relation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R›</span></span></span></span> must satisfy:

<span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R ⊥ ⊥›</span></span></span></span>;
<span class="antiquoted"><span class="antiquoted">▪</span></span> <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R Null Null›</span></span></span></span>; and
<span class="antiquoted"><span class="antiquoted">▪</span></span> if <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R (Node⋅x⋅l⋅r) (Node⋅x'⋅l'⋅r')›</span></span></span></span> then <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>x = x'›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R l l'›</span></span></span></span>, and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>R r r'›</span></span></span></span>.

›</span></span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The following pair of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>left›</span></span></span></span> functions define suitable left
paths from the corresponding <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">root</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>s.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">left5</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">left5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> Null"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">left5</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">)</span> <span class="main">=</span> sfoldl<span class="main">⋅</span><span class="main">(</span>op5<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root5<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">us</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">left6</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">left6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> Null"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">left6</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">u</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">)</span> <span class="main">=</span> sfoldl<span class="main">⋅</span><span class="main">(</span>op6<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root6<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">us</span></span></span>"</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="comment1">―‹ This relation is not inductive. ›</span>
  <span class="entity">root_bisim</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">⇒</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">⇒</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">⇒</span> bool"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">pat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  bottom<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">root_bisim</span> <span class="free">pat</span> <span class="main">⊥</span> <span class="main">⊥</span>"</span></span>
<span class="main">|</span> Null<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">root_bisim</span> <span class="free">pat</span> Null Null"</span></span>
<span class="main">|</span> gl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span>
   <span class="main">⟹</span> <span class="free">root_bisim</span> <span class="free">pat</span> <span class="main">(</span>grep6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>grep5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>left5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> root_bisim.intros<span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">,</span> <span class="operator">simp</span><span class="main">]</span>

<span class="keyword1" id="KMP-left6_left5_strict"><span class="command">lemma</span></span> left6_left5_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"left5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="KMP-op6_left6"><span class="command">lemma</span></span> op6_left6<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">us</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">us</span><span class="main">)</span><span class="main">⋅</span><span class="free">v</span> <span class="main">=</span> left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">v</span><span class="main">:]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">us</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-op5_left5"><span class="command">lemma</span></span> op5_left5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">us</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>left5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">us</span><span class="main">)</span><span class="main">⋅</span><span class="free">v</span> <span class="main">=</span> left5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">v</span><span class="main">:]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">us</span></span><span class="main">)</span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-root5_left5"><span class="command">lemma</span></span> root5_left5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> root5<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> left5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">[:</span><span class="free">v</span><span class="main">:]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="KMP-op5_sfoldl_left5"><span class="command">lemma</span></span> op5_sfoldl_left5<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">us</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">u</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">v</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
                 op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>sfoldl<span class="main">⋅</span><span class="main">(</span>op5<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root5<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="free">us</span><span class="main">)</span><span class="main">⋅</span><span class="free">v</span> <span class="main">=</span> left5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span><span class="free">u</span> <span class="main">:#</span> <span class="free">us</span> <span class="main">:@</span> <span class="main">[:</span><span class="free">v</span><span class="main">:]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="KMP-root_bisim_root"><span class="command">lemma</span></span> root_bisim_root<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"root_bisim <span class="free">pat</span> <span class="main">(</span>root6<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span> <span class="main">(</span>root5<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root6.unfold root5.unfold <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> left5.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> left6.simps<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> root_bisim.simps slist.con_rews<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>

<span class="keyword1" id="KMP-next_grep6_cases"><span class="command">lemma</span></span> next_grep6_cases<span class="main">[</span><span class="operator">consumes</span> 3<span class="main">,</span> <span class="operator">case_names</span> gl nl<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">vs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>next<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="main">(</span>grep6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">us</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="free">vs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="main">(</span>gl<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>grep6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">us</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="free">vs</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">|</span> <span class="main">(</span>nl<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">(</span>next<span class="main">⋅</span><span class="free">vs</span><span class="main">⋅</span><span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">us</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">atomize_elim</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep6.unfold<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="KMP-root_bisim_op_next56"><span class="command">lemma</span></span> root_bisim_op_next56<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"root_bisim <span class="free">pat</span> <span class="free">t6</span> <span class="free">t5</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">[:</span><span class="free">x</span><span class="main">:]</span><span class="main">⋅</span><span class="free">xs</span> <span class="main">=</span> FF"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">t6</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t6</span><span class="main">⋅</span><span class="free">x</span> <span class="main">∧</span> op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="free">xs</span><span class="main">⋅</span><span class="free">t5</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t5</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹root_bisim <span class="free">pat</span> <span class="free">t6</span> <span class="free">t5</span>›</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
  <span class="keyword3"><span class="command">case</span></span> Null <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>gl <span class="skolem">us</span> <span class="skolem">vs</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> grep6.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> grep5.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The main part of establishing that <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹root_bisim›<span class="antiquote"><span class="antiquote">}</span></span></span></span>
is a <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹tree_bisim›<span class="antiquote"><span class="antiquote">}</span></span></span></span> is in showing that the left
paths constructed by the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>grep›</span></span></span></span>s are <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
‹root_bisim›<span class="antiquote"><span class="antiquote">}</span></span></span></span>-related. We do this by inducting over the
length of the pattern so far matched (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>us›</span></span></span></span>), as we did
when proving that this tree has the `K' property in
\S\ref{thm:k_property}.

›</span></span>

<span class="keyword1"><span class="command">lemma</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> root_bisim_op<span class="main">:</span> <span class="quoted"><span class="quoted">"root_bisim <span class="free">pat</span> <span class="free">t6</span> <span class="free">t5</span> <span class="main">⟹</span> root_bisim <span class="free">pat</span> <span class="main">(</span>op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t6</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">(</span>op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t5</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span> <span class="comment1">― ‹ unused ›</span>
    <span class="keyword2"><span class="keyword">and</span></span> root_bisim_next_left<span class="main">:</span> <span class="quoted"><span class="quoted">"root_bisim <span class="free">pat</span> <span class="main">(</span>next<span class="main">⋅</span><span class="free">vs</span><span class="main">⋅</span><span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">us</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>next<span class="main">⋅</span><span class="free">vs</span><span class="main">⋅</span><span class="main">(</span>left5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">us</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rbnl</span> <span class="free">us</span> <span class="free">vs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ogl5</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">us</span> <span class="bound">vs</span><span class="main">.</span> op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>grep5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>left5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="bound">us</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">us</span><span class="main">,</span> <span class="bound">vs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?ogl6</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">us</span> <span class="bound">vs</span><span class="main">.</span> op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>grep6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="bound">us</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">us</span><span class="main">,</span> <span class="bound">vs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?for5</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">us</span><span class="main">.</span> sfoldl<span class="main">⋅</span><span class="main">(</span>op5<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root5<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="bound">us</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?for6</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">us</span><span class="main">.</span> sfoldl<span class="main">⋅</span><span class="main">(</span>op6<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root6<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">⋅</span><span class="bound">us</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="var">?ogl6</span> <span class="skolem">us</span> <span class="skolem">vs</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="skolem">usvs</span><span class="main">⋅</span><span class="skolem">l</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">;</span> cfst<span class="main">⋅</span><span class="skolem">usvs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="skolem">usvs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">us</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span>op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="skolem">xs</span><span class="main">⋅</span><span class="main">(</span>grep6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">us</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="skolem">us</span><span class="main">,</span> <span class="skolem">vs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="skolem">usvs</span><span class="main">⋅</span><span class="skolem">l</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">;</span> cfst<span class="main">⋅</span><span class="skolem">usvs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="skolem">usvs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">us</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="var">?for6</span> <span class="skolem">us</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="skolem">usvs</span><span class="main">⋅</span><span class="skolem">l</span><span class="main">⋅</span><span class="skolem">r</span><span class="main">;</span> cfst<span class="main">⋅</span><span class="skolem">usvs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="skolem">usvs</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">us</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span> root_bisim <span class="free">pat</span> <span class="main">(</span><span class="var">?ogl6</span> <span class="skolem">us</span> <span class="skolem">vs</span><span class="main">)</span> <span class="main">(</span><span class="var">?ogl5</span> <span class="skolem">us</span> <span class="skolem">vs</span><span class="main">)</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"root_bisim <span class="free">pat</span> <span class="main">(</span><span class="var">?for6</span> <span class="skolem">us</span><span class="main">)</span> <span class="main">(</span><span class="var">?for5</span> <span class="skolem">us</span><span class="main">)</span>"</span></span>
   <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="var">?rbnl</span> <span class="skolem">us</span> <span class="skolem">vs</span>"</span></span>
   <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">usvs</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="skolem">xs</span> <span class="skolem">us</span> <span class="skolem">vs</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">us</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">usvs</span></span> <span class="quoted"><span class="skolem">l</span></span> <span class="quoted"><span class="skolem">r</span></span> <span class="quoted"><span class="skolem">vs</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> op_induct'<span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">us</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> rbl<span class="main">:</span> <span class="quoted"><span class="quoted">"root_bisim <span class="free">pat</span> <span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">us</span><span class="main">)</span> <span class="main">(</span>left5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">us</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> left6.unfold left5.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>1 <span class="skolem">usvs</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="skolem">vs</span> <span class="skolem">x</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> rbl
      <span class="keyword1"><span class="command">have</span></span> L<span class="main">:</span> <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>prod.fst <span class="skolem">usvs'</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">us</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
          <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="skolem">vs</span><span class="main">⋅</span><span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">us</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="skolem">usvs'</span><span class="main">⋅</span><span class="skolem">l</span><span class="main">⋅</span><span class="skolem">r</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"cfst<span class="main">⋅</span><span class="skolem">usvs'</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
         <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
         <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">usvs'</span> <span class="skolem">l</span> <span class="skolem">r</span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
        <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> Null <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> root6.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> le_plus_1<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>gl <span class="skolem">us''</span> <span class="skolem">vs''</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span><span class="main">)</span>
          <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> snil <span class="keyword1"><span class="command">with</span></span> that <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> root6.unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">ush</span> <span class="skolem">ust</span><span class="main">)</span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> that gl scons <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"le<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>cfst<span class="main">⋅</span><span class="skolem">usvs'</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">us''</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">,</span></span> 3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
          <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> gl scons <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"lt<span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="skolem">us''</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>slength<span class="main">⋅</span><span class="main">(</span>stail<span class="main">⋅</span><span class="skolem">us</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> TT"</span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
          <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Integer_le_both_plus_1 Ord_linear_class.le_trans le_iff_lt_or_eq<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">from</span></span> 1 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> L<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
         <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> ab_semigroup_add_class.add_ac<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> fst_conv grep6.simps le_refl_Integer sappend_snil_id_right slength.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> slength_bottom_iff slength_sappend slist.con_rews<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> tree_injects'<span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> L<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
        <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">note</span></span> slength_ogl <span class="main">=</span> this
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>2 <span class="skolem">usvs</span> <span class="skolem">l</span> <span class="skolem">r</span> <span class="skolem">vs</span> <span class="skolem">x</span> <span class="skolem">xs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> 2 <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">clarsimp</span>
      <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">xs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> 2<span class="main">(</span>1<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> next_grep6_cases<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> gl <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹cfst<span class="main">⋅</span><span class="skolem">usvs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">x</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">using</span></span> slength_ogl <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> nl
        <span class="keyword1"><span class="command">from</span></span> rbl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
          <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">with</span></span> nl <span class="quoted"><span class="quoted">‹cfst<span class="main">⋅</span><span class="skolem">usvs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> Null <span class="keyword1"><span class="command">with</span></span> nl <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">vs</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> root6.unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>gl <span class="skolem">us''</span> <span class="skolem">vs''</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span><span class="main">)</span>
            <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> snil <span class="keyword1"><span class="command">with</span></span> gl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span> <span class="operator">simp</span>
          <span class="keyword1"><span class="command">next</span></span>
            <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>scons <span class="skolem">u'</span> <span class="skolem">us'</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> 2 nl gl <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> step<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> step<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> lt_le<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Integer_le_both_plus_1 Ord_linear_class.le_trans<span class="main">)</span>
              <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
          <span class="keyword1"><span class="command">qed</span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>3 <span class="skolem">usvs</span> <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> srev_cases<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> snil <span class="keyword1"><span class="command">with</span></span> 3 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> root6.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">fastforce</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ssnoc <span class="skolem">u'</span> <span class="skolem">us'</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"root_bisim <span class="free">pat</span> <span class="main">(</span><span class="var">?for6</span> <span class="skolem">us'</span><span class="main">)</span> <span class="main">(</span><span class="var">?for5</span> <span class="skolem">us'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
          <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">with</span></span> 3 ssnoc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> Null <span class="keyword1"><span class="command">with</span></span> 3 ssnoc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> root6.unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">next</span></span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>gl <span class="skolem">us''</span> <span class="skolem">vs''</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> 3 ssnoc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> zero_Integer_def one_Integer_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> if_splits <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span> step<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> slengthE<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">qed</span></span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> 3 <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">simp</span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>4 <span class="skolem">vs</span> <span class="skolem">x</span><span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"prefix<span class="main">⋅</span><span class="main">[:</span><span class="skolem">x</span><span class="main">:]</span><span class="main">⋅</span><span class="skolem">vs</span>"</span></span><span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep6.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep5.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> TT <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep6.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep5.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> op6_left6<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> left6.simps left5.simps <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> root5_left5<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> op5_sfoldl_left5 root5_left5 root_bisim.simps sappend_bottom_iff slist.con_rews<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> slist.con_rews<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> FF <span class="keyword1"><span class="command">with</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">us</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep6.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep5.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> rbl
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> root_bisim_op_next56 <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> root_bisim.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> root_bisim_root<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> 5 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> srev_cases<span class="main">)</span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>ssnoc <span class="skolem">u'</span> <span class="skolem">us'</span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"root_bisim <span class="free">pat</span> <span class="main">(</span><span class="var">?for6</span> <span class="skolem">us'</span><span class="main">)</span> <span class="main">(</span><span class="var">?for5</span> <span class="skolem">us'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span><span class="main">)</span>
        <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
        <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
          <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>gl <span class="skolem">us''</span> <span class="skolem">vs''</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> ssnoc <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
            <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
        <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> ssnoc root_bisim_root <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>
      <span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> root_bisim_root <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>6 <span class="skolem">vs</span><span class="main">)</span>
      <span class="keyword1"><span class="command">from</span></span> rbl <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> rbnl<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="var">?rbnl</span> <span class="skolem">us</span> <span class="skolem">vs</span>"</span></span>
      <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
        <span class="keyword3"><span class="command">case</span></span> bottom <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> Null <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main">)</span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">next</span></span>
        <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>gl <span class="skolem">us''</span> <span class="skolem">vs''</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep5.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep6.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep5.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">vs''</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
           <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Rep_cfun_strict1 bottom left5.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> left6.simps<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> next_snil next_strict<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> rbl<span class="main">)</span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
          <span class="keyword1"><span class="command">using</span></span> rbl <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main"><span class="main">[</span></span><span class="operator">rotated</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> step<span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If2_def<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> eq_FF <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> If2_splits<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
          <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword1"><span class="command">qed</span></span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> this<span class="main">(</span>4<span class="main">)</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"root_bisim <span class="free">pat</span> <span class="free">t6</span> <span class="free">t5</span> <span class="main">⟹</span> root_bisim <span class="free">pat</span> <span class="main">(</span>op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t6</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span> <span class="main">(</span>op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t5</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> root_bisim.cases <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> root_bisim_root<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">‹root_bisim <span class="free">pat</span> <span class="main">(</span>next<span class="main">⋅</span><span class="free">vs</span><span class="main">⋅</span><span class="main">(</span>left6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">us</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>next<span class="main">⋅</span><span class="free">vs</span><span class="main">⋅</span><span class="main">(</span>left5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">us</span><span class="main">)</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

With this result in hand the remainder is technically fiddly but straightforward.

›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> tree_bisimI <span class="main">=</span> iffD2<span class="main">[</span><span class="operator">OF</span> fun_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tree.bisim_def<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> atomize_eq<span class="main"><span class="main">]</span></span><span class="main"><span class="main">]</span></span><span class="main">,</span> <span class="operator">rule_format</span><span class="main">]</span>

<span class="keyword1" id="KMP-tree_bisim_root_bisim"><span class="command">lemma</span></span> tree_bisim_root_bisim<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"tree_bisim <span class="main">(</span>root_bisim <span class="free">pat</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> tree_bisimI<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> root_bisim.cases<span class="main"><span class="keyword3">,</span></span> <span class="operator">goal_cases</span> bottom Null Node<span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Node <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">us</span> <span class="skolem">vs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep5.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">asm</span><span class="main"><span class="main">)</span></span> grep6.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">hypsubst_thin</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> root_bisim_next_left<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">us</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> left6.simps left5.simps <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> op5_sfoldl_left5 op6_left6<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> root5_left5 root_bisim.simps slist.con_rews<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span>4<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>no_types<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> op5_sfoldl_left5 root_bisim.simps sappend_bottom_iff slist.con_rews<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">,</span></span> 4<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-r6_5"><span class="command">lemma</span></span> r6_5<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>root6<span class="main">⋅</span><span class="free">pat</span><span class="main">,</span> op6<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>root5<span class="main">⋅</span><span class="free">pat</span><span class="main">,</span> op5<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">from</span></span> True <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"root6<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> root5<span class="main">⋅</span><span class="free">pat</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> root6.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep6.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> root5.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> grep5.unfold<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> True <span class="quoted"><span class="quoted">‹root6<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> root5<span class="main">⋅</span><span class="free">pat</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">t</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">t</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">t</span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">t</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> root<span class="main">:</span> <span class="quoted"><span class="quoted">"root6<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> root5<span class="main">⋅</span><span class="free">pat</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> tree.coinduct<span class="main"><span class="main">[</span></span><span class="operator">OF</span> tree_bisim_root_bisim root_bisim_root<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">moreover</span></span>
  <span class="keyword1"><span class="command">from</span></span> root <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">t</span><span class="main">⋅</span><span class="skolem">x</span> <span class="main">=</span> op5<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="skolem">t</span><span class="main">⋅</span><span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">t</span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">t</span></span><span class="main">)</span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We conclude this section by observing that accumulator-introduction is a well known technique
(see, for instance, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] ‹\S13.6› "Hutton:2016"<span class="antiquote"><span class="antiquote">}</span></span></span></span>), but the examples in the
literature assume that the type involved is defined inductively. Bird adopts this strategy without
considering what the mixed inductive/coinductive rule is that justifies the preservation of total
correctness.

The difficulty of this step is why we wired in the `K' opt earlier: it allows us to preserve the
shape of the tree all the way from the data refinement to the final version.

›</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Step 7: Simplify, unfold prefix ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The next step (Bird, bottom of p132) is to move the case split in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹grep6›<span class="antiquote"><span class="antiquote">}</span></span></span></span> on <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>vs›</span></span></span></span> above the
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Node›</span></span></span></span> constructor, which makes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">grep7</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> strict in that parameter and therefore not
extensionally equal to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹grep6›<span class="antiquote"><span class="antiquote">}</span></span></span></span>. We establish a weaker correspondence using fixed-point induction.

We also unfold <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹prefix›<span class="antiquote"><span class="antiquote">}</span></span></span></span> in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹op6›<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span>
    <span class="entity">root7</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">op7</span>    <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">grep7</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">root7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span> <span class="free">grep7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="main">(</span><span class="main">[::]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">op7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">root7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">op7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="main">[::]</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">op7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span> <span class="comment1">―‹ Unfold <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>prefix›</span></span> ›</span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">op7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> eq<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">else</span> <span class="free">op7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">grep7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="main">[::]</span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="main">[::]</span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span>Null"</span></span> <span class="comment1">―‹ Case split on <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>vs›</span></span> hoisted above <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>Node›</span></span>. ›</span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">grep7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">grep7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free">op7</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">us</span></span></span> <span class="main">:@</span> <span class="main">[:</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">:]</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> root7_op7_grep7_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> root7  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op7    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep7  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>
   <span class="main">=</span> fix<span class="main">⋅</span><span class="var">?F</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root7_def op7_def grep7_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="KMP-r7_6_aux"><span class="command">lemma</span></span> r7_6_aux<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>root<span class="main">,</span> op<span class="main">,</span> grep<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">root</span><span class="main">⋅</span><span class="free">pat</span><span class="main">,</span> seq<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">(</span><span class="bound">op</span><span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">,</span> <span class="bound">grep</span><span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="free">vs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>
   <span class="main">(</span> root7  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op7    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep7  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>
 <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>root<span class="main">,</span> op<span class="main">,</span> grep<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">root</span><span class="main">⋅</span><span class="free">pat</span><span class="main">,</span> seq<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">(</span><span class="bound">op</span><span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span><span class="main">,</span> seq<span class="main">⋅</span><span class="free">vs</span><span class="main">⋅</span><span class="main">(</span><span class="bound">grep</span><span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="main">(</span><span class="free">us</span><span class="main">,</span> <span class="free">vs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span>
   <span class="main">(</span> root6  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> op6    <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree
   <span class="main">,</span> grep6  <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">(</span><span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">×</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span><span class="main">)</span> tree <span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root6_op6_grep6_def root7_op7_grep7_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">us</span></span> <span class="quoted"><span class="free">vs</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> parallel_fix_ind<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> adm bottom step<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">X</span> <span class="skolem">Y</span> <span class="skolem">t</span> <span class="skolem">x</span> <span class="skolem">l</span> <span class="skolem">us</span> <span class="skolem">vs</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">X</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">Y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> r10 o10 g10 r9 o9 g9<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff assms match_Node_mplus_match_Node match_Null_match_Node_tree_case tree_case_distr match_snil_match_scons_slist_case slist_case_distr If_distr<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> allI conjI<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">t</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> us vs l r<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="skolem">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> ID1 seq_simps<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="KMP-r7_6"><span class="command">lemma</span></span> r7_6<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"root7<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> root6<span class="main">⋅</span><span class="free">pat</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">x</span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> op7<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t</span><span class="main">⋅</span><span class="free">x</span> <span class="main">=</span> op6<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t</span><span class="main">⋅</span><span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> r7_6_aux<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> spec<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> x<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">x</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Step 8: Discard us \label{sec:KMP:step8} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We now discard <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>us›</span></span></span></span> from the tree as it is no longer used. This requires a new
definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹next›<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

This is essentially another data refinement.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">next'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span><span class="main">::</span>Eq_def <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">next'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span>Null <span class="main">=</span> Null"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">next'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">next'</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="keyword1">If</span> eq<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">l</span></span></span> <span class="keyword1">else</span> Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span>"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="comment1">―‹ Bird p133 ›</span>
    <span class="entity">root8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">op8</span>   <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree"</span></span>
<span class="keyword2"><span class="keyword">and</span></span> <span class="entity">grep8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">root8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span> <span class="free">grep8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">op8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">root8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">op8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">op8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">op8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="keyword1">If</span> eq<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="keyword1">else</span> <span class="free">op8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">grep8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="main">[::]</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span>Null"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">;</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span><span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">grep8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span> <span class="main">=</span> Node<span class="main">⋅</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">v</span></span></span> <span class="main">:#</span> <span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>next'<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="free">grep8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="main">(</span><span class="free">op8</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">v</span></span></span><span class="main">)</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">ok8</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree <span class="main">→</span> tr"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">vs</span></span></span> <span class="main">≠</span> <span class="main">⊥</span> <span class="main">⟹</span> <span class="free">ok8</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">l</span></span></span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span> <span class="main">=</span> snull<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">vs</span></span></span>"</span></span>

<span class="keyword1"><span class="command">schematic_goal</span></span> root8_op8_grep8_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span> root8 <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree
   <span class="main">,</span> op8   <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree <span class="main">→</span> <span class="tfree">'a</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree
   <span class="main">,</span> grep8 <span class="main">::</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> tree <span class="main">)</span>
   <span class="main">=</span> fix<span class="main">⋅</span><span class="var">?F</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> op8_def root8_def grep8_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="KMP-next'_strict"><span class="command">lemma</span></span> next'_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"next'<span class="main">⋅</span><span class="free">x</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"next'<span class="main">⋅</span><span class="main">⊥</span><span class="main">⋅</span><span class="main">(</span>Node<span class="main">⋅</span><span class="main">(</span><span class="free">v</span> <span class="main">:#</span> <span class="free">vs</span><span class="main">)</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">r</span><span class="main">)</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">:#</span> <span class="free">vs</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="KMP-root8_op8_grep8_strict"><span class="command">lemma</span></span> root8_op8_grep8_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"grep8<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"op8<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"root8<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="KMP-ok8_strict"><span class="command">lemma</span></span> ok8_strict<span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"ok8<span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="quoted"><span class="quoted">"ok8<span class="main">⋅</span>Null <span class="main">=</span> <span class="main">⊥</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">fixrec_simp</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

We cannot readily relate <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹next›<span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span>
‹next'›<span class="antiquote"><span class="antiquote">}</span></span></span></span> using worker/wrapper as the obvious abstraction
is not invertible.  Conversely the desired result is easily shown by
fixed-point induction.

›</span></span>

<span class="keyword1" id="KMP-next'_next"><span class="command">lemma</span></span> next'_next<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">v</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">vs</span> <span class="main">≠</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"next'<span class="main">⋅</span><span class="free">v</span><span class="main">⋅</span><span class="main">(</span>tree_map'<span class="main">⋅</span>csnd<span class="main">⋅</span><span class="free">t</span><span class="main">)</span> <span class="main">=</span> tree_map'<span class="main">⋅</span>csnd<span class="main">⋅</span><span class="main">(</span>next<span class="main">⋅</span><span class="main">(</span><span class="free">v</span> <span class="main">:#</span> <span class="free">vs</span><span class="main">)</span><span class="main">⋅</span><span class="free">t</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">t</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Node <span class="skolem">usvs'</span> <span class="skolem">l</span> <span class="skolem">r</span><span class="main">)</span> <span class="keyword1"><span class="command">with</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">usvs'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> us'' vs''<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">vs''</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If_distr<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="main">(</span><span class="operator">use</span> assms <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">simp_all</span><span class="main">)</span>

<span class="keyword1" id="KMP-r8_7"><span class="command">lemma</span></span> r8_7<span class="main">[</span><span class="operator">simplified</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>root<span class="main">,</span> op<span class="main">,</span> grep<span class="main">)</span><span class="main">.</span> <span class="main">(</span> <span class="bound">root</span><span class="main">⋅</span><span class="free">pat</span>
                              <span class="main">,</span>  <span class="bound">op</span><span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>tree_map'<span class="main">⋅</span>csnd<span class="main">⋅</span><span class="free">t</span><span class="main">)</span><span class="main">⋅</span><span class="free">x</span>
                              <span class="main">,</span> <span class="bound">grep</span><span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="main">(</span>tree_map'<span class="main">⋅</span>csnd<span class="main">⋅</span><span class="free">l</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>csnd<span class="main">⋅</span><span class="free">usvs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root8<span class="main">,</span> op8<span class="main">,</span> grep8<span class="main">)</span>
       <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>root<span class="main">,</span> op<span class="main">,</span> grep<span class="main">)</span><span class="main">.</span> <span class="main">(</span> tree_map'<span class="main">⋅</span>csnd<span class="main">⋅</span><span class="main">(</span><span class="bound">root</span><span class="main">⋅</span><span class="free">pat</span><span class="main">)</span>
                              <span class="main">,</span> tree_map'<span class="main">⋅</span>csnd<span class="main">⋅</span><span class="main">(</span><span class="bound">op</span><span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">t</span><span class="main">⋅</span><span class="free">x</span><span class="main">)</span>
                              <span class="main">,</span> tree_map'<span class="main">⋅</span>csnd<span class="main">⋅</span><span class="main">(</span><span class="bound">grep</span><span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="free">l</span><span class="main">⋅</span><span class="free">usvs</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root7<span class="main">,</span> op7<span class="main">,</span> grep7<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root7_op7_grep7_def root8_op8_grep8_def
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induct</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">l</span></span> <span class="quoted"><span class="free">t</span></span> <span class="quoted"><span class="free">usvs</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> parallel_fix_ind<span class="main"><span class="main">[</span></span><span class="operator">case_names</span> adm bottom step<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>step <span class="skolem">X</span> <span class="skolem">Y</span> <span class="skolem">l</span> <span class="skolem">t</span> <span class="skolem">usvs</span> <span class="skolem">x</span><span class="main">)</span> <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">X</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">Y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff next'_next
                          match_snil_match_scons_slist_case slist_case_distr
                          match_Node_mplus_match_Node match_Null_match_Node_tree_case tree_case_distr
                    <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> slist_case_cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">t</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If_distr<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> us vs l r<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">vs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Top-level equivalence follows from <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lfp_fusion›</span></span></span></span> specialized to <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>sscanl›</span></span></span></span> (<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> [source]
"sscanl_lfp_fusion"<span class="antiquote"><span class="antiquote">}</span></span></span></span>), which states that
\begin{center}
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">‹smap<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">g</span></span> <span class="keyword1"><span class="keyword1">oo</span></span> sscanl<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">f</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">z</span></span> <span class="main"><span class="main">=</span></span> sscanl<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">f'</span></span><span class="main"><span class="main">⋅</span></span><span class="main"><span class="main">(</span></span><span class="free"><span class="free">g</span></span><span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">z</span></span><span class="main"><span class="main">)</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
\end{center}
provided that <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>g›</span></span></span></span> is strict and the following diagram commutes for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">prop</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">x</span></span> <span class="main"><span class="main">≠</span></span> <span class="main"><span class="main">⊥</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>:

\begin{center}
  \begin{tikzcd}[column sep=6em]
    a \arrow[r, "<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Λ a. f⋅a⋅x›</span></span></span></span>"] \arrow[d, "<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>g›</span></span></span></span>"] &amp; a' \arrow[d, "<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>g›</span></span></span></span>"] \\
    b \arrow[r, "<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Λ a. f'⋅a⋅x›</span></span></span></span>"]                 &amp; b'
  \end{tikzcd}
\end{center}

›</span></span>

<span class="keyword1" id="KMP-ok8_ok8"><span class="command">lemma</span></span> ok8_ok8<span class="main">:</span> <span class="quoted"><span class="quoted">"ok8 <span class="keyword1">oo</span> tree_map'<span class="main">⋅</span>csnd <span class="main">=</span> snull <span class="keyword1">oo</span> csnd <span class="keyword1">oo</span> abs2"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">t</span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">t</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">t</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">t</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span> <span class="main">(</span><span class="operator">metis</span> ok8.simps ok8_strict<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> snull_strict tree.con_rews<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="KMP-matches8"><span class="command">lemma</span></span> matches8<span class="main">:</span> <span class="comment1">―‹ Bird p133 ›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"matches<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> smap<span class="main">⋅</span>cfst <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="main">(</span>ok8 <span class="keyword1">oo</span> csnd<span class="main">)</span> <span class="keyword1">oo</span> sscanl<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>n<span class="main">,</span> x<span class="main">)</span> y<span class="main">.</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> op8<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> root8<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">pat</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> True
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">xs</span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xs</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> False
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> *<span class="main">:</span> <span class="quoted"><span class="quoted">"matches<span class="main">⋅</span><span class="free">pat</span> <span class="main">=</span> smap<span class="main">⋅</span>cfst <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="main">(</span>snull <span class="keyword1">oo</span> csnd <span class="keyword1">oo</span> abs2 <span class="keyword1">oo</span> csnd<span class="main">)</span> <span class="keyword1">oo</span> sscanl<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>n<span class="main">,</span> x<span class="main">)</span> y<span class="main">.</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> op7<span class="main">⋅</span><span class="free">pat</span><span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> root7<span class="main">⋅</span><span class="free">pat</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">using</span></span> data_refinement<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">]</span> r3_2<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">]</span> r4_3<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">]</span> r5_4<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="tfree">'a</span><span class="main"><span class="main">=</span></span><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">]</span> r6_5<span class="main">(</span>1<span class="main">)</span><span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> pat<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">pat</span></span><span class="main">]</span> r7_6<span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> pat<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">pat</span></span></span></span><span class="main">]</span>
    <span class="keyword1"><span class="command">unfolding</span></span> matches2.unfold <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> oo_assoc cfun_eq_iff csplit_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cfun_arg_cong sscanl_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">pat</span> <span class="main">≠</span> <span class="main">⊥</span>›</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">-</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> conjunct1<span class="main"><span class="main">[</span></span><span class="operator">OF</span> r8_7<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> sscanl_lfp_fusion<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> g<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"ID <span class="main"><span class="main">**</span></span> tree_map'<span class="main"><span class="main">⋅</span></span>csnd"</span></span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword"><span class="quasi_keyword">and</span></span></span></span> z<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">0</span></span><span class="main"><span class="main">,</span></span> root7<span class="main"><span class="main">⋅</span></span><span class="free"><span class="free">pat</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> oo_assoc<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> sfilter_smap<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oo_assoc<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> oo_assoc<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subst</span> oo_assoc<span class="main"><span class="keyword3">,</span></span> <span class="operator">subst</span> ok8_ok8<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> oo_assoc *<span class="main">)</span>
     <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span> <span class="comment1">(* instantiate schematic *)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> r8_7<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹ Step 9: Factor out pat (final version) \label{sec:KMP:final_version} ›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

Finally we factor <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="free">pat</span></span>›</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> from these definitions and arrive
at Bird's cyclic data structure, which when executed using lazy
evaluation actually memoises the computation of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> ‹grep8›<span class="antiquote"><span class="antiquote">}</span></span></span></span>.

The <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Letrec›</span></span></span></span> syntax groups recursive bindings with
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>,›</span></span></span></span> and separates these with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>;›</span></span></span></span>. Its lack
of support for clausal definitions, and that \texttt{HOLCF}
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>case›</span></span></span></span> does not support nested patterns, leads to some
awkwardness.

›</span></span>

<span class="keyword1"><span class="command">fixrec</span></span> <span class="entity">matchesf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[:</span><span class="tfree">'a</span><span class="main">::</span>Eq_def<span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span><span class="tfree">'a</span><span class="main">:]</span> <span class="main">→</span> <span class="main">[:</span>Integer<span class="main">:]</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
<span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">del</span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">matchesf</span><span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span> <span class="main">=</span>
    <span class="main">(</span><span class="keyword1">Letrec</span> <span class="bound">okf</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>Node<span class="main">⋅</span>vs<span class="main">⋅</span>l<span class="main">⋅</span>r<span class="main">)</span><span class="main">.</span> snull<span class="main">⋅</span><span class="bound">vs</span><span class="main">)</span><span class="main">;</span>
            <span class="bound">nextf</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> x t<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">t</span> <span class="keyword1">of</span>
                   Null <span class="main">⇒</span> Null
                 <span class="main">|</span> Node<span class="main">⋅</span><span class="bound">vs</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">r</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">vs</span> <span class="keyword1">of</span>
                     <span class="main">[::]</span> <span class="main">⇒</span> <span class="bound">t</span>
                   <span class="main">|</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⇒</span> <span class="keyword1">If</span> eq<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">v</span> <span class="keyword1">then</span> <span class="bound">l</span> <span class="keyword1">else</span> <span class="bound">t</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
            <span class="bound">rootf</span> <span class="main">=</span> <span class="bound">grepf</span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="free"><span class="bound"><span class="entity">pat</span></span></span><span class="main">,</span>
            <span class="bound">opf</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> t x<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">t</span> <span class="keyword1">of</span>
                   Null <span class="main">⇒</span> <span class="bound">rootf</span>
                 <span class="main">|</span> Node<span class="main">⋅</span><span class="bound">vs</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">r</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">vs</span> <span class="keyword1">of</span>
                     <span class="main">[::]</span> <span class="main">⇒</span> <span class="bound">opf</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">x</span>
                   <span class="main">|</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⇒</span> <span class="keyword1">If</span> eq<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">v</span> <span class="keyword1">then</span> <span class="bound">r</span> <span class="keyword1">else</span> <span class="bound">opf</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
            <span class="bound">grepf</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> l vs<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">vs</span> <span class="keyword1">of</span>
                   <span class="main">[::]</span> <span class="main">⇒</span> Node<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span>Null
                 <span class="main">|</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⇒</span> Node<span class="main">⋅</span><span class="main">(</span><span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">nextf</span><span class="main">⋅</span><span class="bound">v</span><span class="main">⋅</span><span class="bound">l</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">grepf</span><span class="main">⋅</span><span class="main">(</span><span class="bound">opf</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">v</span><span class="main">)</span><span class="main">⋅</span><span class="bound">vs</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>
            <span class="bound">stepf</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>n<span class="main">,</span> t<span class="main">)</span> x<span class="main">.</span> <span class="main">(</span><span class="bound">n</span> <span class="main">+</span> <span class="main">1</span><span class="main">,</span> <span class="bound">opf</span><span class="main">⋅</span><span class="bound">t</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span><span class="main">)</span>
         <span class="keyword1">in</span> smap<span class="main">⋅</span>cfst <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="main">(</span><span class="bound">okf</span> <span class="keyword1">oo</span> csnd<span class="main">)</span> <span class="keyword1">oo</span> sscanl<span class="main">⋅</span><span class="bound">stepf</span><span class="main">⋅</span><span class="main">(</span><span class="main">0</span><span class="main">,</span> <span class="bound">rootf</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="KMP-matchesf_ok8"><span class="command">lemma</span></span> matchesf_ok8<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>Node<span class="main">⋅</span>vs<span class="main">⋅</span>l<span class="main">⋅</span>r<span class="main">)</span><span class="main">.</span> snull<span class="main">⋅</span><span class="bound">vs</span><span class="main">)</span> <span class="main">=</span> ok8"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff<span class="main"><span class="keyword3">;</span></span> <span class="operator">rename_tac</span> x<span class="main"><span class="keyword3">;</span></span> <span class="operator">case_tac</span> <span class="quoted"><span class="improper">x</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">clarsimp</span><span class="main">)</span>

<span class="keyword1" id="KMP-matchesf_next'"><span class="command">lemma</span></span> matchesf_next'<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Λ</span> x t<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">t</span> <span class="keyword1">of</span> Null <span class="main">⇒</span> Null <span class="main">|</span> Node<span class="main">⋅</span><span class="bound">vs</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">r</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">vs</span> <span class="keyword1">of</span> <span class="main">[::]</span> <span class="main">⇒</span> <span class="bound">t</span> <span class="main">|</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⇒</span> <span class="keyword1">If</span> eq<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">v</span> <span class="keyword1">then</span> <span class="bound">l</span> <span class="keyword1">else</span> <span class="bound">t</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> next'"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff next'.unfold
                      match_snil_match_scons_slist_case slist_case_distr
                      match_Node_mplus_match_Node match_Null_match_Node_tree_case tree_case_distr<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> tree_case_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> slist_case_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="KMP-matchesf_8"><span class="command">lemma</span></span> matchesf_8<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fix<span class="main">⋅</span><span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>Rootf<span class="main">,</span> Opf<span class="main">,</span> Grepf<span class="main">)</span><span class="main">.</span>
          <span class="main">(</span> <span class="bound">Grepf</span><span class="main">⋅</span>Null<span class="main">⋅</span><span class="free">pat</span>
          <span class="main">,</span> <span class="keyword1">Λ</span> t x<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">t</span> <span class="keyword1">of</span> Null <span class="main">⇒</span> <span class="bound">Rootf</span> <span class="main">|</span> Node<span class="main">⋅</span><span class="bound">vs</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">r</span> <span class="main">⇒</span>
                <span class="main">(</span><span class="keyword1">case</span> <span class="bound">vs</span> <span class="keyword1">of</span> <span class="main">[::]</span> <span class="main">⇒</span> <span class="bound">Opf</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">x</span> <span class="main">|</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⇒</span> <span class="keyword1">If</span> eq<span class="main">⋅</span><span class="bound">x</span><span class="main">⋅</span><span class="bound">v</span> <span class="keyword1">then</span> <span class="bound">r</span> <span class="keyword1">else</span> <span class="bound">Opf</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">x</span><span class="main">)</span>
          <span class="main">,</span> <span class="keyword1">Λ</span> l vs<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">vs</span> <span class="keyword1">of</span> <span class="main">[::]</span> <span class="main">⇒</span> Node<span class="main">⋅</span><span class="main">[::]</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span>Null <span class="main">|</span> <span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span> <span class="main">⇒</span> Node<span class="main">⋅</span><span class="main">(</span><span class="bound">v</span> <span class="main">:#</span> <span class="bound">vs</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>next'<span class="main">⋅</span><span class="bound">v</span><span class="main">⋅</span><span class="bound">l</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span><span class="bound">Grepf</span><span class="main">⋅</span><span class="main">(</span><span class="bound">Opf</span><span class="main">⋅</span><span class="bound">l</span><span class="main">⋅</span><span class="bound">v</span><span class="main">)</span><span class="main">⋅</span><span class="bound">vs</span><span class="main">)</span><span class="main">)</span> <span class="main">)</span>
<span class="main">=</span> <span class="main">(</span><span class="keyword1">Λ</span> <span class="main">(</span>root<span class="main">,</span> op<span class="main">,</span> grep<span class="main">)</span><span class="main">.</span> <span class="main">(</span><span class="bound">root</span><span class="main">⋅</span><span class="free">pat</span><span class="main">,</span> <span class="bound">op</span><span class="main">⋅</span><span class="free">pat</span><span class="main">,</span> <span class="bound">grep</span><span class="main">⋅</span><span class="free">pat</span><span class="main">)</span><span class="main">)</span><span class="main">⋅</span><span class="main">(</span>root8<span class="main">,</span> op8<span class="main">,</span> grep8<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> root8_op8_grep8_def
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> lfp_fusion<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="main">(</span><span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff
                    match_snil_match_scons_slist_case slist_case_distr
                    match_Node_mplus_match_Node match_Null_match_Node_tree_case tree_case_distr<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">theorem</span></span> matches_final<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"matches <span class="main">=</span> matchesf"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> cfun_eq_iff fix_const eta_cfun csplit_cfun3 CLetrec_def
                   matches8 matchesf.unfold matchesf_next' matchesf_ok8 matchesf_8<span class="main"><span class="main">[</span></span><span class="operator">simplified</span> eta_cfun<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹

The final program above is easily syntactically translated into the
Haskell shown in Figure~\ref{fig:haskell-kmp}, and one can expect
GHC's list fusion machinery to compile the top-level driver into an
efficient loop.  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] "LochbihlerMaximova:2015"<span class="antiquote"><span class="antiquote">}</span></span></span></span>
have mechanised this optimisation for Isabelle/HOL's code generator
(and see also <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> [cite_macro=citet] "Huffman:2009"<span class="antiquote"><span class="antiquote">}</span></span></span></span>).

As we lack both pieces of infrastructure we show such a fusion is sound
by hand.

›</span></span>

<span class="keyword1" id="KMP-fused_driver'"><span class="command">lemma</span></span> fused_driver'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">g</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span><span class="main">⋅</span><span class="main">⊥</span> <span class="main">=</span> <span class="main">⊥</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"smap<span class="main">⋅</span><span class="free">g</span> <span class="keyword1">oo</span> sfilter<span class="main">⋅</span><span class="free">p</span> <span class="keyword1">oo</span> sscanl<span class="main">⋅</span><span class="free">f</span><span class="main">⋅</span><span class="free">z</span>
       <span class="main">=</span> <span class="main">(</span><span class="keyword1">μ</span> <span class="bound">R</span><span class="main">.</span> <span class="keyword1">Λ</span> z xxs<span class="main">.</span> <span class="keyword1">case</span> <span class="bound">xxs</span> <span class="keyword1">of</span>
                          <span class="main">[::]</span> <span class="main">⇒</span> <span class="keyword1">If</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">z</span> <span class="keyword1">then</span> <span class="main">[:</span><span class="free">g</span><span class="main">⋅</span><span class="bound">z</span><span class="main">:]</span> <span class="keyword1">else</span> <span class="main">[::]</span>
                        <span class="main">|</span> <span class="bound">x</span> <span class="main">:#</span> <span class="bound">xs</span> <span class="main">⇒</span> <span class="keyword1">let</span> <span class="bound">z'</span> <span class="main">=</span> <span class="free">f</span><span class="main">⋅</span><span class="bound">z</span><span class="main">⋅</span><span class="bound">x</span> <span class="keyword1">in</span> <span class="keyword1">If</span> <span class="free">p</span><span class="main">⋅</span><span class="bound">z</span> <span class="keyword1">then</span> <span class="free">g</span><span class="main">⋅</span><span class="bound">z</span> <span class="main">:#</span> <span class="bound">R</span><span class="main">⋅</span><span class="bound">z'</span><span class="main">⋅</span><span class="bound">xs</span> <span class="keyword1">else</span> <span class="bound">R</span><span class="main">⋅</span><span class="bound">z'</span><span class="main">⋅</span><span class="bound">xs</span><span class="main">)</span><span class="main">⋅</span><span class="free">z</span>"</span></span>
<span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> cfun_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">xs</span> <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span><span class="main">⋅</span><span class="skolem">xs</span> <span class="main">=</span> <span class="var">?rhs</span><span class="main">⋅</span><span class="skolem">xs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">xs</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">z</span></span><span class="main">)</span> <span class="main">(</span><span class="operator">subst</span> fix_eq<span class="main"><span class="keyword3">;</span></span> <span class="operator">fastforce</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> If_distr Let_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="comment1">(*&lt;*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span>
</pre>
</div>