<div id="Monomorphic_Monad">
<div class="head">
<h1>Theory Monomorphic_Monad</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      Monomorphic_Monad.thy
    Author:     Andreas Lochbihler, ETH Zurich *)</span>

<span class="keyword1"><span class="command">theory</span></span> Monomorphic_Monad <span class="keyword2"><span class="keyword">imports</span></span>
  <span class="quoted">"<a href="../../HOL/HOL-Probability/Probability.html">HOL-Probability.Probability</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Multiset.html">HOL-Library.Multiset</a>"</span>
  <span class="quoted">"<a href="../../HOL/HOL-Library/Countable_Set_Type.html">HOL-Library.Countable_Set_Type</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Preliminaries›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> comp_fun_idem<span class="main">)</span> fold_set_union<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> Finite_Set.fold <span class="free">f</span> <span class="free">x</span> <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> Finite_Set.fold <span class="free">f</span> <span class="main">(</span>Finite_Set.fold <span class="free">f</span> <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> finite_induct<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fold_insert_idem2 <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> fold_insert_idem<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> comp_fun_idem<span class="main">)</span> ffold_set_union<span class="main">:</span> <span class="quoted"><span class="quoted">"ffold <span class="free">f</span> <span class="free">x</span> <span class="main">(</span><span class="free">A</span> <span class="main">|∪|</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> ffold <span class="free">f</span> <span class="main">(</span>ffold <span class="free">f</span> <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">including</span></span> fset.lifting <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer</span> <span class="quasi_keyword">fixing</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">f</span></span><span class="main">)</span><span class="main">(</span><span class="operator">rule</span> fold_set_union<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-relcompp_top_top"><span class="command">lemma</span></span> relcompp_top_top <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"top <span class="keyword1">OO</span> top <span class="main">=</span> top"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>

<span class="keyword1"><span class="command">attribute_setup</span></span> locale_witness <span class="main">=</span> <span class="quoted">‹Scan.succeed <span class="entity">Locale.witness_add</span>›</span>

<span class="keyword1"><span class="command">named_theorems</span></span> monad_unfold <span class="quoted">"Defining equations for overloaded monad operations"</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">rel_itself</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itself <span class="main">⇒</span> <span class="tfree">'b</span> itself <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rel_itself</span> <span class="keyword1">TYPE</span><span class="main">(</span><span class="main">_</span><span class="main">)</span> <span class="keyword1">TYPE</span><span class="main">(</span><span class="main">_</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-type_parametric"><span class="command">lemma</span></span> type_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_itself <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'b</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_itself.simps<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-plus_multiset_parametric"><span class="command">lemma</span></span> plus_multiset_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_mset <span class="free">A</span> <span class="main">===&gt;</span> rel_mset <span class="free">A</span> <span class="main">===&gt;</span> rel_mset <span class="free">A</span><span class="main">)</span> <span class="main">(+)</span> <span class="main">(+)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> prems <span class="keyword1"><span class="command">using</span></span> prems <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_mset_Plus<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-Mempty_parametric"><span class="command">lemma</span></span> Mempty_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_mset <span class="free">A</span> <span class="main">{#}</span> <span class="main">{#}</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> rel_mset_Zero<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-fold_mset_parametric"><span class="command">lemma</span></span> fold_mset_parametric<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 12<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="free">f1</span> <span class="free">f2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"comp_fun_commute <span class="free">f1</span>"</span></span> <span class="quoted"><span class="quoted">"comp_fun_commute <span class="free">f2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> rel_mset <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">(</span>fold_mset <span class="free">f1</span><span class="main">)</span> <span class="main">(</span>fold_mset <span class="free">f2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> f1<span class="main">:</span> comp_fun_commute <span class="quoted"><span class="free">f1</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> f2<span class="main">:</span> comp_fun_commute <span class="quoted"><span class="free">f2</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">(</span>fold_mset <span class="free">f1</span> <span class="skolem">z1</span> <span class="skolem">X</span><span class="main">)</span> <span class="main">(</span>fold_mset <span class="free">f2</span> <span class="skolem">z2</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"rel_mset <span class="free">A</span> <span class="skolem">X</span> <span class="skolem">Y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="skolem">z1</span> <span class="skolem">z2</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">z1</span> <span class="skolem">z2</span> <span class="skolem">X</span> <span class="skolem">Y</span>
    <span class="keyword1"><span class="command">using</span></span> that<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="skolem">R</span><span class="main"><span class="main">≡</span></span><span class="quoted"><span class="free">A</span></span> <span class="quoted"><span class="skolem">X</span></span> <span class="quoted"><span class="skolem">Y</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> 12<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_fset_induct"><span class="command">lemma</span></span> rel_fset_induct <span class="main">[</span><span class="operator">consumes</span> 1<span class="main">,</span> <span class="operator">case_names</span> empty step<span class="main">,</span> <span class="operator">induct</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">pred</span></span></span><span class="main"><span class="main"><span class="main"><span class="main">:</span></span></span></span> rel_fset<span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> XY<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_fset <span class="free">A</span> <span class="free">X</span> <span class="free">Y</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="main">{||}</span> <span class="main">{||}</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> step<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">X</span> <span class="bound">Y</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">.</span> <span class="main">⟦</span> rel_fset <span class="free">A</span> <span class="bound">X</span> <span class="bound">Y</span><span class="main">;</span> <span class="free">P</span> <span class="bound">X</span> <span class="bound">Y</span><span class="main">;</span> <span class="free">A</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">;</span> <span class="bound">x</span> <span class="main">|∉|</span> <span class="bound">X</span> <span class="main">∨</span> <span class="bound">y</span> <span class="main">|∉|</span> <span class="bound">Y</span> <span class="main">⟧</span> <span class="main">⟹</span> <span class="free">P</span> <span class="main">(</span>finsert <span class="bound">x</span> <span class="bound">X</span><span class="main">)</span> <span class="main">(</span>finsert <span class="bound">y</span> <span class="bound">Y</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">P</span> <span class="free">X</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> XY <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Z</span></span> <span class="keyword2"><span class="keyword">where</span></span> X<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">=</span> fst <span class="main">|`|</span> <span class="skolem">Z</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Y<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">=</span> snd <span class="main">|`|</span> <span class="skolem">Z</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> Z<span class="main">:</span> <span class="quoted"><span class="quoted">"fBall <span class="skolem">Z</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span><span class="main">.</span> <span class="free">A</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> fset.in_rel <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fBall.rep_eq<span class="main">)</span>
  <span class="keyword1"><span class="command">from</span></span> Z <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">unfolding</span></span> X Y
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">Z</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>insert <span class="skolem">xy</span> <span class="skolem">Z</span><span class="main">)</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">x</span></span> <span class="skolem"><span class="skolem">y</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">xy</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">x</span><span class="main">,</span> <span class="skolem">y</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">xy</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> insert
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">|∈|</span> fst <span class="main">|`|</span> <span class="skolem">Z</span> <span class="main">∧</span> <span class="skolem">y</span> <span class="main">|∈|</span> snd <span class="main">|`|</span> <span class="skolem">Z</span>"</span></span><span class="main">)</span>
       <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> finsert_absorb<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> step <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fset.in_rel fBall.rep_eq<span class="main"><span class="keyword3">;</span></span> <span class="operator">blast</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assms<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-ffold_parametric"><span class="command">lemma</span></span> ffold_parametric<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 12<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="free">f1</span> <span class="free">f2</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"comp_fun_idem <span class="free">f1</span>"</span></span> <span class="quoted"><span class="quoted">"comp_fun_idem <span class="free">f2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">B</span> <span class="main">===&gt;</span> rel_fset <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">B</span><span class="main">)</span> <span class="main">(</span>ffold <span class="free">f1</span><span class="main">)</span> <span class="main">(</span>ffold <span class="free">f2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> f1<span class="main">:</span> comp_fun_idem <span class="quoted"><span class="free">f1</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> f2<span class="main">:</span> comp_fun_idem <span class="quoted"><span class="free">f2</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="main">(</span>ffold <span class="free">f1</span> <span class="skolem">z1</span> <span class="skolem">X</span><span class="main">)</span> <span class="main">(</span>ffold <span class="free">f2</span> <span class="skolem">z2</span> <span class="skolem">Y</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"rel_fset <span class="free">A</span> <span class="skolem">X</span> <span class="skolem">Y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">B</span> <span class="skolem">z1</span> <span class="skolem">z2</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">z1</span> <span class="skolem">z2</span> <span class="skolem">X</span> <span class="skolem">Y</span>
    <span class="keyword1"><span class="command">using</span></span> that<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> that<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> 12<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_set_Grp"><span class="command">lemma</span></span> rel_set_Grp<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_set <span class="main">(</span>BNF_Def.Grp <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> BNF_Def.Grp <span class="main">{</span><span class="bound">X</span><span class="main">.</span> <span class="bound">X</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">}</span> <span class="main">(</span>image <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff Grp_def rel_set_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> cset.lifting <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-cUNION_assoc"><span class="command">lemma</span></span> cUNION_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"cUNION <span class="main">(</span>cUNION <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="free">g</span> <span class="main">=</span> cUNION <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> cUNION <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">g</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">auto</span>

<span class="keyword1" id="Monomorphic_Monad-cUnion_cempty"><span class="command">lemma</span></span> cUnion_cempty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cUnion cempty <span class="main">=</span> cempty"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Monomorphic_Monad-cUNION_cempty"><span class="command">lemma</span></span> cUNION_cempty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cUNION cempty <span class="free">f</span> <span class="main">=</span> cempty"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Monomorphic_Monad-cUnion_cinsert"><span class="command">lemma</span></span> cUnion_cinsert<span class="main">:</span> <span class="quoted"><span class="quoted">"cUnion <span class="main">(</span>cinsert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> cUn <span class="free">x</span> <span class="main">(</span>cUnion <span class="free">A</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span> <span class="operator">simp</span>

<span class="keyword1" id="Monomorphic_Monad-cUNION_cinsert"><span class="command">lemma</span></span> cUNION_cinsert<span class="main">:</span> <span class="quoted"><span class="quoted">"cUNION <span class="main">(</span>cinsert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> cUn <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span>cUNION <span class="free">A</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cUnion_cinsert<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cUnion_csingle"><span class="command">lemma</span></span> cUnion_csingle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cUnion <span class="main">(</span>csingle <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cUnion_cinsert<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cUNION_csingle"><span class="command">lemma</span></span> cUNION_csingle <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cUNION <span class="main">(</span>csingle <span class="free">x</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">f</span> <span class="free">x</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Monomorphic_Monad-cUNION_csingle2"><span class="command">lemma</span></span> cUNION_csingle2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cUNION <span class="free">A</span> csingle <span class="main">=</span> <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">fact</span> cUN_csingleton<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cUNION_cUn"><span class="command">lemma</span></span> cUNION_cUn<span class="main">:</span> <span class="quoted"><span class="quoted">"cUNION <span class="main">(</span>cUn <span class="free">A</span> <span class="free">B</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> cUn <span class="main">(</span>cUNION <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span>cUNION <span class="free">B</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Monomorphic_Monad-cUNION_parametric"><span class="command">lemma</span></span> cUNION_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_cset <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_cset <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> rel_cset <span class="free">B</span><span class="main">)</span> cUNION cUNION"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> rel_fun_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_set_UNION<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> three <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">tytok</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itself"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ex_three<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">x</span> <span class="bound">y</span> <span class="bound">z</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≠</span> <span class="bound">z</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">threes</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'a</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">threes</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">SOME</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">,</span> <span class="bound">z</span><span class="main">)</span><span class="main">.</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">y</span> <span class="main">∧</span> <span class="bound">x</span> <span class="main">≠</span> <span class="bound">z</span> <span class="main">∧</span> <span class="bound">y</span> <span class="main">≠</span> <span class="bound">z</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">three<span class="hidden">⇩</span><sub>1</sub></span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>1</b></span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free"><span class="hidden">❙</span><b>1</b></span></span> <span class="main">=</span> fst threes"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">three<span class="hidden">⇩</span><sub>2</sub></span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>2</b></span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free"><span class="hidden">❙</span><b>2</b></span></span> <span class="main">=</span> fst <span class="main">(</span>snd threes<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">three<span class="hidden">⇩</span><sub>3</sub></span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span> <span class="main">(</span><span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>3</b></span>"</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="free"><span class="hidden">❙</span><b>3</b></span></span> <span class="main">=</span> snd <span class="main">(</span>snd <span class="main">(</span>threes<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-three_neq_aux"><span class="command">lemma</span></span> three_neq_aux<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>2</b></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>3</b></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>3</b></span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="main">∧</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>3</b></span> <span class="main">∧</span> <span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>3</b></span>"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> three<span class="hidden">⇩</span><sub>1</sub>_def three<span class="hidden">⇩</span><sub>2</sub>_def three<span class="hidden">⇩</span><sub>3</sub>_def threes_def split_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> someI_ex<span class="main">)</span><span class="main">(</span><span class="operator">use</span> ex_three <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="operator">auto</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>2</b></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>3</b></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>3</b></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> three_neq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">=</span> three_neq_aux three_neq_aux<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">rel_12_23</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rel_12_23</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main"><span class="hidden">❙</span><b>2</b></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">rel_12_23</span> <span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="main"><span class="hidden">❙</span><b>3</b></span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-bi_unique_rel_12_23"><span class="command">lemma</span></span> bi_unique_rel_12_23 <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique rel_12_23"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bi_unique_def rel_12_23.simps<span class="main">)</span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">rel_12_21</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">rel_12_21</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main"><span class="hidden">❙</span><b>2</b></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">rel_12_21</span> <span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="main"><span class="hidden">❙</span><b>1</b></span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-bi_unique_rel_12_21"><span class="command">lemma</span></span> bi_unique_rel_12_21 <span class="main">[</span><span class="operator">simp</span><span class="main">,</span> <span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique rel_12_21"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bi_unique_def rel_12_21.simps<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monomorphic_Monad-bernoulli_pmf_0"><span class="command">lemma</span></span> bernoulli_pmf_0<span class="main">:</span> <span class="quoted"><span class="quoted">"bernoulli_pmf <span class="main">0</span> <span class="main">=</span> return_pmf False"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pmf_eqI<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-bernoulli_pmf_1"><span class="command">lemma</span></span> bernoulli_pmf_1<span class="main">:</span> <span class="quoted"><span class="quoted">"bernoulli_pmf <span class="main">1</span> <span class="main">=</span> return_pmf True"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pmf_eqI<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> split_indicator<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-bernoulli_Not"><span class="command">lemma</span></span> bernoulli_Not<span class="main">:</span> <span class="quoted"><span class="quoted">"map_pmf Not <span class="main">(</span>bernoulli_pmf <span class="free">r</span><span class="main">)</span> <span class="main">=</span> bernoulli_pmf <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="free">r</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> pmf_eqI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted">"pmf <span class="main"><span class="main">_</span></span> <span class="main"><span class="main">⌑</span></span> <span class="main"><span class="main">=</span></span> <span class="main"><span class="main">_</span></span>"</span></span></span> not_not<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> pmf_map_inj'<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def bernoulli_pmf.rep_eq min_def max_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-pmf_eqI_avoid"><span class="command">lemma</span></span> pmf_eqI_avoid<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="free">q</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">i</span><span class="main">.</span> <span class="bound">i</span> <span class="main">≠</span> <span class="free">x</span> <span class="main">⟹</span> pmf <span class="free">p</span> <span class="bound">i</span> <span class="main">=</span> pmf <span class="free">q</span> <span class="bound">i</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> pmf_eqI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pmf <span class="free">p</span> <span class="skolem">i</span> <span class="main">=</span> pmf <span class="free">q</span> <span class="skolem">i</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">i</span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> <span class="free">x</span>"</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> True
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf <span class="free">p</span> <span class="skolem">i</span> <span class="main">=</span> measure_pmf.prob <span class="free">p</span> <span class="main">{</span><span class="skolem">i</span><span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_pmf_single<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">1</span> <span class="main">-</span> measure_pmf.prob <span class="free">p</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="main">{</span><span class="skolem">i</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> measure_pmf.prob_compl<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> space_measure_pmf<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"measure_pmf.prob <span class="free">p</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="main">{</span><span class="skolem">i</span><span class="main">}</span><span class="main">)</span> <span class="main">=</span> measure_pmf.prob <span class="free">q</span> <span class="main">(</span>UNIV <span class="main">-</span> <span class="main">{</span><span class="skolem">i</span><span class="main">}</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">unfolding</span></span> integral_pmf<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Bochner_Integration.integral_cong<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> that<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">-</span> <span class="main">…</span> <span class="main">=</span> measure_pmf.prob <span class="free">q</span> <span class="main">{</span><span class="skolem">i</span><span class="main">}</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> measure_pmf.prob_compl<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> space_measure_pmf<span class="main"><span class="main">]</span></span><span class="main">)</span> <span class="operator">simp_all</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> pmf <span class="free">q</span> <span class="skolem">i</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_pmf_single<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> False
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> that<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Locales for monomorphic monads›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Plain monad›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_base <span class="main">=</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">sequence</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> list <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sequence</span> <span class="main">[]</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">[]</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">sequence</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free">bind</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">sequence</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">∘</span> <span class="main">(#)</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lift</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lift</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">bind</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span>
  monad_base.sequence.simps <span class="main">[</span><span class="operator">code</span><span class="main">]</span>
  monad_base.lift_def <span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-sequence_parametric"><span class="command">lemma</span></span> sequence_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> list_all2 <span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span>list_all2 <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> monad_base.sequence monad_base.sequence"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> monad_base.sequence_def<span class="main">[</span><span class="operator">abs_def</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-lift_parametric"><span class="command">lemma</span></span> lift_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> monad_base.lift monad_base.lift"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> monad_base.lift_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bind_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="main">(</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'m</span><span class="main">)</span> <span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">bind</span> <span class="bound">x</span> <span class="bound">f</span><span class="main">)</span> <span class="bound">g</span> <span class="main">=</span> <span class="free">bind</span> <span class="bound">x</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">y</span><span class="main">)</span> <span class="bound">g</span><span class="main">)</span>"</span></span> 
  <span class="keyword2"><span class="keyword">and</span></span> return_bind<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">return</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="bound">f</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bind_return<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">x</span> <span class="free">return</span> <span class="main">=</span> <span class="bound">x</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-bind_lift"><span class="command">lemma</span></span> bind_lift <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>lift <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="free">g</span> <span class="main">=</span> <span class="free">bind</span> <span class="free">x</span> <span class="main">(</span><span class="free">g</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lift_def bind_assoc return_bind o_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-lift_bind"><span class="command">lemma</span></span> lift_bind <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"lift <span class="free">f</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> lift <span class="free">f</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lift_def bind_assoc<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹State›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_state_base <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">update</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">update</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">put</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span> monad_state_base.update_def <span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1" id="Monomorphic_Monad-update_parametric"><span class="command">lemma</span></span> update_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span>  
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">S</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span>
   monad_state_base.update monad_state_base.update"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> monad_state_base.update_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">locale</span></span> monad_state <span class="main">=</span> monad_state_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="main">+</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> put_get<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">get</span> <span class="bound">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="bound">f</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> get_get<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">s</span> <span class="bound">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> put_put<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">put</span> <span class="free">s'</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s'</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> get_put<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">put</span> <span class="bound">s</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> get_const<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">m</span><span class="main">)</span> <span class="main">=</span> <span class="bound">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bind_get<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">get</span> <span class="bound">f</span><span class="main">)</span> <span class="bound">g</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">s</span><span class="main">)</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bind_put<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">put</span> <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="bound">f</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-put_update"><span class="command">lemma</span></span> put_update<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">put</span> <span class="free">s</span> <span class="main">(</span>update <span class="free">f</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">put</span> <span class="main">(</span><span class="free">f</span> <span class="free">s</span><span class="main">)</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def put_get put_put<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-update_put"><span class="command">lemma</span></span> update_put<span class="main">:</span> <span class="quoted"><span class="quoted">"update <span class="free">f</span> <span class="main">(</span><span class="free">put</span> <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def put_put get_const<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-bind_update"><span class="command">lemma</span></span> bind_update<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>update <span class="free">f</span> <span class="free">m</span><span class="main">)</span> <span class="free">g</span> <span class="main">=</span> update <span class="free">f</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def bind_get bind_put<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-update_get"><span class="command">lemma</span></span> update_get<span class="main">:</span> <span class="quoted"><span class="quoted">"update <span class="free">f</span> <span class="main">(</span><span class="free">get</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span>update <span class="free">f</span> <span class="main">∘</span> <span class="free">g</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def put_get get_get o_def<span class="main">)</span> 
 
<span class="keyword1" id="Monomorphic_Monad-update_const"><span class="command">lemma</span></span> update_const<span class="main">:</span> <span class="quoted"><span class="quoted">"update <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">s</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def get_const<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-update_update"><span class="command">lemma</span></span> update_update<span class="main">:</span> <span class="quoted"><span class="quoted">"update <span class="free">f</span> <span class="main">(</span>update <span class="free">g</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> update <span class="main">(</span><span class="free">g</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def put_get put_put<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-update_id"><span class="command">lemma</span></span> update_id<span class="main">:</span> <span class="quoted"><span class="quoted">"update id <span class="free">m</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def get_put<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Failure›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'m</span> fail <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_fail_base <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">assert</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">assert</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> <span class="free">bind</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">P</span></span></span> <span class="bound">x</span> <span class="keyword1">then</span> <span class="free">return</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="free">fail</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span> monad_fail_base.assert_def <span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1" id="Monomorphic_Monad-assert_parametric"><span class="command">lemma</span></span> assert_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span>
   monad_fail_base.assert monad_fail_base.assert"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> monad_fail_base.assert_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">locale</span></span> monad_fail <span class="main">=</span> monad_fail_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="main">+</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> fail_bind<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">bind</span> <span class="free">fail</span> <span class="bound">f</span> <span class="main">=</span> <span class="free">fail</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-assert_fail"><span class="command">lemma</span></span> assert_fail<span class="main">:</span> <span class="quoted"><span class="quoted">"assert <span class="free">P</span> <span class="free">fail</span> <span class="main">=</span> <span class="free">fail</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assert_def fail_bind<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Exception›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'m</span> catch <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_catch_base <span class="main">=</span> monad_fail_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">catch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> catch"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_catch <span class="main">=</span> monad_catch_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">catch</span></span> <span class="main">+</span> monad_fail <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">catch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> catch"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> catch_return<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">catch</span> <span class="main">(</span><span class="free">return</span> <span class="free">x</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="free">return</span> <span class="free">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> catch_fail<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">catch</span> <span class="free">fail</span> <span class="free">m</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> catch_fail2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">catch</span> <span class="free">m</span> <span class="free">fail</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> catch_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">catch</span> <span class="main">(</span><span class="free">catch</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="free">m''</span> <span class="main">=</span> <span class="free">catch</span> <span class="free">m</span> <span class="main">(</span><span class="free">catch</span> <span class="free">m'</span> <span class="free">m''</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_catch_state <span class="main">=</span> monad_catch <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">catch</span></span> <span class="main">+</span> monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">catch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> catch"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> catch_get<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">catch</span> <span class="main">(</span><span class="free">get</span> <span class="free">f</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">catch</span> <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="free">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> catch_put<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">catch</span> <span class="main">(</span><span class="free">put</span> <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="free">m'</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">catch</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-catch_update"><span class="command">lemma</span></span> catch_update<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">catch</span> <span class="main">(</span>update <span class="free">f</span> <span class="free">m</span><span class="main">)</span> <span class="free">m'</span> <span class="main">=</span> update <span class="free">f</span> <span class="main">(</span><span class="free">catch</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def catch_get catch_put<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Reader›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As ask takes a continuation, we have to restate the monad laws for ask›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_reader_base <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ask</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_reader <span class="main">=</span> monad_reader_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="main">+</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">ask</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ask_ask<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">r</span> <span class="bound">r</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> ask_const<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bind_ask<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">ask</span> <span class="bound">f</span><span class="main">)</span> <span class="bound">g</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">r</span><span class="main">)</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bind_ask2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-ask_bind"><span class="command">lemma</span></span> ask_bind<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">ask</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">g</span> <span class="bound">r</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_ask bind_ask2 ask_ask<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_reader_state <span class="main">=</span>
  monad_reader <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="main">+</span>
  monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">ask</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> ask_get<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">r</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> put_ask<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">ask</span> <span class="bound">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Probability›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'p</span> pmf <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'p</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_prob_base <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_prob <span class="main">=</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="main">+</span> monad_prob_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">sample</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sample_const<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span> <span class="bound">m</span><span class="main">.</span> <span class="free">sample</span> <span class="bound">p</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">m</span><span class="main">)</span> <span class="main">=</span> <span class="bound">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sample_return_pmf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="free">sample</span> <span class="main">(</span>return_pmf <span class="bound">x</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="bound">f</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sample_bind_pmf<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span> <span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">sample</span> <span class="main">(</span>bind_pmf <span class="bound">p</span> <span class="bound">f</span><span class="main">)</span> <span class="bound">g</span> <span class="main">=</span> <span class="free">sample</span> <span class="bound">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">sample</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sample_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span> <span class="bound">q</span> <span class="bound">f</span><span class="main">.</span> <span class="free">sample</span> <span class="bound">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">sample</span> <span class="bound">q</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">sample</span> <span class="bound">q</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">sample</span> <span class="bound">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="comment1">― ‹We'd like to state that we can combine independent samples rather than just commute them, but that's not possible with a monomorphic sampling operation›</span>
  <span class="keyword2"><span class="keyword">and</span></span> bind_sample1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">p</span> <span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">sample</span> <span class="bound">p</span> <span class="bound">f</span><span class="main">)</span> <span class="bound">g</span> <span class="main">=</span> <span class="free">sample</span> <span class="bound">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bind_sample2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">f</span> <span class="bound">p</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">sample</span> <span class="bound">p</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">sample</span> <span class="bound">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> sample_parametric<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">R</span><span class="main">.</span> bi_unique <span class="bound">R</span> <span class="main">⟹</span> rel_fun <span class="main">(</span>rel_pmf <span class="bound">R</span><span class="main">)</span> <span class="main">(</span>rel_fun <span class="main">(</span>rel_fun <span class="bound">R</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(=)</span><span class="main">)</span> <span class="free">sample</span> <span class="free">sample</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-sample_cong"><span class="command">lemma</span></span> sample_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> set_pmf <span class="free">p</span> <span class="main">⟹</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">sample</span> <span class="free">p</span> <span class="free">f</span> <span class="main">=</span> <span class="free">sample</span> <span class="free">q</span> <span class="free">g</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="free">q</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> sample_parametric<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"eq_onp <span class="main"><span class="main"><span class="main">(</span></span></span><span class="main"><span class="main"><span class="main">λ</span></span></span><span class="bound"><span class="bound"><span class="bound">x</span></span></span><span class="main"><span class="main"><span class="main">.</span></span></span> <span class="bound"><span class="bound"><span class="bound">x</span></span></span> <span class="main"><span class="main"><span class="main">∈</span></span></span> set_pmf <span class="free"><span class="free"><span class="free">p</span></span></span><span class="main"><span class="main"><span class="main">)</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bi_unique_def eq_onp_def rel_fun_def pmf.rel_refl_strong that<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can implement binary probabilistic choice using <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">sample</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> provided that the sample space
  contains at least three elements.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_prob3 <span class="main">=</span> monad_prob <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">sample</span></span> <span class="main">+</span> three <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'p</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pchoose</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"real <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pchoose</span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span> <span class="main">=</span> <span class="free">sample</span> <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">else</span> <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span> <span class="main">(</span>bernoulli_pmf <span class="free"><span class="bound"><span class="entity">r</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">pchoose_syntax</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> real <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="main">(</span><span class="quoted">"_ <span class="keyword1">⊲</span> _ <span class="keyword1">⊳</span> _"</span> <span class="main">[</span>100<span class="main">,</span> 0<span class="main">,</span> 100<span class="main">]</span> 99<span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main"><span class="free">⊲</span></span> <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="main"><span class="free">⊳</span></span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span> <span class="main">≡</span> pchoose <span class="free"><span class="bound"><span class="entity">r</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-pchoose_0"><span class="command">lemma</span></span> pchoose_0<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">⊲</span> <span class="main">0</span> <span class="main">⊳</span> <span class="free">m'</span> <span class="main">=</span> <span class="free">m'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pchoose_def bernoulli_pmf_0 sample_return_pmf<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-pchoose_1"><span class="command">lemma</span></span> pchoose_1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">⊲</span> <span class="main">1</span> <span class="main">⊳</span> <span class="free">m'</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pchoose_def bernoulli_pmf_1 sample_return_pmf<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-pchoose_idemp"><span class="command">lemma</span></span> pchoose_idemp<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">⊲</span> <span class="free">r</span> <span class="main">⊳</span> <span class="free">m</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pchoose_def sample_const<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-pchoose_bind1"><span class="command">lemma</span></span> pchoose_bind1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span><span class="free">m</span> <span class="main">⊲</span> <span class="free">r</span> <span class="main">⊳</span> <span class="free">m'</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">bind</span> <span class="free">m</span> <span class="free">f</span> <span class="main">⊲</span> <span class="free">r</span> <span class="main">⊳</span> <span class="free">bind</span> <span class="free">m'</span> <span class="free">f</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pchoose_def bind_sample1 if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">m</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-pchoose_bind2"><span class="command">lemma</span></span> pchoose_bind2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">⊲</span> <span class="free">p</span> <span class="main">⊳</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="free">m</span> <span class="free">f</span> <span class="main">⊲</span> <span class="free">p</span> <span class="main">⊳</span> <span class="free">bind</span> <span class="free">m</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pchoose_def bind_sample2 <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">sample</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-pchoose_commute"><span class="command">lemma</span></span> pchoose_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">⊲</span> <span class="main">1</span> <span class="main">-</span> <span class="free">r</span> <span class="main">⊳</span> <span class="free">m'</span> <span class="main">=</span> <span class="free">m'</span> <span class="main">⊲</span> <span class="free">r</span> <span class="main">⊳</span> <span class="free">m</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pchoose_def bernoulli_Not<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> pmf.map_comp o_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> sample_parametric<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">rel_12_21</span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pmf.map_transfer<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Rb<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">(=)</span></span></span>"</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
            <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def rel_12_21.simps pmf.rel_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def rel_12_21.simps<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-pchoose_assoc"><span class="command">lemma</span></span> pchoose_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">⊲</span> <span class="free">p</span> <span class="main">⊳</span> <span class="main">(</span><span class="free">m'</span> <span class="main">⊲</span> <span class="free">q</span> <span class="main">⊳</span> <span class="free">m''</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">m</span> <span class="main">⊲</span> <span class="free">r</span> <span class="main">⊳</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⊲</span> <span class="free">s</span> <span class="main">⊳</span> <span class="free">m''</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">p</span><span class="main">)</span> <span class="main">=</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">r</span><span class="main">)</span> <span class="main">*</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">s</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">-</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">s</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">then</span> <span class="free">m</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="keyword1">then</span> <span class="free">m'</span> <span class="keyword1">else</span> <span class="free">m''</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?p</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"bind_pmf <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">else</span> <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span> <span class="main">(</span>bernoulli_pmf <span class="free">p</span><span class="main">)</span><span class="main">)</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">then</span> return_pmf <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">else</span> map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="keyword1">else</span> <span class="main"><span class="hidden">❙</span><b>3</b></span><span class="main">)</span> <span class="main">(</span>bernoulli_pmf <span class="free">q</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?q</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"bind_pmf <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">else</span> <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span> <span class="main">(</span>bernoulli_pmf <span class="free">s</span><span class="main">)</span><span class="main">)</span>
     <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">then</span> map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">else</span> <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span> <span class="main">(</span>bernoulli_pmf <span class="free">r</span><span class="main">)</span> <span class="keyword1">else</span> return_pmf <span class="main"><span class="hidden">❙</span><b>3</b></span><span class="main">)</span>"</span></span>

  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="main">¬</span> <span class="bound">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span>False<span class="main">}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">}</span> <span class="main">=</span> <span class="main">{</span>True<span class="main">}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="main">=</span> <span class="free">sample</span> <span class="var">?p</span> <span class="var">?f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pchoose_def sample_bind_pmf if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">sample</span> <span class="bound">x</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> sample_return_pmf rel_fun_def rel_12_23.simps pmf.rel_eq <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sample_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span> sample_parametric<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"rel_12_23"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span> pmf.map_transfer<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> Rb<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">(=)</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?p</span> <span class="main">=</span> <span class="var">?q</span>"</span></span>
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">rule</span> pmf_eqI_avoid<span class="main">)</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">i</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'p</span>"</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>2</b></span>"</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">consider</span></span> <span class="main">(</span>one<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>1</b></span>"</span></span> <span class="main">|</span> <span class="main">(</span>three<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>3</b></span>"</span></span> <span class="main">|</span> <span class="main">(</span>other<span class="main">)</span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>1</b></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>2</b></span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">i</span> <span class="main">≠</span> <span class="main"><span class="hidden">❙</span><b>3</b></span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"pmf <span class="var">?p</span> <span class="skolem">i</span> <span class="main">=</span> pmf <span class="var">?q</span> <span class="skolem">i</span>"</span></span>
    <span class="keyword1"><span class="command">proof</span></span> <span class="operator">cases</span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> one
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf <span class="var">?p</span> <span class="skolem">i</span> <span class="main">=</span> measure_pmf.expectation <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">else</span> <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span> <span class="main">(</span>bernoulli_pmf <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>indicator <span class="main">{</span><span class="main"><span class="hidden">❙</span><b>1</b></span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> pmf_bind
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">measure_pmf.expectation</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff pmf_eq_0_set_pmf<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">p</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> vimage_def<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_pmf_single bernoulli_pmf.rep_eq<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">s</span><span class="main">)</span> <span class="main">*</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> that<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> measure_pmf.expectation <span class="main">(</span>bernoulli_pmf <span class="free">s</span><span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> indicator <span class="main">{</span>True<span class="main">}</span> <span class="bound">x</span> <span class="main">*</span> pmf <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">else</span> <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span> <span class="main">(</span>bernoulli_pmf <span class="free">r</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>1</b></span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_map vimage_def measure_pmf_single<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  bernoulli_pmf.rep_eq<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> pmf <span class="var">?q</span> <span class="skolem">i</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> pmf_bind integral_map_pmf
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">measure_pmf.expectation</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff pmf_eq_0_set_pmf<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> three
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf <span class="var">?p</span> <span class="skolem">i</span> <span class="main">=</span> measure_pmf.expectation <span class="main">(</span>bernoulli_pmf <span class="free">p</span><span class="main">)</span>
            <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> indicator <span class="main">{</span>False<span class="main">}</span> <span class="bound">x</span> <span class="main">*</span> pmf <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="keyword1">else</span> <span class="main"><span class="hidden">❙</span><b>3</b></span><span class="main">)</span> <span class="main">(</span>bernoulli_pmf <span class="free">q</span><span class="main">)</span><span class="main">)</span> <span class="main"><span class="hidden">❙</span><b>3</b></span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> pmf_bind integral_map_pmf
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">measure_pmf.expectation</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff pmf_eq_0_set_pmf<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">p</span><span class="main">)</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">q</span><span class="main">)</span><span class="main">)</span>"</span></span> 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_map vimage_def measure_pmf_single<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span>  bernoulli_pmf.rep_eq<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="main">1</span> <span class="main">-</span> min <span class="main">1</span> <span class="main">(</span>max <span class="main">0</span> <span class="free">s</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> that<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> measure_pmf.expectation <span class="main">(</span>map_pmf <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">b</span> <span class="keyword1">then</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">else</span> <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span> <span class="main">(</span>bernoulli_pmf <span class="free">s</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>indicator <span class="main">{</span><span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">}</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> vimage_def<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> measure_pmf_single bernoulli_pmf.rep_eq<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> pmf <span class="var">?q</span> <span class="skolem">i</span>"</span></span>
        <span class="keyword1"><span class="command">unfolding</span></span> pmf_bind
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> Bochner_Integration.integral_cong_AE<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff pmf_eq_0_set_pmf AE_measure_pmf_iff<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">next</span></span>
      <span class="keyword3"><span class="command">case</span></span> other
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"pmf <span class="var">?p</span> <span class="skolem">i</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="quoted"><span class="quoted">"pmf <span class="var">?q</span> <span class="skolem">i</span> <span class="main">=</span> <span class="main">0</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pmf_eq_0_set_pmf<span class="main">)</span>
      <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sample</span> <span class="var">?q</span> <span class="var">?f</span> <span class="main">=</span> <span class="var">?rhs</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pchoose_def sample_bind_pmf if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">sample</span> <span class="bound">x</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> sample_return_pmf <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sample_cong<span class="main"><span class="main">[</span></span><span class="operator">OF</span> refl<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-pchoose_assoc'"><span class="command">lemma</span></span> pchoose_assoc'<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">⊲</span> <span class="free">p</span> <span class="main">⊳</span> <span class="main">(</span><span class="free">m'</span> <span class="main">⊲</span> <span class="free">q</span> <span class="main">⊳</span> <span class="free">m''</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">m</span> <span class="main">⊲</span> <span class="free">r</span> <span class="main">⊳</span> <span class="free">m'</span><span class="main">)</span> <span class="main">⊲</span> <span class="free">s</span> <span class="main">⊳</span> <span class="free">m''</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">=</span> <span class="free">r</span> <span class="main">*</span> <span class="free">s</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">1</span> <span class="main">-</span> <span class="free">s</span> <span class="main">=</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="free">p</span><span class="main">)</span> <span class="main">*</span> <span class="main">(</span><span class="main">1</span> <span class="main">-</span> <span class="free">q</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">p</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">p</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">q</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">q</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">r</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">r</span> <span class="main">≤</span> <span class="main">1</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">0</span> <span class="main">≤</span> <span class="free">s</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">s</span> <span class="main">≤</span> <span class="main">1</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> pchoose_assoc<span class="main"><span class="keyword3">;</span></span> <span class="operator">use</span> that <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted">‹<span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main">:</span> min_def max_def›</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>    

<span class="keyword1"><span class="command">locale</span></span> monad_state_prob <span class="main">=</span> monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="main">+</span> monad_prob <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">sample</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> sample_get<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sample</span> <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">sample</span> <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-sample_put"><span class="command">lemma</span></span> sample_put<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sample</span> <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">m</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">sample</span> <span class="free">p</span> <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">UU</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">sample</span> <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">m</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">sample</span> <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">return</span> <span class="skolem">UU</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">m</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_put return_bind<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">return</span> <span class="skolem">UU</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">sample</span> <span class="free">p</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_sample2<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">sample</span> <span class="free">p</span> <span class="free">m</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_put return_bind<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-sample_update"><span class="command">lemma</span></span> sample_update<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sample</span> <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> update <span class="free">f</span> <span class="main">(</span><span class="free">m</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> update <span class="free">f</span> <span class="main">(</span><span class="free">sample</span> <span class="free">p</span> <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def sample_get sample_put<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Nondeterministic choice›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Binary choice›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'m</span> alt <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_alt_base <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> alt"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_alt <span class="main">=</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="main">+</span> monad_alt_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">alt</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> alt"</span></span>
  <span class="main">+</span> <span class="comment1">― ‹Laws taken from Gibbons, Hinze: Just do it›</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> alt_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt</span> <span class="main">(</span><span class="free">alt</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="free">m3</span> <span class="main">=</span> <span class="free">alt</span> <span class="free">m1</span> <span class="main">(</span><span class="free">alt</span> <span class="free">m2</span> <span class="free">m3</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bind_alt1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span><span class="free">alt</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">alt</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m'</span> <span class="free">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_fail_alt <span class="main">=</span> monad_fail <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="main">+</span> monad_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">alt</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> alt"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> alt_fail1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt</span> <span class="free">fail</span> <span class="free">m</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> alt_fail2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt</span> <span class="free">m</span> <span class="free">fail</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-assert_alt"><span class="command">lemma</span></span> assert_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"assert <span class="free">P</span> <span class="main">(</span><span class="free">alt</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> <span class="free">alt</span> <span class="main">(</span>assert <span class="free">P</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span>assert <span class="free">P</span> <span class="free">m'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> assert_def bind_alt1<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_state_alt <span class="main">=</span> monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="main">+</span> monad_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">alt</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> alt"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> alt_get<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt</span> <span class="main">(</span><span class="free">get</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">get</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">alt</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> alt_put<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt</span> <span class="main">(</span><span class="free">put</span> <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="free">put</span> <span class="free">s</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">alt</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span>"</span></span>
  <span class="comment1">― ‹Unlike for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">sample</span></span><span class="antiquote">}</span></span>, we must require both <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">alt_get</span><span class="antiquote">}</span></span> and <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">alt_put</span><span class="antiquote">}</span></span> because
  we do not require that <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">bind</span></span><span class="antiquote">}</span></span> right-distributes over <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted"><span class="free">alt</span></span><span class="antiquote">}</span></span>.›</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-alt_update"><span class="command">lemma</span></span> alt_update<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt</span> <span class="main">(</span>update <span class="free">f</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span>update <span class="free">f</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> update <span class="free">f</span> <span class="main">(</span><span class="free">alt</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def alt_get alt_put<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Countable choice›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> cset <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_altc_base <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fail</span> <span class="main">=</span> <span class="free">altc</span> cempty <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> undefined<span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span> monad_altc_base.fail_def <span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">locale</span></span> monad_altc <span class="main">=</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="main">+</span> monad_altc_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bind_altc1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">C</span> <span class="bound">g</span> <span class="bound">f</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">altc</span> <span class="bound">C</span> <span class="bound">g</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="free">altc</span> <span class="bound">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="bound">g</span> <span class="bound">c</span><span class="main">)</span> <span class="bound">f</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> altc_single<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="free">altc</span> <span class="main">(</span>csingle <span class="bound">x</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="bound">f</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> altc_cUNION<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">C</span> <span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">altc</span> <span class="main">(</span>cUNION <span class="bound">C</span> <span class="bound">f</span><span class="main">)</span> <span class="bound">g</span> <span class="main">=</span> <span class="free">altc</span> <span class="bound">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">altc</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="comment1">― ‹We do not assume <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">altc_const</span><span class="antiquote">}</span></span> like for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">sample</span><span class="antiquote">}</span></span> because the choice set might be empty›</span>
  <span class="keyword2"><span class="keyword">and</span></span> altc_parametric<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">R</span><span class="main">.</span> bi_unique <span class="bound">R</span> <span class="main">⟹</span> rel_fun <span class="main">(</span>rel_cset <span class="bound">R</span><span class="main">)</span> <span class="main">(</span>rel_fun <span class="main">(</span>rel_fun <span class="bound">R</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(=)</span><span class="main">)</span> <span class="free">altc</span> <span class="free">altc</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-altc_cong"><span class="command">lemma</span></span> altc_cong<span class="main">:</span> <span class="quoted"><span class="quoted">"cBall <span class="free">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">g</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">altc</span> <span class="free">C</span> <span class="free">f</span> <span class="main">=</span> <span class="free">altc</span> <span class="free">C</span> <span class="free">g</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> altc_parametric<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"eq_onp <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">x</span></span><span class="main"><span class="main">.</span></span> cin <span class="bound"><span class="bound">x</span></span> <span class="free"><span class="free">C</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bi_unique_def eq_onp_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cset.rel_eq_onp eq_onp_same_args pred_cset_def cin_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def eq_onp_def cBall_def cin_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail"><span class="command">lemma</span></span> monad_fail <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_fail <span class="free">return</span> <span class="free">bind</span> fail"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> fail <span class="skolem">f</span> <span class="main">=</span> fail"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_def bind_altc1 <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> altc_cong<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can implement <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>alt›</span></span></span></span> via <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>altc›</span></span></span></span> only if we know that there are sufficiently
  many elements in the choice type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'c</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>. For the associativity law, we need at least
  three elements.›</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_altc3 <span class="main">=</span> monad_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="main">+</span> three <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">alt</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">=</span> <span class="free">altc</span> <span class="main">(</span>cinsert <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main">(</span>csingle <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">c</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="keyword1">else</span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_alt"><span class="command">lemma</span></span> monad_alt<span class="main">:</span> <span class="quoted"><span class="quoted">"monad_alt <span class="free">return</span> <span class="free">bind</span> alt"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>alt <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> alt <span class="main">(</span><span class="free">bind</span> <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="free">bind</span> <span class="skolem">m'</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_def bind_altc1 if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">m</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>

  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m1</span> <span class="skolem">m2</span> <span class="skolem">m3</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'m</span></span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?C</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"cUNION <span class="main">(</span>cinsert <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main">(</span>csingle <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">c</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">then</span> cinsert <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main">(</span>csingle <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span> <span class="keyword1">else</span> csingle <span class="main"><span class="hidden">❙</span><b>3</b></span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?D</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"cUNION <span class="main">(</span>cinsert <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="main">(</span>csingle <span class="main"><span class="hidden">❙</span><b>2</b></span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">c</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">then</span> csingle <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">else</span> cinsert <span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="main">(</span>csingle <span class="main"><span class="hidden">❙</span><b>3</b></span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">let</span></span> <span class="var"><span class="quoted"><span class="var">?f</span></span></span> <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">c</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>1</b></span> <span class="keyword1">then</span> <span class="skolem">m1</span> <span class="keyword1">else</span> <span class="keyword1">if</span> <span class="bound">c</span> <span class="main">=</span> <span class="main"><span class="hidden">❙</span><b>2</b></span> <span class="keyword1">then</span> <span class="skolem">m2</span> <span class="keyword1">else</span> <span class="skolem">m3</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"alt <span class="main">(</span>alt <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span> <span class="skolem">m3</span> <span class="main">=</span> <span class="free">altc</span> <span class="var">?C</span> <span class="var">?f</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> altc_cUNION<span class="main">)</span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_def altc_single <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> altc_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?C</span> <span class="main">=</span> <span class="var">?D</span>"</span></span> <span class="keyword1"><span class="command">including</span></span> cset.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> insert_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">altc</span> <span class="var">?D</span> <span class="var">?f</span> <span class="main">=</span> alt <span class="skolem">m1</span> <span class="main">(</span>alt <span class="skolem">m2</span> <span class="skolem">m3</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> altc_cUNION<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_def altc_single <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> altc_cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> altc_parametric <span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> R<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted"><span class="quoted">"conversep rel_12_23"</span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">including</span></span> cset.lifting <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer</span>
      <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_set_def rel_12_23.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def rel_12_23.simps<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt <span class="main">(</span>alt <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span> <span class="skolem">m3</span> <span class="main">=</span> alt <span class="skolem">m1</span> <span class="main">(</span>alt <span class="skolem">m2</span> <span class="skolem">m3</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_state_altc <span class="main">=</span>
  monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="main">+</span>
  monad_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> altc_get<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">C</span> <span class="bound">f</span><span class="main">.</span> <span class="free">altc</span> <span class="bound">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">altc</span> <span class="bound">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">c</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> altc_put<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">C</span> <span class="bound">f</span><span class="main">.</span> <span class="free">altc</span> <span class="bound">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span><span class="free">altc</span> <span class="bound">C</span> <span class="bound">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Writer monad›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> tell <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'w</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_writer_base <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">tell</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> tell"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_writer <span class="main">=</span> monad_writer_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">tell</span></span> <span class="main">+</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">tell</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> tell"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bind_tell<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">w</span> <span class="bound">m</span> <span class="bound">f</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">tell</span> <span class="bound">w</span> <span class="bound">m</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="free">tell</span> <span class="bound">w</span> <span class="main">(</span><span class="free">bind</span> <span class="bound">m</span> <span class="bound">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Resumption monad›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'o</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'i</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_resumption_base <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pause</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_resumption <span class="main">=</span> monad_resumption_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">pause</span></span> <span class="main">+</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">pause</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bind_pause<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span><span class="free">pause</span> <span class="free">out</span> <span class="free">c</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">pause</span> <span class="free">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">c</span> <span class="bound">i</span><span class="main">)</span> <span class="free">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Commutative monad›</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_commute <span class="main">=</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bind_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="free">m'</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="free">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Discardable monad›</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_discard <span class="main">=</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bind_const<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> <span class="free">m'</span>"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Duplicable monad›</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_duplicate <span class="main">=</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bind_duplicate<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Monad implementations›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Identity monad›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We need a type constructor such that we can overload the monad operations›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="tfree">'a</span> id <span class="main">=</span> return_id <span class="main">(</span><span class="quoted">"<span class="free"><span class="entity">extract</span></span>"</span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> return_id_parametric <span class="main">=</span> id.ctr_transfer

<span class="keyword1" id="Monomorphic_Monad-rel_id_unfold"><span class="command">lemma</span></span> rel_id_unfold<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"rel_id <span class="free">A</span> <span class="main">(</span>return_id <span class="free">x</span><span class="main">)</span> <span class="free">m'</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x'</span><span class="main">.</span> <span class="free">m'</span> <span class="main">=</span> return_id <span class="bound">x'</span> <span class="main">∧</span> <span class="free">A</span> <span class="free">x</span> <span class="bound">x'</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"rel_id <span class="free">A</span> <span class="free">m</span> <span class="main">(</span>return_id <span class="free">x'</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">m</span> <span class="main">=</span> return_id <span class="bound">x</span> <span class="main">∧</span> <span class="free">A</span> <span class="bound">x</span> <span class="free">x'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_id_expand"><span class="command">lemma</span></span> rel_id_expand<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">(</span>extract <span class="free">m</span><span class="main">)</span> <span class="main">(</span>extract <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span> rel_id <span class="free">M</span> <span class="free">m</span> <span class="free">m'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">m'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Plain monad›</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">bind_id</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> id<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_id</span> <span class="main">(</span>return_id <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-extract_bind"><span class="command">lemma</span></span> extract_bind <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"extract <span class="main">(</span>bind_id <span class="free">x</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> extract <span class="main">(</span><span class="free">f</span> <span class="main">(</span>extract <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Monomorphic_Monad-bind_id_parametric"><span class="command">lemma</span></span> bind_id_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_id <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_id <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> rel_id <span class="free">A</span><span class="main">)</span> bind_id bind_id"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_id_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-monad_id"><span class="command">lemma</span></span> monad_id <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return_id bind_id"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_id <span class="main">(</span>bind_id <span class="skolem">x</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> bind_id <span class="skolem">x</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_id <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> id"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> id"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> id"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_id <span class="main">(</span>return_id <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> id"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_id <span class="skolem">x</span> return_id <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> id"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_commute_id"><span class="command">lemma</span></span> monad_commute_id <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_commute return_id bind_id"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_id <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_id <span class="skolem">m'</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_id <span class="skolem">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_id <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> id"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_discard_id"><span class="command">lemma</span></span> monad_discard_id <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_discard return_id bind_id"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_id <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m'</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> id"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_duplicate_id"><span class="command">lemma</span></span> monad_duplicate_id <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_duplicate return_id bind_id"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_id <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_id <span class="skolem">m</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_id <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> id"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Probability monad›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We don't know of a sensible probability monad transformer, so we define the plain probability monad.›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'a</span> prob <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> pmf"</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_prob"><span class="command">lemma</span></span> monad_prob <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return_pmf bind_pmf"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc_pmf bind_return_pmf bind_return_pmf'<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_prob_prob"><span class="command">lemma</span></span> monad_prob_prob <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_prob return_pmf bind_pmf bind_pmf"</span></span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_pmf <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> pmf"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prob"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> bind_pmf_const<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_pmf <span class="main">(</span>return_pmf <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> prob"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> bind_return_pmf<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_pmf <span class="main">(</span>bind_pmf <span class="skolem">p</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> bind_pmf <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_pmf <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> pmf"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> pmf"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> prob"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> bind_assoc_pmf<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_pmf <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_pmf <span class="skolem">q</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_pmf <span class="skolem">q</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_pmf <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> pmf"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> prob"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> bind_commute_pmf<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_pmf <span class="main">(</span>bind_pmf <span class="skolem">p</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> bind_pmf <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_pmf <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> pmf"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> prob"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> prob"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc_pmf<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_pmf <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_pmf <span class="skolem">p</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_pmf <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_pmf <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prob"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> pmf"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> prob"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> bind_commute_pmf<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_pmf <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> bind_pmf bind_pmf"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_commute_prob"><span class="command">lemma</span></span> monad_commute_prob <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_commute return_pmf bind_pmf"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_pmf <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_pmf <span class="skolem">m'</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_pmf <span class="skolem">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_pmf <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> prob"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> prob"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> bind_commute_pmf<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_discard_prob"><span class="command">lemma</span></span> monad_discard_prob <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_discard return_pmf bind_pmf"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_pmf <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m'</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> pmf"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Resumption›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We cannot define a resumption monad transformer because the codatatype recursion would have to
  go through a type variable. If we plug in something like unbounded non-determinism, then the
  HOL type does not exist.
›</span></span>

<span class="keyword1"><span class="command">codatatype</span></span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption <span class="main">=</span> <span class="entity">is_Done</span><span class="main">:</span> Done <span class="main">(</span><span class="free"><span class="entity">result</span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span><span class="main">)</span> <span class="main">|</span> Pause <span class="main">(</span><span class="quoted">"<span class="free"><span class="entity">output</span></span>"</span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'o</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free"><span class="entity">resume</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Plain monad›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_resumption</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">return_resumption</span> <span class="main">=</span> Done"</span></span>

<span class="keyword1"><span class="command">primcorec</span></span> <span class="entity">bind_resumption</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_resumption</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> is_Done <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="keyword1">then</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span>result <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="keyword1">else</span> Pause <span class="main">(</span>output <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">bind_resumption</span> <span class="main">(</span>resume <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pause_resumption</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'o</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'i</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pause_resumption</span> <span class="main">=</span> Pause"</span></span>

<span class="keyword1" id="Monomorphic_Monad-is_Done_return_resumption"><span class="command">lemma</span></span> is_Done_return_resumption <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"is_Done <span class="main">(</span>return_resumption <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_resumption_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-result_return_resumption"><span class="command">lemma</span></span> result_return_resumption <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"result <span class="main">(</span>return_resumption <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_resumption_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_resumption"><span class="command">lemma</span></span> monad_resumption <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return_resumption bind_resumption"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_resumption <span class="main">(</span>bind_resumption <span class="skolem">x</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> bind_resumption <span class="skolem">x</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_resumption <span class="main">(</span><span class="skolem">f</span> <span class="bound">y</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quoted"><span class="skolem">f</span></span> <span class="quoted"><span class="skolem">g</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resumption.coinduct_strong<span class="main">)</span> <span class="operator">auto</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_resumption <span class="main">(</span>return_resumption <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> resumption.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_resumption_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_resumption <span class="skolem">x</span> return_resumption <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">coinduction</span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">x</span></span> <span class="quasi_keyword">rule</span><span class="main"><span class="main">:</span></span> resumption.coinduct_strong<span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_resumption_resumption"><span class="command">lemma</span></span> monad_resumption_resumption <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_resumption return_resumption bind_resumption pause_resumption"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_resumption <span class="main">(</span>pause_resumption <span class="skolem">out</span> <span class="skolem">c</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> pause_resumption <span class="skolem">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> bind_resumption <span class="main">(</span><span class="skolem">c</span> <span class="bound">i</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">out</span> <span class="skolem">c</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">)</span> resumption"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> resumption.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pause_resumption_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Failure and exception monad transformer›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The phantom type variable <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is needed to avoid hidden polymorphism when overloading the
  monad operations for the failure monad transformer.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="quasi_keyword">plugins</span> <span class="quasi_keyword">del</span><span class="main">:</span> transfer<span class="main">)</span> <span class="main">(</span>phantom_optionT<span class="main">:</span> <span class="tfree">'a</span><span class="main">,</span> set_optionT<span class="main">:</span> <span class="tfree">'m</span><span class="main">)</span> optionT <span class="main">=</span>
  OptionT <span class="main">(</span><span class="free"><span class="entity">run_option</span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'m</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">for</span></span> rel<span class="main">:</span> rel_optionT' 
      map<span class="main">:</span> map_optionT'

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define our own relator and mapper such that the phantom variable does not need any relation.
›</span></span>

<span class="keyword1" id="Monomorphic_Monad-phantom_optionT"><span class="command">lemma</span></span> phantom_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"phantom_optionT <span class="free">x</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_optionT'_phantom"><span class="command">lemma</span></span> rel_optionT'_phantom<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_optionT' <span class="free">A</span> <span class="main">=</span> rel_optionT' top"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> optionT.rel_mono antisym optionT.rel_mono_strong<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-map_optionT'_phantom"><span class="command">lemma</span></span> map_optionT'_phantom<span class="main">:</span> <span class="quoted"><span class="quoted">"map_optionT' <span class="free">f</span> <span class="main">=</span> map_optionT' undefined"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> optionT.map_cong<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m'</span><span class="main">)</span> optionT"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">map_optionT</span> <span class="main">=</span> map_optionT' undefined"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rel_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m'</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m'</span><span class="main">)</span> optionT <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rel_optionT</span> <span class="main">=</span> rel_optionT' top"</span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_optionTE"><span class="command">lemma</span></span> rel_optionTE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"rel_optionT <span class="free">M</span> <span class="free">m</span> <span class="free">m'</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">x</span> <span class="free">y</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> OptionT <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m'</span> <span class="main">=</span> OptionT <span class="free">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">m'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_optionT_simps"><span class="command">lemma</span></span> rel_optionT_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_optionT <span class="free">M</span> <span class="main">(</span>OptionT <span class="free">m</span><span class="main">)</span> <span class="main">(</span>OptionT <span class="free">m'</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">M</span> <span class="free">m</span> <span class="free">m'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_optionT_eq"><span class="command">lemma</span></span> rel_optionT_eq <span class="main">[</span><span class="operator">relator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_optionT <span class="main">(=)</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff rel_optionT_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> optionT.rel_refl_strong <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> optionT.rel_cases<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_optionT_mono"><span class="command">lemma</span></span> rel_optionT_mono <span class="main">[</span><span class="operator">relator_mono</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_optionT <span class="free">A</span> <span class="main">≤</span> rel_optionT <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≤</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_optionT_def optionT.rel_mono that<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_optionT_distr"><span class="command">lemma</span></span> rel_optionT_distr <span class="main">[</span><span class="operator">relator_distr</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_optionT <span class="free">A</span> <span class="keyword1">OO</span> rel_optionT <span class="free">B</span> <span class="main">=</span> rel_optionT <span class="main">(</span><span class="free">A</span> <span class="keyword1">OO</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_optionT_def optionT.rel_compp<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_optionT_Grp"><span class="command">lemma</span></span> rel_optionT_Grp<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_optionT <span class="main">(</span>BNF_Def.Grp <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> BNF_Def.Grp <span class="main">{</span><span class="bound">x</span><span class="main">.</span> set_optionT <span class="bound">x</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">}</span> <span class="main">(</span>map_optionT <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_optionT_def rel_optionT'_phantom<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"BNF_Def.Grp UNIV undefined"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> optionT.rel_Grp map_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-OptionT_parametric"><span class="command">lemma</span></span> OptionT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> OptionT OptionT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def rel_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_option_parametric"><span class="command">lemma</span></span> run_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_optionT <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> run_option run_option"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def rel_optionT_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> optionT.rel_cases<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-case_optionT_parametric"><span class="command">lemma</span></span> case_optionT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> case_optionT case_optionT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def rel_optionT_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> optionT.split<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rec_optionT_parametric"><span class="command">lemma</span></span> rec_optionT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> rec_optionT rec_optionT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_optionTE<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Plain monad, failure, and exceptions›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">return_option</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> OptionT <span class="main">(</span><span class="free">return</span> <span class="main">(</span>Some <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">bind_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">bind_option</span> <span class="main">(</span>OptionT <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> 
   OptionT <span class="main">(</span><span class="free">bind</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">return</span> <span class="main">(</span>None <span class="main">::</span> <span class="tfree">'a</span> option<span class="main">)</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> run_option <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fail_option</span> <span class="main">=</span> OptionT <span class="main">(</span><span class="free">return</span> None<span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">catch_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT catch"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">catch_option</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="main">=</span> OptionT <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>run_option <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> None <span class="keyword1">then</span> run_option <span class="free"><span class="bound"><span class="entity">h</span></span></span> <span class="keyword1">else</span> <span class="free">return</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_bind_option"><span class="command">lemma</span></span> run_bind_option<span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>bind_option <span class="free">x</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>run_option <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">return</span> None <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> run_option <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Monomorphic_Monad-run_return_option"><span class="command">lemma</span></span> run_return_option <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>return_option <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_option_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_fail_option"><span class="command">lemma</span></span> run_fail_option <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option fail_option <span class="main">=</span> <span class="free">return</span> None"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_option_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_catch_option"><span class="command">lemma</span></span> run_catch_option <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>catch_option <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>run_option <span class="free">m1</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> None <span class="keyword1">then</span> run_option <span class="free">m2</span> <span class="keyword1">else</span> <span class="free">return</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> catch_option_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> monad<span class="main">:</span> <span class="quoted"><span class="quoted">"monad <span class="free">return</span> <span class="free">bind</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_optionT"><span class="command">lemma</span></span> monad_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return_option bind_option"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"monad <span class="var">?return</span> <span class="var">?bind</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?bind</span> <span class="main">(</span><span class="var">?bind</span> <span class="skolem">x</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> <span class="var">?bind</span> <span class="skolem">x</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="var">?bind</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>  <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc run_bind_option return_bind <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">bind</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?bind</span> <span class="main">(</span><span class="var">?return</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_bind_option return_bind return_option_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?bind</span> <span class="skolem">x</span> <span class="var">?return</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_bind_option option.case_distrib<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> case_option_id bind_return <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_optionT"><span class="command">lemma</span></span> monad_fail_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_fail return_option bind_option fail_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option fail_option <span class="skolem">f</span> <span class="main">=</span> fail_option"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_bind_option return_bind<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_catch_optionT"><span class="command">lemma</span></span> monad_catch_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_catch return_option bind_option fail_option catch_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"catch_option <span class="main">(</span>return_option <span class="skolem">x</span><span class="main">)</span> <span class="skolem">m</span> <span class="main">=</span> return_option <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"catch_option fail_option <span class="skolem">m</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"catch_option <span class="skolem">m</span> fail_option <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_return if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="free">return</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_weak_cong<span class="main">)</span>
   <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"catch_option <span class="main">(</span>catch_option <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span> <span class="skolem">m''</span> <span class="main">=</span> catch_option <span class="skolem">m</span> <span class="main">(</span>catch_option <span class="skolem">m'</span> <span class="skolem">m''</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="skolem">m''</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc fun_eq_iff return_bind <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">bind</span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Reader›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ask</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ask_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> ask"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ask_option</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> OptionT <span class="main">(</span><span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_option <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_ask_option"><span class="command">lemma</span></span> run_ask_option <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>ask_option <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_option <span class="main">(</span><span class="free">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_option_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_reader_optionT"><span class="command">lemma</span></span> monad_reader_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_reader <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_reader return_option bind_option ask_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_reader <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_option <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> ask_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ask_option <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">r</span> <span class="bound">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_ask<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_option <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_const<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="main">(</span>ask_option <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> ask_option <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> bind_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_ask run_bind_option<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ask_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ask_option <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_ask2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> run_bind_option ask_const <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">bind</span></span><span class="main"><span class="main">]</span></span> ext <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹State›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_option</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> OptionT <span class="main">(</span><span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_option <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">put_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">put_option</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>OptionT <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">=</span> OptionT <span class="main">(</span><span class="free">put</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_get_option"><span class="command">lemma</span></span> run_get_option <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>get_option <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_option <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_option_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_put_option"><span class="command">lemma</span></span> run_put_option <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>put_option <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span>run_option <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> state<span class="main">:</span> <span class="quoted"><span class="quoted">"monad_state <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> state<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_optionT"><span class="command">lemma</span></span> monad_state_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state return_option bind_option get_option put_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_option <span class="skolem">s</span> <span class="main">(</span>get_option <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> put_option <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_get<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_option <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> get_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_option <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">s</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_get<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_option <span class="skolem">s</span> <span class="main">(</span>put_option <span class="skolem">s'</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> put_option <span class="skolem">s'</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_put<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_option <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> put_option <span class="bound">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_put<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_option <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_const<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="main">(</span>get_option <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> get_option <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bind_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_get run_bind_option<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="main">(</span>put_option <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> put_option <span class="skolem">s</span> <span class="main">(</span>bind_option <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">m</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_put run_bind_option<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_catch_state_optionT"><span class="command">lemma</span></span> monad_catch_state_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_catch_state return_option bind_option fail_option catch_option get_option put_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"catch_option <span class="main">(</span>get_option <span class="skolem">f</span><span class="main">)</span> <span class="skolem">m</span> <span class="main">=</span> get_option <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> catch_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span> <span class="skolem">m</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_get<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"catch_option <span class="main">(</span>put_option <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">m'</span> <span class="main">=</span> put_option <span class="skolem">s</span> <span class="main">(</span>catch_option <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">m</span> <span class="skolem">m'</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_put<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Probability›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">altc_sample_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'x</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'x</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">altc_sample_option</span> <span class="free"><span class="bound"><span class="entity">altc_sample</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> OptionT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">altc_sample</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_option <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_altc_sample_option"><span class="command">lemma</span></span> run_altc_sample_option <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>altc_sample_option <span class="free">altc_sample</span> <span class="free">p</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">altc_sample</span> <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_option <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_sample_option_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sample_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sample_option</span> <span class="main">≡</span> altc_sample_option <span class="free">sample</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_prob_optionT"><span class="command">lemma</span></span> monad_prob_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_prob <span class="free">return</span> <span class="free">bind</span> <span class="free">sample</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_prob return_option bind_option sample_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_prob <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">sample</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> sample_parametric<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">including</span></span> lifting_syntax
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_option <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_const<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_option <span class="main">(</span>return_pmf <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_return_pmf<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_option <span class="main">(</span>bind_pmf <span class="skolem">p</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> sample_option <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> sample_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_bind_pmf<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_option <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> sample_option <span class="skolem">q</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sample_option <span class="skolem">q</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> sample_option <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">q</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> sample_commute<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="main">(</span>sample_option <span class="skolem">p</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> sample_option <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_sample1 run_bind_option<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> sample_option <span class="skolem">p</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sample_option <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">p</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_sample2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> run_bind_option sample_const <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">bind</span></span><span class="main"><span class="main">]</span></span> ext <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span>  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_pmf <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> sample_option sample_option"</span></span> 
      <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span>
      <span class="keyword1"><span class="command">unfolding</span></span> altc_sample_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_prob_optionT"><span class="command">lemma</span></span> monad_state_prob_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state_prob <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span> <span class="free">sample</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state_prob return_option bind_option get_option put_option sample_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state_prob <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">sample</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_option <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> get_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_option <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> sample_option <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_get<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Writer›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">tell</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tell_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> tell"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tell_option</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> OptionT <span class="main">(</span><span class="free">tell</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span>run_option <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_tell_option"><span class="command">lemma</span></span> run_tell_option <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>tell_option <span class="free">w</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">tell</span> <span class="free">w</span> <span class="main">(</span>run_option <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tell_option_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_writer_optionT"><span class="command">lemma</span></span> monad_writer_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_writer <span class="free">return</span> <span class="free">bind</span> <span class="free">tell</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_writer return_option bind_option tell_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_writer <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">tell</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="main">(</span>tell_option <span class="skolem">w</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> tell_option <span class="skolem">w</span> <span class="main">(</span>bind_option <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">w</span> <span class="skolem">m</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_bind_option bind_tell<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Binary Non-determinism›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> alt"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">alt_option</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">=</span> OptionT <span class="main">(</span><span class="free">alt</span> <span class="main">(</span>run_option <span class="free"><span class="bound"><span class="entity">m1</span></span></span><span class="main">)</span> <span class="main">(</span>run_option <span class="free"><span class="bound"><span class="entity">m2</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_alt_option"><span class="command">lemma</span></span> run_alt_option <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>alt_option <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="main">=</span> <span class="free">alt</span> <span class="main">(</span>run_option <span class="free">m1</span><span class="main">)</span> <span class="main">(</span>run_option <span class="free">m2</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_option_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_alt_optionT"><span class="command">lemma</span></span> monad_alt_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_alt <span class="free">return</span> <span class="free">bind</span> <span class="free">alt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_alt return_option bind_option alt_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">alt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_option <span class="main">(</span>alt_option <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span> <span class="skolem">m3</span> <span class="main">=</span> alt_option <span class="skolem">m1</span> <span class="main">(</span>alt_option <span class="skolem">m2</span> <span class="skolem">m3</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m1</span> <span class="skolem">m2</span> <span class="skolem">m3</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_assoc<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="main">(</span>alt_option <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> alt_option <span class="main">(</span>bind_option <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>bind_option <span class="skolem">m'</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_alt1 run_bind_option<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">fail</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span> optionT"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> does not combine with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">alt</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> of the inner monad
  because <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span> optionT"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> injects failures with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">return</span></span> None"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> into the inner monad.
›</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_alt_optionT"><span class="command">lemma</span></span> monad_state_alt_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state_alt <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span> <span class="free">alt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state_alt return_option bind_option get_option put_option alt_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">alt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_option <span class="main">(</span>get_option <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>get_option <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> get_option <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> alt_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_option <span class="main">(</span>put_option <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span>put_option <span class="skolem">s</span> <span class="skolem">m'</span><span class="main">)</span> <span class="main">=</span> put_option <span class="skolem">s</span> <span class="main">(</span>alt_option <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_put<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Countable Non-determinism›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">altc_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">altc_option</span> <span class="main">≡</span> altc_sample_option <span class="free">altc</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_altc_optionT"><span class="command">lemma</span></span> monad_altc_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_altc <span class="free">return</span> <span class="free">bind</span> <span class="free">altc</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_altc return_option bind_option altc_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">note</span></span> altc_parametric<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">including</span></span> lifting_syntax
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="main">(</span>altc_option <span class="skolem">C</span> <span class="skolem">g</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> altc_option <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> bind_option <span class="main">(</span><span class="skolem">g</span> <span class="bound">c</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">g</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_bind_option bind_altc1 o_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_option <span class="main">(</span>csingle <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_altc1 altc_single<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_option <span class="main">(</span>cUNION <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> altc_option <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> altc_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_altc1 altc_cUNION o_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_cset <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> altc_option altc_option"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span>
      <span class="keyword1"><span class="command">unfolding</span></span> altc_sample_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_altc3_optionT"><span class="command">lemma</span></span> monad_altc3_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_altc3 <span class="free">return</span> <span class="free">bind</span> <span class="free">altc</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_altc3 return_option bind_option altc_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_altc3 <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_altc_optionT"><span class="command">lemma</span></span> monad_state_altc_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state_altc <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span> <span class="free">altc</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state_altc return_option bind_option get_option put_option altc_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_option <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> get_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_option <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> altc_option <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">c</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def altc_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_option <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> put_option <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> put_option <span class="skolem">s</span> <span class="main">(</span>altc_option <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">s</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def altc_put<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Resumption›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pause</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pause_option</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pause_option</span> <span class="free"><span class="bound"><span class="entity">out</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> OptionT <span class="main">(</span><span class="free">pause</span> <span class="free"><span class="bound"><span class="entity">out</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> run_option <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_pause_option"><span class="command">lemma</span></span> run_pause_option <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>pause_option <span class="free">out</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">pause</span> <span class="free">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> run_option <span class="main">(</span><span class="free">c</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pause_option_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_resumption_optionT"><span class="command">lemma</span></span> monad_resumption_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_resumption <span class="free">return</span> <span class="free">bind</span> <span class="free">pause</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_resumption return_option bind_option pause_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_resumption <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">pause</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="main">(</span>pause_option <span class="skolem">out</span> <span class="skolem">c</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> pause_option <span class="skolem">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> bind_option <span class="main">(</span><span class="skolem">c</span> <span class="bound">i</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">out</span> <span class="skolem">c</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_pause run_bind_option<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Commutativity›</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_commute_optionT"><span class="command">lemma</span></span> monad_commute_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_commute <span class="free">return</span> <span class="free">bind</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"monad_discard <span class="free">return</span> <span class="free">bind</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_commute return_option bind_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_commute <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_discard <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_option <span class="skolem">m'</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> 
      <span class="free">bind</span> <span class="main">(</span>run_option <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>run_option <span class="skolem">m'</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="keyword1">case</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="keyword1">of</span> <span class="main">(</span>Some <span class="bound">x'</span><span class="main">,</span> Some <span class="bound">y'</span><span class="main">)</span> <span class="main">⇒</span> run_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">x'</span> <span class="bound">y'</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free">return</span> None<span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_bind_option bind_const <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> option.case_cong <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">bind</span></span><span class="main"><span class="main">]</span></span> ext <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>run_option <span class="skolem">m'</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>run_option <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="main">(</span><span class="bound">x</span><span class="main">,</span> <span class="bound">y</span><span class="main">)</span> <span class="keyword1">of</span> <span class="main">(</span>Some <span class="bound">x'</span><span class="main">,</span> Some <span class="bound">y'</span><span class="main">)</span> <span class="main">⇒</span> run_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">x'</span> <span class="bound">y'</span><span class="main">)</span> <span class="main">|</span> <span class="main"><span class="bound">_</span></span> <span class="main">⇒</span> <span class="free">return</span> None<span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> bind_commute<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> run_option <span class="main">(</span>bind_option <span class="skolem">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_bind_option bind_const case_option_collapse <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> option.case_cong <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> ext <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">bind</span></span><span class="main"><span class="main">]</span></span> ext <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_option <span class="skolem">m'</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_option <span class="skolem">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Duplicability›</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_duplicate_optionT"><span class="command">lemma</span></span> monad_duplicate_optionT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_duplicate <span class="free">return</span> <span class="free">bind</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"monad_discard <span class="free">return</span> <span class="free">bind</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_duplicate return_option bind_option"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_duplicate <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_discard <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">m</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_option <span class="skolem">m</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
          <span class="free">bind</span> <span class="main">(</span>run_option <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>run_option <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">return</span> None <span class="main">|</span> Some <span class="bound">x'</span> <span class="main">⇒</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">y</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">return</span> None <span class="main">|</span> Some <span class="bound">y'</span> <span class="main">⇒</span> run_option <span class="main">(</span><span class="skolem">f</span> <span class="bound">x'</span> <span class="bound">y'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong2<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">bind</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_const run_bind_option <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> run_option <span class="main">(</span>bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_duplicate run_bind_option <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_option <span class="skolem">m</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_option <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> optionT.expand<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Parametricity›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-return_option_parametric"><span class="command">lemma</span></span> return_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_option <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> return_option return_option"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-bind_option_parametric"><span class="command">lemma</span></span> bind_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_option <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span>rel_option <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span>
   <span class="main">===&gt;</span> rel_optionT <span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span>
   bind_option bind_option"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-fail_option_parametric"><span class="command">lemma</span></span> fail_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_option <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> fail_option fail_option"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fail_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-catch_option_parametric"><span class="command">lemma</span></span> catch_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_option <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span>rel_option <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span>
   <span class="main">===&gt;</span> rel_optionT <span class="free">M</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span>
  catch_option catch_option"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> catch_option_def Option.is_none_def<span class="main">[</span><span class="operator">symmetric</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-ask_option_parametric"><span class="command">lemma</span></span> ask_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> ask_option ask_option"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ask_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-get_option_parametric"><span class="command">lemma</span></span> get_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> get_option get_option"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> get_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-put_option_parametric"><span class="command">lemma</span></span> put_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">S</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> put_option put_option"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> put_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-altc_sample_option_parametric"><span class="command">lemma</span></span> altc_sample_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">P</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">P</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span>
   altc_sample_option altc_sample_option"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> altc_sample_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-alt_option_parametric"><span class="command">lemma</span></span> alt_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> alt_option alt_option"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> alt_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-tell_option_parametric"><span class="command">lemma</span></span> tell_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">W</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">W</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> tell_option tell_option"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> tell_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-pause_option_parametric"><span class="command">lemma</span></span> pause_option_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Out</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">In</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">Out</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">In</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_optionT <span class="free">M</span><span class="main">)</span>
   pause_option pause_option"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> pause_option_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Reader monad transformer›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT <span class="main">=</span> EnvT <span class="main">(</span><span class="free"><span class="entity">run_env</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="tfree">'r</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rel_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span> <span class="main">⇒</span> <span class="tfree">'r'</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m'</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r'</span><span class="main">,</span> <span class="tfree">'m'</span><span class="main">)</span> envT <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rel_envT</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="main">=</span> BNF_Def.vimage2p run_env run_env <span class="main">(</span><span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">===&gt;</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_envTI"><span class="command">lemma</span></span> rel_envTI <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span> <span class="main">⟹</span> rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">(</span>EnvT <span class="free">f</span><span class="main">)</span> <span class="main">(</span>EnvT <span class="free">g</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_envT_def BNF_Def.vimage2p_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_envT_simps"><span class="command">lemma</span></span> rel_envT_simps<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">(</span>EnvT <span class="free">f</span><span class="main">)</span> <span class="main">(</span>EnvT <span class="free">g</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_envT_def BNF_Def.vimage2p_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_envTE"><span class="command">lemma</span></span> rel_envTE <span class="main">[</span><span class="operator">cases</span> <span class="quasi_keyword"><span class="quasi_keyword"><span class="quasi_keyword">pred</span></span></span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"rel_envT <span class="free">R</span> <span class="free">M</span> <span class="free">m</span> <span class="free">m'</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">f</span> <span class="free">g</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> EnvT <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m'</span> <span class="main">=</span> EnvT <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">m'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span>  <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_envT_simps<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_envT_eq"><span class="command">lemma</span></span> rel_envT_eq <span class="main">[</span><span class="operator">relator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_envT <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_envT_def rel_fun_eq BNF_Def.vimage2p_def fun_eq_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> envT.expand<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_envT_mono"><span class="command">lemma</span></span> rel_envT_mono <span class="main">[</span><span class="operator">relator_mono</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">R</span> <span class="main">≤</span> <span class="free">R'</span><span class="main">;</span> <span class="free">M</span> <span class="main">≤</span> <span class="free">M'</span> <span class="main">⟧</span> <span class="main">⟹</span> rel_envT <span class="free">R'</span> <span class="free">M</span> <span class="main">≤</span> rel_envT <span class="free">R</span> <span class="free">M'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_envT_def predicate2I vimage2p_mono fun_mono<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-EnvT_parametric"><span class="command">lemma</span></span> EnvT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> EnvT EnvT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_funI rel_envT_simps<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_env_parametric"><span class="command">lemma</span></span> run_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> run_env run_env"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_envTE<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rec_envT_parametric"><span class="command">lemma</span></span> rec_envT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> rec_envT rec_envT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_envTE <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_funD<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-case_envT_parametric"><span class="command">lemma</span></span> case_envT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> case_envT case_envT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_envTE <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_funD<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Plain monad and ask›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">return_env</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">return</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">bind_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_env</span> <span class="main">(</span>EnvT <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> run_env <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">y</span><span class="main">)</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ask_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ask_env</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_env <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">r</span><span class="main">)</span> <span class="bound">r</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_bind_env"><span class="command">lemma</span></span> run_bind_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>bind_env <span class="free">x</span> <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>run_env <span class="free">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Monomorphic_Monad-run_return_env"><span class="command">lemma</span></span> run_return_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>return_env <span class="free">x</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">return</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_ask_env"><span class="command">lemma</span></span> run_ask_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>ask_env <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> run_env <span class="main">(</span><span class="free">f</span> <span class="free">r</span><span class="main">)</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_env_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> monad<span class="main">:</span> <span class="quoted"><span class="quoted">"monad <span class="free">return</span> <span class="free">bind</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> monad<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_envT"><span class="command">lemma</span></span> monad_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return_env bind_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>bind_env <span class="skolem">x</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> bind_env <span class="skolem">x</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc return_bind<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>return_env <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind return_env_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="skolem">x</span> <span class="main">(</span>return_env <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> return<span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_return fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_reader_envT"><span class="command">lemma</span></span> monad_reader_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_reader return_env bind_env ask_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_env <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> ask_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ask_env <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">r</span> <span class="bound">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'r</span> <span class="main">⇒</span> <span class="tfree">'r</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_env <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>ask_env <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> ask_env <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> bind_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'r</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ask_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ask_env <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> bind_env <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Failure›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fail_env</span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">fail</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_fail_env"><span class="command">lemma</span></span> run_fail_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env fail_env <span class="free">r</span> <span class="main">=</span> <span class="free">fail</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_envT"><span class="command">lemma</span></span> monad_fail_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_fail <span class="free">return</span> <span class="free">bind</span> <span class="free">fail</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_fail return_env bind_env fail_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_fail <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"bind_env fail_env <span class="skolem">f</span> <span class="main">=</span> fail_env"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff fail_bind<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">catch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> catch"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">catch_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT catch"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">catch_env</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">catch</span> <span class="main">(</span>run_env <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span>run_env <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_catch_env"><span class="command">lemma</span></span> run_catch_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>catch_env <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">catch</span> <span class="main">(</span>run_env <span class="free">m1</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span>run_env <span class="free">m2</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> catch_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_catch_envT"><span class="command">lemma</span></span> monad_catch_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_catch <span class="free">return</span> <span class="free">bind</span> <span class="free">fail</span> <span class="free">catch</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_catch return_env bind_env fail_env catch_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_catch <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">catch</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"catch_env <span class="main">(</span>return_env <span class="skolem">x</span><span class="main">)</span> <span class="skolem">m</span> <span class="main">=</span> return_env <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff catch_return<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"catch_env fail_env <span class="skolem">m</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff catch_fail<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"catch_env <span class="skolem">m</span> fail_env <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff catch_fail2<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"catch_env <span class="main">(</span>catch_env <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span> <span class="skolem">m''</span> <span class="main">=</span> catch_env <span class="skolem">m</span> <span class="main">(</span>catch_env <span class="skolem">m'</span> <span class="skolem">m''</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="skolem">m''</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff catch_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>
       
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹State›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_env</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_env <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">put_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">put_env</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">put</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>run_env <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_get_env"><span class="command">lemma</span></span> run_get_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>get_env <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_put_env"><span class="command">lemma</span></span> run_put_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>put_env <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span>run_env <span class="free">m</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_envT"><span class="command">lemma</span></span> monad_state_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state return_env bind_env get_env put_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_env <span class="skolem">s</span> <span class="main">(</span>get_env <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> put_env <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'s</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff put_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_env <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> get_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_env <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">s</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff get_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_env <span class="skolem">s</span> <span class="main">(</span>put_env <span class="skolem">s'</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> put_env <span class="skolem">s'</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">s'</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'s</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff put_put<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_env <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> put_env <span class="bound">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff get_put<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_env <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff get_const<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>get_env <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> get_env <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bind_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>put_env <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> put_env <span class="skolem">s</span> <span class="main">(</span>bind_env <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_put<span class="main">)</span>    
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Probability›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sample_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sample_env</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">sample</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_env <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_sample_env"><span class="command">lemma</span></span> run_sample_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>sample_env <span class="free">p</span> <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">sample</span> <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_prob_envT"><span class="command">lemma</span></span> monad_prob_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_prob <span class="free">return</span> <span class="free">bind</span> <span class="free">sample</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_prob return_env bind_env sample_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_prob <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">sample</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> sample_parametric<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">including</span></span> lifting_syntax
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_env <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'p</span> pmf"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff sample_const<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_env <span class="main">(</span>return_pmf <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'p</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff sample_return_pmf<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_env <span class="main">(</span>bind_pmf <span class="skolem">p</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> sample_env <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> sample_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'p</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">p</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff sample_bind_pmf<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_env <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> sample_env <span class="skolem">q</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sample_env <span class="skolem">q</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> sample_env <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">q</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'p</span> pmf"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'p</span> <span class="main">⇒</span> <span class="tfree">'p</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sample_commute<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>sample_env <span class="skolem">p</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> sample_env <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'p</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_sample1<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> sample_env <span class="skolem">p</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sample_env <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_env <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">p</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'p</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_sample2<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_pmf <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> sample_env sample_env"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="keyword1"><span class="command">unfolding</span></span> sample_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_prob_envT"><span class="command">lemma</span></span> monad_state_prob_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state_prob <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span> <span class="free">sample</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state_prob return_env bind_env get_env put_env sample_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state_prob <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">sample</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_env <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> get_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_env <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> sample_env <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'p</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff sample_get<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Binary Non-determinism›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> alt"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">alt_env</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">alt</span> <span class="main">(</span>run_env <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="bound">r</span><span class="main">)</span> <span class="main">(</span>run_env <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_alt_env"><span class="command">lemma</span></span> run_alt_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>alt_env <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">alt</span> <span class="main">(</span>run_env <span class="free">m1</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span>run_env <span class="free">m2</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_alt_envT"><span class="command">lemma</span></span> monad_alt_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_alt <span class="free">return</span> <span class="free">bind</span> <span class="free">alt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_alt return_env bind_env alt_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">alt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_env <span class="main">(</span>alt_env <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span> <span class="skolem">m3</span> <span class="main">=</span> alt_env <span class="skolem">m1</span> <span class="main">(</span>alt_env <span class="skolem">m2</span> <span class="skolem">m3</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m1</span> <span class="skolem">m2</span> <span class="skolem">m3</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff alt_assoc<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>alt_env <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> alt_env <span class="main">(</span>bind_env <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>bind_env <span class="skolem">m'</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_alt1<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_alt_envT"><span class="command">lemma</span></span> monad_fail_alt_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fail</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_fail_alt <span class="free">return</span> <span class="free">bind</span> <span class="free">fail</span> <span class="free">alt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_fail_alt return_env bind_env <span class="main">(</span>fail_env <span class="free">fail</span><span class="main">)</span> alt_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_fail_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">alt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_env <span class="main">(</span>fail_env <span class="free">fail</span><span class="main">)</span> <span class="skolem">m</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_fail1 fun_eq_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_env <span class="skolem">m</span> <span class="main">(</span>fail_env <span class="free">fail</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_fail2 fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_alt_envT"><span class="command">lemma</span></span> monad_state_alt_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state_alt <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span> <span class="free">alt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state_alt return_env bind_env get_env put_env alt_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">alt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_env <span class="main">(</span>get_env <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>get_env <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> get_env <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> alt_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff alt_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_env <span class="main">(</span>put_env <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span>put_env <span class="skolem">s</span> <span class="skolem">m'</span><span class="main">)</span> <span class="main">=</span> put_env <span class="skolem">s</span> <span class="main">(</span>alt_env <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff alt_put<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Countable Non-determinism›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">altc_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">altc_env</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">altc</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> run_env <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">c</span><span class="main">)</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_altc_env"><span class="command">lemma</span></span> run_altc_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>altc_env <span class="free">C</span> <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">altc</span> <span class="free">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">f</span> <span class="bound">c</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_altc_envT"><span class="command">lemma</span></span> monad_altc_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_altc <span class="free">return</span> <span class="free">bind</span> <span class="free">altc</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_altc return_env bind_env altc_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">note</span></span> altc_parametric<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">including</span></span> lifting_syntax
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>altc_env <span class="skolem">C</span> <span class="skolem">g</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> altc_env <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> bind_env <span class="main">(</span><span class="skolem">g</span> <span class="bound">c</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">g</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_altc1<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_env <span class="main">(</span>csingle <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff altc_single<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_env <span class="main">(</span>cUNION <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> altc_env <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> altc_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">f</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff altc_cUNION<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_cset <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> altc_env altc_env"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span>
      <span class="keyword1"><span class="command">unfolding</span></span> altc_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_altc3_envT"><span class="command">lemma</span></span> monad_altc3_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_altc3 <span class="free">return</span> <span class="free">bind</span> <span class="free">altc</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_altc3 return_env bind_env altc_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_altc3 <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_altc_envT"><span class="command">lemma</span></span> monad_state_altc_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state_altc <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span> <span class="free">altc</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state_altc return_env bind_env get_env put_env altc_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_env <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> get_env <span class="main">(</span><span class="skolem">f</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_env <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> altc_env <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">c</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff altc_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_env <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> put_env <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> put_env <span class="skolem">s</span> <span class="main">(</span>altc_env <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">s</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff altc_put<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Resumption›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pause</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pause_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pause_env</span> <span class="free"><span class="bound"><span class="entity">out</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">pause</span> <span class="free"><span class="bound"><span class="entity">out</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> run_env <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_pause_env"><span class="command">lemma</span></span> run_pause_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>pause_env <span class="free">out</span> <span class="free">c</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">pause</span> <span class="free">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">c</span> <span class="bound">i</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pause_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_resumption_envT"><span class="command">lemma</span></span> monad_resumption_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_resumption <span class="free">return</span> <span class="free">bind</span> <span class="free">pause</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_resumption return_env bind_env pause_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_resumption <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">pause</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>pause_env <span class="skolem">out</span> <span class="skolem">c</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> pause_env <span class="skolem">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> bind_env <span class="main">(</span><span class="skolem">c</span> <span class="bound">i</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">out</span> <span class="skolem">f</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">c</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'i</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_pause<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Writer›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">tell</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tell_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tell_env</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">tell</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span>run_env <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_tell_env"><span class="command">lemma</span></span> run_tell_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>tell_env <span class="free">w</span> <span class="free">m</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">tell</span> <span class="free">w</span> <span class="main">(</span>run_env <span class="free">m</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tell_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_writer_envT"><span class="command">lemma</span></span> monad_writer_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_writer <span class="free">return</span> <span class="free">bind</span> <span class="free">tell</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_writer return_env bind_env tell_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_writer <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">tell</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>tell_env <span class="skolem">w</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> tell_env <span class="skolem">w</span> <span class="main">(</span>bind_env <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">w</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_tell fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Commutativity›</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_commute_envT"><span class="command">lemma</span></span> monad_commute_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_commute <span class="free">return</span> <span class="free">bind</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_commute return_env bind_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_commute <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_env <span class="skolem">m'</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_env <span class="skolem">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_env <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> bind_commute<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Discardability›</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_discard_envT"><span class="command">lemma</span></span> monad_discard_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_discard <span class="free">return</span> <span class="free">bind</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_discard return_env bind_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_discard <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m'</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m'</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_const<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Duplicability›</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_duplicate_envT"><span class="command">lemma</span></span> monad_duplicate_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_duplicate <span class="free">return</span> <span class="free">bind</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_duplicate return_env bind_env"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_duplicate <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_env <span class="skolem">m</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_env <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_duplicate<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Parametricity›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-return_env_parametric"><span class="command">lemma</span></span> return_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> return_env return_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-bind_env_parametric"><span class="command">lemma</span></span> bind_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span>
   bind_env bind_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-ask_env_parametric"><span class="command">lemma</span></span> ask_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> ask_env ask_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ask_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-fail_env_parametric"><span class="command">lemma</span></span> fail_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> fail_env fail_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fail_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-catch_env_parametric"><span class="command">lemma</span></span> catch_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> catch_env catch_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> catch_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-get_env_parametric"><span class="command">lemma</span></span> get_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> get_env get_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> get_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-put_env_parametric"><span class="command">lemma</span></span> put_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">S</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> put_env put_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> put_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-sample_env_parametric"><span class="command">lemma</span></span> sample_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_pmf <span class="free">P</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">P</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_pmf <span class="free">P</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">P</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span>
  sample_env sample_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> sample_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-alt_env_parametric"><span class="command">lemma</span></span> alt_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> alt_env alt_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> alt_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-altc_env_parametric"><span class="command">lemma</span></span> altc_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_cset <span class="free">C</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">C</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_cset <span class="free">C</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">C</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> 
   altc_env altc_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> altc_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-pause_env_parametric"><span class="command">lemma</span></span> pause_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Out</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">In</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">Out</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">In</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span>
   pause_env pause_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> pause_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-tell_env_parametric"><span class="command">lemma</span></span> tell_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">W</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">W</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> tell_env tell_env"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> tell_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Unbounded non-determinism›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">return_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> set<span class="main">)</span> return"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">return_set</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">≡</span> <span class="main">{</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">bind_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> set<span class="main">)</span> bind"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_set</span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">A</span> <span class="bound">f</span><span class="main">.</span> <span class="main">⋃</span> <span class="main">(</span><span class="bound">f</span> <span class="main">`</span> <span class="bound">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">fail_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set fail"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fail_set</span> <span class="main">≡</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">alt_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> set alt"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">alt_set</span> <span class="main">≡</span> <span class="main">(∪)</span>"</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">altc_set</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'a</span> set<span class="main">)</span> altc"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">altc_set</span> <span class="free"><span class="bound"><span class="entity">C</span></span></span> <span class="main">≡</span> <span class="main">λ</span><span class="bound">f</span><span class="main">.</span> <span class="main">⋃</span> <span class="main">(</span><span class="bound">f</span> <span class="main">`</span> rcset <span class="free"><span class="bound"><span class="entity">C</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_set"><span class="command">lemma</span></span> monad_set <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return_set bind_set"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_set"><span class="command">lemma</span></span> monad_fail_set <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_fail return_set bind_set fail_set"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>

<span class="keyword1" id="Monomorphic_Monad-monad_lift_set"><span class="command">lemma</span></span> monad_lift_set <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_base.lift return_set bind_set  <span class="main">=</span> image"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> monad_base.lift_def o_def fun_eq_iff<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_alt_set"><span class="command">lemma</span></span> monad_alt_set <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_alt return_set bind_set alt_set"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span> <span class="operator">auto</span>

<span class="keyword1" id="Monomorphic_Monad-monad_altc_set"><span class="command">lemma</span></span> monad_altc_set <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_altc return_set bind_set altc_set"</span></span>
  <span class="keyword1"><span class="command">including</span></span> cset.lifting lifting_syntax
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_cset <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">C</span> <span class="bound">f</span><span class="main">.</span> <span class="main">⋃</span> <span class="main">(</span><span class="bound">f</span> <span class="main">`</span> rcset <span class="bound">C</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">C</span> <span class="bound">f</span><span class="main">.</span> <span class="main">⋃</span> <span class="main">(</span><span class="bound">f</span> <span class="main">`</span> rcset <span class="bound">C</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span>
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">fail</span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_altc3_set"><span class="command">lemma</span></span> monad_altc3_set <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_altc3 return_set bind_set <span class="main">(</span>altc_set <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'a</span> set<span class="main">)</span> altc<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"three <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Non-determinism transformer›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="quasi_keyword">plugins</span> <span class="quasi_keyword">del</span><span class="main">:</span> transfer<span class="main">)</span> <span class="main">(</span>phantom_nondetT<span class="main">:</span> <span class="tfree">'a</span><span class="main">,</span> set_nondetT<span class="main">:</span> <span class="tfree">'m</span><span class="main">)</span> nondetT <span class="main">=</span> NondetT <span class="main">(</span><span class="free"><span class="entity">run_nondet</span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'m</span></span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">for</span></span> map<span class="main">:</span> map_nondetT'
      rel<span class="main">:</span> rel_nondetT'

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define our own relator and mapper such that the phantom variable does not need any relation.
›</span></span>

<span class="keyword1" id="Monomorphic_Monad-phantom_nondetT"><span class="command">lemma</span></span> phantom_nondetT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"phantom_nondetT <span class="free">x</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_nondetT'_phantom"><span class="command">lemma</span></span> rel_nondetT'_phantom<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_nondetT' <span class="free">A</span> <span class="main">=</span> rel_nondetT' top"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nondetT.rel_mono antisym nondetT.rel_mono_strong<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-map_nondetT'_phantom"><span class="command">lemma</span></span> map_nondetT'_phantom<span class="main">:</span> <span class="quoted"><span class="quoted">"map_nondetT' <span class="free">f</span> <span class="main">=</span> map_nondetT' undefined"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nondetT.map_cong<span class="main">)</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">map_nondetT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m'</span><span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m'</span><span class="main">)</span> nondetT"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">map_nondetT</span> <span class="main">=</span> map_nondetT' undefined"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rel_nondetT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m'</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m'</span><span class="main">)</span> nondetT <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rel_nondetT</span> <span class="main">=</span> rel_nondetT' top"</span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_nondetTE"><span class="command">lemma</span></span> rel_nondetTE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"rel_nondetT <span class="free">M</span> <span class="free">m</span> <span class="free">m'</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">x</span> <span class="free">y</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">=</span> NondetT <span class="free">x</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m'</span> <span class="main">=</span> NondetT <span class="free">y</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="free">x</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">m'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_nondetT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_nondetT_simps"><span class="command">lemma</span></span> rel_nondetT_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_nondetT <span class="free">M</span> <span class="main">(</span>NondetT <span class="free">m</span><span class="main">)</span> <span class="main">(</span>NondetT <span class="free">m'</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">M</span> <span class="free">m</span> <span class="free">m'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_nondetT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_nondetT_unfold"><span class="command">lemma</span></span> rel_nondetT_unfold<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">m'</span><span class="main">.</span> rel_nondetT <span class="free">M</span> <span class="main">(</span>NondetT <span class="bound">m</span><span class="main">)</span> <span class="bound">m'</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">m''</span><span class="main">.</span> <span class="bound">m'</span> <span class="main">=</span> NondetT <span class="bound">m''</span> <span class="main">∧</span> <span class="free">M</span> <span class="bound">m</span> <span class="bound">m''</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">m'</span><span class="main">.</span> rel_nondetT <span class="free">M</span> <span class="bound">m</span> <span class="main">(</span>NondetT <span class="bound">m'</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">m''</span><span class="main">.</span> <span class="bound">m</span> <span class="main">=</span> NondetT <span class="bound">m''</span> <span class="main">∧</span> <span class="free">M</span> <span class="bound">m''</span> <span class="bound">m'</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> m m' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> m m' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_nondetT_expand"><span class="command">lemma</span></span> rel_nondetT_expand<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">M</span> <span class="main">(</span>run_nondet <span class="free">m</span><span class="main">)</span> <span class="main">(</span>run_nondet <span class="free">m'</span><span class="main">)</span> <span class="main">⟹</span> rel_nondetT <span class="free">M</span> <span class="free">m</span> <span class="free">m'</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">m'</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_nondetT_eq"><span class="command">lemma</span></span> rel_nondetT_eq <span class="main">[</span><span class="operator">relator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_nondetT <span class="main">(=)</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff rel_nondetT_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> nondetT.rel_refl_strong <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> nondetT.rel_cases<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_nondetT_mono"><span class="command">lemma</span></span> rel_nondetT_mono <span class="main">[</span><span class="operator">relator_mono</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_nondetT <span class="free">A</span> <span class="main">≤</span> rel_nondetT <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≤</span> <span class="free">B</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_nondetT_def nondetT.rel_mono that<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_nondetT_distr"><span class="command">lemma</span></span> rel_nondetT_distr <span class="main">[</span><span class="operator">relator_distr</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_nondetT <span class="free">A</span> <span class="keyword1">OO</span> rel_nondetT <span class="free">B</span> <span class="main">=</span> rel_nondetT <span class="main">(</span><span class="free">A</span> <span class="keyword1">OO</span> <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_nondetT_def nondetT.rel_compp<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_nondetT_Grp"><span class="command">lemma</span></span> rel_nondetT_Grp<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_nondetT <span class="main">(</span>BNF_Def.Grp <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> BNF_Def.Grp <span class="main">{</span><span class="bound">x</span><span class="main">.</span> set_nondetT <span class="bound">x</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">}</span> <span class="main">(</span>map_nondetT <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_nondetT_def rel_nondetT'_phantom<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="quoted">"BNF_Def.Grp UNIV undefined"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> nondetT.rel_Grp map_nondetT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-NondetT_parametric"><span class="command">lemma</span></span> NondetT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span> NondetT NondetT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def rel_nondetT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_nondet_parametric"><span class="command">lemma</span></span> run_nondet_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_nondetT <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> run_nondet run_nondet"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def rel_nondetT_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> nondetT.rel_cases<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-case_nondetT_parametric"><span class="command">lemma</span></span> case_nondetT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> case_nondetT case_nondetT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def rel_nondetT_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> nondetT.split<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rec_nondetT_parametric"><span class="command">lemma</span></span> rec_nondetT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">X</span><span class="main">)</span> rec_nondetT rec_nondetT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> rel_nondetTE<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Generic implementation›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> merge <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> nondetM_base <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> merge"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">single</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">union</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span>  <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>∪</b></span>"</span> 65<span class="main">)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_nondet</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">return_nondet</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> NondetT <span class="main">(</span><span class="free">return</span> <span class="main">(</span><span class="free">single</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_nondet</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_nondet</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> NondetT <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>run_nondet <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="main">(</span>run_nondet <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_nondet</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fail_nondet</span> <span class="main">=</span> NondetT <span class="main">(</span><span class="free">return</span> <span class="free">empty</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_nondet</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">alt_nondet</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">=</span> NondetT <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>run_nondet <span class="free"><span class="bound"><span class="entity">m1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>run_nondet <span class="free"><span class="bound"><span class="entity">m2</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">A</span> <span class="main"><span class="free"><span class="hidden">❙</span><b>∪</b></span></span> <span class="bound">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_nondet</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'state</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'state</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_nondet</span> <span class="free"><span class="bound"><span class="entity">get</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> NondetT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">get</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">get</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">put_nondet</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'state</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'state</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">put_nondet</span> <span class="free"><span class="bound"><span class="entity">put</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> NondetT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">put</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>run_nondet <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">put</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ask_nondet</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ask_nondet</span> <span class="free"><span class="bound"><span class="entity">ask</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> NondetT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ask</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  The canonical lift of sampling into <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span> nondetT"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> does not satisfy <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> monad_prob<span class="antiquote"><span class="antiquote">}</span></span></span></span>,
  because sampling does not distribute over bind backwards. Intuitively, if we sample first,
  then the same sample is used in all non-deterministic choices. But if we sample later,
  each non-deterministic choice may sample a different value.
›</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_return_nondet"><span class="command">lemma</span></span> run_return_nondet <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>return_nondet <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="main">(</span><span class="free">single</span> <span class="free">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_nondet_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_bind_nondet"><span class="command">lemma</span></span> run_bind_nondet <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>bind_nondet <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>run_nondet <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="main">(</span>run_nondet <span class="main">∘</span> <span class="free">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_nondet_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_fail_nondet"><span class="command">lemma</span></span> run_fail_nondet <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet fail_nondet <span class="main">=</span> <span class="free">return</span> <span class="free">empty</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_nondet_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_alt_nondet"><span class="command">lemma</span></span> run_alt_nondet <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>alt_nondet <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>run_nondet <span class="free">m1</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>run_nondet <span class="free">m2</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">A</span> <span class="main"><span class="free"><span class="hidden">❙</span><b>∪</b></span></span> <span class="bound">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_nondet_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_get_nondet"><span class="command">lemma</span></span> run_get_nondet <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>get_nondet <span class="free">get</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">get</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_nondet_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_put_nondet"><span class="command">lemma</span></span> run_put_nondet <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>put_nondet <span class="free">put</span> <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span>run_nondet <span class="free">m</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">put</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_nondet_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_ask_nondet"><span class="command">lemma</span></span> run_ask_nondet <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>ask_nondet <span class="free">ask</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="free">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">ask</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_nondet_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monomorphic_Monad-bind_nondet_cong"><span class="command">lemma</span></span> bind_nondet_cong <span class="main">[</span><span class="operator">cong</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"nondetM_base.bind_nondet <span class="free">bind</span> <span class="free">merge</span> <span class="main">=</span> nondetM_base.bind_nondet <span class="free">bind</span> <span class="free">merge</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">bind</span> <span class="free">merge</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span> 
  nondetM_base.return_nondet_def
  nondetM_base.bind_nondet_def
  nondetM_base.fail_nondet_def
  nondetM_base.alt_nondet_def
  nondetM_base.get_nondet_def
  nondetM_base.put_nondet_def
  nondetM_base.ask_nondet_def

<span class="keyword1"><span class="command">locale</span></span> nondetM <span class="main">=</span> nondetM_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">merge</span></span> <span class="quoted"><span class="free">empty</span></span> <span class="quoted"><span class="free">single</span></span> <span class="quoted"><span class="free">union</span></span>
  <span class="main">+</span>
  monad_commute <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> merge"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">single</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">union</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>∪</b></span>"</span> 65<span class="main">)</span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bind_merge_merge<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">merge</span> <span class="bound">y</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="bound">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">merge</span> <span class="bound">y</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="bound">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> merge_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">merge</span> <span class="free">empty</span> <span class="bound">f</span> <span class="main">=</span> <span class="free">return</span> <span class="free">empty</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> merge_single<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="free">merge</span> <span class="main">(</span><span class="free">single</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="bound">f</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> merge_single2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="free">single</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="bound">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> merge_union<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span> <span class="bound">B</span> <span class="bound">f</span><span class="main">.</span> <span class="free">merge</span> <span class="main">(</span><span class="bound">A</span> <span class="main"><span class="free"><span class="hidden">❙</span><b>∪</b></span></span> <span class="bound">B</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">merge</span> <span class="bound">A</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A'</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">merge</span> <span class="bound">B</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B'</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">A'</span> <span class="main"><span class="free"><span class="hidden">❙</span><b>∪</b></span></span> <span class="bound">B'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> union_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span> <span class="bound">B</span> <span class="bound">C</span><span class="main">.</span> <span class="main">(</span><span class="bound">A</span> <span class="main"><span class="free"><span class="hidden">❙</span><b>∪</b></span></span> <span class="bound">B</span><span class="main">)</span> <span class="main"><span class="free"><span class="hidden">❙</span><b>∪</b></span></span> <span class="bound">C</span> <span class="main">=</span> <span class="bound">A</span> <span class="main"><span class="free"><span class="hidden">❙</span><b>∪</b></span></span> <span class="main">(</span><span class="bound">B</span> <span class="main"><span class="free"><span class="hidden">❙</span><b>∪</b></span></span> <span class="bound">C</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> empty_union<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span><span class="main">.</span> <span class="free">empty</span> <span class="main"><span class="free"><span class="hidden">❙</span><b>∪</b></span></span> <span class="bound">A</span> <span class="main">=</span> <span class="bound">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> union_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span><span class="main">.</span> <span class="bound">A</span> <span class="main"><span class="free"><span class="hidden">❙</span><b>∪</b></span></span> <span class="free">empty</span> <span class="main">=</span> <span class="bound">A</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_nondetT"><span class="command">lemma</span></span> monad_nondetT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return_nondet bind_nondet"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet <span class="main">(</span>bind_nondet <span class="skolem">x</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> bind_nondet <span class="skolem">x</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">y</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc bind_merge_merge o_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet <span class="main">(</span>return_nondet <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind merge_single<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet <span class="skolem">x</span> return_nondet <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_return o_def merge_single2<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_nondetT"><span class="command">lemma</span></span> monad_fail_nondetT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_fail return_nondet bind_nondet fail_nondet"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet fail_nondet <span class="skolem">f</span> <span class="main">=</span> fail_nondet"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind merge_empty<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_alt_nondetT"><span class="command">lemma</span></span> monad_alt_nondetT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_alt return_nondet bind_nondet alt_nondet"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_nondet <span class="main">(</span>alt_nondet <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span> <span class="skolem">m3</span> <span class="main">=</span> alt_nondet <span class="skolem">m1</span> <span class="main">(</span>alt_nondet <span class="skolem">m2</span> <span class="skolem">m3</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m1</span> <span class="skolem">m2</span> <span class="skolem">m3</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc return_bind union_assoc<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet <span class="main">(</span>alt_nondet <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> alt_nondet <span class="main">(</span>bind_nondet <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>bind_nondet <span class="skolem">m'</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc return_bind<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> bind_commute<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> merge_union<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_alt_nondetT"><span class="command">lemma</span></span> monad_fail_alt_nondetT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_fail_alt return_nondet bind_nondet fail_nondet alt_nondet"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_nondet fail_nondet <span class="skolem">m</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span>  <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind bind_return empty_union<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_nondet <span class="skolem">m</span> fail_nondet <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind bind_return union_empty<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_nondetT"><span class="command">lemma</span></span> monad_state_nondetT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="comment1">― ‹It's not really sensible to assume a commutative state monad, but let's prove it anyway ...›</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">get</span> <span class="free">put</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state return_nondet bind_nondet <span class="main">(</span>get_nondet <span class="free">get</span><span class="main">)</span> <span class="main">(</span>put_nondet <span class="free">put</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_nondet <span class="free">put</span> <span class="skolem">s</span> <span class="main">(</span>get_nondet <span class="free">get</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> put_nondet <span class="free">put</span> <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_nondet <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> get_nondet <span class="free">get</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_nondet <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">s</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_nondet <span class="free">put</span> <span class="skolem">s</span> <span class="main">(</span>put_nondet <span class="free">put</span> <span class="skolem">s'</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> put_nondet <span class="free">put</span> <span class="skolem">s'</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_put<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_nondet <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> put_nondet <span class="free">put</span> <span class="bound">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_put<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_nondet <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_const<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet <span class="main">(</span>get_nondet <span class="free">get</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> get_nondet <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bind_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet <span class="main">(</span>put_nondet <span class="free">put</span> <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> put_nondet <span class="free">put</span> <span class="skolem">s</span> <span class="main">(</span>bind_nondet <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">m</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_put<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_alt_nondetT"><span class="command">lemma</span></span> monad_state_alt_nondetT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">get</span> <span class="free">put</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state_alt return_nondet bind_nondet <span class="main">(</span>get_nondet <span class="free">get</span><span class="main">)</span> <span class="main">(</span>put_nondet <span class="free">put</span><span class="main">)</span> alt_nondet"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_nondet <span class="main">(</span>get_nondet <span class="free">get</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>get_nondet <span class="free">get</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> get_nondet <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> alt_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_get<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> bind_commute<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_get get_get<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_nondet <span class="main">(</span>put_nondet <span class="free">put</span> <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span>put_nondet <span class="free">put</span> <span class="skolem">s</span> <span class="skolem">m'</span><span class="main">)</span> <span class="main">=</span> put_nondet <span class="free">put</span> <span class="skolem">s</span> <span class="main">(</span>alt_nondet <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">m</span> <span class="skolem">m'</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_put<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> bind_commute<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_put put_put<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> nondetM_lemmas <span class="main">=</span>
  nondetM.monad_nondetT
  nondetM.monad_fail_nondetT
  nondetM.monad_alt_nondetT
  nondetM.monad_fail_alt_nondetT
  nondetM.monad_state_nondetT

<span class="keyword1"><span class="command">locale</span></span> nondetM_ask <span class="main">=</span> nondetM <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">merge</span></span> <span class="quoted"><span class="free">empty</span></span> <span class="quoted"><span class="free">single</span></span> <span class="quoted"><span class="free">union</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">ask</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'s</span><span class="main">)</span> merge"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">empty</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">single</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">union</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">infixl</span></span> <span class="quoted">"<span class="keyword1"><span class="hidden">❙</span><b>∪</b></span>"</span> 65<span class="main">)</span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> monad_reader<span class="main">:</span> <span class="quoted"><span class="quoted">"monad_reader <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span>"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> merge_ask<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span> <span class="main">(</span><span class="bound">f</span> <span class="main">::</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'r</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>
     <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad_reader <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> monad_reader<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_reader_nondetT"><span class="command">lemma</span></span> monad_reader_nondetT<span class="main">:</span> <span class="quoted"><span class="quoted">"monad_reader return_nondet bind_nondet <span class="main">(</span>ask_nondet <span class="free">ask</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_nondet <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> ask_nondet <span class="free">ask</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ask_nondet <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">r</span> <span class="bound">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_ask<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_nondet <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_const<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet <span class="main">(</span>ask_nondet <span class="free">ask</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> ask_nondet <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> bind_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_ask<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ask_nondet <span class="free">ask</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ask_nondet <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> bind_nondet <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_ask2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> o_def merge_ask<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> nondetM_ask_lemmas <span class="main">=</span>
  nondetM_ask.monad_reader_nondetT

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Parametricity›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-return_nondet_parametric"><span class="command">lemma</span></span> return_nondet_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">S</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span>
   nondetM_base.return_nondet nondetM_base.return_nondet"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nondetM_base.return_nondet_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-bind_nondet_parametric"><span class="command">lemma</span></span> bind_nondet_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> 
    rel_nondetT <span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span>
   nondetM_base.bind_nondet nondetM_base.bind_nondet"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nondetM_base.bind_nondet_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-fail_nondet_parametric"><span class="command">lemma</span></span> fail_nondet_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">S</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span> nondetM_base.fail_nondet nondetM_base.fail_nondet"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nondetM_base.fail_nondet_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-alt_nondet_parametric"><span class="command">lemma</span></span> alt_nondet_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">S</span> <span class="main">===&gt;</span> <span class="free">S</span><span class="main">)</span> <span class="main">===&gt;</span>
    rel_nondetT <span class="free">M</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span>
   nondetM_base.alt_nondet nondetM_base.alt_nondet"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nondetM_base.alt_nondet_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-get_nondet_parametric"><span class="command">lemma</span></span> get_nondet_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span>
   nondetM_base.get_nondet nondetM_base.get_nondet"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nondetM_base.get_nondet_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-put_nondet_parametric"><span class="command">lemma</span></span> put_nondet_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">S</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span> 
   nondetM_base.put_nondet nondetM_base.put_nondet"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nondetM_base.put_nondet_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-ask_nondet_parametric"><span class="command">lemma</span></span> ask_nondet_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_nondetT <span class="free">M</span><span class="main">)</span>
   nondetM_base.ask_nondet nondetM_base.ask_nondet"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> nondetM_base.ask_nondet_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation using lists›</span></span>

<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">lunionM</span> <span class="free">lUnionM</span> 
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">lunionM</span> <span class="free">m1</span> <span class="free">m2</span> <span class="main">≡</span> <span class="free">bind</span> <span class="free">m1</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">bind</span> <span class="free">m2</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">A</span> <span class="main">@</span> <span class="bound">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">lUnionM</span> <span class="free">ms</span> <span class="main">≡</span> foldr <span class="free">lunionM</span> <span class="free">ms</span> <span class="main">(</span><span class="free">return</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lmerge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> list <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lmerge</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free">lUnionM</span> <span class="main">(</span>map <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_commute <span class="free">return</span> <span class="free">bind</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad_commute <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
<span class="keyword1"><span class="command">interpretation</span></span> nondetM_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted">lmerge</span> <span class="quoted"><span class="quoted">"<span class="main">[]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(@)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Monomorphic_Monad-lUnionM_empty"><span class="command">lemma</span></span> lUnionM_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lUnionM</span> <span class="main">[]</span> <span class="main">=</span> <span class="free">return</span> <span class="main">[]</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lUnionM_def<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-lUnionM_Cons"><span class="command">lemma</span></span> lUnionM_Cons <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lUnionM</span> <span class="main">(</span><span class="free">x</span> <span class="main">#</span> <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="free">lunionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">lUnionM</span> <span class="free">M</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">M</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lUnionM_def<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-lunionM_return_empty1"><span class="command">lemma</span></span> lunionM_return_empty1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lunionM</span> <span class="main">(</span><span class="free">return</span> <span class="main">[]</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lunionM_def return_bind bind_return<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-lunionM_return_empty2"><span class="command">lemma</span></span> lunionM_return_empty2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lunionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">return</span> <span class="main">[]</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lunionM_def return_bind bind_return<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-lunionM_return_return"><span class="command">lemma</span></span> lunionM_return_return <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lunionM</span> <span class="main">(</span><span class="free">return</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">return</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="main">(</span><span class="free">A</span> <span class="main">@</span> <span class="free">B</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">B</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lunionM_def return_bind<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-lunionM_assoc"><span class="command">lemma</span></span> lunionM_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lunionM</span> <span class="main">(</span><span class="free">lunionM</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="free">z</span> <span class="main">=</span> <span class="free">lunionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">lunionM</span> <span class="free">y</span> <span class="free">z</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">y</span> <span class="free">z</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lunionM_def bind_assoc return_bind<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-lunionM_lUnionM1"><span class="command">lemma</span></span> lunionM_lUnionM1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lunionM</span> <span class="main">(</span><span class="free">lUnionM</span> <span class="free">A</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> foldr <span class="free">lunionM</span> <span class="free">A</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">x</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lunionM_assoc<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-lUnionM_append"><span class="command">lemma</span></span> lUnionM_append <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lUnionM</span> <span class="main">(</span><span class="free">A</span> <span class="main">@</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">lunionM</span> <span class="main">(</span><span class="free">lUnionM</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">lUnionM</span> <span class="free">B</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">B</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> lunionM_lUnionM1<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lUnionM_def<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-lUnionM_return"><span class="command">lemma</span></span> lUnionM_return <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">lUnionM</span> <span class="main">(</span>map <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">return</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1" id="Monomorphic_Monad-bind_lunionM"><span class="command">lemma</span></span> bind_lunionM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span><span class="free">lunionM</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">lunionM</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m'</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span> <span class="bound">B</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">A</span> <span class="main">@</span> <span class="bound">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">B</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">x</span> <span class="main">@</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">m</span> <span class="free">m'</span> <span class="free">f</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc return_bind lunionM_def that<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> bind_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-list_nondetM"><span class="command">lemma</span></span> list_nondetM<span class="main">:</span> <span class="quoted"><span class="quoted">"nondetM <span class="free">return</span> <span class="free">bind</span> lmerge <span class="main">[]</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">)</span> <span class="main">(@)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>lmerge <span class="skolem">y</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> lmerge <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> lmerge <span class="skolem">y</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> lmerge <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmerge_def return_bind<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_lunionM<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lunionM_def o_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lmerge <span class="main">[]</span> <span class="skolem">f</span> <span class="main">=</span> <span class="free">return</span> <span class="main">[]</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmerge_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lmerge <span class="main">[</span><span class="skolem">x</span><span class="main">]</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmerge_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lmerge <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">return</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmerge_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lmerge <span class="main">(</span><span class="skolem">A</span> <span class="main">@</span> <span class="skolem">B</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>lmerge <span class="skolem">A</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A'</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>lmerge <span class="skolem">B</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B'</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">A'</span> <span class="main">@</span> <span class="bound">B'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">A</span> <span class="skolem">B</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lmerge_def lunionM_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Monomorphic_Monad-list_nondetM_ask"><span class="command">lemma</span></span> list_nondetM_ask<span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> list_nondetM<span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_reader <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nondetM_ask <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span> lmerge <span class="main">[]</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">[</span><span class="bound">x</span><span class="main">]</span><span class="main">)</span> <span class="main">(@)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_reader <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"lmerge <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> lmerge <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> lmerge_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">A</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_const lunionM_def bind_ask bind_ask2 ask_ask<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> list_nondetMs <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span> <span class="main">=</span>
  nondetM_lemmas<span class="main">[</span><span class="operator">OF</span> list_nondetM<span class="main">]</span>
  nondetM_ask_lemmas<span class="main">[</span><span class="operator">OF</span> list_nondetM_ask<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monomorphic_Monad-lmerge_parametric"><span class="command">lemma</span></span> lmerge_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>list_all2 <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span>list_all2 <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span>
    <span class="main">===&gt;</span> list_all2 <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span>
   lmerge lmerge"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> lmerge_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation using multisets›</span></span>

<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> multiset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> multiset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">munionM</span> <span class="free">mUnionM</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">munionM</span> <span class="free">m1</span> <span class="free">m2</span> <span class="main">≡</span> <span class="free">bind</span> <span class="free">m1</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">bind</span> <span class="free">m2</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">A</span> <span class="main">+</span> <span class="bound">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">mUnionM</span> <span class="main">≡</span> fold_mset <span class="free">munionM</span> <span class="main">(</span><span class="free">return</span> <span class="main">{#}</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mmerge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> multiset <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mmerge</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free">mUnionM</span> <span class="main">(</span>image_mset <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_commute <span class="free">return</span> <span class="free">bind</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad_commute <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
<span class="keyword1"><span class="command">interpretation</span></span> nondetM_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted">mmerge</span> <span class="quoted"><span class="quoted">"<span class="main">{#}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Monomorphic_Monad-munionM_comp_fun_commute"><span class="command">lemma</span></span> munionM_comp_fun_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_fun_commute <span class="free">munionM</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_assoc return_bind munionM_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> union_ac<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">interpretation</span></span> comp_fun_commute <span class="quoted"><span class="free">munionM</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> munionM_comp_fun_commute<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-mUnionM_empty"><span class="command">lemma</span></span> mUnionM_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mUnionM</span> <span class="main">{#}</span> <span class="main">=</span> <span class="free">return</span> <span class="main">{#}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mUnionM_def<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-mUnionM_add_mset"><span class="command">lemma</span></span> mUnionM_add_mset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mUnionM</span> <span class="main">(</span>add_mset <span class="free">x</span> <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="free">munionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">mUnionM</span> <span class="free">M</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">M</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mUnionM_def<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-munionM_return_empty1"><span class="command">lemma</span></span> munionM_return_empty1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">munionM</span> <span class="main">(</span><span class="free">return</span> <span class="main">{#}</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> munionM_def return_bind bind_return<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-munionM_return_empty2"><span class="command">lemma</span></span> munionM_return_empty2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">munionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">return</span> <span class="main">{#}</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> munionM_def return_bind bind_return<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-munionM_return_return"><span class="command">lemma</span></span> munionM_return_return <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">munionM</span> <span class="main">(</span><span class="free">return</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">return</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="main">(</span><span class="free">A</span> <span class="main">+</span> <span class="free">B</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">B</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> munionM_def return_bind<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-munionM_assoc"><span class="command">lemma</span></span> munionM_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">munionM</span> <span class="main">(</span><span class="free">munionM</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="free">z</span> <span class="main">=</span> <span class="free">munionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">munionM</span> <span class="free">y</span> <span class="free">z</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">y</span> <span class="free">z</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> munionM_def bind_assoc return_bind add.assoc<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-munionM_commute"><span class="command">lemma</span></span> munionM_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">munionM</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> <span class="free">munionM</span> <span class="free">y</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">y</span>
  <span class="keyword1"><span class="command">unfolding</span></span> munionM_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> bind_commute<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> add.commute<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-munionM_mUnionM1"><span class="command">lemma</span></span> munionM_mUnionM1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">munionM</span> <span class="main">(</span><span class="free">mUnionM</span> <span class="free">A</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> fold_mset <span class="free">munionM</span> <span class="free">x</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">x</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> munionM_assoc<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-munionM_mUnionM2"><span class="command">lemma</span></span> munionM_mUnionM2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">munionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">mUnionM</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> fold_mset <span class="free">munionM</span> <span class="free">x</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">A</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> munionM_commute<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> munionM_mUnionM1<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-mUnionM_add"><span class="command">lemma</span></span> mUnionM_add <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mUnionM</span> <span class="main">(</span><span class="free">A</span> <span class="main">+</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">munionM</span> <span class="main">(</span><span class="free">mUnionM</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">mUnionM</span> <span class="free">B</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">B</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> munionM_mUnionM2<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mUnionM_def<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-mUnionM_return"><span class="command">lemma</span></span> mUnionM_return <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">mUnionM</span> <span class="main">(</span>image_mset <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">return</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1" id="Monomorphic_Monad-bind_munionM"><span class="command">lemma</span></span> bind_munionM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span><span class="free">munionM</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">munionM</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m'</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span> <span class="bound">B</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">A</span> <span class="main">+</span> <span class="bound">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">B</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">x</span> <span class="main">+</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">m</span> <span class="free">m'</span> <span class="free">f</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc return_bind munionM_def that<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> bind_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-mset_nondetM"><span class="command">lemma</span></span> mset_nondetM<span class="main">:</span> <span class="quoted"><span class="quoted">"nondetM <span class="free">return</span> <span class="free">bind</span> mmerge <span class="main">{#}</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span><span class="main">)</span> <span class="main">(+)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>mmerge <span class="skolem">y</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> mmerge <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> mmerge <span class="skolem">y</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> mmerge <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind mmerge_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_munionM<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> munionM_def o_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"mmerge <span class="main">{#}</span> <span class="skolem">f</span> <span class="main">=</span> <span class="free">return</span> <span class="main">{#}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mmerge_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"mmerge <span class="main">{#</span><span class="skolem">x</span><span class="main">#}</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mmerge_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"mmerge <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">return</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mmerge_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"mmerge <span class="main">(</span><span class="skolem">A</span> <span class="main">+</span> <span class="skolem">B</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>mmerge <span class="skolem">A</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A'</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>mmerge <span class="skolem">B</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B'</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">A'</span> <span class="main">+</span> <span class="bound">B'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">A</span> <span class="skolem">B</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mmerge_def munionM_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">simp_all</span>

<span class="keyword1" id="Monomorphic_Monad-mset_nondetM_ask"><span class="command">lemma</span></span> mset_nondetM_ask<span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> mset_nondetM<span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_reader <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nondetM_ask <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span> mmerge <span class="main">{#}</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span><span class="main">)</span> <span class="main">(+)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_reader <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"mmerge <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> mmerge <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> mmerge_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">A</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_const munionM_def bind_ask bind_ask2 ask_ask<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> mset_nondetMs <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span> <span class="main">=</span>
  nondetM_lemmas<span class="main">[</span><span class="operator">OF</span> mset_nondetM<span class="main">]</span>
  nondetM_ask_lemmas<span class="main">[</span><span class="operator">OF</span> mset_nondetM_ask<span class="main">]</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monomorphic_Monad-mmerge_parametric"><span class="command">lemma</span></span> mmerge_parametric<span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">assumes</span></span> return <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_mset <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="free">return1</span> <span class="free">return2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> bind <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span>rel_mset <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="free">bind1</span> <span class="free">bind2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> comm1<span class="main">:</span> <span class="quoted"><span class="quoted">"monad_commute <span class="free">return1</span> <span class="free">bind1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> comm2<span class="main">:</span> <span class="quoted"><span class="quoted">"monad_commute <span class="free">return2</span> <span class="free">bind2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_mset <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">(</span>mmerge <span class="free">return1</span> <span class="free">bind1</span><span class="main">)</span> <span class="main">(</span>mmerge <span class="free">return2</span> <span class="free">bind2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> mmerge_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> multiset.map_transfer<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> fold_mset_parametric<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ munionM_comp_fun_commute<span class="main"><span class="main">[</span></span><span class="operator">OF</span> comm1<span class="main"><span class="main">]</span></span> munionM_comp_fun_commute<span class="main"><span class="main">[</span></span><span class="operator">OF</span> comm2<span class="main"><span class="main">]</span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation using finite sets›</span></span>

<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> fset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> fset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">funionM</span> <span class="free">fUnionM</span>
  <span class="keyword2"><span class="keyword">defines</span></span> <span class="quoted"><span class="quoted">"<span class="free">funionM</span> <span class="free">m1</span> <span class="free">m2</span> <span class="main">≡</span> <span class="free">bind</span> <span class="free">m1</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">bind</span> <span class="free">m2</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">A</span> <span class="main">|∪|</span> <span class="bound">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"<span class="free">fUnionM</span> <span class="main">≡</span> ffold <span class="free">funionM</span> <span class="main">(</span><span class="free">return</span> <span class="main">{||}</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fmerge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> fset <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fmerge</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> <span class="free">fUnionM</span> <span class="main">(</span>fimage <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_commute <span class="free">return</span> <span class="free">bind</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">"monad_duplicate <span class="free">return</span> <span class="free">bind</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad_commute <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
<span class="keyword1"><span class="command">interpretation</span></span> monad_duplicate <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
<span class="keyword1"><span class="command">interpretation</span></span> nondetM_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted">fmerge</span> <span class="quoted"><span class="quoted">"<span class="main">{||}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{|</span><span class="bound">x</span><span class="main">|}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(|∪|)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Monomorphic_Monad-funionM_comp_fun_commute"><span class="command">lemma</span></span> funionM_comp_fun_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_fun_commute <span class="free">funionM</span>"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_assoc return_bind funionM_def<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funion_ac<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">interpretation</span></span> comp_fun_commute <span class="quoted"><span class="free">funionM</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> funionM_comp_fun_commute<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-funionM_comp_fun_idem"><span class="command">lemma</span></span> funionM_comp_fun_idem<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_fun_idem <span class="free">funionM</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff funionM_def bind_assoc bind_duplicate return_bind<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> comp_fun_idem <span class="quoted"><span class="free">funionM</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> funionM_comp_fun_idem<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-fUnionM_empty"><span class="command">lemma</span></span> fUnionM_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fUnionM</span> <span class="main">{||}</span> <span class="main">=</span> <span class="free">return</span> <span class="main">{||}</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fUnionM_def<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-fUnionM_finset"><span class="command">lemma</span></span> fUnionM_finset <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fUnionM</span> <span class="main">(</span>finsert <span class="free">x</span> <span class="free">M</span><span class="main">)</span> <span class="main">=</span> <span class="free">funionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">fUnionM</span> <span class="free">M</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">M</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fUnionM_def<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-funionM_return_empty1"><span class="command">lemma</span></span> funionM_return_empty1 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">funionM</span> <span class="main">(</span><span class="free">return</span> <span class="main">{||}</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funionM_def return_bind bind_return<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-funionM_return_empty2"><span class="command">lemma</span></span> funionM_return_empty2 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">funionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">return</span> <span class="main">{||}</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funionM_def return_bind bind_return<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-funionM_return_return"><span class="command">lemma</span></span> funionM_return_return <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">funionM</span> <span class="main">(</span><span class="free">return</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">return</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="main">(</span><span class="free">A</span> <span class="main">|∪|</span> <span class="free">B</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">B</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funionM_def return_bind<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-funionM_assoc"><span class="command">lemma</span></span> funionM_assoc<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">funionM</span> <span class="main">(</span><span class="free">funionM</span> <span class="free">x</span> <span class="free">y</span><span class="main">)</span> <span class="free">z</span> <span class="main">=</span> <span class="free">funionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">funionM</span> <span class="free">y</span> <span class="free">z</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">y</span> <span class="free">z</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funionM_def bind_assoc return_bind funion_assoc<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-funionM_commute"><span class="command">lemma</span></span> funionM_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">funionM</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> <span class="free">funionM</span> <span class="free">y</span> <span class="free">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">y</span>
  <span class="keyword1"><span class="command">unfolding</span></span> funionM_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> bind_commute<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funion_commute<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-funionM_fUnionM1"><span class="command">lemma</span></span> funionM_fUnionM1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">funionM</span> <span class="main">(</span><span class="free">fUnionM</span> <span class="free">A</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> ffold <span class="free">funionM</span> <span class="free">x</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">x</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funionM_assoc<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-funionM_fUnionM2"><span class="command">lemma</span></span> funionM_fUnionM2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">funionM</span> <span class="free">x</span> <span class="main">(</span><span class="free">fUnionM</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> ffold <span class="free">funionM</span> <span class="free">x</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="free">A</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> funionM_commute<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> funionM_fUnionM1<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-fUnionM_funion"><span class="command">lemma</span></span> fUnionM_funion <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fUnionM</span> <span class="main">(</span><span class="free">A</span> <span class="main">|∪|</span> <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">funionM</span> <span class="main">(</span><span class="free">fUnionM</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="free">fUnionM</span> <span class="free">B</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">B</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> funionM_fUnionM2<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fUnionM_def ffold_set_union<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-fUnionM_return"><span class="command">lemma</span></span> fUnionM_return <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fUnionM</span> <span class="main">(</span>fimage <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">return</span> <span class="main">{|</span><span class="bound">x</span><span class="main">|}</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="free">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1" id="Monomorphic_Monad-bind_funionM"><span class="command">lemma</span></span> bind_funionM<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span><span class="free">funionM</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">funionM</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m'</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span> <span class="bound">B</span><span class="main">.</span> <span class="free">f</span> <span class="main">(</span><span class="bound">A</span> <span class="main">|∪|</span> <span class="bound">B</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">B</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">x</span> <span class="main">|∪|</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">m</span> <span class="free">m'</span> <span class="free">f</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc return_bind funionM_def that<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> bind_commute<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1" id="Monomorphic_Monad-fUnionM_return_fempty"><span class="command">lemma</span></span> fUnionM_return_fempty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fUnionM</span> <span class="main">(</span>fimage <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">return</span> <span class="main">{||}</span><span class="main">)</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="main">{||}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span> <span class="operator">simp_all</span>
<span class="keyword1" id="Monomorphic_Monad-funionM_bind"><span class="command">lemma</span></span> funionM_bind<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">funionM</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="free">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">funionM</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">m</span> <span class="free">f</span> <span class="free">g</span>
  <span class="keyword1"><span class="command">unfolding</span></span> funionM_def bind_assoc <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> bind_commute<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_duplicate<span class="main">)</span>
<span class="keyword1" id="Monomorphic_Monad-fUnionM_funionM"><span class="command">lemma</span></span> fUnionM_funionM<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="free">fUnionM</span> <span class="main">(</span><span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="free">funionM</span> <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">|`|</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="free">funionM</span> <span class="main">(</span><span class="free">fUnionM</span> <span class="main">(</span><span class="free">f</span> <span class="main">|`|</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">fUnionM</span> <span class="main">(</span><span class="free">g</span> <span class="main">|`|</span> <span class="free">A</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">f</span> <span class="free">g</span> <span class="free">A</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funionM_assoc funionM_commute fun_left_comm<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-fset_nondetM"><span class="command">lemma</span></span> fset_nondetM<span class="main">:</span> <span class="quoted"><span class="quoted">"nondetM <span class="free">return</span> <span class="free">bind</span> fmerge <span class="main">{||}</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{|</span><span class="bound">x</span><span class="main">|}</span><span class="main">)</span> <span class="main">(|∪|)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>fmerge <span class="skolem">y</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> fmerge <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> fmerge <span class="skolem">y</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> fmerge <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">y</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind fmerge_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_funionM<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> funionM_def o_def fimage_funion<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmerge <span class="main">{||}</span> <span class="skolem">f</span> <span class="main">=</span> <span class="free">return</span> <span class="main">{||}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmerge_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmerge <span class="main">{|</span><span class="skolem">x</span><span class="main">|}</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmerge_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmerge <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">return</span> <span class="main">{|</span><span class="bound">x</span><span class="main">|}</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmerge_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmerge <span class="main">(</span><span class="skolem">A</span> <span class="main">|∪|</span> <span class="skolem">B</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>fmerge <span class="skolem">A</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A'</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>fmerge <span class="skolem">B</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B'</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">A'</span> <span class="main">|∪|</span> <span class="bound">B'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">A</span> <span class="skolem">B</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmerge_def funionM_def fimage_funion<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span> <span class="operator">auto</span>

<span class="keyword1" id="Monomorphic_Monad-fset_nondetM_ask"><span class="command">lemma</span></span> fset_nondetM_ask<span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> fset_nondetM<span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_reader <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"nondetM_ask <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span> fmerge <span class="main">{||}</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{|</span><span class="bound">x</span><span class="main">|}</span><span class="main">)</span> <span class="main">(|∪|)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_reader <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"fmerge <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> fmerge <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT"</span></span> <span class="keyword1"><span class="command">unfolding</span></span> fmerge_def
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">A</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_const funionM_def bind_ask bind_ask2 ask_ask<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> fset_nondetMs <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span> <span class="main">=</span>
  nondetM_lemmas<span class="main">[</span><span class="operator">OF</span> fset_nondetM<span class="main">]</span>
  nondetM_ask_lemmas<span class="main">[</span><span class="operator">OF</span> fset_nondetM_ask<span class="main">]</span>


<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_discard <span class="free">return</span> <span class="free">bind</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad_discard <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

<span class="keyword1" id="Monomorphic_Monad-fmerge_bind"><span class="command">lemma</span></span> fmerge_bind<span class="main">:</span>
  <span class="quoted"><span class="quoted">"fmerge <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="free">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A'</span><span class="main">.</span> fmerge <span class="bound">A'</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="free">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A'</span><span class="main">.</span> fmerge <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> fmerge <span class="bound">A'</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmerge_def bind_const funionM_bind<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-fmerge_commute"><span class="command">lemma</span></span> fmerge_commute<span class="main">:</span> <span class="quoted"><span class="quoted">"fmerge <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> fmerge <span class="free">B</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> fmerge <span class="free">B</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> fmerge <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">A</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fmerge_def fUnionM_funionM<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_commute_nondetT_fset"><span class="command">lemma</span></span> monad_commute_nondetT_fset <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_commute return_nondet bind_nondet"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_nondet <span class="skolem">m'</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> bind_nondet <span class="skolem">m'</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_nondet <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> fmerge_bind<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> bind_commute<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> fmerge_commute<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> fmerge_bind<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> refl<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monomorphic_Monad-fmerge_parametric"><span class="command">lemma</span></span> fmerge_parametric<span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">assumes</span></span> return <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_fset <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="free">return1</span> <span class="free">return2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> bind <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span>rel_fset <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="free">bind1</span> <span class="free">bind2</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> comm1<span class="main">:</span> <span class="quoted"><span class="quoted">"monad_commute <span class="free">return1</span> <span class="free">bind1</span>"</span></span> <span class="quoted"><span class="quoted">"monad_duplicate <span class="free">return1</span> <span class="free">bind1</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> comm2<span class="main">:</span> <span class="quoted"><span class="quoted">"monad_commute <span class="free">return2</span> <span class="free">bind2</span>"</span></span> <span class="quoted"><span class="quoted">"monad_duplicate <span class="free">return2</span> <span class="free">bind2</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_fset <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">(</span>fmerge <span class="free">return1</span> <span class="free">bind1</span><span class="main">)</span> <span class="main">(</span>fmerge <span class="free">return2</span> <span class="free">bind2</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> fmerge_def
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> fset.map_transfer<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> ffold_parametric<span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ funionM_comp_fun_idem<span class="main"><span class="main">[</span></span><span class="operator">OF</span> comm1<span class="main"><span class="main">]</span></span> funionM_comp_fun_idem<span class="main"><span class="main">[</span></span><span class="operator">OF</span> comm2<span class="main"><span class="main">]</span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">rotated</span> -1<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">premises</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Implementation using countable sets›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For non-finite choices, we cannot generically construct the merge operation. So we formalize
  in a locale what can be proven generically and then prove instances of the locale for concrete
  locale implementations.

  We need two separate merge parameters because we must merge effects over choices (type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'c</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>)
  and effects over the non-deterministic results (type <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>) of computations.
›</span></span>

<span class="keyword1"><span class="command">locale</span></span> cset_nondetM_base <span class="main">=</span>
  nondetM_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">merge</span></span> <span class="quoted">cempty</span> <span class="quoted">csingle</span> <span class="quoted">cUn</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> cset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> cset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'a</span> cset<span class="main">)</span> merge"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mergec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'c</span> cset<span class="main">)</span> merge"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">altc_nondet</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> altc"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">altc_nondet</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> NondetT <span class="main">(</span><span class="free">mergec</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span>run_nondet <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_altc_nondet"><span class="command">lemma</span></span> run_altc_nondet <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>altc_nondet <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">mergec</span> <span class="free">A</span> <span class="main">(</span>run_nondet <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_nondet_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> cset_nondetM <span class="main">=</span>
  cset_nondetM_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">merge</span></span> <span class="quoted"><span class="free">mergec</span></span>
  <span class="main">+</span>
  monad_commute <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="main">+</span>
  monad_duplicate <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> cset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> cset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'a</span> cset<span class="main">)</span> merge"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mergec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'c</span> cset<span class="main">)</span> merge"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bind_merge_merge<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">merge</span> <span class="bound">y</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="bound">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">merge</span> <span class="bound">y</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="bound">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> merge_empty<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">f</span><span class="main">.</span> <span class="free">merge</span> cempty <span class="bound">f</span> <span class="main">=</span> <span class="free">return</span> cempty"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> merge_single<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="free">merge</span> <span class="main">(</span>csingle <span class="bound">x</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="bound">f</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> merge_single2<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span>csingle <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="bound">A</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> merge_union<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">A</span> <span class="bound">B</span> <span class="bound">f</span><span class="main">.</span> <span class="free">merge</span> <span class="main">(</span>cUn <span class="bound">A</span> <span class="bound">B</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">merge</span> <span class="bound">A</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A'</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">merge</span> <span class="bound">B</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B'</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span>cUn <span class="bound">A'</span> <span class="bound">B'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> bind_mergec_merge<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">y</span> <span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">mergec</span> <span class="bound">y</span> <span class="bound">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="bound">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">mergec</span> <span class="bound">y</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> <span class="free">merge</span> <span class="bound">A</span> <span class="bound">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> mergec_single<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="free">mergec</span> <span class="main">(</span>csingle <span class="bound">x</span><span class="main">)</span> <span class="bound">f</span> <span class="main">=</span> <span class="bound">f</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> mergec_UNION<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">C</span> <span class="bound">f</span> <span class="bound">g</span><span class="main">.</span> <span class="free">mergec</span> <span class="main">(</span>cUNION <span class="bound">C</span> <span class="bound">f</span><span class="main">)</span> <span class="bound">g</span> <span class="main">=</span> <span class="free">mergec</span> <span class="bound">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">mergec</span> <span class="main">(</span><span class="bound">f</span> <span class="bound">x</span><span class="main">)</span> <span class="bound">g</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> mergec_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">R</span><span class="main">.</span> bi_unique <span class="bound">R</span> <span class="main">⟹</span> rel_fun <span class="main">(</span>rel_cset <span class="bound">R</span><span class="main">)</span> <span class="main">(</span>rel_fun <span class="main">(</span>rel_fun <span class="bound">R</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(=)</span><span class="main">)</span> <span class="free">mergec</span> <span class="free">mergec</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> nondetM <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">merge</span></span> <span class="quoted">cempty</span> <span class="quoted">csingle</span> <span class="quoted">cUn</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="main">(</span><span class="operator">rule</span> bind_merge_merge merge_empty merge_single merge_single2 merge_union <span class="main"><span class="keyword3">|</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cUn_assoc<span class="main">)</span><span class="main"><span class="keyword3">?</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">sublocale</span></span> nondet<span class="main">:</span> monad_altc <span class="quoted">return_nondet</span> <span class="quoted">bind_nondet</span> <span class="quoted">altc_nondet</span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_nondet <span class="main">(</span>altc_nondet <span class="skolem">C</span> <span class="skolem">g</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> altc_nondet <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> bind_nondet <span class="main">(</span><span class="skolem">g</span> <span class="bound">c</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">g</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_mergec_merge o_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_nondet <span class="main">(</span>csingle <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> mergec_single<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_nondet <span class="main">(</span>cUNION <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> altc_nondet <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> altc_nondet <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> nondetT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def mergec_UNION<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_cset <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> altc_nondet altc_nondet"</span></span> 
    <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span>
    <span class="keyword1"><span class="command">unfolding</span></span> altc_nondet_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">transfer_prover</span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> cset_nondetM3 <span class="main">=</span>
  cset_nondetM <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">merge</span></span> <span class="quoted"><span class="free">mergec</span></span>
  <span class="main">+</span>
  three <span class="quoted"><span class="quoted">"<span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'c</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> cset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> cset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'a</span> cset<span class="main">)</span> merge"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mergec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'c</span> cset<span class="main">)</span> merge"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> nondet<span class="main">:</span> monad_altc3 <span class="quoted">return_nondet</span> <span class="quoted">bind_nondet</span> <span class="quoted">altc_nondet</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Identity monad›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">merge_id</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'a</span> cset id<span class="main">,</span> <span class="tfree">'c</span> cset<span class="main">)</span> merge"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">merge_id</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> return_id <span class="main">(</span>cUNION <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span>extract <span class="main">∘</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-extract_merge_id"><span class="command">lemma</span></span> extract_merge_id <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"extract <span class="main">(</span>merge_id <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> cUNION <span class="free">A</span> <span class="main">(</span>extract <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> merge_id_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-merge_id_parametric"><span class="command">lemma</span></span> merge_id_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_cset <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_id <span class="main">(</span>rel_cset <span class="free">A</span><span class="main">)</span><span class="main">)</span> <span class="main">===&gt;</span> rel_id <span class="main">(</span>rel_cset <span class="free">A</span><span class="main">)</span><span class="main">)</span> merge_id merge_id"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> merge_id_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-cset_nondetM_id"><span class="command">lemma</span></span> cset_nondetM_id <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cset_nondetM return_id bind_id merge_id merge_id"</span></span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_id <span class="main">(</span>merge_id <span class="skolem">y</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> merge_id <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> merge_id <span class="skolem">y</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_id <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> merge_id <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span> cset id"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def cUNION_assoc<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_id <span class="main">(</span>merge_id <span class="skolem">y</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> merge_id <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> merge_id <span class="skolem">y</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_id <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> merge_id <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'d</span> cset id"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">this</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_id cempty <span class="skolem">f</span> <span class="main">=</span> return_id cempty"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> cset id"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_id <span class="main">(</span>csingle <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'a</span> cset id"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_id <span class="main">(</span>csingle <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'a</span> cset id"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">this</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_id <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> return_id <span class="main">(</span>csingle <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> return_id <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> cset"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_id <span class="main">(</span>cUn <span class="skolem">A</span> <span class="skolem">B</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> bind_id <span class="main">(</span>merge_id <span class="skolem">A</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A'</span><span class="main">.</span> bind_id <span class="main">(</span>merge_id <span class="skolem">B</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B'</span><span class="main">.</span> return_id <span class="main">(</span>cUn <span class="bound">A'</span> <span class="bound">B'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="skolem">B</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> cset id"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cUNION_cUn<span class="main">)</span>   
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_id <span class="main">(</span>cUNION <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> merge_id <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> merge_id <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> cset"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'a</span> cset id"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> id.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def cUNION_assoc<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_cset <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> merge_id merge_id"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool"</span></span>
    <span class="keyword1"><span class="command">unfolding</span></span> merge_id_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">paragraph</span></span> <span class="quoted"><span class="plain_text">‹Reader monad transformer›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">merge_env</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'c</span> cset<span class="main">)</span> merge <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">,</span> <span class="tfree">'c</span> cset<span class="main">)</span> merge"</span></span> <span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">merge_env</span> <span class="free"><span class="bound"><span class="entity">merge</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> EnvT <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">merge</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> run_env <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">a</span><span class="main">)</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">merge</span>

<span class="keyword1" id="Monomorphic_Monad-run_merge_env"><span class="command">lemma</span></span> run_merge_env <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>merge_env <span class="free">merge</span> <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> <span class="free">merge</span> <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">f</span> <span class="bound">a</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">merge</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> merge_env_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-merge_env_parametric"><span class="command">lemma</span></span> merge_env_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_cset <span class="free">C</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">C</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_cset <span class="free">C</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">C</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_envT <span class="free">R</span> <span class="free">M</span><span class="main">)</span>
   merge_env merge_env"</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> merge_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-cset_nondetM_envT"><span class="command">lemma</span></span> cset_nondetM_envT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> cset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span> 
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> cset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">merge</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'a</span> cset<span class="main">)</span> merge"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> <span class="free">mergec</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">,</span> <span class="tfree">'c</span> cset<span class="main">)</span> merge"</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cset_nondetM <span class="free">return</span> <span class="free">bind</span> <span class="free">merge</span> <span class="free">mergec</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"cset_nondetM <span class="main">(</span>return_env <span class="free">return</span><span class="main">)</span> <span class="main">(</span>bind_env <span class="free">bind</span><span class="main">)</span> <span class="main">(</span>merge_env <span class="free">merge</span><span class="main">)</span> <span class="main">(</span>merge_env <span class="free">mergec</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> cset_nondetM <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">merge</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">including</span></span> lifting_syntax
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="free">bind</span> <span class="main">(</span>merge_env <span class="free">merge</span> <span class="skolem">y</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> merge_env <span class="free">merge</span> <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span>
      merge_env <span class="free">merge</span> <span class="skolem">y</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_env <span class="free">bind</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> merge_env <span class="free">merge</span> <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff cUNION_assoc bind_merge_merge<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_env <span class="free">merge</span> cempty <span class="skolem">f</span> <span class="main">=</span> return_env <span class="free">return</span> cempty"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff merge_empty<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_env <span class="free">merge</span> <span class="main">(</span>csingle <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff merge_single<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_env <span class="free">merge</span> <span class="skolem">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> return_env <span class="free">return</span> <span class="main">(</span>csingle <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> return_env <span class="free">return</span> <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff merge_single2<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_env <span class="free">merge</span> <span class="main">(</span>cUn <span class="skolem">A</span> <span class="skolem">B</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span>
      bind_env <span class="free">bind</span> <span class="main">(</span>merge_env <span class="free">merge</span> <span class="skolem">A</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A'</span><span class="main">.</span> bind_env <span class="free">bind</span> <span class="main">(</span>merge_env <span class="free">merge</span> <span class="skolem">B</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B'</span><span class="main">.</span> return_env <span class="free">return</span> <span class="main">(</span>cUn <span class="bound">A'</span> <span class="bound">B'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="skolem">B</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff merge_union<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_env <span class="free">bind</span> <span class="main">(</span>merge_env <span class="free">mergec</span> <span class="skolem">y</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> merge_env <span class="free">merge</span> <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span>
      merge_env <span class="free">mergec</span> <span class="skolem">y</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_env <span class="free">bind</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> merge_env <span class="free">merge</span> <span class="bound">A</span> <span class="skolem">g</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">y</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff cUNION_assoc bind_mergec_merge<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_env <span class="free">mergec</span> <span class="main">(</span>csingle <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff mergec_single<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"merge_env <span class="free">mergec</span> <span class="main">(</span>cUNION <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> merge_env <span class="free">mergec</span> <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> merge_env <span class="free">mergec</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">f</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> envT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff mergec_UNION<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_cset <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">(</span>merge_env <span class="free">mergec</span><span class="main">)</span> <span class="main">(</span>merge_env <span class="free">mergec</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span>
      <span class="keyword1"><span class="command">unfolding</span></span> merge_env_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>



<span class="comment1">(* paragraph ‹Exception monad transformer›

text ‹Failure in the non-determinism transformer is absorbed by choice. So there is no way to handle 
  failures. In contrast, in this combination, we choose that failures abort all choices.›

context
  fixes return :: "('a cset option, 'm) return"
    and bind :: "('a cset option, 'm) bind"
    and merge :: "('a option, 'm, 'a option cset) merge"
begin

definition merge_option :: "('a, ('a cset, 'm) optionT, 'a cset) merge" where
  "merge_option A f = 
  OptionT (merge (cimage Some A) (λx. case x of None ⇒ return None
                                      | Some x' ⇒ run_option (f x')))"
lemma run_merge_optionT [simp]:
  "run_option (merge_option A f) = 
  merge (cimage Some A) (λx. case x of None ⇒ return None | Some x' ⇒ run_option (f x'))"
  by(simp add: merge_option_def)

definition return_optionT_cset :: "('a option cset, 'm) return" where
  "return_optionT_cset A = (if cin None A then return None else return (Some (cimage the A)))"

definition bind_optionT_cset :: "('a option cset, 'm) bind" where
  "bind_optionT_cset m f = 
   bind m (λx. case x of None ⇒ return None | Some A ⇒ f (cimage Some A))"

(* lemma
  assumes "monad return_optionT_cset bind_optionT_cset"
  shows "monad return bind"
proof -
  interpret monad return_optionT_cset bind_optionT_cset by fact
  show ?thesis
  proof(unfold_locales)
    show "bind (return x) f = f x" for x f
      using return_bind[of "case x of None ⇒ csingle None | Some A ⇒ cimage Some A" ff]
      apply(simp add: bind_optionT_cset_def return_optionT_cset_def split: option.split_asm)
    subgoal for m f g
      using bind_assoc[of m "λA. if cin None A then return None else f (Some (cimage the A))" "λA. if cin None A then return None else g (Some (cimage the A))"]
      apply(simp add: bind_optionT_cset_def)
      apply(subst (asm) if_distrib[where f="λm. bind m _"])
 *)

lemma cset_nondetM_optionT [locale_witness]:
  assumes "monad_commute return bind"
    and "monad_discard return bind"
    and "monad_duplicate return bind"
    and "cset_nondetM return_optionT_cset bind_optionT_cset merge"
  shows "cset_nondetM (return_option return) (bind_option return bind) merge_option"
proof -
  interpret monad_commute return bind by fact
  interpret monad_discard return bind by fact
  interpret monad_duplicate return bind by fact
  interpret *: cset_nondetM return_optionT_cset bind_optionT_cset merge by fact
  show ?thesis
  proof
    show "bind_option return bind (merge_option y f)
        (λA. merge_option A g) =
       merge_option y
        (λx. bind_option return bind (f x) (λA. merge_option A g))" for y f g
      apply(rule optionT.expand)
      apply(simp add: run_bind_option cong del: option.case_cong) *)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹State transformer›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT <span class="main">=</span> StateT <span class="main">(</span><span class="free"><span class="entity">run_state</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span><span class="main">)</span>
  <span class="keyword2"><span class="keyword">for</span></span> rel<span class="main">:</span> rel_stateT'

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We define a more general relator for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span> stateT"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> than the one generated
  by the datatype package such that we can also show parametricity in the state.
›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">rel_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s'</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m'</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s'</span><span class="main">,</span> <span class="tfree">'m'</span><span class="main">)</span> stateT <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">rel_stateT</span> <span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">S</span></span></span> <span class="main">===&gt;</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">)</span> <span class="main">(</span>run_state <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>run_state <span class="free"><span class="bound"><span class="entity">m'</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_stateT_eq"><span class="command">lemma</span></span> rel_stateT_eq <span class="main">[</span><span class="operator">relator_eq</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_stateT <span class="main">(=)</span> <span class="main">(=)</span> <span class="main">=</span> <span class="main">(=)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_stateT_def fun_eq_iff rel_fun_eq <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> stateT.expand<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rel_stateT_mono"><span class="command">lemma</span></span> rel_stateT_mono <span class="main">[</span><span class="operator">relator_mono</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">S'</span> <span class="main">≤</span> <span class="free">S</span><span class="main">;</span> <span class="free">M</span> <span class="main">≤</span> <span class="free">M'</span> <span class="main">⟧</span> <span class="main">⟹</span> rel_stateT <span class="free">S</span> <span class="free">M</span> <span class="main">≤</span> rel_stateT <span class="free">S'</span> <span class="free">M'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> predicate2I<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_stateT_def fun_mono<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> predicate2D<span class="main"><span class="main">]</span></span><span class="main">)</span> 

<span class="keyword1" id="Monomorphic_Monad-StateT_parametric"><span class="command">lemma</span></span> StateT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> StateT StateT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_state_parametric"><span class="command">lemma</span></span> run_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_stateT <span class="free">S</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> run_state run_state"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-case_stateT_parametric"><span class="command">lemma</span></span> case_stateT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> case_stateT case_stateT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> stateT.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_stateT_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> rel_funI <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_funD<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-rec_stateT_parametric"><span class="command">lemma</span></span> rec_stateT_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> rec_stateT rec_stateT"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> … m m' <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">m</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="skolem">m'</span></span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_stateT_def <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> rel_funI <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_funD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-rel_stateT_Grp"><span class="command">lemma</span></span> rel_stateT_Grp<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_stateT <span class="main">(=)</span> <span class="main">(</span>BNF_Def.Grp UNIV <span class="free">f</span><span class="main">)</span> <span class="main">=</span> BNF_Def.Grp UNIV <span class="main">(</span>map_stateT <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff Grp_def rel_stateT_def rel_fun_def stateT.map_sel <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> stateT.expand<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Plain monad, get, and put›</span></span>

<span class="keyword1"><span class="command">context</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">bind_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_state</span> <span class="main">(</span>StateT <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> run_state <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">a</span><span class="main">)</span> <span class="bound">s'</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">return_state</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_state</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_state <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">put_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">put_state</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>StateT <span class="free"><span class="bound"><span class="entity">f</span></span></span><span class="main">)</span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_put_state"><span class="command">lemma</span></span> run_put_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>put_state <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="free">s'</span> <span class="main">=</span> run_state <span class="free">m</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m</span></span><span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1" id="Monomorphic_Monad-run_get_state"><span class="command">lemma</span></span> run_get_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>get_state <span class="free">f</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> run_state <span class="main">(</span><span class="free">f</span> <span class="free">s</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_state_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_bind_state"><span class="command">lemma</span></span> run_bind_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>bind_state <span class="free">x</span> <span class="free">f</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>run_state <span class="free">x</span> <span class="free">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> run_state <span class="main">(</span><span class="free">f</span> <span class="bound">a</span><span class="main">)</span> <span class="bound">s'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">x</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp</span><span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_return_state"><span class="command">lemma</span></span> run_return_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>return_state <span class="free">x</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="free">return</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_state_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> monad<span class="main">:</span> <span class="quoted"><span class="quoted">"monad <span class="free">return</span> <span class="free">bind</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> monad<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_stateT"><span class="command">lemma</span></span> monad_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return_state bind_state"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"monad <span class="var">?return</span> <span class="var">?bind</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?bind</span> <span class="main">(</span><span class="var">?bind</span> <span class="skolem">x</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> <span class="var">?bind</span> <span class="skolem">x</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="var">?bind</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand ext<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc split_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?bind</span> <span class="main">(</span><span class="var">?return</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand ext<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?bind</span> <span class="skolem">x</span> <span class="var">?return</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand ext<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_return<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_stateT"><span class="command">lemma</span></span> monad_state_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state return_state bind_state get_state put_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_state <span class="skolem">s</span> <span class="main">(</span>get_state <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> put_state <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">s</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_state_def fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_state <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> get_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_state <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">s</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_state <span class="skolem">s</span> <span class="main">(</span>put_state <span class="skolem">s'</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> put_state <span class="skolem">s'</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">s'</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'s</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_state <span class="main">(</span><span class="main">λ</span><span class="bound">s</span> <span class="main">::</span> <span class="tfree">'s</span><span class="main">.</span> put_state <span class="bound">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>  
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_state <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>get_state <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> get_state <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bind_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>put_state <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> put_state <span class="skolem">s</span> <span class="main">(</span>bind_state <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'s</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We cannot define a generic lifting operation for state like in Haskell.
  If we separate the monad type variable from the element type variable, then
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lift›</span></span></span></span> should have type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a 'm =&gt; (('a × 's) 'm) stateT›</span></span></span></span>, but this means
  that the type of results must change, which does not work for monomorphic monads.

  Instead, we must lift all operations individually. <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lift_definition›</span></span></span></span> does not work
  because the monad transformer type is typically larger than the base type, but
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lift_definition›</span></span></span></span> only works if the lifted type is no bigger.
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Failure›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fail_state</span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">fail</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_fail_state"><span class="command">lemma</span></span> run_fail_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state fail_state <span class="free">s</span> <span class="main">=</span> <span class="free">fail</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_state_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_stateT"><span class="command">lemma</span></span> monad_fail_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_fail <span class="free">return</span> <span class="free">bind</span> <span class="free">fail</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_fail return_state bind_state fail_state"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"monad_fail <span class="var">?return</span> <span class="var">?bind</span> <span class="var">?fail</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_fail <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?bind</span> <span class="var">?fail</span> <span class="skolem">f</span> <span class="main">=</span> <span class="var">?fail</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff fail_bind<span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">notepad</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
  <span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
    <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>catch›</span></span></span></span> cannot be lifted through the state monad according to <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">monad_catch_state</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
   because there is now way to communicate the state updates to the handler.
  ›</span></span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">catch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> catch"</span></span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">"monad_catch <span class="free">return</span> <span class="free">bind</span> <span class="free">fail</span> <span class="skolem">catch</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">interpret</span></span> monad_catch <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="skolem">catch</span></span> <span class="keyword1"><span class="command">.</span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">catch_state</span></span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT catch"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">"<span class="skolem">catch_state</span> <span class="skolem">m1</span> <span class="skolem">m2</span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">catch</span> <span class="main">(</span>run_state <span class="skolem">m1</span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>run_state <span class="skolem">m2</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m1</span> <span class="skolem">m2</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"monad_catch return_state bind_state fail_state <span class="skolem">catch_state</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">unfold_locales</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> stateT.expand<span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff catch_state_def catch_return catch_fail catch_fail2 catch_assoc<span class="main">)</span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Reader›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ask</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ask_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ask_state</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_state <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">r</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_ask_state"><span class="command">lemma</span></span> run_ask_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>ask_state <span class="free">f</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_state <span class="main">(</span><span class="free">f</span> <span class="bound">r</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_state_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_reader_stateT"><span class="command">lemma</span></span> monad_reader_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_reader <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_reader return_state bind_state ask_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_reader <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_state <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> ask_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ask_state <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">r</span> <span class="bound">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'r</span> <span class="main">⇒</span> <span class="tfree">'r</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff ask_ask<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_state <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff ask_const<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>ask_state <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> ask_state <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> bind_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_ask<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_state <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ask_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ask_state <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> bind_state <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_ask2 split_def<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_reader_state_stateT"><span class="command">lemma</span></span> monad_reader_state_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_reader <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_reader_state return_state bind_state ask_state get_state put_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_reader <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_state <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> get_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_state <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> ask_state <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">r</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_state <span class="skolem">m</span> <span class="main">(</span>ask_state <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> ask_state <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> put_state <span class="skolem">m</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Probability›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">altc_sample_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'x</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'x</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">altc_sample_state</span> <span class="free"><span class="bound"><span class="entity">altc_sample</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">altc_sample</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_state <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_altc_sample_state"><span class="command">lemma</span></span> run_altc_sample_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>altc_sample_state <span class="free">altc_sample</span> <span class="free">p</span> <span class="free">f</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="free">altc_sample</span> <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_state <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_sample_state_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sample_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> sample"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">sample_state</span> <span class="main">≡</span> altc_sample_state <span class="free">sample</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_prob <span class="free">return</span> <span class="free">bind</span> <span class="free">sample</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad_prob <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">sample</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span><span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_prob_stateT"><span class="command">lemma</span></span> monad_prob_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_prob return_state bind_state sample_state"</span></span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">note</span></span> sample_parametric<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_state <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff sample_const<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_state <span class="main">(</span>return_pmf <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff sample_return_pmf<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_state <span class="main">(</span>bind_pmf <span class="skolem">p</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> sample_state <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> sample_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff sample_bind_pmf<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_state <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> sample_state <span class="skolem">q</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sample_state <span class="skolem">q</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> sample_state <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">q</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sample_commute<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>sample_state <span class="skolem">p</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> sample_state <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_sample1<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_state <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> sample_state <span class="skolem">p</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sample_state <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_state <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">p</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_sample2 split_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_pmf <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> sample_state sample_state"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="keyword1"><span class="command">unfolding</span></span> altc_sample_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_prob_stateT"><span class="command">lemma</span></span> monad_state_prob_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_prob return_state bind_state get_state put_state sample_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_state <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> get_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_state <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> sample_state <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Writer›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">tell</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tell_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tell_state</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">tell</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">(</span>run_state <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_tell_state"><span class="command">lemma</span></span> run_tell_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>tell_state <span class="free">w</span> <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="free">tell</span> <span class="free">w</span> <span class="main">(</span>run_state <span class="free">m</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tell_state_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_writer_stateT"><span class="command">lemma</span></span> monad_writer_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_writer <span class="free">return</span> <span class="free">bind</span> <span class="free">tell</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_writer return_state bind_state tell_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_writer <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">tell</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>tell_state <span class="skolem">w</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> tell_state <span class="skolem">w</span> <span class="main">(</span>bind_state <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">w</span> <span class="skolem">m</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_tell fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Binary Non-determinism›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> alt"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">alt_state</span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">alt</span> <span class="main">(</span>run_state <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="main">(</span>run_state <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_alt_state"><span class="command">lemma</span></span> run_alt_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>alt_state <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="free">alt</span> <span class="main">(</span>run_state <span class="free">m1</span> <span class="free">s</span><span class="main">)</span> <span class="main">(</span>run_state <span class="free">m2</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_state_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_alt <span class="free">return</span> <span class="free">bind</span> <span class="free">alt</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">alt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

<span class="keyword1" id="Monomorphic_Monad-monad_alt_stateT"><span class="command">lemma</span></span> monad_alt_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_alt return_state bind_state alt_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_state <span class="main">(</span>alt_state <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span> <span class="skolem">m3</span> <span class="main">=</span> alt_state <span class="skolem">m1</span> <span class="main">(</span>alt_state <span class="skolem">m2</span> <span class="skolem">m3</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m1</span> <span class="skolem">m2</span> <span class="skolem">m3</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_assoc fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>alt_state <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> alt_state <span class="main">(</span>bind_state <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>bind_state <span class="skolem">m'</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_alt1 fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_alt_stateT"><span class="command">lemma</span></span> monad_state_alt_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_alt return_state bind_state get_state put_state alt_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_state <span class="main">(</span>get_state <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>get_state <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> get_state <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> alt_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_state <span class="main">(</span>put_state <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span>put_state <span class="skolem">s</span> <span class="skolem">m'</span><span class="main">)</span> <span class="main">=</span> put_state <span class="skolem">s</span> <span class="main">(</span>alt_state <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_alt_stateT"><span class="command">lemma</span></span> monad_fail_alt_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fail</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_fail_alt <span class="free">return</span> <span class="free">bind</span> <span class="free">fail</span> <span class="free">alt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_fail_alt return_state bind_state <span class="main">(</span>fail_state <span class="free">fail</span><span class="main">)</span> alt_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_fail_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">alt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span>  <span class="quoted"><span class="quoted">"alt_state <span class="main">(</span>fail_state <span class="free">fail</span><span class="main">)</span> <span class="skolem">m</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff alt_fail1<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_state <span class="skolem">m</span> <span class="main">(</span>fail_state <span class="free">fail</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff alt_fail2<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Countable Non-determinism›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">altc_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">altc_state</span> <span class="main">≡</span> altc_sample_state <span class="free">altc</span>"</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_altc <span class="free">return</span> <span class="free">bind</span> <span class="free">altc</span>"</span></span> 
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

<span class="keyword1" id="Monomorphic_Monad-monad_altc_stateT"><span class="command">lemma</span></span> monad_altc_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_altc return_state bind_state altc_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword1"><span class="command">note</span></span> altc_parametric<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>altc_state <span class="skolem">C</span> <span class="skolem">g</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> altc_state <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> bind_state <span class="main">(</span><span class="skolem">g</span> <span class="bound">c</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">g</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_altc1<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_state <span class="main">(</span>csingle <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff altc_single<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_state <span class="main">(</span>cUNION <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> altc_state <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> altc_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff altc_cUNION<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_cset <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> altc_state altc_state"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span>
    <span class="keyword1"><span class="command">unfolding</span></span> altc_sample_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_altc_stateT"><span class="command">lemma</span></span> monad_state_altc_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_altc return_state bind_state get_state put_state altc_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_state <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> get_state <span class="main">(</span><span class="skolem">f</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_state <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> altc_state <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">c</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_state <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> put_state <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> put_state <span class="skolem">s</span> <span class="main">(</span>altc_state <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">s</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_altc3_stateT"><span class="command">lemma</span></span> monad_altc3_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_altc3 <span class="free">return</span> <span class="free">bind</span> <span class="free">altc</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_altc3 return_state bind_state altc_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_altc3 <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Resumption›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pause</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pause_state</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pause_state</span> <span class="free"><span class="bound"><span class="entity">out</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> StateT <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">pause</span> <span class="free"><span class="bound"><span class="entity">out</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> run_state <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="bound">i</span><span class="main">)</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_pause_state"><span class="command">lemma</span></span> run_pause_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>pause_state <span class="free">out</span> <span class="free">c</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> <span class="free">pause</span> <span class="free">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> run_state <span class="main">(</span><span class="free">c</span> <span class="bound">i</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pause_state_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_resumption_stateT"><span class="command">lemma</span></span> monad_resumption_stateT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_resumption <span class="free">return</span> <span class="free">bind</span> <span class="free">pause</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_resumption return_state bind_state pause_state"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_resumption <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">pause</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>pause_state <span class="skolem">out</span> <span class="skolem">c</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> pause_state <span class="skolem">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> bind_state <span class="main">(</span><span class="skolem">c</span> <span class="bound">i</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">out</span> <span class="skolem">c</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> stateT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff bind_pause<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Parametricity›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-return_state_parametric"><span class="command">lemma</span></span> return_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_prod <span class="free">A</span> <span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> return_state return_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-bind_state_parametric"><span class="command">lemma</span></span> bind_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span>rel_prod <span class="free">A</span> <span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span>
   bind_state bind_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-get_state_parametric"><span class="command">lemma</span></span> get_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> get_state get_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> get_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-put_state_parametric"><span class="command">lemma</span></span> put_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> put_state put_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> put_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-fail_state_parametric"><span class="command">lemma</span></span> fail_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> fail_state fail_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fail_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-ask_state_parametric"><span class="command">lemma</span></span> ask_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> ask_state ask_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ask_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-altc_sample_state_parametric"><span class="command">lemma</span></span> altc_sample_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">X</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">P</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">X</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">P</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span>
   altc_sample_state altc_sample_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> altc_sample_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-tell_state_parametric"><span class="command">lemma</span></span> tell_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">W</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">W</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span>
   tell_state tell_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> tell_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-alt_state_parametric"><span class="command">lemma</span></span> alt_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span>
   alt_state alt_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> alt_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-pause_state_parametric"><span class="command">lemma</span></span> pause_state_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Out</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">In</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">Out</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">In</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_stateT <span class="free">S</span> <span class="free">M</span><span class="main">)</span>
   pause_state pause_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> pause_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Writer monad transformer›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  We implement a simple writer monad which collects all the output in a list. It would also have
  been possible to use a monoid instead. The phantom type variables <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="tfree"><span class="quoted"><span class="tfree">'w</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> are needed to
  avoid hidden polymorphism when overloading the monad operations for the writer monad
  transformer.
›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT <span class="main">=</span> WriterT <span class="main">(</span><span class="free"><span class="entity">run_writer</span></span><span class="main">:</span> <span class="tfree"><span class="quoted"><span class="tfree">'m</span></span></span><span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">return_writer</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> WriterT <span class="main">(</span><span class="free">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_writer</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> WriterT <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>run_writer <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">ws</span><span class="main">)</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>run_writer <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">ws'</span><span class="main">)</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">ws</span> <span class="main">@</span> <span class="bound">ws'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tell_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">tell_writer</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> WriterT <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>run_writer <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">ws</span><span class="main">)</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">w</span></span></span> <span class="main">#</span> <span class="bound">ws</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_return_writer"><span class="command">lemma</span></span> run_return_writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>return_writer <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="main">[]</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_writer_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_bind_writer"><span class="command">lemma</span></span> run_bind_writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>bind_writer <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>run_writer <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">ws</span><span class="main">)</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>run_writer <span class="main">(</span><span class="free">f</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">ws'</span><span class="main">)</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">ws</span> <span class="main">@</span> <span class="bound">ws'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_writer_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_tell_writer"><span class="command">lemma</span></span> run_tell_writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>tell_writer <span class="free">w</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>run_writer <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">ws</span><span class="main">)</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="free">w</span> <span class="main">#</span> <span class="bound">ws</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tell_writer_def<span class="main">)</span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad <span class="free">return</span> <span class="free">bind</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>

<span class="keyword1" id="Monomorphic_Monad-monad_writerT"><span class="command">lemma</span></span> monad_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return_writer bind_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="main">(</span>bind_writer <span class="skolem">x</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> bind_writer <span class="skolem">x</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> bind_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">y</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc split_def return_bind<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="main">(</span>return_writer <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span>  <span class="skolem">x</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_return return_bind<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="skolem">x</span> return_writer <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_return return_bind<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_writer_writerT"><span class="command">lemma</span></span> monad_writer_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_writer return_writer bind_writer tell_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="main">(</span>tell_writer <span class="skolem">w</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> tell_writer <span class="skolem">w</span> <span class="main">(</span>bind_writer <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">w</span> <span class="skolem">m</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc split_def return_bind<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Failure›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fail_writer</span> <span class="main">=</span> WriterT <span class="free">fail</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_fail_writer"><span class="command">lemma</span></span> run_fail_writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer fail_writer <span class="main">=</span> <span class="free">fail</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_writer_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_writerT"><span class="command">lemma</span></span> monad_fail_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_fail <span class="free">return</span> <span class="free">bind</span> <span class="free">fail</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_fail return_writer bind_writer fail_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_fail <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer fail_writer <span class="skolem">f</span> <span class="main">=</span> fail_writer"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_bind<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  Just like for the state monad, we cannot lift <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">catch</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because the output before the failure would be lost.
›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹State›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_writer</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> WriterT <span class="main">(</span><span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">put_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">put_writer</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> WriterT <span class="main">(</span><span class="free">put</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>run_writer <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_get_writer"><span class="command">lemma</span></span> run_get_writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>get_writer <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_writer_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_put_writer"><span class="command">lemma</span></span> run_put_writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>put_writer <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span>run_writer <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_writer_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_writerT"><span class="command">lemma</span></span> monad_state_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state return_writer bind_writer get_writer put_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_writer <span class="skolem">s</span> <span class="main">(</span>get_writer <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> put_writer <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_writer <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> get_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_writer <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">s</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_writer <span class="skolem">s</span> <span class="main">(</span>put_writer <span class="skolem">s'</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> put_writer <span class="skolem">s'</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">s'</span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_put<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_writer <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> put_writer <span class="bound">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_put<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_writer <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_const<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="main">(</span>get_writer <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> get_writer <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bind_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="main">(</span>put_writer <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> put_writer <span class="skolem">s</span> <span class="main">(</span>bind_writer <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">m</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_put<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span>  <span class="quoted"><span class="plain_text">‹Probability›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">altc_sample_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'x</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'x</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">altc_sample_writer</span> <span class="free"><span class="bound"><span class="entity">altc_sample</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> WriterT <span class="main">(</span><span class="free"><span class="bound"><span class="entity">altc_sample</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_altc_sample_writer"><span class="command">lemma</span></span> run_altc_sample_writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>altc_sample_writer <span class="free">altc_sample</span> <span class="free">p</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">altc_sample</span> <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">p</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free">f</span> <span class="bound">p</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_sample_writer_def<span class="main">)</span>


<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">sample_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sample_writer</span> <span class="main">≡</span> altc_sample_writer <span class="free">sample</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_prob_writerT"><span class="command">lemma</span></span> monad_prob_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_prob <span class="free">return</span> <span class="free">bind</span> <span class="free">sample</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_prob return_writer bind_writer sample_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_prob <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">sample</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">note</span></span> sample_parametric<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">including</span></span> lifting_syntax
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_writer <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_const<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_writer <span class="main">(</span>return_pmf <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_return_pmf<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_writer <span class="main">(</span><span class="skolem">p</span> <span class="main">⤜</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> sample_writer <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> sample_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_bind_pmf<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_writer <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> sample_writer <span class="skolem">q</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sample_writer <span class="skolem">q</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> sample_writer <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">q</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> sample_commute<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="main">(</span>sample_writer <span class="skolem">p</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> sample_writer <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_sample1<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> sample_writer <span class="skolem">p</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sample_writer <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> bind_writer <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">y</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">p</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_sample2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> bind_sample1 split_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_pmf <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> sample_writer sample_writer"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="keyword1"><span class="command">unfolding</span></span> altc_sample_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_prob_writerT"><span class="command">lemma</span></span> monad_state_prob_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state_prob <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span> <span class="free">sample</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state_prob return_writer bind_writer get_writer put_writer sample_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state_prob <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">sample</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"sample_writer <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> get_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_writer <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> sample_writer <span class="skolem">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">p</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_get<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Reader›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">ask</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ask_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">ask_writer</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> WriterT <span class="main">(</span><span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_ask_writer"><span class="command">lemma</span></span> run_ask_writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>ask_writer <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_writer_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_reader_writerT"><span class="command">lemma</span></span> monad_reader_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_reader <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_reader return_writer bind_writer ask_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_reader <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_writer <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> ask_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ask_writer <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">r</span> <span class="bound">r</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_ask<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_writer <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_const<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="main">(</span>ask_writer <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> ask_writer <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> bind_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_ask<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ask_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> ask_writer <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> bind_writer <span class="skolem">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">x</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def bind_ask2<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> bind_ask<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_reader_state_writerT"><span class="command">lemma</span></span> monad_reader_state_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_reader_state <span class="free">return</span> <span class="free">bind</span> <span class="free">ask</span> <span class="free">get</span> <span class="free">put</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_reader_state return_writer bind_writer ask_writer get_writer put_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_reader_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"ask_writer <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> get_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_writer <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> ask_writer <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">r</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_writer <span class="skolem">s</span> <span class="main">(</span>ask_writer <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> ask_writer <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> put_writer <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_ask<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Resumption›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">pause</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pause_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">pause_writer</span> <span class="free"><span class="bound"><span class="entity">out</span></span></span> <span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="main">=</span> WriterT <span class="main">(</span><span class="free">pause</span> <span class="free"><span class="bound"><span class="entity">out</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">input</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free"><span class="bound"><span class="entity">c</span></span></span> <span class="bound">input</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_pause_writer"><span class="command">lemma</span></span> run_pause_writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>pause_writer <span class="free">out</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">pause</span> <span class="free">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">input</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free">c</span> <span class="bound">input</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pause_writer_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_resumption_writerT"><span class="command">lemma</span></span> monad_resumption_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_resumption <span class="free">return</span> <span class="free">bind</span> <span class="free">pause</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_resumption return_writer bind_writer pause_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_resumption <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">pause</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="main">(</span>pause_writer <span class="skolem">out</span> <span class="skolem">c</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> pause_writer <span class="skolem">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> bind_writer <span class="main">(</span><span class="skolem">c</span> <span class="bound">i</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">out</span> <span class="skolem">c</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_pause<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Binary Non-determinism›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">alt</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> alt"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">alt_writer</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">m'</span></span></span> <span class="main">=</span> WriterT <span class="main">(</span><span class="free">alt</span> <span class="main">(</span>run_writer <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span> <span class="main">(</span>run_writer <span class="free"><span class="bound"><span class="entity">m'</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_alt_writer"><span class="command">lemma</span></span> run_alt_writer <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>alt_writer <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> <span class="free">alt</span> <span class="main">(</span>run_writer <span class="free">m</span><span class="main">)</span> <span class="main">(</span>run_writer <span class="free">m'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_writer_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_alt_writerT"><span class="command">lemma</span></span> monad_alt_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_alt <span class="free">return</span> <span class="free">bind</span> <span class="free">alt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_alt return_writer bind_writer alt_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">alt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_writer <span class="main">(</span>alt_writer <span class="skolem">m1</span> <span class="skolem">m2</span><span class="main">)</span> <span class="skolem">m3</span> <span class="main">=</span> alt_writer <span class="skolem">m1</span> <span class="main">(</span>alt_writer <span class="skolem">m2</span> <span class="skolem">m3</span><span class="main">)</span>"</span></span> 
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m1</span> <span class="skolem">m2</span> <span class="skolem">m3</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_assoc<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="main">(</span>alt_writer <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> alt_writer <span class="main">(</span>bind_writer <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>bind_writer <span class="skolem">m'</span> <span class="skolem">f</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_alt1<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_alt_writerT"><span class="command">lemma</span></span> monad_fail_alt_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_fail_alt <span class="free">return</span> <span class="free">bind</span> <span class="free">fail</span> <span class="free">alt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_fail_alt return_writer bind_writer fail_writer alt_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_fail_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">alt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_writer fail_writer <span class="skolem">m</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_fail1<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_writer <span class="skolem">m</span> fail_writer <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_fail2<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_alt_writerT"><span class="command">lemma</span></span> monad_state_alt_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state_alt <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span> <span class="free">alt</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state_alt return_writer bind_writer get_writer put_writer alt_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state_alt <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">alt</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_writer <span class="main">(</span>get_writer <span class="skolem">f</span><span class="main">)</span> <span class="main">(</span>get_writer <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> get_writer <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> alt_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">g</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">g</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"alt_writer <span class="main">(</span>put_writer <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">(</span>put_writer <span class="skolem">s</span> <span class="skolem">m'</span><span class="main">)</span> <span class="main">=</span> put_writer <span class="skolem">s</span> <span class="main">(</span>alt_writer <span class="skolem">m</span> <span class="skolem">m'</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">m</span> <span class="skolem">m'</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_put<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Countable Non-determinism›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">altc_writer</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">altc_writer</span> <span class="main">≡</span> altc_sample_writer <span class="free">altc</span>"</span></span>


<span class="keyword1" id="Monomorphic_Monad-monad_altc_writerT"><span class="command">lemma</span></span> monad_altc_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_altc <span class="free">return</span> <span class="free">bind</span> <span class="free">altc</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_altc return_writer bind_writer altc_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword1"><span class="command">note</span></span> altc_parametric<span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">including</span></span> lifting_syntax
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_writer <span class="main">(</span>altc_writer <span class="skolem">C</span> <span class="skolem">g</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> altc_writer <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> bind_writer <span class="main">(</span><span class="skolem">g</span> <span class="bound">c</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">g</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_altc1 o_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_writer <span class="main">(</span>csingle <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_single<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_writer <span class="main">(</span>cUNION <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> altc_writer <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> altc_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">f</span> <span class="skolem">g</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_cUNION o_def<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_cset <span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="skolem">R</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> altc_writer altc_writer"</span></span>
      <span class="keyword2"><span class="keyword">if</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"bi_unique <span class="skolem">R</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">R</span> <span class="keyword1"><span class="command">unfolding</span></span> altc_sample_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_altc3_writerT"><span class="command">lemma</span></span> monad_altc3_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_altc3 <span class="free">return</span> <span class="free">bind</span> <span class="free">altc</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_altc3 return_writer bind_writer altc_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_altc3 <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">..</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_altc_writerT"><span class="command">lemma</span></span> monad_state_altc_writerT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state_altc <span class="free">return</span> <span class="free">bind</span> <span class="free">get</span> <span class="free">put</span> <span class="free">altc</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state_altc return_writer bind_writer get_writer put_writer altc_writer"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">fact</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_writer <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> get_writer <span class="main">(</span><span class="skolem">f</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_writer <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> altc_writer <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">c</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def altc_get<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"altc_writer <span class="skolem">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">c</span><span class="main">.</span> put_writer <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">c</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> put_writer <span class="skolem">s</span> <span class="main">(</span>altc_writer <span class="skolem">C</span> <span class="skolem">f</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">C</span> <span class="skolem">s</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> writerT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> o_def altc_put<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Parametricity›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-return_writer_parametric"><span class="command">lemma</span></span> return_writer_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_prod <span class="free">A</span> <span class="main">(</span>list_all2 <span class="free">W</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span> return_writer return_writer"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-bind_writer_parametric"><span class="command">lemma</span></span> bind_writer_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_prod <span class="free">A</span> <span class="main">(</span>list_all2 <span class="free">W</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span>rel_prod <span class="free">A</span> <span class="main">(</span>list_all2 <span class="free">W</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span>
   <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span>
   bind_writer bind_writer"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-tell_writer_parametric"><span class="command">lemma</span></span> tell_writer_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>rel_prod <span class="free">A</span> <span class="main">(</span>list_all2 <span class="free">W</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span>rel_prod <span class="free">A</span> <span class="main">(</span>list_all2 <span class="free">W</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span>
   <span class="main">===&gt;</span> <span class="free">W</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span>
   tell_writer tell_writer"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> tell_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-ask_writer_parametric"><span class="command">lemma</span></span> ask_writer_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">R</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span> ask_writer ask_writer"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ask_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-fail_writer_parametric"><span class="command">lemma</span></span> fail_writer_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span> fail_writer fail_writer"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fail_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-get_writer_parametric"><span class="command">lemma</span></span> get_writer_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span> get_writer get_writer"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> get_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-put_writer_parametric"><span class="command">lemma</span></span> put_writer_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">S</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">S</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span> put_writer put_writer"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> put_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-altc_sample_writer_parametric"><span class="command">lemma</span></span> altc_sample_writer_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">X</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">P</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">X</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">P</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span>
  altc_sample_writer altc_sample_writer"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> altc_sample_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-alt_writer_parametric"><span class="command">lemma</span></span> alt_writer_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span>
   alt_writer alt_writer"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> alt_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-pause_writer_parametric"><span class="command">lemma</span></span> pause_writer_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">Out</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">In</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">Out</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">In</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_writerT <span class="free">W</span> <span class="free">A</span> <span class="free">M</span><span class="main">)</span>
   pause_writer pause_writer"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> pause_writer_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Continuation monad transformer›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT <span class="main">=</span> ContT <span class="main">(</span><span class="free"><span class="entity">run_cont</span></span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹CallCC›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> callcc <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">callcc_cont</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> callcc"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">callcc_cont</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> ContT <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> run_cont <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ContT <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">k</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="bound">k</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_callcc_cont"><span class="command">lemma</span></span> run_callcc_cont <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_cont <span class="main">(</span>callcc_cont <span class="free">f</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> run_cont <span class="main">(</span><span class="free">f</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> ContT <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">k</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> <span class="free">k</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> callcc_cont_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Plain monad›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_cont</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">return_cont</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> ContT <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="bound">k</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_cont</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind_cont</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> ContT <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> run_cont <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_cont <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">x</span><span class="main">)</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_return_cont"><span class="command">lemma</span></span> run_return_cont <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_cont <span class="main">(</span>return_cont <span class="free">x</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> <span class="free">k</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_cont_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_bind_cont"><span class="command">lemma</span></span> run_bind_cont <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_cont <span class="main">(</span>bind_cont <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> run_cont <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_cont <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_cont_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_contT"><span class="command">lemma</span></span> monad_contT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return_cont bind_cont"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"monad <span class="var">?return</span> <span class="var">?bind</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?bind</span> <span class="main">(</span><span class="var">?bind</span> <span class="skolem">x</span> <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> <span class="var">?bind</span> <span class="skolem">x</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="var">?bind</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span> <span class="skolem">g</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?bind</span> <span class="main">(</span><span class="var">?return</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> <span class="skolem">f</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?bind</span> <span class="skolem">x</span> <span class="var">?return</span> <span class="main">=</span> <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Failure›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_cont</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fail_cont</span> <span class="main">=</span> ContT <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">fail</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_fail_cont"><span class="command">lemma</span></span> run_fail_cont <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_cont fail_cont <span class="free">k</span> <span class="main">=</span> <span class="free">fail</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_cont_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_fail_contT"><span class="command">lemma</span></span> monad_fail_contT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_fail return_cont bind_cont fail_cont"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_cont fail_cont <span class="skolem">f</span> <span class="main">=</span> fail_cont"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹State›</span></span>

<span class="keyword1"><span class="command">context</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_cont</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">get_cont</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="main">=</span> ContT <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_cont <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="bound">s</span><span class="main">)</span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">put_cont</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">put_cont</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> ContT <span class="main">(</span><span class="main">λ</span><span class="bound">k</span><span class="main">.</span> <span class="free">put</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="main">(</span>run_cont <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="bound">k</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-run_get_cont"><span class="command">lemma</span></span> run_get_cont <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_cont <span class="main">(</span>get_cont <span class="free">f</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_cont <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_cont_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-run_put_cont"><span class="command">lemma</span></span> run_put_cont <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_cont <span class="main">(</span>put_cont <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="free">k</span> <span class="main">=</span> <span class="free">put</span> <span class="free">s</span> <span class="main">(</span>run_cont <span class="free">m</span> <span class="free">k</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_cont_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-monad_state_contT"><span class="command">lemma</span></span> monad_state_contT <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"monad_state <span class="free">return'</span> <span class="free">bind'</span> <span class="free">get</span> <span class="free">put</span>"</span></span> <span class="comment1">― ‹We don't need the plain monad operations for lifting.›</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"monad_state return_cont bind_cont get_cont <span class="main">(</span>put_cont <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> put<span class="main">)</span>"</span></span>
  <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"monad_state <span class="var">?return</span> <span class="var">?bind</span> <span class="var">?get</span> <span class="var">?put</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">interpret</span></span> monad_state <span class="quoted"><span class="free">return'</span></span> <span class="quoted"><span class="free">bind'</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> assms<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
  <span class="keyword1"><span class="command">proof</span></span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_cont <span class="skolem">s</span> <span class="main">(</span>get_cont <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> put_cont <span class="skolem">s</span> <span class="main">(</span><span class="skolem">f</span> <span class="skolem">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'s</span></span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_get fun_eq_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_cont <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> get_cont <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> get_cont <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">s</span> <span class="bound">s</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_get fun_eq_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"put_cont <span class="skolem">s</span> <span class="main">(</span>put_cont <span class="skolem">s'</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> put_cont <span class="skolem">s'</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="skolem">s'</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_put fun_eq_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_cont <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> put_cont <span class="bound">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_put fun_eq_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"get_cont <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_const fun_eq_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_cont <span class="main">(</span>get_cont <span class="skolem">f</span><span class="main">)</span> <span class="skolem">g</span> <span class="main">=</span> get_cont <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> bind_cont <span class="main">(</span><span class="skolem">f</span> <span class="bound">s</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
      <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">g</span> 
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"bind_cont <span class="main">(</span>put_cont <span class="skolem">s</span> <span class="skolem">m</span><span class="main">)</span> <span class="skolem">f</span> <span class="main">=</span> put_cont <span class="skolem">s</span> <span class="main">(</span>bind_cont <span class="skolem">m</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">s</span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">m</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> contT.expand<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff<span class="main">)</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Locales for monad homomorphisms›</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_hom <span class="main">=</span> m1<span class="main">:</span> monad <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="main">+</span>
  m2<span class="main">:</span> monad <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">return2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hom_return<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="free">h</span> <span class="main">(</span><span class="free">return1</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">return2</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> hom_bind<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">f</span><span class="main">.</span> <span class="free">h</span> <span class="main">(</span><span class="free">bind1</span> <span class="bound">x</span> <span class="bound">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind2</span> <span class="main">(</span><span class="free">h</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">h</span> <span class="main">∘</span> <span class="bound">f</span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Monomorphic_Monad-hom_lift"><span class="command">lemma</span></span> hom_lift <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span>m1.lift <span class="free">f</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> m2.lift <span class="free">f</span> <span class="main">(</span><span class="free">h</span> <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> m1.lift_def m2.lift_def hom_bind hom_return o_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_state_hom <span class="main">=</span> m1<span class="main">:</span> monad_state <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">get1</span></span> <span class="quoted"><span class="free">put1</span></span> <span class="main">+</span> 
  m2<span class="main">:</span> monad_state <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">get2</span></span> <span class="quoted"><span class="free">put2</span></span> <span class="main">+</span>
  monad_hom <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">h</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">return2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hom_get <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span><span class="free">get1</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">get2</span> <span class="main">(</span><span class="free">h</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> hom_put <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span><span class="free">put1</span> <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">put2</span> <span class="free">s</span> <span class="main">(</span><span class="free">h</span> <span class="free">m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_fail_hom <span class="main">=</span> m1<span class="main">:</span> monad_fail <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">fail1</span></span> <span class="main">+</span> 
  m2<span class="main">:</span> monad_fail <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">fail2</span></span> <span class="main">+</span>
  monad_hom <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">h</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">return2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m2</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hom_fail <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="free">fail1</span> <span class="main">=</span> <span class="free">fail2</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_catch_hom <span class="main">=</span> m1<span class="main">:</span> monad_catch <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">fail1</span></span> <span class="quoted"><span class="free">catch1</span></span> <span class="main">+</span>
  m2<span class="main">:</span> monad_catch <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">fail2</span></span> <span class="quoted"><span class="free">catch2</span></span> <span class="main">+</span>
  monad_fail_hom <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">fail1</span></span> <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">fail2</span></span> <span class="quoted"><span class="free">h</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">catch1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> catch"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">return2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m2</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">catch2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m2</span> catch"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hom_catch <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span><span class="free">catch1</span> <span class="free">m1</span> <span class="free">m2</span><span class="main">)</span> <span class="main">=</span> <span class="free">catch2</span> <span class="main">(</span><span class="free">h</span> <span class="free">m1</span><span class="main">)</span> <span class="main">(</span><span class="free">h</span> <span class="free">m2</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_reader_hom <span class="main">=</span> m1<span class="main">:</span> monad_reader <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">ask1</span></span> <span class="main">+</span>
  m2<span class="main">:</span> monad_reader <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">ask2</span></span> <span class="main">+</span>
  monad_hom <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">h</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">ask1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> ask"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">return2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">ask2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> ask"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hom_ask <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span><span class="free">ask1</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">ask2</span> <span class="main">(</span><span class="free">h</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_prob_hom <span class="main">=</span> m1<span class="main">:</span> monad_prob <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">sample1</span></span> <span class="main">+</span>
  m2<span class="main">:</span> monad_prob <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">sample2</span></span> <span class="main">+</span>
  monad_hom <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">h</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sample1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> sample"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">return2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sample2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> sample"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hom_sample <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span><span class="free">sample1</span> <span class="free">p</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">sample2</span> <span class="free">p</span> <span class="main">(</span><span class="free">h</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_alt_hom <span class="main">=</span> m1<span class="main">:</span> monad_alt <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">alt1</span></span> <span class="main">+</span>
  m2<span class="main">:</span> monad_alt <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">alt2</span></span> <span class="main">+</span>
  monad_hom <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">h</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">alt1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> alt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">return2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">alt2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m2</span> alt"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hom_alt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span><span class="free">alt1</span> <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> <span class="free">alt2</span> <span class="main">(</span><span class="free">h</span> <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="free">h</span> <span class="free">m'</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_altc_hom <span class="main">=</span> m1<span class="main">:</span> monad_altc <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">altc1</span></span> <span class="main">+</span>
  m2<span class="main">:</span> monad_altc <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">altc2</span></span> <span class="main">+</span>
  monad_hom <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">h</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">altc1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> altc"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">return2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">altc2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> altc"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hom_altc <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span><span class="free">altc1</span> <span class="free">C</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">altc2</span> <span class="free">C</span> <span class="main">(</span><span class="free">h</span> <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_writer_hom <span class="main">=</span> m1<span class="main">:</span> monad_writer <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">tell1</span></span> <span class="main">+</span>
  m2<span class="main">:</span> monad_writer <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">tell2</span></span> <span class="main">+</span>
  monad_hom <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">h</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">tell1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> tell"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">return2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">tell2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> tell"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hom_tell <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span><span class="free">tell1</span> <span class="free">w</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> <span class="free">tell2</span> <span class="free">w</span> <span class="main">(</span><span class="free">h</span> <span class="free">m</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_resumption_hom <span class="main">=</span> m1<span class="main">:</span> monad_resumption <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">pause1</span></span> <span class="main">+</span>
  m2<span class="main">:</span> monad_resumption <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">pause2</span></span> <span class="main">+</span>
  monad_hom <span class="quoted"><span class="free">return1</span></span> <span class="quoted"><span class="free">bind1</span></span> <span class="quoted"><span class="free">return2</span></span> <span class="quoted"><span class="free">bind2</span></span> <span class="quoted"><span class="free">h</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">pause1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> pause"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">return2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">pause2</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> pause"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">h</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span>"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> hom_pause <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">h</span> <span class="main">(</span><span class="free">pause1</span> <span class="free">out</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> <span class="free">pause2</span> <span class="free">out</span> <span class="main">(</span><span class="free">h</span> <span class="main">∘</span> <span class="free">c</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Switching between monads›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Homomorphisms are functional relations between monads. In general, it is more
  convenient to use arbitrary relations as embeddings because arbitrary relations allow us to
  change the type of values in a monad. As different monad transformers change the value type in 
  different ways, the embeddings must also support such changes in values. ›</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Embedding Identity into Probability›</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> cr_id_prob_transfer

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">prob_of_id</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> id <span class="main">⇒</span> <span class="tfree">'a</span> prob"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">prob_of_id</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> return_pmf <span class="main">(</span>extract <span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-monad_id_prob_hom"><span class="command">lemma</span></span> monad_id_prob_hom <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_hom return_id bind_id return_pmf bind_pmf prob_of_id"</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"prob_of_id <span class="main">(</span>return_id <span class="skolem">x</span><span class="main">)</span> <span class="main">=</span> return_pmf <span class="skolem">x</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prob_of_id_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"prob_of_id <span class="main">(</span>bind_id <span class="skolem">x</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> prob_of_id <span class="skolem">x</span> <span class="main">⤜</span> prob_of_id <span class="main">∘</span> <span class="skolem">f</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> id"</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> prob_of_id_def bind_return_pmf<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>


<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">cr_id_prob</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> id <span class="main">⇒</span> <span class="tfree">'b</span> prob <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">A</span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="free"><span class="bound"><span class="entity">y</span></span></span> <span class="main">⟹</span> <span class="free">cr_id_prob</span> <span class="free">A</span> <span class="main">(</span>return_id <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span>return_pmf <span class="free"><span class="bound"><span class="entity">y</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">inductive_simps</span></span> cr_id_prob_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cr_id_prob <span class="free">A</span> <span class="main">(</span>return_id <span class="free">x</span><span class="main">)</span> <span class="main">(</span>return_pmf <span class="free">y</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-cr_id_prob_return"><span class="command">lemma</span></span> cr_id_prob_return <span class="main">[</span><span class="operator">cr_id_prob_transfer</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> cr_id_prob <span class="free">A</span><span class="main">)</span> return_id return_pmf"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_id_prob_bind"><span class="command">lemma</span></span> cr_id_prob_bind <span class="main">[</span><span class="operator">cr_id_prob_transfer</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"<span class="main">(</span>cr_id_prob <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> cr_id_prob <span class="free">B</span><span class="main">)</span> <span class="main">===&gt;</span> cr_id_prob <span class="free">B</span><span class="main">)</span> bind_id bind_pmf"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def bind_return_pmf <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cr_id_prob.cases<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_id_prob_Grp"><span class="command">lemma</span></span> cr_id_prob_Grp<span class="main">:</span> <span class="quoted"><span class="quoted">"cr_id_prob <span class="main">(</span>BNF_Def.Grp <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> BNF_Def.Grp <span class="main">{</span><span class="bound">x</span><span class="main">.</span> set_id <span class="bound">x</span> <span class="main">⊆</span> <span class="free">A</span><span class="main">}</span> <span class="main">(</span>return_pmf <span class="main">∘</span> <span class="free">f</span> <span class="main">∘</span> extract<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Grp_def fun_eq_iff <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_id_prob.simps <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> id.expand<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span> <span class="keyword2"><span class="keyword">for</span></span> x <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="skolem">x</span></span><span class="main">)</span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹State and Reader›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹When no state updates are needed, the operation <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">get</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> can be replaced by <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">ask</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> cr_envT_stateT_transfer

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cr_prod1</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'c</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">×</span> <span class="tfree">'c</span> <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cr_prod1</span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">c</span><span class="main">)</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">∧</span> <span class="free"><span class="bound"><span class="entity">c'</span></span></span> <span class="main">=</span> <span class="bound">c</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-cr_prod1_simps"><span class="command">lemma</span></span> cr_prod1_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"cr_prod1 <span class="free">c'</span> <span class="free">A</span> <span class="free">a</span> <span class="main">(</span><span class="free">b</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">A</span> <span class="free">a</span> <span class="free">b</span> <span class="main">∧</span> <span class="free">c'</span> <span class="main">=</span> <span class="free">c</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_prod1_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_prod1I"><span class="command">lemma</span></span> cr_prod1I<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="free">a</span> <span class="free">b</span> <span class="main">⟹</span> cr_prod1 <span class="free">c'</span> <span class="free">A</span> <span class="free">a</span> <span class="main">(</span><span class="free">b</span><span class="main">,</span> <span class="free">c'</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1" id="Monomorphic_Monad-cr_prod1_Pair_transfer"><span class="command">lemma</span></span> cr_prod1_Pair_transfer <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> eq_onp <span class="main">(</span><span class="main">(=)</span> <span class="free">c</span><span class="main">)</span> <span class="main">===&gt;</span> cr_prod1 <span class="free">c</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span> <span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">a</span><span class="main">)</span> Pair"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def eq_onp_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_prod1_fst_transfer"><span class="command">lemma</span></span> cr_prod1_fst_transfer <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>cr_prod1 <span class="free">c</span> <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">A</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="bound">a</span><span class="main">)</span> fst"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_prod1_case_prod_transfer"><span class="command">lemma</span></span> cr_prod1_case_prod_transfer <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> eq_onp <span class="main">(</span><span class="main">(=)</span> <span class="free">c</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span> <span class="main">===&gt;</span> cr_prod1 <span class="free">c</span> <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">f</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">f</span> <span class="bound">a</span> <span class="free">c</span><span class="main">)</span> case_prod"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def eq_onp_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_prod1_Grp"><span class="command">lemma</span></span> cr_prod1_Grp<span class="main">:</span> <span class="quoted"><span class="quoted">"cr_prod1 <span class="free">c</span> <span class="main">(</span>BNF_Def.Grp <span class="free">A</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> BNF_Def.Grp <span class="free">A</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="free">f</span> <span class="bound">b</span><span class="main">,</span> <span class="free">c</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Grp_def fun_eq_iff<span class="main">)</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cr_envT_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'m1</span> <span class="main">⇒</span> <span class="tfree">'m2</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m1</span><span class="main">)</span> envT <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m2</span><span class="main">)</span> stateT <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cr_envT_stateT</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span> <span class="free"><span class="bound"><span class="entity">M</span></span></span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">=</span> <span class="main">(</span>eq_onp <span class="main">(</span><span class="main">(=)</span> <span class="free"><span class="bound"><span class="entity">s</span></span></span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free"><span class="bound"><span class="entity">M</span></span></span><span class="main">)</span> <span class="main">(</span>run_env <span class="free"><span class="bound"><span class="entity">m1</span></span></span><span class="main">)</span> <span class="main">(</span>run_state <span class="free"><span class="bound"><span class="entity">m2</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-cr_envT_stateT_simps"><span class="command">lemma</span></span> cr_envT_stateT_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"cr_envT_stateT <span class="free">s</span> <span class="free">M</span> <span class="main">(</span>EnvT <span class="free">f</span><span class="main">)</span> <span class="main">(</span>StateT <span class="free">g</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">M</span> <span class="main">(</span><span class="free">f</span> <span class="free">s</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_envT_stateT_def rel_fun_def eq_onp_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_envT_stateTE"><span class="command">lemma</span></span> cr_envT_stateTE<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"cr_envT_stateT <span class="free">s</span> <span class="free">M</span> <span class="free">m1</span> <span class="free">m2</span>"</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">f</span> <span class="free">g</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">m1</span> <span class="main">=</span> EnvT <span class="free">f</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="free">m2</span> <span class="main">=</span> StateT <span class="free">g</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>eq_onp <span class="main">(</span><span class="main">(=)</span> <span class="free">s</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="free">f</span> <span class="free">g</span>"</span></span>
<span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">m1</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">cases</span> <span class="quoted"><span class="free">m2</span></span><span class="main"><span class="keyword3">;</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_onp_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_envT_stateTD"><span class="command">lemma</span></span> cr_envT_stateTD<span class="main">:</span> <span class="quoted"><span class="quoted">"cr_envT_stateT <span class="free">s</span> <span class="free">M</span> <span class="free">m1</span> <span class="free">m2</span> <span class="main">⟹</span> <span class="free">M</span> <span class="main">(</span>run_env <span class="free">m1</span> <span class="free">s</span><span class="main">)</span> <span class="main">(</span>run_state <span class="free">m2</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cr_envT_stateTE <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_funD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_onp_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_envT_stateT_run"><span class="command">lemma</span></span> cr_envT_stateT_run <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>cr_envT_stateT <span class="free">s</span> <span class="free">M</span> <span class="main">===&gt;</span> eq_onp <span class="main">(</span><span class="main">(=)</span> <span class="free">s</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> run_env run_state"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cr_envT_stateTE<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_envT_stateT_StateT_EnvT"><span class="command">lemma</span></span> cr_envT_stateT_StateT_EnvT <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>eq_onp <span class="main">(</span><span class="main">(=)</span> <span class="free">s</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">s</span> <span class="free">M</span><span class="main">)</span> EnvT StateT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> 4 3 <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_funD <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_onp_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_envT_stateT_rec"><span class="command">lemma</span></span> cr_envT_stateT_rec <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(</span>eq_onp <span class="main">(</span><span class="main">(=)</span> <span class="free">s</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">s</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="free">C</span><span class="main">)</span> rec_envT rec_stateT"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cr_envT_stateTE<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_envT_stateT_return"><span class="command">lemma</span></span> cr_envT_stateT_return <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> <span class="dynamic"><span class="dynamic">cr_envT_stateT_transfer</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>cr_prod1 <span class="free">s</span> <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">A</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">s</span> <span class="free">M</span><span class="main">)</span> return_env return_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_env_def return_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Monomorphic_Monad-cr_envT_stateT_bind"><span class="command">lemma</span></span> cr_envT_stateT_bind <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span>cr_prod1 <span class="free">s</span> <span class="free">A</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">s</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">s</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">s</span> <span class="free">M</span><span class="main">)</span>
   bind_env bind_state"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> cr_envT_stateTE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> split_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> rel_funD<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> rel_funD<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_onp_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> rel_funD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> cr_envT_stateT_run<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> B<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">M</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> rel_funD<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_onp_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-cr_envT_stateT_ask_get"><span class="command">lemma</span></span> cr_envT_stateT_ask_get <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span>eq_onp <span class="main">(</span><span class="main">(=)</span> <span class="free">s</span><span class="main">)</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">s</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">s</span> <span class="free">M</span><span class="main">)</span> ask_env get_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> ask_env_def get_state_def
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> cr_envT_stateT_run<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> rel_funD<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> eq_onp_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-cr_envT_stateT_fail"><span class="command">lemma</span></span> cr_envT_stateT_fail <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> <span class="dynamic"><span class="dynamic">cr_envT_stateT_transfer</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">s</span> <span class="free">M</span><span class="main">)</span> fail_env fail_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> fail_env_def fail_state_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">_</span></span> spmf"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span> prob<span class="main"><span class="main">)</span></span> optionT"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹
  This section defines the mapping between the <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">_</span></span> spmf"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> monad and the monad obtained by
  composing transforming <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">_</span></span> prob"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> with <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">typ</span></span> <span class="quoted"><span class="quoted">"<span class="main"><span class="main">(</span></span><span class="main"><span class="main">_</span></span><span class="main"><span class="main">,</span></span> <span class="main"><span class="main">_</span></span><span class="main"><span class="main">)</span></span> optionT"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.
›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">cr_spmf_prob_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> option prob<span class="main">)</span> optionT <span class="main">⇒</span> <span class="tfree">'b</span> spmf <span class="main">⇒</span> bool"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">cr_spmf_prob_optionT</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">⟷</span> rel_spmf <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span>run_option <span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">q</span></span></span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-cr_spmf_prob_optionTI"><span class="command">lemma</span></span> cr_spmf_prob_optionTI<span class="main">:</span> <span class="quoted"><span class="quoted">"rel_spmf <span class="free">A</span> <span class="main">(</span>run_option <span class="free">p</span><span class="main">)</span> <span class="free">q</span> <span class="main">⟹</span> cr_spmf_prob_optionT <span class="free">A</span> <span class="free">p</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_spmf_prob_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_spmf_prob_optionTD"><span class="command">lemma</span></span> cr_spmf_prob_optionTD<span class="main">:</span> <span class="quoted"><span class="quoted">"cr_spmf_prob_optionT <span class="free">A</span> <span class="free">p</span> <span class="free">q</span> <span class="main">⟹</span> rel_spmf <span class="free">A</span> <span class="main">(</span>run_option <span class="free">p</span><span class="main">)</span> <span class="free">q</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_spmf_prob_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_spmf_prob_optionT_return_transfer"><span class="command">lemma</span></span> cr_spmf_prob_optionT_return_transfer<span class="main">:</span>
   <span class="comment1">― ‹Cannot be used as a transfer rule in <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">method</span> transfer_prover<span class="antiquote">}</span></span> because <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">return_spmf</span><span class="antiquote">}</span></span> is not a constant.›</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> cr_spmf_prob_optionT <span class="free">A</span><span class="main">)</span> <span class="main">(</span>return_option return_pmf<span class="main">)</span> return_spmf"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def cr_spmf_prob_optionTI<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_spmf_prob_optionT_bind_transfer"><span class="command">lemma</span></span> cr_spmf_prob_optionT_bind_transfer<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>cr_spmf_prob_optionT <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> cr_spmf_prob_optionT <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> cr_spmf_prob_optionT <span class="free">A</span><span class="main">)</span>
   <span class="main">(</span>bind_option return_pmf bind_pmf<span class="main">)</span> bind_spmf"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> rel_funI cr_spmf_prob_optionTI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
  <span class="main">(</span><span class="operator">auto</span> 4 4 <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> run_bind_option bind_spmf_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> cr_spmf_prob_optionTD <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> rel_funD <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> rel_pmf_bindI <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_spmf_prob_optionT_fail_transfer"><span class="command">lemma</span></span> cr_spmf_prob_optionT_fail_transfer<span class="main">:</span>
  <span class="quoted"><span class="quoted">"cr_spmf_prob_optionT <span class="free">A</span> <span class="main">(</span>fail_option return_pmf<span class="main">)</span> <span class="main">(</span>return_pmf None<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> cr_spmf_prob_optionTI<span class="main">)</span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">spmf_of_prob_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> option prob<span class="main">)</span> optionT <span class="main">⇒</span> <span class="tfree">'a</span> spmf"</span></span> 
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">spmf_of_prob_optionT</span> <span class="main">≡</span> run_option"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span> <span class="entity">prob_optionT_of_spmf</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> spmf <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> option prob<span class="main">)</span> optionT"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">prob_optionT_of_spmf</span> <span class="main">≡</span> OptionT"</span></span>

<span class="keyword1" id="Monomorphic_Monad-spmf_of_prob_optionT_transfer"><span class="command">lemma</span></span> spmf_of_prob_optionT_transfer<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>cr_spmf_prob_optionT <span class="free">A</span> <span class="main">===&gt;</span> rel_spmf <span class="free">A</span><span class="main">)</span> spmf_of_prob_optionT <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> cr_spmf_prob_optionTD<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-prob_optionT_of_spmf_transfer"><span class="command">lemma</span></span> prob_optionT_of_spmf_transfer<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>rel_spmf <span class="free">A</span> <span class="main">===&gt;</span> cr_spmf_prob_optionT <span class="free">A</span><span class="main">)</span> prob_optionT_of_spmf <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> cr_spmf_prob_optionTI<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Probabilities and countable non-determinism›</span></span>

<span class="keyword1"><span class="command">named_theorems</span></span> cr_prob_ndi_transfer

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> cset.lifting <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> cset_nondetM <span class="quoted">return_id</span> <span class="quoted">bind_id</span> <span class="quoted">merge_id</span> <span class="quoted">merge_id</span> <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">lift_definition</span></span> cset_pmf <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> pmf <span class="main">⇒</span> <span class="tfree">'a</span> cset"</span></span> <span class="keyword2"><span class="keyword">is</span></span> <span class="quoted">set_pmf</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">cr_pmf_cset</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> pmf <span class="main">⇒</span> <span class="tfree">'a</span> cset <span class="main">⇒</span> bool"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">p</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cr_pmf_cset</span> <span class="free">p</span> <span class="main">(</span>cset_pmf <span class="free">p</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-cr_pmf_cset_Grp"><span class="command">lemma</span></span> cr_pmf_cset_Grp<span class="main">:</span> <span class="quoted"><span class="quoted">"cr_pmf_cset <span class="main">=</span> BNF_Def.Grp UNIV cset_pmf"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff cr_pmf_cset.simps Grp_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_pmf_cset_return_pmf"><span class="command">lemma</span></span> cr_pmf_cset_return_pmf <span class="main">[</span><span class="operator">cr_prob_ndi_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_pmf_cset<span class="main">)</span> return_pmf csingle"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_pmf_cset.simps rel_fun_def<span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">cr_prob_ndi</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> prob <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'b</span><span class="main">,</span> <span class="tfree">'b</span> cset id<span class="main">)</span> nondetT <span class="main">⇒</span> bool"</span></span> 
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">A</span> <span class="entity">p</span> <span class="entity">B</span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">cr_prob_ndi</span> <span class="free">A</span> <span class="free">p</span> <span class="free">B</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"rel_set <span class="free">A</span> <span class="main">(</span>set_pmf <span class="free">p</span><span class="main">)</span> <span class="main">(</span>rcset <span class="main">(</span>extract <span class="main">(</span>run_nondet <span class="free">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Monomorphic_Monad-cr_prob_ndi_Grp"><span class="command">lemma</span></span> cr_prob_ndi_Grp<span class="main">:</span> <span class="quoted"><span class="quoted">"cr_prob_ndi <span class="main">(</span>BNF_Def.Grp UNIV <span class="free">f</span><span class="main">)</span> <span class="main">=</span> BNF_Def.Grp UNIV <span class="main">(</span>NondetT <span class="main">∘</span> return_id <span class="main">∘</span> cimage <span class="free">f</span> <span class="main">∘</span> cset_pmf<span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff cr_prob_ndi.simps rel_set_Grp<span class="main">)</span>
    <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Grp_def cimage.rep_eq cset_pmf.rep_eq cin.rep_eq <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> nondetT.expand id.expand<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_ndi_prob_return"><span class="command">lemma</span></span> cr_ndi_prob_return <span class="main">[</span><span class="operator">cr_prob_ndi_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> cr_prob_ndi <span class="free">A</span><span class="main">)</span> return_pmf return_nondet"</span></span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def cr_prob_ndi.simps<span class="main">)</span><span class="main">(</span><span class="operator">transfer</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_set_def<span class="main">)</span>

<span class="keyword1" id="Monomorphic_Monad-cr_ndi_prob_bind"><span class="command">lemma</span></span> cr_ndi_prob_bind <span class="main">[</span><span class="operator">cr_prob_ndi_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>cr_prob_ndi <span class="free">A</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">A</span> <span class="main">===&gt;</span> cr_prob_ndi <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> cr_prob_ndi <span class="free">A</span><span class="main">)</span> bind_pmf bind_nondet"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_prob_ndi.simps cUnion.rep_eq cimage.rep_eq <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Union_transfer<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> image_transfer<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> rel_funD<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> cr_prob_ndi.cases<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span><span class="main"><span class="keyword3">+</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Monomorphic_Monad-cr_ndi_prob_sample"><span class="command">lemma</span></span> cr_ndi_prob_sample <span class="main">[</span><span class="operator">cr_prob_ndi_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span>cr_pmf_cset <span class="main">===&gt;</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_prob_ndi <span class="free">A</span><span class="main">)</span> <span class="main">===&gt;</span> cr_prob_ndi <span class="free">A</span><span class="main">)</span> bind_pmf altc_nondet"</span></span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> rel_funI <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cr_pmf_cset.simps cr_prob_ndi.simps cUnion.rep_eq cimage.rep_eq cset_pmf.rep_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> Union_transfer<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> image_transfer<span class="main"><span class="main">[</span></span><span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">]</span></span><span class="main">)</span>                                  
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> rel_funI<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">drule</span> <span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> rel_funD<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">erule</span> cr_prob_ndi.cases<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_set_eq<span class="main">)</span>
  <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Monad_Overloading">
<div class="head">
<h1>Theory Monad_Overloading</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Overloaded monad operations›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Monad_Overloading <span class="keyword2"><span class="keyword">imports</span></span> <a href="Monomorphic_Monad.html">Monomorphic_Monad</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">consts</span></span> return <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
<span class="keyword1"><span class="command">consts</span></span> bind <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
<span class="keyword1"><span class="command">consts</span></span> get <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
<span class="keyword1"><span class="command">consts</span></span> put <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
<span class="keyword1"><span class="command">consts</span></span> fail <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
<span class="keyword1"><span class="command">consts</span></span> catch <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> catch"</span></span>
<span class="keyword1"><span class="command">consts</span></span> ask <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask"</span></span>
<span class="keyword1"><span class="command">consts</span></span> sample <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>
<span class="keyword1"><span class="command">consts</span></span> pause <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause"</span></span>
<span class="keyword1"><span class="command">consts</span></span> tell <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> tell"</span></span>
<span class="keyword1"><span class="command">consts</span></span> alt <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> alt"</span></span>
<span class="keyword1"><span class="command">consts</span></span> altc <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Identity monad›</span></span>

<span class="keyword1"><span class="command">overloading</span></span> 
  bind_id' <span class="main">≡</span> <span class="quoted"><span class="quoted">"bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> id<span class="main">)</span> bind"</span></span>
  return_id <span class="main">≡</span> <span class="quoted"><span class="quoted">"return <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> id<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_id'</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> id<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind_id'</span> <span class="main">=</span> bind_id"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_id</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> id<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">return_id</span> <span class="main">=</span> id.return_id"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monad_Overloading-extract_bind'"><span class="command">lemma</span></span> extract_bind' <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"extract <span class="main">(</span>bind <span class="free">x</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> extract <span class="main">(</span><span class="free">f</span> <span class="main">(</span>extract <span class="free">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_id'_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-extract_return"><span class="command">lemma</span></span> extract_return <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"extract <span class="main">(</span>return <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_id_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_id'"><span class="command">lemma</span></span> monad_id' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> id<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_id'_def return_id_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_id<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_commute_id'"><span class="command">lemma</span></span> monad_commute_id' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> id<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> bind_id'_def return_id_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_commute_id<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Probability monad›</span></span>

<span class="keyword1"><span class="command">overloading</span></span>
  return_prob <span class="main">≡</span> <span class="quoted"><span class="quoted">"return <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> prob<span class="main">)</span> return"</span></span>
  bind_prob <span class="main">≡</span> <span class="quoted"><span class="quoted">"bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> prob<span class="main">)</span> bind"</span></span>
  sample_prob <span class="main">≡</span> <span class="quoted"><span class="quoted">"sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'a</span> prob<span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_prob</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> pmf<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">return_prob</span> <span class="main">=</span> return_pmf"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_prob</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> prob<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind_prob</span> <span class="main">=</span> bind_pmf"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sample_prob</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'a</span> pmf<span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sample_prob</span> <span class="main">=</span> bind_pmf"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monad_Overloading-monad_prob'"><span class="command">lemma</span></span> monad_prob' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> prob<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_prob_def bind_prob_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_prob<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_commute_prob'"><span class="command">lemma</span></span> monad_commute_prob' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> prob<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_prob_def bind_prob_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_commute_prob<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_prob_prob'"><span class="command">lemma</span></span> monad_prob_prob' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'a</span> prob<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'a</span> prob<span class="main">)</span> sample<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_prob_def bind_prob_def sample_prob_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_prob_prob<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Nondeterminism monad transformer›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹As the collection type is not determined from the type of the return operation, we can
  only provide definitions for one collection type implementation. We choose multisets.
  Accordingly, <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">const</span></span> altc<span class="antiquote"><span class="antiquote">}</span></span></span></span> is not available.›</span></span>

<span class="keyword1"><span class="command">consts</span></span>
  munionMT <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itself <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
  mUnionMT <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itself <span class="main">⇒</span> <span class="tfree">'m</span> multiset <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">overloading</span></span> 
  return_nondetT <span class="main">≡</span> <span class="quoted"><span class="quoted">"return <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> return"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  bind_nondetT <span class="main">≡</span> <span class="quoted"><span class="quoted">"bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> bind"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  fail_nondetT <span class="main">≡</span> <span class="quoted"><span class="quoted">"fail <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT fail"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  ask_nondetT <span class="main">≡</span> <span class="quoted"><span class="quoted">"ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> ask"</span></span>
  get_nondetT <span class="main">≡</span> <span class="quoted"><span class="quoted">"get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> get"</span></span>
  put_nondetT <span class="main">≡</span> <span class="quoted"><span class="quoted">"put <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> put"</span></span>
  alt_nondetT <span class="main">≡</span> <span class="quoted"><span class="quoted">"alt <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT alt"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  munionMT <span class="main">≡</span> <span class="quoted"><span class="quoted">"munionMT <span class="main">::</span> <span class="tfree">'a</span> itself <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  mUnionMT <span class="main">≡</span> <span class="quoted"><span class="quoted">"mUnionMT <span class="main">::</span> <span class="tfree">'a</span> itself <span class="main">⇒</span> <span class="tfree">'m</span> multiset <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> nondetM_base <span class="quoted">return</span> <span class="quoted">bind</span> <span class="quoted"><span class="quoted">"mmerge return bind"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{#}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_nondetT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">return_nondetT</span> <span class="main">=</span> return_nondet"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_nondetT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind_nondetT</span> <span class="main">=</span> bind_nondet"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_nondetT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fail_nondetT</span> <span class="main">=</span> fail_nondet"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ask_nondetT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ask_nondetT</span> <span class="main">=</span> ask_nondet ask"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_nondetT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">get_nondetT</span> <span class="main">=</span> get_nondet get"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">put_nondetT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">put_nondetT</span> <span class="main">=</span> put_nondet put"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_nondetT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt_nondetT</span> <span class="main">=</span> alt_nondet"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">munionMT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itself <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">munionMT</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">=</span> bind <span class="free"><span class="bound"><span class="entity">m1</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> bind <span class="free"><span class="bound"><span class="entity">m2</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="bound">B</span><span class="main">.</span> return <span class="main">(</span><span class="bound">A</span> <span class="main">+</span> <span class="bound">B</span> <span class="main">::</span> <span class="tfree">'a</span> multiset<span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">mUnionMT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> itself <span class="main">⇒</span> <span class="tfree">'m</span> multiset <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">mUnionMT</span> <span class="main"><span class="bound"><span class="entity">_</span></span></span> <span class="main">=</span> fold_mset <span class="main">(</span>munionMT <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span>return <span class="main">(</span><span class="main">{#}</span> <span class="main">::</span> <span class="tfree">'a</span> multiset<span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">interpretation</span></span> nondetM_base <span class="quoted">return</span> <span class="quoted">bind</span> <span class="quoted"><span class="quoted">"mmerge return bind"</span></span> <span class="quoted"><span class="quoted">"<span class="main">{#}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="main">{#</span><span class="bound">x</span><span class="main">#}</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="main">(+)</span>"</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1" id="Monad_Overloading-run_bind_nondetT"><span class="command">lemma</span></span> run_bind_nondetT<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>bind <span class="free">m</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> bind <span class="main">(</span>run_nondet <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span><span class="main">.</span> mUnionMT <span class="keyword1">TYPE</span><span class="main">(</span><span class="tfree">'a</span><span class="main">)</span> <span class="main">(</span>image_mset <span class="main">(</span>run_nondet <span class="main">∘</span> <span class="free">f</span><span class="main">)</span> <span class="bound">A</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_nondetT_def mUnionMT_def munionMT_def<span class="main"><span class="main">[</span></span><span class="operator">abs_def</span><span class="main"><span class="main">]</span></span> mmerge_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_return_nondetT"><span class="command">lemma</span></span> run_return_nondetT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>return <span class="free">x</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> <span class="main">=</span> return <span class="main">{#</span><span class="free">x</span><span class="main">#}</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_nondetT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_fail_nondetT"><span class="command">lemma</span></span> run_fail_nondetT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>fail <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> <span class="main">=</span> return <span class="main">(</span><span class="main">{#}</span> <span class="main">::</span> <span class="tfree">'a</span> multiset<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_nondetT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_ask_nondetT"><span class="command">lemma</span></span> run_ask_nondetT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>ask <span class="free">f</span><span class="main">)</span> <span class="main">=</span> ask <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="free">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_nondetT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_get_nondetT"><span class="command">lemma</span></span> run_get_nondetT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>get <span class="free">f</span><span class="main">)</span> <span class="main">=</span> get <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_nondet <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_nondetT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_put_nondetT"><span class="command">lemma</span></span> run_put_nondetT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>put <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> put <span class="free">s</span> <span class="main">(</span>run_nondet <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_nondetT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_alt_nondetT"><span class="command">lemma</span></span> run_alt_nondetT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_nondet <span class="main">(</span>alt <span class="free">m</span> <span class="free">m'</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> <span class="main">=</span> 
   bind <span class="main">(</span>run_nondet <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">A</span> <span class="main">::</span> <span class="tfree">'a</span> multiset<span class="main">.</span> bind <span class="main">(</span>run_nondet <span class="free">m'</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">B</span><span class="main">.</span> return <span class="main">(</span><span class="bound">A</span> <span class="main">+</span> <span class="bound">B</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_nondetT_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monad_Overloading-monad_nondetT'"><span class="command">lemma</span></span> monad_nondetT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> multiset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_nondetT_def bind_nondetT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mset_nondetMs<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_fail_nondetT'"><span class="command">lemma</span></span> monad_fail_nondetT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> multiset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad_fail return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> bind<span class="main">)</span> fail"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_nondetT_def bind_nondetT_def fail_nondetT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mset_nondetMs<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_alt_nondetT'"><span class="command">lemma</span></span> monad_alt_nondetT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> multiset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> bind<span class="main">)</span> alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_nondetT_def bind_nondetT_def alt_nondetT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mset_nondetMs<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_fail_alt_nondetT'"><span class="command">lemma</span></span> monad_fail_alt_nondetT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> multiset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad_fail_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> bind<span class="main">)</span> fail alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_nondetT_def bind_nondetT_def fail_nondetT_def alt_nondetT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mset_nondetMs<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_reader_nondetT'"><span class="command">lemma</span></span> monad_reader_nondetT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> multiset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span><span class="main">;</span>
     monad_reader return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> multiset<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask<span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> monad_reader return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> nondetT<span class="main">)</span> ask<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_nondetT_def bind_nondetT_def ask_nondetT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> mset_nondetMs<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹State monad transformer›</span></span>

<span class="keyword1"><span class="command">overloading</span></span>
  get_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> get"</span></span>
  put_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"put <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> put"</span></span>
  bind_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  return_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"return <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> return"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  fail_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"fail <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT fail"</span></span>
  ask_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> ask"</span></span>
  sample_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> sample"</span></span>
  tell_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> tell"</span></span>
  alt_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"alt <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT alt"</span></span>
  altc_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> altc"</span></span>
  pause_stateT <span class="main">≡</span> <span class="quoted"><span class="quoted">"pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">get_stateT</span> <span class="main">=</span> get_state"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">put_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">put_stateT</span> <span class="main">=</span> put_state"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind_stateT</span> <span class="main">=</span> bind_state bind"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">return_stateT</span> <span class="main">=</span> return_state return"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fail_stateT</span> <span class="main">=</span> fail_state fail"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ask_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ask_stateT</span> <span class="main">=</span> ask_state ask"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sample_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sample_stateT</span> <span class="main">=</span> sample_state sample"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tell_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tell_stateT</span> <span class="main">=</span> tell_state tell"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt_stateT</span> <span class="main">=</span> alt_state alt"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">altc_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">altc_stateT</span> <span class="main">=</span> altc_state altc"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pause_stateT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pause_stateT</span> <span class="main">=</span> pause_state pause"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monad_Overloading-run_bind_stateT"><span class="command">lemma</span></span> run_bind_stateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>bind <span class="free">x</span> <span class="free">f</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> bind <span class="main">(</span>run_state <span class="free">x</span> <span class="free">s</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="bound">s'</span><span class="main">)</span><span class="main">.</span> run_state <span class="main">(</span><span class="free">f</span> <span class="bound">a</span><span class="main">)</span> <span class="bound">s'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_return_stateT"><span class="command">lemma</span></span> run_return_stateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>return <span class="free">x</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> return <span class="main">(</span><span class="free">x</span><span class="main">,</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_put_stateT"><span class="command">lemma</span></span> run_put_stateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>put <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="free">s'</span> <span class="main">=</span> run_state <span class="free">m</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_get_state"><span class="command">lemma</span></span> run_get_state <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>get <span class="free">f</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> run_state <span class="main">(</span><span class="free">f</span> <span class="free">s</span><span class="main">)</span> <span class="free">s</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_fail_stateT"><span class="command">lemma</span></span> run_fail_stateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state fail <span class="free">s</span> <span class="main">=</span> fail"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_ask_stateT"><span class="command">lemma</span></span> run_ask_stateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>ask <span class="free">f</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> ask <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_state <span class="main">(</span><span class="free">f</span> <span class="bound">r</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_sample_stateT"><span class="command">lemma</span></span> run_sample_stateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>sample <span class="free">p</span> <span class="free">f</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> sample <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_state <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_tell_stateT"><span class="command">lemma</span></span> run_tell_stateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>tell <span class="free">w</span> <span class="free">m</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> tell <span class="free">w</span> <span class="main">(</span>run_state <span class="free">m</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tell_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_alt_stateT"><span class="command">lemma</span></span> run_alt_stateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>alt <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> alt <span class="main">(</span>run_state <span class="free">m</span> <span class="free">s</span><span class="main">)</span> <span class="main">(</span>run_state <span class="free">m'</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_altc_stateT"><span class="command">lemma</span></span> run_altc_stateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>altc <span class="free">C</span> <span class="free">f</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> altc <span class="free">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_state <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_pause_stateT"><span class="command">lemma</span></span> run_pause_stateT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>pause <span class="free">out</span> <span class="free">c</span><span class="main">)</span> <span class="free">s</span> <span class="main">=</span> pause <span class="free">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">input</span><span class="main">.</span> run_state <span class="main">(</span><span class="free">c</span> <span class="bound">input</span><span class="main">)</span> <span class="free">s</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pause_stateT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_stateT'"><span class="command">lemma</span></span> monad_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">⟹</span> monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_stateT<span class="main">)</span> 

<span class="keyword1" id="Monad_Overloading-monad_state_stateT'"><span class="command">lemma</span></span> monad_state_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> 
  <span class="main">⟹</span> monad_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> get <span class="main">(</span>put <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> put<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def get_stateT_def put_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_stateT<span class="main">)</span> 

<span class="keyword1" id="Monad_Overloading-monad_fail_stateT'"><span class="command">lemma</span></span> monad_fail_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_fail return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> fail
  <span class="main">⟹</span> monad_fail return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> fail"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def fail_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_fail_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_reader_stateT'"><span class="command">lemma</span></span> monad_reader_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_reader return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask<span class="main">)</span>
  <span class="main">⟹</span> monad_reader return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> ask<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def ask_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_reader_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_reader_state_stateT'"><span class="command">lemma</span></span> monad_reader_state_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_reader return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask<span class="main">)</span>
  <span class="main">⟹</span> monad_reader_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> ask<span class="main">)</span> get_state put_state"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def ask_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_reader_state_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_prob_stateT'"><span class="command">lemma</span></span> monad_prob_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample<span class="main">)</span>
  <span class="main">⟹</span> monad_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> sample<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def sample_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_prob_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_prob_stateT'"><span class="command">lemma</span></span> monad_state_prob_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample<span class="main">)</span>
  <span class="main">⟹</span> monad_state_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> get <span class="main">(</span>put <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> put<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> sample<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def sample_stateT_def get_stateT_def put_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_prob_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_writer_stateT'"><span class="command">lemma</span></span> monad_writer_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_writer return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> tell<span class="main">)</span>
  <span class="main">⟹</span> monad_writer return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> tell<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def tell_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_writer_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_alt_stateT'"><span class="command">lemma</span></span> monad_alt_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> alt
   <span class="main">⟹</span> monad_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def alt_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_alt_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_alt_stateT'"><span class="command">lemma</span></span> monad_state_alt_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> alt
   <span class="main">⟹</span> monad_state_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> get<span class="main">)</span> put alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def get_stateT_def put_stateT_def alt_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_alt_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_fail_alt_stateT'"><span class="command">lemma</span></span> monad_fail_alt_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_fail_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> fail alt
   <span class="main">⟹</span> monad_fail_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> fail alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def fail_stateT_def alt_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_fail_alt_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_altc_stateT'"><span class="command">lemma</span></span> monad_altc_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc<span class="main">)</span>
   <span class="main">⟹</span> monad_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> altc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def altc_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_altc_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_altc_stateT'"><span class="command">lemma</span></span> monad_state_altc_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc<span class="main">)</span>
   <span class="main">⟹</span> monad_state_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> altc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def get_stateT_def put_stateT_def altc_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_altc_stateT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_resumption_stateT'"><span class="command">lemma</span></span> monad_resumption_stateT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_resumption return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause<span class="main">)</span>
   <span class="main">⟹</span> monad_resumption return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> stateT<span class="main">)</span> pause<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_stateT_def bind_stateT_def fail_stateT_def pause_stateT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_resumption_stateT<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Failure and Exception monad transformer›</span></span>

<span class="keyword1"><span class="command">overloading</span></span> 
  return_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"return <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> return"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  bind_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  fail_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"fail <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT fail"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  catch_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"catch <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT catch"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  ask_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> ask"</span></span>
  get_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> get"</span></span>
  put_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"put <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> put"</span></span>
  sample_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> sample"</span></span>
  tell_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> tell"</span></span>
  alt_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"alt <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT alt"</span></span>
  altc_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> altc"</span></span>
  pause_optionT <span class="main">≡</span> <span class="quoted"><span class="quoted">"pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">return_optionT</span> <span class="main">=</span> return_option return"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind_optionT</span> <span class="main">=</span> bind_option return bind"</span></span> 

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fail_optionT</span> <span class="main">=</span> fail_option return"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">catch_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT catch"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">catch_optionT</span> <span class="main">=</span> catch_option return bind"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ask_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ask_optionT</span> <span class="main">=</span> ask_option ask"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">get_optionT</span> <span class="main">=</span> get_option get"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">put_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">put_optionT</span> <span class="main">=</span> put_option put"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sample_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sample_optionT</span> <span class="main">=</span> sample_option sample"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tell_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tell_optionT</span> <span class="main">=</span> tell_option tell"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt_optionT</span> <span class="main">=</span> alt_option alt"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">altc_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">altc_optionT</span> <span class="main">=</span> altc_option altc"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pause_optionT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pause_optionT</span> <span class="main">=</span> pause_option pause"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monad_Overloading-run_bind_optionT"><span class="command">lemma</span></span> run_bind_optionT<span class="main">:</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">f</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'a</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT"</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>bind <span class="free">x</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> bind <span class="main">(</span>run_option <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> return <span class="main">(</span>None <span class="main">::</span> <span class="tfree">'a</span> option<span class="main">)</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> run_option <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_optionT_def run_bind_option<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_return_optionT"><span class="command">lemma</span></span> run_return_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>return <span class="free">x</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> <span class="main">=</span> return <span class="main">(</span>Some <span class="free">x</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">x</span> <span class="main">::</span> <span class="tfree"><span class="quoted"><span class="tfree">'a</span></span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_fail_optionT"><span class="command">lemma</span></span> run_fail_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>fail <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT fail<span class="main">)</span> <span class="main">=</span> return <span class="main">(</span>None <span class="main">::</span> <span class="tfree">'a</span> option<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_catch_optionT"><span class="command">lemma</span></span> run_catch_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>catch <span class="free">m</span> <span class="free">h</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> <span class="main">=</span> 
   bind <span class="main">(</span>run_option <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="main">::</span> <span class="tfree">'a</span> option<span class="main">.</span> <span class="keyword1">if</span> <span class="bound">x</span> <span class="main">=</span> None <span class="keyword1">then</span> run_option <span class="free">h</span> <span class="keyword1">else</span> return <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> catch_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_ask_optionT"><span class="command">lemma</span></span> run_ask_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>ask <span class="free">f</span><span class="main">)</span> <span class="main">=</span> ask <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_option <span class="main">(</span><span class="free">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_get_optionT"><span class="command">lemma</span></span> run_get_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>get <span class="free">f</span><span class="main">)</span> <span class="main">=</span> get <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_option <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_put_optionT"><span class="command">lemma</span></span> run_put_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>put <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> put <span class="free">s</span> <span class="main">(</span>run_option <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_sample_optionT"><span class="command">lemma</span></span> run_sample_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>sample <span class="free">p</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> sample <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_option <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_tell_optionT"><span class="command">lemma</span></span> run_tell_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>tell <span class="free">w</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> tell <span class="free">w</span> <span class="main">(</span>run_option <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tell_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_alt_optionT"><span class="command">lemma</span></span> run_alt_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>alt <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> alt <span class="main">(</span>run_option <span class="free">m</span><span class="main">)</span> <span class="main">(</span>run_option <span class="free">m'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_altc_optionT"><span class="command">lemma</span></span> run_altc_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>altc <span class="free">C</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> altc <span class="free">C</span> <span class="main">(</span>run_option <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_optionT_def o_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_pause_optionT"><span class="command">lemma</span></span> run_pause_optionT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_option <span class="main">(</span>pause <span class="free">out</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> pause <span class="free">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">input</span><span class="main">.</span> run_option <span class="main">(</span><span class="free">c</span> <span class="bound">input</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pause_optionT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_optionT'"><span class="command">lemma</span></span> monad_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_fail_optionT'"><span class="command">lemma</span></span> monad_fail_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad_fail return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> fail"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def fail_optionT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_fail_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_catch_optionT'"><span class="command">lemma</span></span> monad_catch_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad_catch return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> fail catch"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def fail_optionT_def catch_optionT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_catch_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_reader_optionT'"><span class="command">lemma</span></span> monad_reader_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_reader return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask<span class="main">)</span>
  <span class="main">⟹</span> monad_reader return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> ask<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def ask_optionT_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_reader_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_optionT'"><span class="command">lemma</span></span> monad_state_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put
  <span class="main">⟹</span> monad_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> get<span class="main">)</span> put"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def get_optionT_def put_optionT_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_catch_state_optionT'"><span class="command">lemma</span></span> monad_catch_state_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put
  <span class="main">⟹</span> monad_catch_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> fail catch <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> get<span class="main">)</span> put"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def fail_optionT_def catch_optionT_def get_optionT_def put_optionT_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_catch_state_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_prob_optionT'"><span class="command">lemma</span></span> monad_prob_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample<span class="main">)</span>
  <span class="main">⟹</span> monad_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> sample<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def sample_optionT_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_prob_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_prob_optionT'"><span class="command">lemma</span></span> monad_state_prob_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample<span class="main">)</span>
  <span class="main">⟹</span> monad_state_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> get<span class="main">)</span> put<span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> sample<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def get_optionT_def put_optionT_def sample_optionT_def
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_prob_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_writer_optionT'"><span class="command">lemma</span></span> monad_writer_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_writer return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> tell<span class="main">)</span>
  <span class="main">⟹</span> monad_writer return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> tell<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def tell_optionT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_writer_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_alt_optionT'"><span class="command">lemma</span></span> monad_alt_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> alt
  <span class="main">⟹</span> monad_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def alt_optionT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_alt_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_alt_optionT'"><span class="command">lemma</span></span> monad_state_alt_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put alt
  <span class="main">⟹</span> monad_state_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> get<span class="main">)</span> put alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def alt_optionT_def get_optionT_def put_optionT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_alt_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_altc_optionT'"><span class="command">lemma</span></span> monad_altc_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc<span class="main">)</span>
  <span class="main">⟹</span> monad_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> altc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def altc_optionT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_altc_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_altc_optionT'"><span class="command">lemma</span></span> monad_state_altc_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc<span class="main">)</span>
  <span class="main">⟹</span> monad_state_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> altc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def altc_optionT_def get_optionT_def put_optionT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_altc_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_resumption_optionT'"><span class="command">lemma</span></span> monad_resumption_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_resumption return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause<span class="main">)</span>
  <span class="main">⟹</span> monad_resumption return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> pause<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def pause_optionT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_resumption_optionT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_commute_optionT'"><span class="command">lemma</span></span> monad_commute_optionT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span><span class="main">;</span> monad_discard return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> option<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">⟧</span>
  <span class="main">⟹</span> monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> optionT<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_optionT_def bind_optionT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_commute_optionT<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Reader monad transformer›</span></span>

<span class="keyword1"><span class="command">overloading</span></span>
  return_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"return <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> return"</span></span>
  bind_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind"</span></span>
  fail_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"fail <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT fail"</span></span>
  get_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> get"</span></span>
  put_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"put <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> put"</span></span>
  sample_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> sample"</span></span>
  ask_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> ask"</span></span>
  catch_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"catch <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT catch"</span></span>
  alt_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"alt <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT alt"</span></span>
  altc_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> altc"</span></span>
  pause_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> pause"</span></span>
  tell_envT <span class="main">≡</span> <span class="quoted"><span class="quoted">"tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">return_envT</span> <span class="main">=</span> return_env return"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind_envT</span> <span class="main">=</span> bind_env bind"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ask_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ask_envT</span> <span class="main">=</span> ask_env"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fail_envT</span> <span class="main">=</span> fail_env fail"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">get_envT</span> <span class="main">=</span> get_env get"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">put_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">put_envT</span> <span class="main">=</span> put_env put"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sample_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sample_envT</span> <span class="main">=</span> sample_env sample"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">catch_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT catch"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">catch_envT</span> <span class="main">=</span> catch_env catch"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt_envT</span> <span class="main">=</span> alt_env alt"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">altc_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">altc_envT</span> <span class="main">=</span> altc_env altc"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pause_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pause_envT</span> <span class="main">=</span> pause_env pause"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tell_envT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tell_envT</span> <span class="main">=</span> tell_env tell"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monad_Overloading-run_bind_envT"><span class="command">lemma</span></span> run_bind_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>bind <span class="free">x</span> <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> bind <span class="main">(</span>run_env <span class="free">x</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">f</span> <span class="bound">y</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_return_envT"><span class="command">lemma</span></span> run_return_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>return <span class="free">x</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> return <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_ask_envT"><span class="command">lemma</span></span> run_ask_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>ask <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> run_env <span class="main">(</span><span class="free">f</span> <span class="free">r</span><span class="main">)</span> <span class="free">r</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_fail_envT"><span class="command">lemma</span></span> run_fail_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env fail <span class="free">r</span> <span class="main">=</span> fail"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_get_envT"><span class="command">lemma</span></span> run_get_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>get <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> get <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_put_envT"><span class="command">lemma</span></span> run_put_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>put <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> put <span class="free">s</span> <span class="main">(</span>run_env <span class="free">m</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_sample_envT"><span class="command">lemma</span></span> run_sample_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>sample <span class="free">p</span> <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> sample <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_catch_envT"><span class="command">lemma</span></span> run_catch_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>catch <span class="free">m</span> <span class="free">h</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> catch <span class="main">(</span>run_env <span class="free">m</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span>run_env <span class="free">h</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> catch_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_alt_envT"><span class="command">lemma</span></span> run_alt_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>alt <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> alt <span class="main">(</span>run_env <span class="free">m</span> <span class="free">r</span><span class="main">)</span> <span class="main">(</span>run_env <span class="free">m'</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_altc_envT"><span class="command">lemma</span></span> run_altc_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>altc <span class="free">C</span> <span class="free">f</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> altc <span class="free">C</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_pause_envT"><span class="command">lemma</span></span> run_pause_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>pause <span class="free">out</span> <span class="free">c</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> pause <span class="free">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">input</span><span class="main">.</span> run_env <span class="main">(</span><span class="free">c</span> <span class="bound">input</span><span class="main">)</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pause_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_tell_envT"><span class="command">lemma</span></span> run_tell_envT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_env <span class="main">(</span>tell <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="free">r</span> <span class="main">=</span> tell <span class="free">s</span> <span class="main">(</span>run_env <span class="free">m</span> <span class="free">r</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tell_envT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_envT'"><span class="command">lemma</span></span> monad_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_reader_envT'"><span class="command">lemma</span></span> monad_reader_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad_reader return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> ask<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def ask_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_reader_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_fail_envT'"><span class="command">lemma</span></span> monad_fail_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_fail return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> fail
  <span class="main">⟹</span> monad_fail return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> fail"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def fail_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_fail_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_catch_envT'"><span class="command">lemma</span></span> monad_catch_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_catch return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> fail catch
  <span class="main">⟹</span> monad_catch return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> fail catch"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def fail_envT_def catch_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_catch_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_envT'"><span class="command">lemma</span></span> monad_state_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put
  <span class="main">⟹</span> monad_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> get<span class="main">)</span> put"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def get_envT_def put_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_prob_envT'"><span class="command">lemma</span></span> monad_prob_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample<span class="main">)</span>
  <span class="main">⟹</span> monad_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> sample<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def sample_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_prob_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_prob_envT'"><span class="command">lemma</span></span> monad_state_prob_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample<span class="main">)</span>
  <span class="main">⟹</span> monad_state_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> sample<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def sample_envT_def get_envT_def put_envT_def  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_prob_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_alt_envT'"><span class="command">lemma</span></span> monad_alt_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> alt
  <span class="main">⟹</span> monad_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def alt_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_alt_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_fail_alt_envT'"><span class="command">lemma</span></span> monad_fail_alt_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_fail_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> fail alt
  <span class="main">⟹</span> monad_fail_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> fail alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def fail_envT_def alt_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_fail_alt_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_alt_envT'"><span class="command">lemma</span></span> monad_state_alt_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put alt
  <span class="main">⟹</span> monad_state_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> get<span class="main">)</span> put alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def fail_envT_def get_envT_def put_envT_def alt_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_alt_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_altc_envT'"><span class="command">lemma</span></span> monad_altc_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc<span class="main">)</span>
  <span class="main">⟹</span> monad_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> altc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def altc_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_altc_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_altc_envT'"><span class="command">lemma</span></span> monad_state_altc_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc<span class="main">)</span>
  <span class="main">⟹</span> monad_state_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> altc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def fail_envT_def get_envT_def put_envT_def altc_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_altc_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_resumption_envT'"><span class="command">lemma</span></span> monad_resumption_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_resumption return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause<span class="main">)</span>
  <span class="main">⟹</span> monad_resumption return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> pause<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def pause_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_resumption_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_writer_readerT'"><span class="command">lemma</span></span> monad_writer_readerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_writer return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> tell<span class="main">)</span>
  <span class="main">⟹</span> monad_writer return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> tell<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def tell_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_writer_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_commute_envT'"><span class="command">lemma</span></span> monad_commute_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad_commute return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_commute_envT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_discard_envT'"><span class="command">lemma</span></span> monad_discard_envT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_discard return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad_discard return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> envT<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_envT_def bind_envT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_discard_envT<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Writer monad transformer›</span></span>

<span class="keyword1"><span class="command">overloading</span></span>
  return_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"return <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> return"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  bind_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
  fail_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"fail <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT fail"</span></span>
  get_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> get"</span></span>
  put_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"put <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> put"</span></span>
  sample_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> sample"</span></span>
  ask_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> ask"</span></span>
  alt_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"alt <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT alt"</span></span>
  altc_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> altc"</span></span>
  pause_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> pause"</span></span>
  tell_writerT <span class="main">≡</span> <span class="quoted"><span class="quoted">"tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> tell"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">unchecked</span></span><span class="main">)</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">return_writerT</span> <span class="main">=</span> return_writer return"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind_writerT</span> <span class="main">=</span> bind_writer return bind"</span></span>
                                                     
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">ask_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">ask_writerT</span> <span class="main">=</span> ask_writer ask"</span></span>
                                                   
<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fail_writerT</span> <span class="main">=</span> fail_writer fail"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">get_writerT</span> <span class="main">=</span> get_writer get"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">put_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">put_writerT</span> <span class="main">=</span> put_writer put"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sample_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">sample_writerT</span> <span class="main">=</span> sample_writer sample"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">alt_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT alt"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">alt_writerT</span> <span class="main">=</span> alt_writer alt"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">altc_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">altc_writerT</span> <span class="main">=</span> altc_writer altc"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">pause_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> pause"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">pause_writerT</span> <span class="main">=</span> pause_writer pause"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">tell_writerT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> tell"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">tell_writerT</span> <span class="main">=</span> tell_writer return bind"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monad_Overloading-run_bind_writerT"><span class="command">lemma</span></span> run_bind_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>bind <span class="free">m</span> <span class="free">f</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> <span class="main">=</span> bind <span class="main">(</span>run_writer <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">,</span> <span class="bound">ws</span> <span class="main">::</span> <span class="tfree">'w</span> list<span class="main">)</span><span class="main">.</span> bind <span class="main">(</span>run_writer <span class="main">(</span><span class="free">f</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">b</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">,</span> <span class="bound">ws'</span> <span class="main">::</span> <span class="tfree">'w</span> list<span class="main">)</span><span class="main">.</span> return <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="bound">ws</span> <span class="main">@</span> <span class="bound">ws'</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_writerT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_return_writerT"><span class="command">lemma</span></span> run_return_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>return <span class="free">x</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> <span class="main">=</span> return <span class="main">(</span><span class="free">x</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">,</span> <span class="main">[]</span> <span class="main">::</span> <span class="tfree">'w</span> list<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_writerT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_ask_writerT"><span class="command">lemma</span></span> run_ask_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>ask <span class="free">f</span><span class="main">)</span> <span class="main">=</span> ask <span class="main">(</span><span class="main">λ</span><span class="bound">r</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free">f</span> <span class="bound">r</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> ask_writerT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_fail_writerT"><span class="command">lemma</span></span> run_fail_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer fail <span class="main">=</span> fail"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_writerT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_get_writerT"><span class="command">lemma</span></span> run_get_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>get <span class="free">f</span><span class="main">)</span> <span class="main">=</span> get <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free">f</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_writerT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_put_writerT"><span class="command">lemma</span></span> run_put_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>put <span class="free">s</span> <span class="free">m</span><span class="main">)</span> <span class="main">=</span> put <span class="free">s</span> <span class="main">(</span>run_writer <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> put_writerT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_sample_writerT"><span class="command">lemma</span></span> run_sample_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>sample <span class="free">p</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> sample <span class="free">p</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_writerT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_alt_writerT"><span class="command">lemma</span></span> run_alt_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>alt <span class="free">m</span> <span class="free">m'</span><span class="main">)</span> <span class="main">=</span> alt <span class="main">(</span>run_writer <span class="free">m</span><span class="main">)</span> <span class="main">(</span>run_writer <span class="free">m'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> alt_writerT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_altc_writerT"><span class="command">lemma</span></span> run_altc_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>altc <span class="free">C</span> <span class="free">f</span><span class="main">)</span> <span class="main">=</span> altc <span class="free">C</span> <span class="main">(</span>run_writer <span class="main">∘</span> <span class="free">f</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> altc_writerT_def o_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_pause_writerT"><span class="command">lemma</span></span> run_pause_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>pause <span class="free">out</span> <span class="free">c</span><span class="main">)</span> <span class="main">=</span> pause <span class="free">out</span> <span class="main">(</span><span class="main">λ</span><span class="bound">input</span><span class="main">.</span> run_writer <span class="main">(</span><span class="free">c</span> <span class="bound">input</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> pause_writerT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-run_tell_writerT"><span class="command">lemma</span></span> run_tell_writerT <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"run_writer <span class="main">(</span>tell <span class="main">(</span><span class="free">w</span> <span class="main">::</span> <span class="tfree">'w</span><span class="main">)</span> <span class="free">m</span> <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> <span class="main">=</span> 
  bind <span class="main">(</span>run_writer <span class="free">m</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main">(</span><span class="bound">a</span> <span class="main">::</span> <span class="tfree">'a</span><span class="main">,</span> <span class="bound">ws</span> <span class="main">::</span> <span class="tfree">'w</span> list<span class="main">)</span><span class="main">.</span> return <span class="main">(</span><span class="bound">a</span><span class="main">,</span> <span class="free">w</span> <span class="main">#</span> <span class="bound">ws</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> tell_writerT_def<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_writerT'"><span class="command">lemma</span></span> monad_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_writer_writerT'"><span class="command">lemma</span></span> monad_writer_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span>
  <span class="main">⟹</span> monad_writer return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>tell <span class="main">::</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> tell<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def tell_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_writer_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_fail_writerT'"><span class="command">lemma</span></span> monad_fail_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_fail return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> fail
  <span class="main">⟹</span> monad_fail return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> fail"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def fail_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_fail_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_writerT'"><span class="command">lemma</span></span> monad_state_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put
  <span class="main">⟹</span> monad_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> get<span class="main">)</span> put"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def get_writerT_def put_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_prob_writerT'"><span class="command">lemma</span></span> monad_prob_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample<span class="main">)</span>
  <span class="main">⟹</span> monad_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> sample<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def sample_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_prob_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_prob_writerT'"><span class="command">lemma</span></span> monad_state_prob_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample<span class="main">)</span>
  <span class="main">⟹</span> monad_state_prob return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>sample <span class="main">::</span> <span class="main">(</span><span class="tfree">'p</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> sample<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def sample_writerT_def get_writerT_def put_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_prob_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_reader_writerT'"><span class="command">lemma</span></span> monad_reader_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"monad_reader return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask<span class="main">)</span>
  <span class="main">⟹</span> monad_reader return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> ask<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def ask_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_reader_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_reader_state_writerT'"><span class="command">lemma</span></span> monad_reader_state_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> 
  <span class="quoted"><span class="quoted">"monad_reader_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put
  <span class="main">⟹</span> monad_reader_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>ask <span class="main">::</span> <span class="main">(</span><span class="tfree">'r</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> ask<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> get<span class="main">)</span> put"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def ask_writerT_def get_writerT_def put_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_reader_state_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_resumption_writerT'"><span class="command">lemma</span></span> monad_resumption_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_resumption return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> pause<span class="main">)</span>
  <span class="main">⟹</span> monad_resumption return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>pause <span class="main">::</span> <span class="main">(</span><span class="tfree">'o</span><span class="main">,</span> <span class="tfree">'i</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> pause<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def pause_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_resumption_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_alt_writerT'"><span class="command">lemma</span></span> monad_alt_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> alt
  <span class="main">⟹</span> monad_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def alt_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_alt_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_fail_alt_writerT'"><span class="command">lemma</span></span> monad_fail_alt_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_fail_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> fail alt
  <span class="main">⟹</span> monad_fail_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> fail alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def fail_writerT_def alt_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_fail_alt_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_alt_writerT'"><span class="command">lemma</span></span> monad_state_alt_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put alt
  <span class="main">⟹</span> monad_state_alt return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> get<span class="main">)</span> put alt"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def get_writerT_def put_writerT_def alt_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_alt_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_altc_writerT'"><span class="command">lemma</span></span> monad_altc_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc<span class="main">)</span>
  <span class="main">⟹</span> monad_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> altc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def altc_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_altc_writerT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_altc_writerT'"><span class="command">lemma</span></span> monad_state_altc_writerT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span> <span class="main">×</span> <span class="tfree">'w</span> list<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc<span class="main">)</span>
  <span class="main">⟹</span> monad_state_altc return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> get<span class="main">)</span> put <span class="main">(</span>altc <span class="main">::</span> <span class="main">(</span><span class="tfree">'c</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'w</span><span class="main">,</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> writerT<span class="main">)</span> altc<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_writerT_def bind_writerT_def get_writerT_def put_writerT_def altc_writerT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_altc_writerT<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Continuation monad transformer›</span></span>

<span class="keyword1"><span class="command">overloading</span></span>
  return_contT <span class="main">≡</span> <span class="quoted"><span class="quoted">"return <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> return"</span></span>
  bind_contT <span class="main">≡</span> <span class="quoted"><span class="quoted">"bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> bind"</span></span>
  fail_contT <span class="main">≡</span> <span class="quoted"><span class="quoted">"fail <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT fail"</span></span>
  get_contT <span class="main">≡</span> <span class="quoted"><span class="quoted">"get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> get"</span></span>
  put_contT <span class="main">≡</span> <span class="quoted"><span class="quoted">"put <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">return_contT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> return"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">return_contT</span> <span class="main">=</span> return_cont"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">bind_contT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> bind"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind_contT</span> <span class="main">=</span> bind_cont"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fail_contT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT fail"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">fail_contT</span> <span class="main">=</span> fail_cont fail"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">get_contT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> get"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">get_contT</span> <span class="main">=</span> get_cont get"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">put_contT</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="main">[</span><span class="operator">code_unfold</span><span class="main">,</span> <span class="operator">monad_unfold</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">put_contT</span> <span class="main">=</span> put_cont put"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Monad_Overloading-monad_contT'"><span class="command">lemma</span></span> monad_contT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> bind<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_contT_def bind_contT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_contT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_fail_contT'"><span class="command">lemma</span></span> monad_fail_contT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"monad_fail return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> bind<span class="main">)</span> fail"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_contT_def bind_contT_def fail_contT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_fail_contT<span class="main">)</span>

<span class="keyword1" id="Monad_Overloading-monad_state_contT'"><span class="command">lemma</span></span> monad_state_contT' <span class="main">[</span><span class="operator">locale_witness</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"monad_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get<span class="main">)</span> put
  <span class="main">⟹</span> monad_state return <span class="main">(</span>bind <span class="main">::</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> bind<span class="main">)</span> <span class="main">(</span>get <span class="main">::</span> <span class="main">(</span><span class="tfree">'s</span><span class="main">,</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> contT<span class="main">)</span> get<span class="main">)</span> put"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> return_contT_def bind_contT_def get_contT_def put_contT_def <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_state_contT<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Interpreter">
<div class="head">
<h1>Theory Interpreter</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Examples›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Monadic interpreter›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Interpreter <span class="keyword2"><span class="keyword">imports</span></span> <a href="Monomorphic_Monad.html">Monomorphic_Monad</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">declare</span></span> <span class="main">[</span><span class="main">[</span><span class="operator">show_variants</span><span class="main">]</span><span class="main">]</span>

<span class="keyword1"><span class="command">definition</span></span> <span class="quoted">"<span class="entity">apply</span>"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'b</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">apply</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>

<span class="keyword1" id="Interpreter-apply_eq_onp"><span class="command">lemma</span></span> apply_eq_onp<span class="main">:</span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span>eq_onp <span class="free">P</span> <span class="main">===&gt;</span> <span class="main">(=)</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> apply apply"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> rel_fun_def eq_onp_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Basic interpreter›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span>vars<span class="main">:</span> <span class="tfree">'v</span><span class="main">)</span> exp <span class="main">=</span> Var <span class="tfree"><span class="quoted"><span class="tfree">'v</span></span></span> <span class="main">|</span> Const <span class="quoted">int</span> <span class="main">|</span> Plus <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> exp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> exp"</span></span> <span class="main">|</span> Div <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> exp"</span></span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> exp"</span></span>

<span class="keyword1" id="Interpreter-rel_exp_simps"><span class="command">lemma</span></span> rel_exp_simps <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
  <span class="quoted"><span class="quoted">"rel_exp <span class="free">V</span> <span class="main">(</span>Var <span class="free">x</span><span class="main">)</span> <span class="free">e'</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">y</span><span class="main">.</span> <span class="free">e'</span> <span class="main">=</span> Var <span class="bound">y</span> <span class="main">∧</span> <span class="free">V</span> <span class="free">x</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"rel_exp <span class="free">V</span> <span class="main">(</span>Const <span class="free">n</span><span class="main">)</span> <span class="free">e'</span> <span class="main">⟷</span> <span class="free">e'</span> <span class="main">=</span> Const <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"rel_exp <span class="free">V</span> <span class="main">(</span>Plus <span class="free">e1</span> <span class="free">e2</span><span class="main">)</span> <span class="free">e'</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">e1'</span> <span class="bound">e2'</span><span class="main">.</span> <span class="free">e'</span> <span class="main">=</span> Plus <span class="bound">e1'</span> <span class="bound">e2'</span> <span class="main">∧</span> rel_exp <span class="free">V</span> <span class="free">e1</span> <span class="bound">e1'</span> <span class="main">∧</span> rel_exp <span class="free">V</span> <span class="free">e2</span> <span class="bound">e2'</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"rel_exp <span class="free">V</span> <span class="main">(</span>Div <span class="free">e1</span> <span class="free">e2</span><span class="main">)</span> <span class="free">e'</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">e1'</span> <span class="bound">e2'</span><span class="main">.</span> <span class="free">e'</span> <span class="main">=</span> Div <span class="bound">e1'</span> <span class="bound">e2'</span> <span class="main">∧</span> rel_exp <span class="free">V</span> <span class="free">e1</span> <span class="bound">e1'</span> <span class="main">∧</span> rel_exp <span class="free">V</span> <span class="free">e2</span> <span class="bound">e2'</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"rel_exp <span class="free">V</span> <span class="free">e</span> <span class="main">(</span>Var <span class="free">y</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">x</span><span class="main">.</span> <span class="free">e</span> <span class="main">=</span> Var <span class="bound">x</span> <span class="main">∧</span> <span class="free">V</span> <span class="bound">x</span> <span class="free">y</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"rel_exp <span class="free">V</span> <span class="free">e</span> <span class="main">(</span>Const <span class="free">n</span><span class="main">)</span> <span class="main">⟷</span> <span class="free">e</span> <span class="main">=</span> Const <span class="free">n</span>"</span></span>
  <span class="quoted"><span class="quoted">"rel_exp <span class="free">V</span> <span class="free">e</span> <span class="main">(</span>Plus <span class="free">e1'</span> <span class="free">e2'</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">e1</span> <span class="bound">e2</span><span class="main">.</span> <span class="free">e</span> <span class="main">=</span> Plus <span class="bound">e1</span> <span class="bound">e2</span> <span class="main">∧</span> rel_exp <span class="free">V</span> <span class="bound">e1</span> <span class="free">e1'</span> <span class="main">∧</span> rel_exp <span class="free">V</span> <span class="bound">e2</span> <span class="free">e2'</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"rel_exp <span class="free">V</span> <span class="free">e</span> <span class="main">(</span>Div <span class="free">e1'</span> <span class="free">e2'</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="main">∃</span><span class="bound">e1</span> <span class="bound">e2</span><span class="main">.</span> <span class="free">e</span> <span class="main">=</span> Div <span class="bound">e1</span> <span class="bound">e2</span> <span class="main">∧</span> rel_exp <span class="free">V</span> <span class="bound">e1</span> <span class="free">e1'</span> <span class="main">∧</span> rel_exp <span class="free">V</span> <span class="bound">e2</span> <span class="free">e2'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">:</span></span> exp.rel_cases<span class="main">)</span>

<span class="keyword1" id="Interpreter-finite_vars"><span class="command">lemma</span></span> finite_vars <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="main">(</span>vars <span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">locale</span></span> exp_base <span class="main">=</span> monad_fail_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">E</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">eval</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> exp <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">E</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="main">(</span>Const <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="free"><span class="bound"><span class="entity">i</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="main">(</span>Plus <span class="free"><span class="bound"><span class="entity">e1</span></span></span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">eval</span> <span class="main">(</span>Div <span class="free"><span class="bound"><span class="entity">e1</span></span></span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">eval</span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">j</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">fail</span> <span class="keyword1">else</span> <span class="free">return</span> <span class="main">(</span><span class="bound">i</span> <span class="keyword1">div</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">σ</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'w</span> exp"</span></span> <span class="keyword2"><span class="keyword">begin</span></span>
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">subst</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> exp <span class="main">⇒</span> <span class="tfree">'w</span> exp"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">subst</span> <span class="main">(</span>Const <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> Const <span class="free"><span class="bound"><span class="entity">n</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">subst</span> <span class="main">(</span>Var <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">σ</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">subst</span> <span class="main">(</span>Plus <span class="free"><span class="bound"><span class="entity">e1</span></span></span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">=</span> Plus <span class="main">(</span><span class="free">subst</span> <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">subst</span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">subst</span> <span class="main">(</span>Div <span class="free"><span class="bound"><span class="entity">e1</span></span></span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span> <span class="main">=</span> Div <span class="main">(</span><span class="free">subst</span> <span class="free"><span class="bound"><span class="entity">e1</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">subst</span> <span class="free"><span class="bound"><span class="entity">e2</span></span></span><span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Interpreter-compositional"><span class="command">lemma</span></span> compositional<span class="main">:</span> <span class="quoted"><span class="quoted">"eval <span class="free">E</span> <span class="main">(</span>subst <span class="free">σ</span> <span class="free">e</span><span class="main">)</span> <span class="main">=</span> eval <span class="main">(</span>eval <span class="free">E</span> <span class="main">∘</span> <span class="free">σ</span><span class="main">)</span> <span class="free">e</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span> <span class="operator">simp_all</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1" id="Interpreter-eval_parametric"><span class="command">lemma</span></span> eval_parametric <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> <span class="free">M</span> <span class="main">===&gt;</span> <span class="main">(</span><span class="free">V</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span> <span class="main">===&gt;</span> rel_exp <span class="free">V</span> <span class="main">===&gt;</span> <span class="free">M</span><span class="main">)</span>
   exp_base.eval exp_base.eval"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> exp_base.eval_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1"><span class="command">declare</span></span> exp_base.eval.simps <span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">context</span></span> exp_base <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Interpreter-eval_cong"><span class="command">lemma</span></span> eval_cong<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vars <span class="free">e</span> <span class="main">⟹</span> <span class="free">E</span> <span class="bound">x</span> <span class="main">=</span> <span class="free">E'</span> <span class="bound">x</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"eval <span class="free">E</span> <span class="free">e</span> <span class="main">=</span> eval <span class="free">E'</span> <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command">including</span></span> lifting_syntax
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">V</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">V</span> <span class="main">≡</span> eq_onp <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="bound">x</span> <span class="main">∈</span> vars <span class="free">e</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"rel_exp <span class="skolem">V</span> <span class="free">e</span> <span class="free">e</span>"</span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> exp.rel_refl_strong<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> V_def eq_onp_def<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="skolem">V</span> <span class="main">===&gt;</span> <span class="main">(=)</span><span class="main">)</span> <span class="free">E</span> <span class="free">E'</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> V_def rel_fun_def eq_onp_def<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Memoisation›</span></span>

<span class="keyword1" id="Interpreter-case_option_apply"><span class="command">lemma</span></span> case_option_apply<span class="main">:</span> <span class="quoted"><span class="quoted">"case_option <span class="free">none</span> <span class="free">some</span> <span class="free">x</span> <span class="free">y</span> <span class="main">=</span> case_option <span class="main">(</span><span class="free">none</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">some</span> <span class="bound">a</span> <span class="free">y</span><span class="main">)</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> monad_base<span class="main">)</span> bind_if2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">t</span> <span class="bound">x</span> <span class="keyword1">else</span> <span class="free">e</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free">b</span> <span class="keyword1">then</span> <span class="free">bind</span> <span class="free">m</span> <span class="free">t</span> <span class="keyword1">else</span> <span class="free">bind</span> <span class="free">m</span> <span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">in</span></span> monad_base<span class="main">)</span> bind_case_option2<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> case_option <span class="main">(</span><span class="free">none</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="free">some</span> <span class="bound">x</span><span class="main">)</span> <span class="free">y</span><span class="main">)</span> <span class="main">=</span> case_option <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="free">none</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">bind</span> <span class="free">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">some</span> <span class="bound">x</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>

<span class="keyword1"><span class="command">locale</span></span> memoization_base <span class="main">=</span> monad_state_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">memo</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'m</span><span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'k</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">memo</span> <span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> 
   <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">table</span><span class="main">.</span> 
   <span class="keyword1">case</span> <span class="bound">table</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> Some <span class="bound">y</span> <span class="main">⇒</span> <span class="free">return</span> <span class="bound">y</span> 
   <span class="main">|</span> None <span class="main">⇒</span> <span class="free">bind</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">f</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> update <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="bound">m</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">↦</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">return</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Interpreter-memo_cong"><span class="command">lemma</span></span> memo_cong <span class="main">[</span><span class="operator">cong</span><span class="main">,</span> <span class="operator">fundef_cong</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">x</span> <span class="main">=</span> <span class="free">y</span><span class="main">;</span> <span class="free">f</span> <span class="free">y</span> <span class="main">=</span> <span class="free">g</span> <span class="free">y</span> <span class="main">⟧</span> <span class="main">⟹</span> memo <span class="free">f</span> <span class="free">x</span> <span class="main">=</span> memo <span class="free">g</span> <span class="free">y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> memo_def <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> option.case_cong_weak<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span> memoization_base.memo_def <span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">locale</span></span> memoization <span class="main">=</span> memoization_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="main">+</span> monad_state <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'k</span> <span class="main">⇀</span> <span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Interpreter-memo_idem"><span class="command">lemma</span></span> memo_idem<span class="main">:</span> <span class="quoted"><span class="quoted">"memo <span class="main">(</span>memo <span class="free">f</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> memo <span class="free">f</span> <span class="free">x</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"memo <span class="main">(</span>memo <span class="free">f</span><span class="main">)</span> <span class="free">x</span> <span class="main">=</span> <span class="free">get</span> 
    <span class="main">(</span><span class="main">λ</span><span class="bound">table</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">table</span> <span class="free">x</span> <span class="keyword1">of</span> 
       None <span class="main">⇒</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">table'</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="keyword1">case</span> <span class="bound">table'</span> <span class="free">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> update <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="bound">m</span><span class="main">(</span><span class="free">x</span> <span class="main">↦</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">return</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>
                                                <span class="main">|</span> Some <span class="bound">x</span> <span class="main">⇒</span> <span class="free">return</span> <span class="bound">x</span><span class="main">)</span>
                             <span class="main">(</span><span class="main">λ</span><span class="bound">y</span><span class="main">.</span> update <span class="main">(</span><span class="main">λ</span><span class="bound">m</span><span class="main">.</span> <span class="bound">m</span> <span class="main">++</span> <span class="main">[</span><span class="free">x</span> <span class="main">↦</span> <span class="bound">y</span><span class="main">]</span><span class="main">)</span> <span class="main">(</span><span class="free">return</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
      <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">return</span> <span class="bound">y</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> memo_def get_const bind_get <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> option.case_cong_weak<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> memo <span class="free">f</span> <span class="free">x</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="free">get</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> get_get case_option_apply bind_assoc update_update bind_update return_bind o_def memo_def <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1" id="Interpreter-memo_same"><span class="command">lemma</span></span> memo_same<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>memo <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">g</span> <span class="bound">a</span> <span class="bound">a</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> memo_def bind_get option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">x</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> bind_assoc bind_update return_bind update_get o_def get_const<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> get_const<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">get</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> get_get<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> case_option_apply <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Interpreter-memo_commute"><span class="command">lemma</span></span> memo_commute<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> f_bind<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">m</span> <span class="bound">x</span> <span class="bound">g</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="bound">g</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">m</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="bound">g</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">and</span></span> f_get<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">x</span> <span class="bound">g</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="bound">g</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="bound">g</span> <span class="bound">s</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>memo <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="free">f</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="free">f</span> <span class="free">y</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">g</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> option.case_cong<span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> update_f<span class="main">:</span> <span class="quoted"><span class="quoted">"update <span class="skolem">F</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> update <span class="skolem">F</span> <span class="main">(</span><span class="skolem">g</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">F</span> <span class="skolem">x</span> <span class="skolem">g</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">UU</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"update <span class="skolem">F</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>update <span class="skolem">F</span> <span class="main">(</span><span class="free">return</span> <span class="skolem">UU</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">g</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_update return_bind<span class="main">)</span>
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>update <span class="skolem">F</span> <span class="main">(</span><span class="free">return</span> <span class="skolem">UU</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">g</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> f_bind<span class="main">)</span> 
    <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">f</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">a</span><span class="main">.</span> update <span class="skolem">F</span> <span class="main">(</span><span class="skolem">g</span> <span class="bound">a</span><span class="main">)</span><span class="main">)</span>"</span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_update return_bind<span class="main">)</span>
    <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> memo_def bind_get option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">x</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> bind_assoc bind_update return_bind update_get o_def f_get<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="free">get</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> get_get case_option_apply if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"case_option <span class="main">_</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"update <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"update <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> update_f update_update <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> if_cong<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="free">get</span>"</span></span><span class="main"><span class="main">]</span></span> ext <span class="quasi_keyword">split</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> option.split <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_if2<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> f_bind<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_upd_twist<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Probabilistic interpreter›</span></span>

<span class="keyword1"><span class="command">locale</span></span> memo_exp_base <span class="main">=</span>
  exp_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="main">+</span>
  memoization_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">s</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">fail</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> <span class="free">return</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Interpreter-lookup_alt_def"><span class="command">lemma</span></span> lookup_alt_def<span class="main">:</span> <span class="quoted"><span class="quoted">"lookup <span class="free">x</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> apply <span class="bound">s</span> <span class="free">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">fail</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> <span class="free">return</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> apply_def lookup_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> prob_exp_base <span class="main">=</span>
  memo_exp_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="main">+</span>
  monad_prob_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">sample</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sample_var</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> int pmf<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sample_var</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">sample</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free">return</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lazy</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> int pmf<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> exp <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lazy</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">≡</span> eval <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">sample_vars</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> int pmf<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> set <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">sample_vars</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">=</span> Finite_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">m</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">eager</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> int pmf<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> exp <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">eager</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">e</span></span></span> <span class="main">=</span> sample_vars <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">(</span>vars <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span> <span class="main">(</span>eval lookup <span class="free"><span class="bound"><span class="entity">e</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> <span class="main">[</span><span class="operator">code</span><span class="main">]</span> <span class="main">=</span>
  prob_exp_base.sample_var_def
  prob_exp_base.lazy_def
  prob_exp_base.eager_def

<span class="keyword1"><span class="command">locale</span></span> prob_exp <span class="main">=</span> prob_exp_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">sample</span></span> <span class="main">+</span> 
  memoization <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="main">+</span>
  monad_state_prob <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">sample</span></span> <span class="main">+</span>
  monad_fail <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">sample</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> sample"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Interpreter-comp_fun_commute_sample_var"><span class="command">lemma</span></span> comp_fun_commute_sample_var<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_fun_commute <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">m</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> memo_commute <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff sample_var_def bind_sample1 bind_sample2 return_bind sample_get<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> sample_var<span class="main">:</span> comp_fun_commute <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">m</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">rewrites</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">X</span> <span class="bound">m</span> <span class="bound">A</span><span class="main">.</span> Finite_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">m</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="bound">X</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="bound">m</span> <span class="bound">A</span> <span class="main">≡</span> sample_vars <span class="bound">X</span> <span class="bound">A</span> <span class="bound">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">X</span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> comp_fun_commute_sample_var<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_vars_def<span class="main">)</span>

<span class="keyword1" id="Interpreter-comp_fun_idem_sample_var"><span class="command">lemma</span></span> comp_fun_idem_sample_var<span class="main">:</span> <span class="quoted"><span class="quoted">"comp_fun_idem <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">m</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">unfold_locales</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fun_eq_iff memo_same<span class="main">)</span>

<span class="keyword1"><span class="command">interpretation</span></span> sample_var<span class="main">:</span> comp_fun_idem <span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span> <span class="bound">m</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">m</span><span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">rewrites</span></span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">X</span> <span class="bound">m</span> <span class="bound">A</span><span class="main">.</span> Finite_Set.fold <span class="main">(</span><span class="main">λ</span><span class="bound">x</span> <span class="bound">m</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="bound">X</span><span class="main">)</span> <span class="bound">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="bound">m</span><span class="main">)</span><span class="main">)</span> <span class="bound">m</span> <span class="bound">A</span> <span class="main">≡</span> sample_vars <span class="bound">X</span> <span class="bound">A</span> <span class="bound">m</span>"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">X</span>
  <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> comp_fun_idem_sample_var<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_vars_def<span class="main">)</span>

<span class="keyword1" id="Interpreter-sample_vars_empty"><span class="command">lemma</span></span> sample_vars_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"sample_vars <span class="free">X</span> <span class="main">{}</span> <span class="free">m</span> <span class="main">=</span> <span class="free">m</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_vars_def<span class="main">)</span>

<span class="keyword1" id="Interpreter-sample_vars_insert"><span class="command">lemma</span></span> sample_vars_insert<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="free">A</span> <span class="main">⟹</span> sample_vars <span class="free">X</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> sample_vars <span class="free">X</span> <span class="free">A</span> <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> sample_var.fold_insert_idem<span class="main">)</span>

<span class="keyword1" id="Interpreter-sample_vars_insert2"><span class="command">lemma</span></span> sample_vars_insert2<span class="main">:</span> 
  <span class="quoted"><span class="quoted">"finite <span class="free">A</span> <span class="main">⟹</span> sample_vars <span class="free">X</span> <span class="main">(</span>insert <span class="free">x</span> <span class="free">A</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> sample_vars <span class="free">X</span> <span class="free">A</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">m</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">fact</span> sample_var.fold_insert_idem2<span class="main">)</span>

<span class="keyword1" id="Interpreter-sample_vars_union"><span class="command">lemma</span></span> sample_vars_union<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="main">⟦</span> finite <span class="free">A</span><span class="main">;</span> finite <span class="free">B</span> <span class="main">⟧</span> <span class="main">⟹</span> sample_vars <span class="free">X</span> <span class="main">(</span><span class="free">A</span> <span class="main">∪</span> <span class="free">B</span><span class="main">)</span> <span class="free">m</span> <span class="main">=</span> sample_vars <span class="free">X</span> <span class="free">A</span> <span class="main">(</span>sample_vars <span class="free">X</span> <span class="free">B</span> <span class="free">m</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> Un_commute<span class="main">)</span><span class="main">(</span><span class="operator">rule</span> sample_var.fold_set_union<span class="main">)</span>

<span class="keyword1" id="Interpreter-memo_lookup"><span class="command">lemma</span></span> memo_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>memo <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>lookup <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="free">g</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="free">f</span> <span class="free">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">g</span> <span class="bound">i</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> option.case_cong_weak <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lookup_def memo_def bind_get option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">x</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> bind_assoc bind_update return_bind update_get o_def get_const<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> get_const<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free"><span class="quoted"><span class="free">get</span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> get_get case_option_apply <span class="quasi_keyword">cong</span><span class="main"><span class="main">:</span></span> option.case_cong<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1" id="Interpreter-lazy_eq_eager"><span class="command">lemma</span></span> lazy_eq_eager<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> put_fail<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⋀</span><span class="bound">s</span><span class="main">.</span> <span class="free">put</span> <span class="bound">s</span> <span class="free">fail</span> <span class="main">=</span> <span class="free">fail</span>"</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">"lazy <span class="free">X</span> <span class="free">e</span> <span class="main">=</span> eager <span class="free">X</span> <span class="free">e</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">note</span></span> option.case_cong <span class="main">[</span><span class="operator">cong</span><span class="main">]</span>
  <span class="keyword1"><span class="command">have</span></span> sample_var_get<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>sample_var <span class="free">X</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">get</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">get</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>sample_var <span class="free">X</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">i</span> <span class="bound">s</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_var_def bind_sample1 return_bind sample_get<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> update_fail <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"update <span class="skolem">f</span> <span class="free">fail</span> <span class="main">=</span> <span class="free">fail</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> update_def put_fail get_const<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> sample_vars_fail<span class="main">:</span> <span class="quoted"><span class="quoted">"sample_vars <span class="free">X</span> <span class="skolem">A</span> <span class="free">fail</span> <span class="main">=</span> <span class="free">fail</span>"</span></span> <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">A</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">A</span> <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">induction</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> memo_def bind_get option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">x</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> bind_assoc bind_update return_bind sample_var_def bind_sample1 sample_const case_option_collapse get_const <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> option.case_cong_weak<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> sample_var_const<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>sample_var <span class="free">X</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="skolem">m</span><span class="main">)</span> <span class="main">=</span> <span class="skolem">m</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">m</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_var_def bind_sample1 return_bind sample_const<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> sample_var_lookup_same<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>lookup <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">i</span> <span class="bound">i</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lookup_def bind_get memo_def option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">x</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> bind_assoc bind_update return_bind update_get sample_var_get option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">get</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> get_get case_option_apply<span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> sample_var_lookup_other<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>lookup <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>lookup <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">y</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="skolem">f</span> <span class="bound">i</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">≠</span> <span class="skolem">y</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">x</span> <span class="skolem">y</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lookup_def memo_def bind_get option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">x</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> bind_assoc return_bind bind_update update_get sample_var_get fail_bind option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">get</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> get_get case_option_apply<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>13<span class="main"><span class="main">)</span></span> get_const<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">clarsimp</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> option.case_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> h<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">get</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span> get_get case_option_apply fun_eq_iff sample_var_const <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> arg_cong<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="free">get</span></span><span class="main"><span class="main">]</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> option.split<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">have</span></span> sample_vars_lookup<span class="main">:</span> <span class="quoted"><span class="quoted">"sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>lookup <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>lookup <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span> 
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">V</span>"</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">V</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">V</span> <span class="skolem">x</span> <span class="skolem">f</span> <span class="keyword1"><span class="command">using</span></span> that
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span><span class="main">)</span><span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_var_lookup_other bind_return<span class="main">)</span>

  <span class="keyword1"><span class="command">have</span></span> lazy_sample_vars<span class="main">:</span> <span class="quoted"><span class="quoted">"sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>lazy <span class="free">X</span> <span class="skolem">e</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>lazy <span class="free">X</span> <span class="skolem">e</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword2"><span class="keyword">if</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">V</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="skolem">e</span> <span class="skolem">V</span> <span class="keyword1"><span class="command">using</span></span> that <span class="keyword1"><span class="command">unfolding</span></span> lazy_def
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="skolem">e</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">f</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Var <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="main">(</span><span class="keyword2"><span class="keyword">is</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">V</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">V</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">using</span></span> Var
    <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∈</span> <span class="skolem">V</span>"</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">V</span>
        <span class="keyword3"><span class="command">assume</span></span> False<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">x</span> <span class="main">∉</span> <span class="skolem">V</span>"</span></span> <span class="keyword2"><span class="keyword">and</span></span> fin<span class="main">:</span> <span class="quoted"><span class="quoted">"finite <span class="skolem">V</span>"</span></span>
        <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">V</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>lookup <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_var_lookup_same<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>lookup <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
          <span class="keyword1"><span class="command">using</span></span> fin False <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_vars_lookup<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> sample_vars <span class="free">X</span> <span class="main">(</span>insert <span class="skolem">x</span> <span class="skolem">V</span><span class="main">)</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>lookup <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fin
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_vars_insert<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>lookup <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> fin
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> sample_vars_insert2<span class="main">)</span>
        <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">V</span>"</span></span>
          <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_var_lookup_same<span class="main">)</span>
        <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">V</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">.</span></span> <span class="keyword1"><span class="command">}</span></span>
      <span class="keyword1"><span class="command">note</span></span> False <span class="main">=</span> this

      <span class="keyword3"><span class="command">case</span></span> True
      <span class="keyword1"><span class="command">hence</span></span> V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">V</span> <span class="main">=</span> insert <span class="skolem">x</span> <span class="main">(</span><span class="skolem">V</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
      <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="var">?lhs</span> <span class="skolem">V</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> sample_vars <span class="free">X</span> <span class="main">(</span><span class="skolem">V</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Var <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> V<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_vars_insert <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> Diff_insert0 insert_Diff_single<span class="main">)</span> 
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> sample_vars <span class="free">X</span> <span class="main">(</span><span class="skolem">V</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="skolem">f</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> memo_same<span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> sample_vars <span class="free">X</span> <span class="main">(</span><span class="skolem">V</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>memo <span class="main">(</span>sample_var <span class="free">X</span><span class="main">)</span> <span class="skolem">x</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span><span class="main">)</span>"</span></span>
        <span class="keyword1"><span class="command">using</span></span> Var <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">subst</span> False<span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
      <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">…</span> <span class="main">=</span> <span class="var">?rhs</span> <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">using</span></span> Var 
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rewrite</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">_</span></span></span> <span class="main"><span class="main"><span class="main">=</span></span></span> <span class="main"><span class="main"><span class="main">⌑</span></span></span>"</span></span></span></span> V<span class="main">)</span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> sample_vars_insert <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> Diff_insert0 insert_Diff_single<span class="main">)</span>
      <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">.</span></span>
    <span class="keyword1"><span class="command">qed</span></span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Const <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Plus <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc return_bind<span class="main">)</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Div <span class="skolem">e1</span> <span class="skolem">e2</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"<span class="main">λ</span><span class="bound">x</span><span class="main">.</span> <span class="free">bind</span> <span class="bound">x</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">]</span></span> fail_bind return_bind <span class="quasi_keyword">cong</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> if_weak_cong<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>6<span class="main"><span class="main">)</span></span> sample_vars_fail<span class="main"><span class="main">[</span></span><span class="operator">OF</span> <span class="quoted"><span class="quoted">‹finite <span class="skolem">V</span>›</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> if_distrib<span class="main"><span class="main">[</span></span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> f<span class="main"><span class="main"><span class="main">=</span></span></span><span class="quoted"><span class="quoted">"sample_vars <span class="main">_</span> <span class="main">_</span>"</span></span><span class="main"><span class="main">,</span></span> <span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span>

  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">V</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="skolem">V</span> <span class="main">≡</span> vars <span class="free">e</span>"</span></span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"vars <span class="free">e</span> <span class="main">⊆</span> <span class="skolem">V</span>"</span></span> <span class="quoted"><span class="quoted">"finite <span class="skolem">V</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp_all</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>eval lookup <span class="free">e</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> sample_vars <span class="free">X</span> <span class="skolem">V</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>lazy <span class="free">X</span> <span class="free">e</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span>
    <span class="keyword1"><span class="command">unfolding</span></span> lazy_def
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">e</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">f</span></span><span class="main">)</span>
    <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Var <span class="skolem">x</span><span class="main">)</span>
    <span class="keyword1"><span class="command">then</span></span> <span class="keyword1"><span class="command">have</span></span> V<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="skolem">V</span> <span class="main">=</span> insert <span class="skolem">x</span> <span class="main">(</span><span class="skolem">V</span> <span class="main">-</span> <span class="main">{</span><span class="skolem">x</span><span class="main">}</span><span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
    <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">using</span></span> Var
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> V<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">subst</span> <span class="main"><span class="main">(</span></span>1 2<span class="main"><span class="main">)</span></span> sample_vars_insert2<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> memo_same memo_lookup<span class="main">)</span>
      <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword1"><span class="command">qed</span></span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc lazy_sample_vars<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> lazy_def<span class="main"><span class="main">]</span></span><span class="main">)</span>
  <span class="keyword1"><span class="command">note</span></span> this<span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="free">return</span></span><span class="main">,</span> <span class="operator">unfolded</span> V_def<span class="main">]</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"sample_vars <span class="free">X</span> <span class="main">(</span>vars <span class="free">e</span><span class="main">)</span> <span class="main">(</span><span class="free">bind</span> <span class="main">(</span>lazy <span class="free">X</span> <span class="free">e</span><span class="main">)</span> <span class="skolem">f</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>lazy <span class="free">X</span> <span class="free">e</span><span class="main">)</span> <span class="skolem">f</span>"</span></span> <span class="keyword2"><span class="keyword">for</span></span> <span class="skolem">f</span> <span class="keyword1"><span class="command">unfolding</span></span> lazy_def
  <span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">e</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">f</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> Var   <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> memo_same bind_return<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> Const <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_return<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> Plus  <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc sample_vars_union lazy_sample_vars<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> lazy_def<span class="main"><span class="main">]</span></span> Plus.IH<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
    <span class="keyword1"><span class="command">{</span></span> <span class="keyword3"><span class="command">case</span></span> Div   <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
        <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_assoc sample_vars_union lazy_sample_vars<span class="main"><span class="main">[</span></span><span class="operator">unfolded</span> lazy_def<span class="main"><span class="main">]</span></span> Div.IH<span class="main">)</span> <span class="keyword1"><span class="command">}</span></span>
  <span class="keyword1"><span class="command">qed</span></span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_return V_def eager_def<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> F<span class="main">:</span> exp_base
  <span class="quoted"><span class="quoted">"return_option return_id"</span></span>
  <span class="quoted"><span class="quoted">"bind_option return_id bind_id"</span></span>
  <span class="quoted"><span class="quoted">"fail_option return_id"</span></span>
<span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="main">[</span>code<span class="main">]</span> <span class="quoted"><span class="quoted">"F.eval <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> return_option return_id <span class="numeral">5</span><span class="main">)</span> <span class="main">(</span>Plus <span class="main">(</span>Var <span class="inner_quoted">''a''</span><span class="main">)</span> <span class="main">(</span>Const <span class="numeral">7</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Moving between monad instances›</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> SFI<span class="main">:</span> memo_exp_base
  <span class="quoted"><span class="quoted">"return_state <span class="main">(</span>return_option <span class="main">(</span>return_id <span class="main">::</span> <span class="main">(</span><span class="main">(</span>int <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇀</span> int<span class="main">)</span><span class="main">)</span> option<span class="main">,</span> <span class="main">_</span><span class="main">)</span> return<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>bind_option return_id bind_id<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"fail_state <span class="main">(</span>fail_option return_id<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"get_state"</span></span>
  <span class="quoted"><span class="quoted">"put_state"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> SFI_lookup <span class="main">=</span> <span class="quoted">SFI.lookup</span> 
<span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> SFI<span class="main">:</span> memoization
  <span class="quoted"><span class="quoted">"return_state <span class="main">(</span>return_option <span class="main">(</span>return_id <span class="main">::</span> <span class="main">(</span><span class="main">(</span>int <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇀</span> int<span class="main">)</span><span class="main">)</span> option<span class="main">,</span> <span class="main">_</span><span class="main">)</span> return<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>bind_option return_id bind_id<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"get_state"</span></span>
  <span class="quoted"><span class="quoted">"put_state"</span></span>
<span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> SFP<span class="main">:</span> prob_exp
  <span class="quoted"><span class="quoted">"return_state <span class="main">(</span>return_option return_pmf<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>bind_option return_pmf bind_pmf<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"fail_state <span class="main">(</span>fail_option return_pmf<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"get_state"</span></span>
  <span class="quoted"><span class="quoted">"put_state"</span></span>
  <span class="quoted"><span class="quoted">"sample_state <span class="main">(</span>sample_option bind_pmf<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> SFP_lookup <span class="main">=</span> <span class="quoted">SFP.lookup</span>
<span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">interpretation</span></span> FSP<span class="main">:</span> prob_exp
  <span class="quoted"><span class="quoted">"return_option <span class="main">(</span>return_state <span class="main">(</span>return_pmf <span class="main">::</span> <span class="main">(</span>int option <span class="main">×</span> <span class="main">(</span><span class="tfree">'b</span> <span class="main">⇀</span> int<span class="main">)</span><span class="main">,</span> <span class="main">_</span><span class="main">)</span> return<span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind_option <span class="main">(</span>return_state return_pmf<span class="main">)</span> <span class="main">(</span>bind_state bind_pmf<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"fail_option <span class="main">(</span>return_state return_pmf<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"get_option get_state"</span></span>
  <span class="quoted"><span class="quoted">"put_option put_state"</span></span>
  <span class="quoted"><span class="quoted">"sample_option <span class="main">(</span>sample_state bind_pmf<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">..</span></span>


<span class="keyword1"><span class="command">locale</span></span> reader_exp_base <span class="main">=</span> exp_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="main">+</span> monad_reader_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">ask</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">ask</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> ask"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lookup</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">lookup</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> <span class="bound">s</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">fail</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> <span class="free">return</span> <span class="bound">y</span><span class="main">)</span>"</span></span>

<span class="keyword1" id="Interpreter-lookup_alt_def"><span class="command">lemma</span></span> lookup_alt_def<span class="main">:</span>
  <span class="quoted"><span class="quoted">"lookup <span class="free">x</span> <span class="main">=</span> <span class="free">ask</span> <span class="main">(</span><span class="main">λ</span><span class="bound">s</span><span class="main">.</span> <span class="keyword1">case</span> apply <span class="bound">s</span> <span class="free">x</span> <span class="keyword1">of</span> None <span class="main">⇒</span> <span class="free">fail</span> <span class="main">|</span> Some <span class="bound">y</span> <span class="main">⇒</span> <span class="free">return</span> <span class="bound">y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> lookup_def apply_def<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">locale</span></span> exp_commute <span class="main">=</span> exp_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="main">+</span> monad_commute <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Interpreter-eval_reverse"><span class="command">lemma</span></span> eval_reverse<span class="main">:</span>
  <span class="quoted"><span class="quoted">"eval <span class="free">E</span> <span class="main">(</span>Var <span class="free">x</span><span class="main">)</span> <span class="main">=</span> <span class="free">E</span> <span class="free">x</span>"</span></span>
  <span class="quoted"><span class="quoted">"eval <span class="free">E</span> <span class="main">(</span>Const <span class="free">i</span><span class="main">)</span> <span class="main">=</span> <span class="free">return</span> <span class="free">i</span>"</span></span>
  <span class="quoted"><span class="quoted">"eval <span class="free">E</span> <span class="main">(</span>Plus <span class="free">e1</span> <span class="free">e2</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>eval <span class="free">E</span> <span class="free">e2</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>eval <span class="free">E</span> <span class="free">e1</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="bound">i</span> <span class="main">+</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"eval <span class="free">E</span> <span class="main">(</span>Div <span class="free">e1</span> <span class="free">e2</span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>eval <span class="free">E</span> <span class="free">e2</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">j</span><span class="main">.</span> <span class="free">bind</span> <span class="main">(</span>eval <span class="free">E</span> <span class="free">e1</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="keyword1">if</span> <span class="bound">j</span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">fail</span> <span class="keyword1">else</span> <span class="free">return</span> <span class="main">(</span><span class="bound">i</span> <span class="keyword1">div</span> <span class="bound">j</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span><span class="main"><span class="keyword3">;</span></span> <span class="operator">rule</span> bind_commute<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> RFI<span class="main">:</span> reader_exp_base 
  <span class="quoted"><span class="quoted">"return_env <span class="main">(</span>return_option return_id<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind_env <span class="main">(</span>bind_option return_id bind_id<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"fail_env <span class="main">(</span>fail_option return_id<span class="main">)</span>"</span></span>
  <span class="quoted">ask_env</span>
  <span class="keyword2"><span class="keyword">defines</span></span> RFI_lookup <span class="main">=</span> <span class="quoted">RFI.lookup</span>
<span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">context</span></span> <span class="keyword2"><span class="keyword">includes</span></span> lifting_syntax <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Interpreter-cr_id_prob_eval"><span class="command">lemma</span></span> cr_id_prob_eval<span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> <span class="dynamic"><span class="dynamic">cr_id_prob_transfer</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"rel_stateT <span class="main">(=)</span> <span class="main">(</span>rel_optionT <span class="main">(</span>cr_id_prob <span class="main">(=)</span><span class="main">)</span><span class="main">)</span>
     <span class="main">(</span>SFI.eval SFI_lookup <span class="free">e</span><span class="main">)</span>
     <span class="main">(</span>SFP.eval SFP_lookup <span class="free">e</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> SFP.lookup_def SFI.lookup_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Interpreter-cr_envT_stateT_lookup'"><span class="command">lemma</span></span> cr_envT_stateT_lookup'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> <span class="dynamic"><span class="dynamic">cr_envT_stateT_transfer</span></span> apply_eq_onp <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">X</span> <span class="main">(</span>rel_optionT <span class="main">(</span>rel_id <span class="main">(</span>rel_option <span class="main">(</span>cr_prod1 <span class="free">X</span> <span class="main">(=)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
   RFI_lookup SFI_lookup"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> RFI.lookup_alt_def SFI.lookup_alt_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Interpreter-cr_envT_stateT_eval'"><span class="command">lemma</span></span> cr_envT_stateT_eval'<span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> <span class="dynamic"><span class="dynamic">cr_envT_stateT_transfer</span></span> cr_envT_stateT_lookup' <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">X</span> <span class="main">(</span>rel_optionT <span class="main">(</span>rel_id <span class="main">(</span>rel_option <span class="main">(</span>cr_prod1 <span class="free">X</span> <span class="main">(=)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="main">(</span>RFI.eval RFI_lookup<span class="main">)</span> <span class="main">(</span>SFI.eval SFI_lookup<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Interpreter-cr_envT_stateT_lookup"><span class="command">lemma</span></span> cr_envT_stateT_lookup <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> <span class="dynamic"><span class="dynamic">cr_id_prob_transfer</span></span> <span class="dynamic"><span class="dynamic">cr_envT_stateT_transfer</span></span> apply_eq_onp <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">X</span> <span class="main">(</span>rel_optionT <span class="main">(</span>cr_id_prob <span class="main">(</span>rel_option <span class="main">(</span>cr_prod1 <span class="free">X</span> <span class="main">(=)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
   RFI_lookup SFP_lookup"</span></span>
<span class="keyword1"><span class="command">unfolding</span></span> RFI.lookup_alt_def SFP.lookup_alt_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Interpreter-cr_envT_stateT_eval"><span class="command">lemma</span></span> cr_envT_stateT_eval <span class="main">[</span><span class="operator">cr_envT_stateT_transfer</span><span class="main">]</span><span class="main">:</span>
  <span class="keyword2"><span class="keyword">notes</span></span> <span class="main">[</span><span class="operator">transfer_rule</span><span class="main">]</span> <span class="main">=</span> <span class="dynamic"><span class="dynamic">cr_id_prob_transfer</span></span> <span class="dynamic"><span class="dynamic">cr_envT_stateT_transfer</span></span> <span class="keyword2"><span class="keyword">shows</span></span>
  <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">(=)</span> <span class="main">===&gt;</span> cr_envT_stateT <span class="free">X</span> <span class="main">(</span>rel_optionT <span class="main">(</span>cr_id_prob <span class="main">(</span>rel_option <span class="main">(</span>cr_prod1 <span class="free">X</span> <span class="main">(=)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>
  <span class="main">(</span>RFI.eval RFI_lookup<span class="main">)</span> <span class="main">(</span>SFP.eval SFP_lookup<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">transfer_prover</span>

<span class="keyword1" id="Interpreter-prob_eval_lookup"><span class="command">lemma</span></span> prob_eval_lookup<span class="main">:</span>
  <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>SFP.eval SFP_lookup <span class="free">e</span><span class="main">)</span> <span class="free">E</span> <span class="main">=</span> 
   map_optionT <span class="main">(</span>return_pmf <span class="main">∘</span> map_option <span class="main">(</span><span class="main">λ</span><span class="bound">b</span><span class="main">.</span> <span class="main">(</span><span class="bound">b</span><span class="main">,</span> <span class="free">E</span><span class="main">)</span><span class="main">)</span> <span class="main">∘</span> extract<span class="main">)</span> <span class="main">(</span>run_env <span class="main">(</span>RFI.eval RFI_lookup <span class="free">e</span><span class="main">)</span> <span class="free">E</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> cr_envT_stateT_eval<span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free"><span class="quoted"><span class="free">E</span></span></span></span></span></span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> rel_funD<span class="main"><span class="main">,</span></span> <span class="operator">OF</span> refl<span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> eq_alt<span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> cr_prod1_Grp option.rel_Grp cr_id_prob_Grp rel_optionT_Grp<span class="main"><span class="main">,</span></span> <span class="operator">simplified</span><span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> cr_envT_stateTD<span class="main"><span class="main">,</span></span> <span class="operator">unfolded</span> BNF_Def.Grp_def<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> conjunct1<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Non-deterministic interpreter›</span></span>

<span class="keyword1"><span class="command">locale</span></span> choose_base <span class="main">=</span> monad_altc_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">choose_var</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇒</span> int cset<span class="main">)</span> <span class="main">⇒</span> <span class="tfree">'v</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">choose_var</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="free">altc</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="free"><span class="bound"><span class="entity">x</span></span></span><span class="main">)</span> <span class="free">return</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">declare</span></span> choose_base.choose_var_def <span class="main">[</span><span class="operator">code</span><span class="main">]</span>

<span class="keyword1"><span class="command">locale</span></span> nondet_exp_base <span class="main">=</span> choose_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> memo_exp_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted">fail</span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lazy</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lazy</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> eval <span class="main">(</span>memo <span class="main">(</span>choose_var <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> nondet_exp <span class="main">=</span>
  monad_state_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="main">+</span>
  nondet_exp_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="main">+</span> 
  memoization <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> monad_fail <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted">fail</span> <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">rule</span> monad_fail<span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> NI<span class="main">:</span> cset_nondetM <span class="quoted">return_id</span> <span class="quoted">bind_id</span> <span class="quoted">merge_id</span> <span class="quoted">merge_id</span> 
  <span class="keyword2"><span class="keyword">defines</span></span> NI_return <span class="main">=</span> <span class="quoted">NI.return_nondet</span>
    <span class="keyword2"><span class="keyword">and</span></span> NI_bind <span class="main">=</span> <span class="quoted">NI.bind_nondet</span>
    <span class="keyword2"><span class="keyword">and</span></span> NI_altc <span class="main">=</span> <span class="quoted">NI.altc_nondet</span>
  <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> SNI<span class="main">:</span> nondet_exp
  <span class="quoted"><span class="quoted">"return_state NI_return"</span></span>
  <span class="quoted"><span class="quoted">"bind_state NI_bind"</span></span>
  <span class="quoted"><span class="quoted">"get_state"</span></span>
  <span class="quoted"><span class="quoted">"put_state"</span></span>
  <span class="quoted"><span class="quoted">"altc_state NI_altc"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> SNI_lazy <span class="main">=</span> <span class="quoted">SNI.lazy</span>
  <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>SNI_lazy <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> cinsert <span class="main">0</span> <span class="main">(</span>cinsert <span class="main">1</span> cempty<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Div <span class="main">(</span>Const <span class="numeral">2</span><span class="main">)</span> <span class="main">(</span>Var <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''x''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> Map.empty"</span></span>

<span class="keyword1"><span class="command">locale</span></span> nondet_fail_exp_base <span class="main">=</span> choose_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">altc</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">sublocale</span></span> memo_exp_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="keyword1"><span class="command">.</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">lazy</span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">lazy</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">=</span> eval <span class="main">(</span>memo <span class="main">(</span>choose_var <span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> nondet_fail_exp <span class="main">=</span>
  monad_state_altc <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="main">+</span>
  nondet_fail_exp_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="quoted"><span class="free">altc</span></span> <span class="main">+</span> 
  memoization <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">get</span></span> <span class="quoted"><span class="free">put</span></span> <span class="main">+</span>
  fail<span class="main">:</span> monad_fail <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">get</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> get"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">put</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'v</span> <span class="main">⇀</span> int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> put"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">altc</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> altc"</span></span>

<span class="keyword1"><span class="command">global_interpretation</span></span> SFNI<span class="main">:</span> nondet_fail_exp
  <span class="quoted"><span class="quoted">"return_state <span class="main">(</span>return_option NI_return<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"bind_state <span class="main">(</span>bind_option NI_return NI_bind<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"fail_state <span class="main">(</span>fail_option NI_return<span class="main">)</span>"</span></span>
  <span class="quoted"><span class="quoted">"get_state"</span></span>
  <span class="quoted"><span class="quoted">"put_state"</span></span>
  <span class="quoted"><span class="quoted">"altc_state <span class="main">(</span>altc_option NI_altc<span class="main">)</span>"</span></span>
  <span class="keyword2"><span class="keyword">defines</span></span> SFNI_lazy <span class="main">=</span> <span class="quoted">SFNI.lazy</span>
  <span class="keyword1"><span class="command">..</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>SFP.lazy <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> pmf_of_set <span class="main">{</span><span class="main">0</span><span class="main">,</span> <span class="main">1</span><span class="main">}</span><span class="main">)</span> <span class="main">(</span>Div <span class="main">(</span>Const <span class="numeral">2</span><span class="main">)</span> <span class="main">(</span>Var <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''x''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> Map.empty"</span></span>

<span class="keyword1"><span class="command">value</span></span> <span class="quoted"><span class="quoted">"run_state <span class="main">(</span>SFNI_lazy <span class="main">(</span><span class="main">λ</span><span class="bound">x</span><span class="main">.</span> cinsert <span class="main">0</span> <span class="main">(</span>cinsert <span class="main">1</span> cempty<span class="main">)</span><span class="main">)</span> <span class="main">(</span>Div <span class="main">(</span>Const <span class="numeral">2</span><span class="main">)</span> <span class="main">(</span>Var <span class="main">(</span><span class="keyword1">CHR</span> <span class="inner_quoted">''x''</span><span class="main">)</span><span class="main">)</span><span class="main">)</span><span class="main">)</span> Map.empty"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Just_Do_It_Examples">
<div class="head">
<h1>Theory Just_Do_It_Examples</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">theory</span></span> Just_Do_It_Examples <span class="keyword2"><span class="keyword">imports</span></span> <a href="Monomorphic_Monad.html">Monomorphic_Monad</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Examples adapted from Gibbons and Hinze (ICFP 2011)›</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Towers of Hanoi›</span></span>

<span class="keyword1"><span class="command">type_synonym</span></span> <span class="tfree">'m</span> tick <span class="main">=</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_count_base <span class="main">=</span> monad_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">tick</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> tick"</span></span>

<span class="keyword1"><span class="command">locale</span></span> monad_count <span class="main">=</span> monad_count_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">tick</span></span> <span class="main">+</span> monad <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="tfree">'a</span><span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">tick</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> tick"</span></span>
  <span class="main">+</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> bind_tick<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">bind</span> <span class="main">(</span><span class="free">tick</span> <span class="free">m</span><span class="main">)</span> <span class="free">f</span> <span class="main">=</span> <span class="free">tick</span> <span class="main">(</span><span class="free">bind</span> <span class="free">m</span> <span class="free">f</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">locale</span></span> hanoi_base <span class="main">=</span> monad_count_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">tick</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">tick</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> tick"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">hanoi</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">hanoi</span> <span class="main">0</span> <span class="main">=</span> <span class="free">return</span> <span class="main">()</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">hanoi</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span><span class="free">hanoi</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">tick</span> <span class="main">(</span><span class="free">hanoi</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">repeat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"nat <span class="main">⇒</span> <span class="tfree">'m</span> <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">repeat</span> <span class="main">0</span> <span class="free"><span class="bound"><span class="entity">mx</span></span></span> <span class="main">=</span> <span class="free">return</span> <span class="main">()</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">repeat</span> <span class="main">(</span>Suc <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">)</span> <span class="free"><span class="bound"><span class="entity">mx</span></span></span> <span class="main">=</span> <span class="free">bind</span> <span class="free"><span class="bound"><span class="entity">mx</span></span></span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> <span class="free">repeat</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">mx</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> hanoi <span class="main">=</span> hanoi_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">tick</span></span> <span class="main">+</span> monad_count <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">tick</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>unit<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">tick</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> tick"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1" id="Just_Do_It_Examples-repeat_1"><span class="command">lemma</span></span> repeat_1<span class="main">:</span> <span class="quoted"><span class="quoted">"repeat <span class="main">1</span> <span class="free">mx</span> <span class="main">=</span> <span class="free">mx</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> bind_return<span class="main">)</span>

<span class="keyword1" id="Just_Do_It_Examples-repeat_add"><span class="command">lemma</span></span> repeat_add<span class="main">:</span> <span class="quoted"><span class="quoted">"repeat <span class="main">(</span><span class="free">n</span> <span class="main">+</span> <span class="free">m</span><span class="main">)</span> <span class="free">mx</span> <span class="main">=</span> <span class="free">bind</span> <span class="main">(</span>repeat <span class="free">n</span> <span class="free">mx</span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="main"><span class="bound">_</span></span><span class="main">.</span> repeat <span class="free">m</span> <span class="free">mx</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> return_bind bind_assoc<span class="main">)</span>

<span class="keyword1" id="Just_Do_It_Examples-hanoi_correct"><span class="command">lemma</span></span> hanoi_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"hanoi <span class="free">n</span> <span class="main">=</span> repeat <span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="free">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">(</span><span class="free">tick</span> <span class="main">(</span><span class="free">return</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">proof</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">n</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> 0 <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span>
  <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"hanoi <span class="main">(</span>Suc <span class="skolem">n</span><span class="main">)</span> <span class="main">=</span> repeat <span class="main">(</span><span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="skolem">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span> <span class="main">+</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="skolem">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span><span class="main">)</span> <span class="main">(</span><span class="free">tick</span> <span class="main">(</span><span class="free">return</span> <span class="main">()</span><span class="main">)</span><span class="main">)</span>"</span></span>
    <span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> hanoi.simps repeat_add repeat_1 Suc.IH bind_assoc bind_tick return_bind<span class="main">)</span>
  <span class="keyword1"><span class="command">also</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="skolem">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">+</span> <span class="main">1</span> <span class="main">+</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> <span class="skolem">n</span> <span class="main">-</span> <span class="main">1</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="numeral">2</span> <span class="main">^</span> Suc <span class="skolem">n</span> <span class="main">-</span> <span class="main">1</span> <span class="main">::</span> nat<span class="main">)</span>"</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
  <span class="keyword1"><span class="command">finally</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> <span class="keyword1"><span class="command">.</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Fast product›</span></span>

<span class="keyword1"><span class="command">locale</span></span> fast_product_base <span class="main">=</span> monad_catch_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">catch</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">catch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> catch"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">work</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int list <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
<span class="keyword2"><span class="keyword">where</span></span> 
  <span class="quoted"><span class="quoted">"<span class="free">work</span> <span class="main">[]</span> <span class="main">=</span> <span class="free">return</span> <span class="main">1</span>"</span></span>
<span class="main">|</span> <span class="quoted"><span class="quoted">"<span class="free">work</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="keyword1">then</span> <span class="free">fail</span> <span class="keyword1">else</span> <span class="free">bind</span> <span class="main">(</span><span class="free">work</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="main">λ</span><span class="bound">i</span><span class="main">.</span> <span class="free">return</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">x</span></span></span> <span class="main">*</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">fastprod</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"int list <span class="main">⇒</span> <span class="tfree">'m</span>"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">"<span class="free">fastprod</span> <span class="free"><span class="bound"><span class="entity">xs</span></span></span> <span class="main">=</span> <span class="free">catch</span> <span class="main">(</span>work <span class="free"><span class="bound"><span class="entity">xs</span></span></span><span class="main">)</span> <span class="main">(</span><span class="free">return</span> <span class="main">0</span><span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword1"><span class="command">locale</span></span> fast_product <span class="main">=</span> fast_product_base <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">catch</span></span> <span class="main">+</span> monad_catch <span class="quoted"><span class="free">return</span></span> <span class="quoted"><span class="free">bind</span></span> <span class="quoted"><span class="free">fail</span></span> <span class="quoted"><span class="free">catch</span></span>
   <span class="keyword2"><span class="keyword">for</span></span> <span class="free">return</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> return"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">bind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>int<span class="main">,</span> <span class="tfree">'m</span><span class="main">)</span> bind"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">fail</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> fail"</span></span>
  <span class="keyword2"><span class="keyword">and</span></span> <span class="free">catch</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="tfree">'m</span> catch"</span></span>
<span class="keyword2"><span class="keyword">begin</span></span> 

<span class="keyword1" id="Just_Do_It_Examples-work_alt_def"><span class="command">lemma</span></span> work_alt_def<span class="main">:</span> <span class="quoted"><span class="quoted">"work <span class="free">xs</span> <span class="main">=</span> <span class="main">(</span><span class="keyword1">if</span> <span class="main">0</span> <span class="main">∈</span> set <span class="free">xs</span> <span class="keyword1">then</span> <span class="free">fail</span> <span class="keyword1">else</span> <span class="free">return</span> <span class="main">(</span>prod_list <span class="free">xs</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">induction</span> <span class="quoted"><span class="free">xs</span></span><span class="main">)</span><span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fail_bind return_bind<span class="main">)</span>

<span class="keyword1" id="Just_Do_It_Examples-fastprod_correct"><span class="command">lemma</span></span> fastprod_correct<span class="main">:</span> <span class="quoted"><span class="quoted">"fastprod <span class="free">xs</span> <span class="main">=</span> <span class="free">return</span> <span class="main">(</span>prod_list <span class="free">xs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> fastprod_def work_alt_def catch_fail catch_return prod_list_zero_iff<span class="main"><span class="main">[</span></span><span class="operator">symmetric</span><span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>