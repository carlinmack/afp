<div id="AutoProj">
<div class="head"><h1>Theory AutoProj</h1>
<span class="command">theory</span> <span class="name">AutoProj</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM

Is there an optimal order of arguments for `next'?
Currently we can have laws like `delta A (a#w) = delta A w o delta A a'
Otherwise we could have `acceps A == fin A o delta A (start A)'
and use foldl instead of foldl2.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Projection functions for automata"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>AutoProj</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>start</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a * 'b * 'c ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"start A = fst A"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"next"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a * 'b * 'c ⇒ 'b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"next A = fst(snd(A))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>fin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a * 'b * 'c ⇒ 'c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fin A = snd(snd(A))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"start(q,d,f) = q"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>start_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"next(q,d,f) = d"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>next_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fin(q,d,f) = f"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fin_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="DA">
<div class="head"><h1>Theory DA</h1>
<span class="command">theory</span> <span class="name">DA</span><br/>
<span class="keyword">imports</span> <a href="AutoProj.html"><span class="name">AutoProj</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Deterministic automata"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>DA</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>AutoProj</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span class="tfree">'s</span><span class="delimiter">)</span><span>da</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s * ('a ⇒ 's ⇒ 's) * ('s ⇒ bool)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>foldl2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b ⇒ 'b) ⇒ 'a list ⇒ 'b ⇒ 'b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"foldl2 f xs a = foldl (λa b. f b a) a xs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>delta</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)da ⇒ 'a list ⇒ 's ⇒ 's"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"delta A = foldl2 (next A)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>accepts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)da ⇒ 'a list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"accepts A = (λw. fin A (delta A w (start A)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"foldl2 f [] a = a ∧ foldl2 f (x#xs) a = foldl2 f xs (f x a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>foldl2_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delta_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"delta A [] s = s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>delta_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delta_Cons</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"delta A (a#w) s = delta A w (next A a s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>delta_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delta_append</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀q ys. delta A (xs@ys) q = delta A ys (delta A xs q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="NA">
<div class="head"><h1>Theory NA</h1>
<span class="command">theory</span> <span class="name">NA</span><br/>
<span class="keyword">imports</span> <a href="AutoProj.html"><span class="name">AutoProj</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Nondeterministic automata"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NA</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>AutoProj</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span class="tfree">'s</span><span class="delimiter">)</span><span> </span><span>na</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s * ('a ⇒ 's ⇒ 's set) * ('s ⇒ bool)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>delta</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)na ⇒ 'a list ⇒ 's ⇒ 's set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"delta A []    p = {p}"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"delta A (a#w) p = Union(delta A w ` next A a p)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>accepts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)na ⇒ 'a list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"accepts A w = (∃q ∈ delta A w (start A). fin A q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)na ⇒ 'a ⇒ ('s * 's)set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"step A a = {(p,q) . q : next A a p}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>steps</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)na ⇒ 'a list ⇒ ('s * 's)set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"steps A [] = Id"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"steps A (a#w) = step A a  O  steps A w"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_append</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"steps A (v@w) = steps A v  O  steps A w"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>v</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>O_assoc</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_steps_append</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(p,r) : steps A (v@w) = ((p,r) : (steps A v O steps A w))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>steps_append</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delta_conv_steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. delta A w p = {q. (p,q) : steps A w}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>w</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_conv_steps</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts A w = (∃q. (start A,q) ∈ steps A w ∧ fin A q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>delta_conv_steps</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>Cons_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a list set ⇒ 'a list set"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"##"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"x ## S ≡ Cons x ` S"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="NAe">
<div class="head"><h1>Theory NAe</h1>
<span class="command">theory</span> <span class="name">NAe</span><br/>
<span class="keyword">imports</span> <a href="NA.html"><span class="name">NA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Nondeterministic automata with epsilon transitions"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NAe</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>NA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span class="tfree">'s</span><span class="delimiter">)</span><span>nae</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a option,'s)na"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>eps</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)nae ⇒ ('s * 's)set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eps A ≡ step A None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>steps</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)nae ⇒ 'a list ⇒   ('s * 's)set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"steps A [] = (eps A)<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"steps A (a#w) = (eps A)<span class="hidden">⇧</span><sup>*</sup> O step A (Some a) O steps A w"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>accepts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)nae ⇒ 'a list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"accepts A w = (∃q. (start A,q) ∈ steps A w ∧ fin A q)"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* not really used:
consts delta :: "('a,'s)nae ⇒ 'a list ⇒ 's ⇒ 's set"
primrec
"delta A [] s = (eps A)<span class="hidden">⇧</span><sup>*</sup> `` {s}"
"delta A (a#w) s = lift(delta A w) (lift(next A (Some a)) ((eps A)<span class="hidden">⇧</span><sup>*</sup> `` {s}))"
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_epsclosure</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(eps A)<span class="hidden">⇧</span><sup>*</sup> O steps A w = steps A w"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>w</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>O_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_steps_epsclosure</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"[| (p,q) : (eps A)<span class="hidden">⇧</span><sup>*</sup>; (q,r) : steps A w |] ==&gt; (p,r) : steps A w"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>steps_epsclosure</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>epsclosure_steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"steps A w O (eps A)<span class="hidden">⇧</span><sup>*</sup> = steps A w"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>O_assoc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_epsclosure_steps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"[| (p,q) : steps A w; (q,r) : (eps A)<span class="hidden">⇧</span><sup>*</sup> |] ==&gt; (p,r) : steps A w"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>epsclosure_steps</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_append</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"steps A (v@w) = steps A v  O  steps A w"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>v</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>O_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_steps_append</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(p,r) : steps A (v@w) = ((p,r) : (steps A v O steps A w))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>steps_append</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Equivalence of steps and delta
* Use "(∃x ∈ f ` A. P x) = (∃a∈A. P(f x))" ?? *
Goal "∀p. (p,q) : steps A w = (q : delta A w p)";
by (induct_tac "w" 1);
 by (Simp_tac 1);
by (asm_simp_tac (simpset() addsimps [comp_def,step_def]) 1);
by (Blast_tac 1);
qed_spec_mp "steps_equiv_delta";
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Automata">
<div class="head"><h1>Theory Automata</h1>
<span class="command">theory</span> <span class="name">Automata</span><br/>
<span class="keyword">imports</span> <a href="DA.html"><span class="name">DA</span></a> <a href="NAe.html"><span class="name">NAe</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Conversions between automata"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Automata</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>DA</span><span> </span><span>NAe</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>na2da</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)na ⇒ ('a,'s set)da"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"na2da A = ({start A}, λa Q. Union(next A a ` Q), λQ. ∃q∈Q. fin A q)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>nae2da</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)nae ⇒ ('a,'s set)da"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"nae2da A = ({start A},
              λa Q. Union(next A (Some a) ` ((eps A)<span class="hidden">⇧</span><sup>*</sup> `` Q)),
              λQ. ∃p ∈ (eps A)<span class="hidden">⇧</span><sup>*</sup> `` Q. fin A p)"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*** Equivalence of NA and DA ***)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DA_delta_is_lift_NA_delta</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Q. DA.delta (na2da A) w Q = Union(NA.delta A w ` Q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>w</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>na2da_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NA_DA_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"NA.accepts A w = DA.accepts (na2da A) w"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DA.accepts_def</span><span> </span><span>NA.accepts_def</span><span> </span><span>DA_delta_is_lift_NA_delta</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>na2da_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*** Direct equivalence of NAe and DA ***)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>espclosure_DA_delta_is_steps</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Q. (eps A)<span class="hidden">⇧</span><sup>*</sup> `` (DA.delta (nae2da A) w Q) = steps A w `` Q"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>w</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>step_def</span><span> </span><span>nae2da_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NAe_DA_equiv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"DA.accepts (nae2da A) w = NAe.accepts A w"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Q. fin (nae2da A) Q = (∃q ∈ (eps A)<span class="hidden">⇧</span><sup>*</sup> `` Q. fin A q)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nae2da_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>espclosure_DA_delta_is_steps</span><span> </span><span>NAe.accepts_def</span><span> </span><span>DA.accepts_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nae2da_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="RegExp2NA">
<div class="head"><h1>Theory RegExp2NA</h1>
<span class="command">theory</span> <span class="name">RegExp2NA</span><br/>
<span class="keyword">imports</span> <a href="Regular_Exp.html"><span class="name">Regular_Exp</span></a> <a href="NA.html"><span class="name">NA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"From regular expressions directly to nondeterministic automata"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RegExp2NA</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Regular-Sets.Regular_Exp"</span></span></span><span> </span><span>NA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>bitsNA</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,bool list)na"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"atom"</span></span></span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a bitsNA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"atom a = ([True],
            λb s. if s=[True] ∧ b=a then {[False]} else {},
            λs. s=[False])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>or</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bitsNA ⇒ 'a bitsNA ⇒ 'a bitsNA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"or = (λ(ql,dl,fl)(qr,dr,fr).
   ([],
    λa s. case s of
            [] ⇒ (True ## dl a ql) ∪ (False ## dr a qr)
          | left#s ⇒ if left then True ## dl a s
                              else False ## dr a s,
    λs. case s of [] ⇒ (fl ql | fr qr)
                | left#s ⇒ if left then fl s else fr s))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>conc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bitsNA ⇒ 'a bitsNA ⇒ 'a bitsNA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"conc = (λ(ql,dl,fl)(qr,dr,fr).
   (True#ql,
    λa s. case s of
            [] ⇒ {}
          | left#s ⇒ if left then (True ## dl a s) ∪
                                   (if fl s then False ## dr a qr else {})
                              else False ## dr a s,
    λs. case s of [] ⇒ False | left#s ⇒ left ∧ fl s ∧ fr qr | ¬left ∧ fr s))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>epsilon</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bitsNA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"epsilon = ([],λa s. {}, λs. s=[])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>plus</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bitsNA ⇒ 'a bitsNA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"plus = (λ(q,d,f). (q, λa s. d a s ∪ (if f s then d a q else {}), f))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>star</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bitsNA ⇒ 'a bitsNA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"star A = or epsilon (plus A)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>rexp2na</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rexp ⇒ 'a bitsNA"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2na Zero       = ([], λa s. {}, λs. False)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2na One        = epsilon"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2na(Atom a)    = atom a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2na(Plus r s)  = or (rexp2na r) (rexp2na s)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2na(Times r s) = conc (rexp2na r) (rexp2na s)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2na(Star r)    = star (rexp2na r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>split_paired_all</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                       atom                         *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_atom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fin (atom a) q) = (q = [False])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>atom_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_atom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"start (atom a) = [True]"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>atom_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_step_atom_Some</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p,q) : step (atom a) b = (p=[True] ∧ q=[False] ∧ b=a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>atom_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>False_False_in_steps_atom</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"([False],[False]) : steps (atom a) w = (w = [])"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>relcomp_unfold</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_fin_in_steps_atom</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(start (atom a), [False]) : steps (atom a) w = (w = [a])"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>start_atom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>False_False_in_steps_atom</span><span> </span><span>relcomp_unfold</span><span> </span><span>start_atom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_atom</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts (atom a) w = (w = [a])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_conv_steps</span><span> </span><span>start_fin_in_steps_atom</span><span> </span><span>fin_atom</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                      or                            *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***** lift True/False over fin *****)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_or_True</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin (or L R) (True#p) = fin L p"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_or_False</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin (or L R) (False#p) = fin R p"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***** lift True/False over step *****)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_in_step_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀L R. (True#p,q) : step (or L R) a = (∃r. q = True#r ∧ (p,r) ∈ step L a)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>False_in_step_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀L R. (False#p,q) : step (or L R) a = (∃r. q = False#r ∧ (p,r) ∈ step R a)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***** lift True/False over steps *****)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_True_over_steps_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. (True#p,q)∈steps (or L R) w = (∃r. q = True # r ∧ (p,r) ∈ steps L w)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_False_over_steps_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. (False#p,q)∈steps (or L R) w = (∃r. q = False#r ∧ (p,r)∈steps R w)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** From the start  **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_step_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. (start(or L R),q) : step(or L R) a = 
         (∃p. (q = True#p ∧ (start L,p) : step L a) | 
               (q = False#p ∧ (start R,p) : step R a))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_or</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(start(or L R), q) : steps (or L R) w = 
  ( (w = [] ∧ q = start(or L R)) | 
    (w ≠ [] ∧ (∃p.  q = True  # p ∧ (start L,p) : steps L w | 
                      q = False # p ∧ (start R,p) : steps R w)))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_start_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin (or L R) (start(or L R)) = (fin L (start L) | fin R (start R))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts (or L R) w = (accepts L w | accepts R w)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_conv_steps</span><span> </span><span>steps_or</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* get rid of case_tac: *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"w = []"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                      conc                        *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** True/False in fin **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_conc_True</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin (conc L R) (True#p) = (fin L p ∧ fin R (start R))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_conc_False</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin (conc L R) (False#p) = fin R p"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** True/False in step **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_step_conc</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. (True#p,q) : step (conc L R) a = 
        ((∃r. q=True#r ∧ (p,r): step L a) | 
         (fin L p ∧ (∃r. q=False#r ∧ (start R,r) : step R a)))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>False_step_conc</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. (False#p,q) : step (conc L R) a = 
       (∃r. q = False#r ∧ (p,r) : step R a)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** False in steps **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>False_steps_conc</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. (False#p,q): steps (conc L R) w = (∃r. q=False#r ∧ (p,r): steps R w)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** True in steps **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_True_steps_concI</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R p. (p,q) : steps L w ⟹ (True#p,True#q) : steps (conc L R) w"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_False_step_conc</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. (True#p,False#q) : step (conc L R) a = 
         (fin L p ∧ (start R,q) : step R a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_steps_concD</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p. (True#p,q) : steps (conc L R) w ⟶ 
     ((∃r. (p,r) : steps L w ∧ q = True#r)  ∨ 
  (∃u a v. w = u@a#v ∧ 
            (∃r. (p,r) : steps L u ∧ fin L r ∧ 
            (∃s. (start R,s) : step R a ∧ 
            (∃t. (s,t) : steps R v ∧ q = False#t)))))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span> </span><span>del</span><span class="delimiter">:</span><span>disjCI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span> </span><span>del</span><span class="delimiter">:</span><span>disjCI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>impE</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"a#u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_steps_conc</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(True#p,q) : steps (conc L R) w = 
 ((∃r. (p,r) : steps L w ∧ q = True#r)  ∨
  (∃u a v. w = u@a#v ∧
            (∃r. (p,r) : steps L u ∧ fin L r ∧ 
            (∃s. (start R,s) : step R a ∧ 
            (∃t. (s,t) : steps R v ∧ q = False#t)))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>True_steps_concD</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>True_True_steps_concI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** starting from the start **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_conc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀L R. start(conc L R) = True#start L"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>final_conc</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin(conc L R) p = ((fin R (start R) ∧ (∃s. p = True#s ∧ fin L s)) ∨
                           (∃s. p = False#s ∧ fin R s))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_conc</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts (conc L R) w = (∃u v. w = u@v ∧ accepts L u ∧ accepts R v)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_conv_steps</span><span> </span><span>True_steps_conc</span><span> </span><span>final_conc</span><span> </span><span>start_conc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"v"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                     epsilon                        *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_epsilon</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"step epsilon a = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>epsilon_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_epsilon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((p,q) : steps epsilon w) = (w=[] ∧ p=q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_epsilon</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts epsilon w = (w = [])"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>steps_epsilon</span><span> </span><span>accepts_conv_steps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>epsilon_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                       plus                         *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_plus</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A. start (plus A) = start A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>plus_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_plus</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A. fin (plus A) = fin A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>plus_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_plusI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A. (p,q) : step A a ⟹ (p,q) : step (plus A) a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>plus_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_plusI</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. (p,q) : steps A w ⟹ (p,q) ∈ steps (plus A) w"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>step_plusI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_plus_conv</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A. (p,r): step (plus A) a = 
       ( (p,r): step A a | fin A p ∧ (start A,r) : step A a )"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>plus_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_steps_plusI</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| (start A,q) : steps A u; u ≠ []; fin A p |] 
 ==&gt; (p,q) : steps (plus A) u"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"u"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>steps_plusI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* reverse list induction! Complicates matters for conc? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_steps_plusD</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀r. (start A,r) ∈ steps (plus A) w ⟶
     (∃us v. w = concat us @ v ∧ 
              (∀u∈set us. accepts A u) ∧ 
              (start A,r) ∈ steps A v)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>w</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>impE</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"us"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"us@[v]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_conv_steps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_star_cycle</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"us ≠ [] ⟶ (∀u ∈ set us. accepts A u) ⟶ accepts (plus A) (concat us)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_conv_steps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>us</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>u</span><span> </span><span>us</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"us = []"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>steps_plusI</span><span> </span><span>fin_steps_plusI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"u = []"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>steps_plusI</span><span> </span><span>fin_steps_plusI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>steps_plusI</span><span> </span><span>fin_steps_plusI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_plus</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts (plus A) w = 
 (∃us. us ≠ [] ∧ w = concat us ∧ (∀u ∈ set us. accepts A u))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_conv_steps</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>start_steps_plusD</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"us@[v]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_conv_steps</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>steps_star_cycle</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                       star                         *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_star</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts (star A) w = (∃us. (∀u ∈ set us. accepts A u) ∧ w = concat us)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>star_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***** Correctness of r2n *****)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_rexp2na</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀w. accepts (rexp2na r) w = (w : lang r)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"r"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_conv_steps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_atom</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_conc</span><span> </span><span>Regular_Set.conc_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_star</span><span> </span><span>in_star_iff_concat</span><span> </span><span>subset_iff</span><span> </span><span>Ball_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="RegExp2NAe">
<div class="head"><h1>Theory RegExp2NAe</h1>
<span class="command">theory</span> <span class="name">RegExp2NAe</span><br/>
<span class="keyword">imports</span> <a href="Regular_Exp.html"><span class="name">Regular_Exp</span></a> <a href="NAe.html"><span class="name">NAe</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"From regular expressions to nondeterministic automata with epsilon"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RegExp2NAe</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Regular-Sets.Regular_Exp"</span></span></span><span> </span><span>NAe</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>bitsNAe</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,bool list)nae"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>epsilon</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bitsNAe"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"epsilon = ([],λa s. {}, λs. s=[])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"atom"</span></span></span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a bitsNAe"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"atom a = ([True],
            λb s. if s=[True] ∧ b=Some a then {[False]} else {},
            λs. s=[False])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>or</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bitsNAe ⇒ 'a bitsNAe ⇒ 'a bitsNAe"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"or = (λ(ql,dl,fl)(qr,dr,fr).
   ([],
    λa s. case s of
            [] ⇒ if a=None then {True#ql,False#qr} else {}
          | left#s ⇒ if left then True ## dl a s
                              else False ## dr a s,
    λs. case s of [] ⇒ False | left#s ⇒ if left then fl s else fr s))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>conc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bitsNAe ⇒ 'a bitsNAe ⇒ 'a bitsNAe"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"conc = (λ(ql,dl,fl)(qr,dr,fr).
   (True#ql,
    λa s. case s of
            [] ⇒ {}
          | left#s ⇒ if left then (True ## dl a s) ∪
                                   (if fl s ∧ a=None then {False#qr} else {})
                              else False ## dr a s,
    λs. case s of [] ⇒ False | left#s ⇒ ¬left ∧ fr s))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>star</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a bitsNAe ⇒ 'a bitsNAe"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"star = (λ(q,d,f).
   ([],
    λa s. case s of
            [] ⇒ if a=None then {True#q} else {}
          | left#s ⇒ if left then (True ## d a s) ∪
                                   (if f s ∧ a=None then {True#q} else {})
                              else {},
    λs. case s of [] ⇒ True | left#s ⇒ left ∧ f s))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>rexp2nae</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rexp ⇒ 'a bitsNAe"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2nae Zero       = ([], λa s. {}, λs. False)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2nae One        = epsilon"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2nae(Atom a)    = atom a"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2nae(Plus r s)  = or   (rexp2nae r) (rexp2nae s)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2nae(Times r s) = conc (rexp2nae r) (rexp2nae s)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"rexp2nae(Star r)    = star (rexp2nae r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>split_paired_all</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                     epsilon                        *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_epsilon</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"step epsilon a = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>epsilon_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_epsilon</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((p,q) : steps epsilon w) = (w=[] ∧ p=q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_epsilon</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts epsilon w = (w = [])"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>steps_epsilon</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>epsilon_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                       atom                         *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_atom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(fin (atom a) q) = (q = [False])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>atom_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_atom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"start (atom a) = [True]"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>atom_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Use {x. False} = {}? *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eps_atom</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"eps(atom a) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>atom_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_step_atom_Some</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p,q) : step (atom a) (Some b) = (p=[True] ∧ q=[False] ∧ b=a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>atom_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>False_False_in_steps_atom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"([False],[False]) : steps (atom a) w = (w = [])"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>relcomp_unfold</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_fin_in_steps_atom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(start (atom a), [False]) : steps (atom a) w = (w = [a])"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>start_atom</span><span> </span><span>rtrancl_empty</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>False_False_in_steps_atom</span><span> </span><span>relcomp_unfold</span><span> </span><span>start_atom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_atom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts (atom a) w = (w = [a])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_def</span><span> </span><span>start_fin_in_steps_atom</span><span> </span><span>fin_atom</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                      or                            *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***** lift True/False over fin *****)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_or_True</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin (or L R) (True#p) = fin L p"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_or_False</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin (or L R) (False#p) = fin R p"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***** lift True/False over step *****)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_in_step_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀L R. (True#p,q) : step (or L R) a = (∃r. q = True#r ∧ (p,r) : step L a)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>False_in_step_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⋀L R. (False#p,q) : step (or L R) a = (∃r. q = False#r ∧ (p,r) : step R a)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***** lift True/False over epsclosure *****)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma1a</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(tp,tq) : (eps(or L R))<span class="hidden">⇧</span><sup>*</sup> ⟹ 
 (⋀p. tp = True#p ⟹ ∃q. (p,q) : (eps L)<span class="hidden">⇧</span><sup>*</sup> ∧ tq = True#q)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma1b</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(tp,tq) : (eps(or L R))<span class="hidden">⇧</span><sup>*</sup> ⟹ 
 (⋀p. tp = False#p ⟹ ∃q. (p,q) : (eps R)<span class="hidden">⇧</span><sup>*</sup> ∧ tq = False#q)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2a</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p,q) : (eps L)<span class="hidden">⇧</span><sup>*</sup>  ⟹ (True#p, True#q) : (eps(or L R))<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2b</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p,q) : (eps R)<span class="hidden">⇧</span><sup>*</sup>  ⟹ (False#p, False#q) : (eps(or L R))<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_epsclosure_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(True#p,q) : (eps(or L R))<span class="hidden">⇧</span><sup>*</sup> = (∃r. q = True#r ∧ (p,r) : (eps L)<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>lemma1a</span><span> </span><span>lemma2a</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>False_epsclosure_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(False#p,q) : (eps(or L R))<span class="hidden">⇧</span><sup>*</sup> = (∃r. q = False#r ∧ (p,r) : (eps R)<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>lemma1b</span><span> </span><span>lemma2b</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***** lift True/False over steps *****)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_True_over_steps_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. (True#p,q):steps (or L R) w = (∃r. q = True # r ∧ (p,r):steps L w)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_False_over_steps_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. (False#p,q):steps (or L R) w = (∃r. q = False#r ∧ (p,r):steps R w)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***** Epsilon closure of start state *****)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unfold_rtrancl2</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"R<span class="hidden">⇧</span><sup>*</sup> = Id ∪ (R O R<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_eqI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>converse_rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_unfold_rtrancl2</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p,q) : R<span class="hidden">⇧</span><sup>*</sup> = (q = p | (∃r. (p,r) : R ∧ (r,q) : R<span class="hidden">⇧</span><sup>*</sup>))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>unfold_rtrancl2</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>in_unfold_rtrancl2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"start(or L R)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>L</span><span> </span><span>R</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_eps_or</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. (start(or L R),q) : eps(or L R) = 
       (q = True#start L | q = False#start R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_start_step_or_Some</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. (start(or L R),q) ∉ step (or L R) (Some a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_or</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(start(or L R), q) : steps (or L R) w = 
 ( (w = [] ∧ q = start(or L R)) | 
   (∃p.  q = True  # p ∧ (start L,p) : steps L w | 
         q = False # p ∧ (start R,p) : steps R w) )"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_or_not_final</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. ¬ fin (or L R) (start(or L R))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>or_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_or</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts (or L R) w = (accepts L w | accepts R w)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>accepts_def</span><span> </span><span>steps_or</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                      conc                          *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** True/False in fin **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_conc_True</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin (conc L R) (True#p) = False"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_conc_False</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin (conc L R) (False#p) = fin R p"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** True/False in step **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_step_conc</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. (True#p,q) : step (conc L R) a = 
       ((∃r. q=True#r ∧ (p,r): step L a) | 
        (fin L p ∧ a=None ∧ q=False#start R))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>False_step_conc</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. (False#p,q) : step (conc L R) a = 
       (∃r. q = False#r ∧ (p,r) : step R a)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** False in epsclosure **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma1b'</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(tp,tq) : (eps(conc L R))<span class="hidden">⇧</span><sup>*</sup> ⟹ 
  (⋀p. tp = False#p ⟹ ∃q. (p,q) : (eps R)<span class="hidden">⇧</span><sup>*</sup> ∧ tq = False#q)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2b'</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p,q) : (eps R)<span class="hidden">⇧</span><sup>*</sup> ⟹ (False#p, False#q) : (eps(conc L R))<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>False_epsclosure_conc</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"((False # p, q) : (eps (conc L R))<span class="hidden">⇧</span><sup>*</sup>) = 
 (∃r. q = False # r ∧ (p, r) : (eps R)<span class="hidden">⇧</span><sup>*</sup>)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>lemma1b'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>lemma2b'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** False in steps **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>False_steps_conc</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. (False#p,q): steps (conc L R) w = (∃r. q=False#r ∧ (p,r): steps R w)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fast</span><span class="delimiter">)</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*MUCH faster than blast*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** True in epsclosure **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_True_eps_concI</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p,q): (eps L)<span class="hidden">⇧</span><sup>*</sup> ⟹ (True#p,True#q) : (eps(conc L R))<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_True_steps_concI</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. (p,q) : steps L w ⟹ (True#p,True#q) : steps (conc L R) w"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>True_True_eps_concI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>True_True_eps_concI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma1a'</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(tp,tq) : (eps(conc L R))<span class="hidden">⇧</span><sup>*</sup> ⟹ 
 (⋀p. tp = True#p ⟹ 
  (∃q. tq = True#q ∧ (p,q) : (eps L)<span class="hidden">⇧</span><sup>*</sup>) | 
  (∃q r. tq = False#q ∧ (p,r):(eps L)<span class="hidden">⇧</span><sup>*</sup> ∧ fin L r ∧ (start R,q) : (eps R)<span class="hidden">⇧</span><sup>*</sup>))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2a'</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, q) : (eps L)<span class="hidden">⇧</span><sup>*</sup> ⟹ (True#p, True#q) : (eps(conc L R))<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lem</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. (p,q) : step R None ⟹ (False#p, False#q) : step (conc L R) None"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conc_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2b''</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p,q) : (eps R)<span class="hidden">⇧</span><sup>*</sup> ⟹ (False#p, False#q) : (eps(conc L R))<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>lem</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_False_eps_concI</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin L p ⟹ (True#p, False#start R) : eps(conc L R)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conc_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_epsclosure_conc</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"((True#p,q) ∈ (eps(conc L R))<span class="hidden">⇧</span><sup>*</sup>) = 
 ((∃r. (p,r) ∈ (eps L)<span class="hidden">⇧</span><sup>*</sup> ∧ q = True#r) ∨
  (∃r. (p,r) ∈ (eps L)<span class="hidden">⇧</span><sup>*</sup> ∧ fin L r ∧
        (∃s. (start R, s) ∈ (eps R)<span class="hidden">⇧</span><sup>*</sup> ∧ q = False#s)))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>lemma1a'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>lemma2a'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>lemma2a'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>converse_rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>True_False_eps_concI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>lemma2b''</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** True in steps **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_steps_concD</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀p. (True#p,q) : steps (conc L R) w ⟶ 
     ((∃r. (p,r) : steps L w ∧ q = True#r)  ∨
      (∃u v. w = u@v ∧ (∃r. (p,r) ∈ steps L u ∧ fin L r ∧
              (∃s. (start R,s) ∈ steps R v ∧ q = False#s))))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>disjCI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>disjCI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>disjCI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>impE</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"a#u"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_steps_conc</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(True#p,q) ∈ steps (conc L R) w = 
 ((∃r. (p,r) ∈ steps L w ∧ q = True#r)  | 
  (∃u v. w = u@v ∧ (∃r. (p,r) : steps L u ∧ fin L r ∧ 
          (∃s. (start R,s) : steps R v ∧ q = False#s))))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>True_steps_concD</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>True_True_steps_concI</span><span> </span><span>in_steps_epsclosure</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** starting from the start **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_conc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀L R. start(conc L R) = True#start L"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conc_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>final_conc</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀L R. fin(conc L R) p = (∃s. p = False#s ∧ fin R s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conc_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_conc</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts (conc L R) w = (∃u v. w = u@v ∧ accepts L u ∧ accepts R v)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_def</span><span> </span><span>True_steps_conc</span><span> </span><span>final_conc</span><span> </span><span>start_conc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*                       star                         *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(******************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_in_eps_star</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A. (True#p,q) ∈ eps(star A) = 
     ( (∃r. q = True#r ∧ (p,r) ∈ eps A) ∨ (fin A p ∧ q = True#start A) )"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>star_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_True_step_starI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A. (p,q) : step A a ⟹ (True#p, True#q) : step (star A) a"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>star_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_True_eps_starI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(p,r) : (eps A)<span class="hidden">⇧</span><sup>*</sup> ⟹ (True#p, True#r) : (eps(star A))<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>True_True_step_starI</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_start_eps_starI</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A. fin A p ⟹ (True#p,True#start A) : eps(star A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>star_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lem'</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(tp,s) : (eps(star A))<span class="hidden">⇧</span><sup>*</sup> ⟹ (∀p. tp = True#p ⟶
 (∃r. ((p,r) ∈ (eps A)<span class="hidden">⇧</span><sup>*</sup> ∨
        (∃q. (p,q) ∈ (eps A)<span class="hidden">⇧</span><sup>*</sup> ∧ fin A q ∧ (start A,r) : (eps A)<span class="hidden">⇧</span><sup>*</sup>)) ∧ 
       s = True#r))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rtrancl_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_eps_star</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"((True#p,s) ∈ (eps(star A))<span class="hidden">⇧</span><sup>*</sup>) = 
 (∃r. ((p,r) ∈ (eps A)<span class="hidden">⇧</span><sup>*</sup> ∨
        (∃q. (p,q) : (eps A)<span class="hidden">⇧</span><sup>*</sup> ∧ fin A q ∧ (start A,r) : (eps A)<span class="hidden">⇧</span><sup>*</sup>)) ∧
       s = True#r)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>lem'</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Why can't blast do the rest? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>True_True_eps_starI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>True_True_eps_starI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>rtrancl_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>r_into_rtrancl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>True_start_eps_starI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>True_True_eps_starI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** True in step Some **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_step_star</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A. (True#p,r) ∈ step (star A) (Some a) =
     (∃q. (p,q) ∈ step A (Some a) ∧ r=True#q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>star_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** True in steps **)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* reverse list induction! Complicates matters for conc? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_start_steps_starD</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀rr. (True#start A,rr) ∈ steps (star A) w ⟶
 (∃us v. w = concat us @ v ∧
             (∀u∈set us. accepts A u) ∧
             (∃r. (start A,r) ∈ steps A v ∧ rr = True#r))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>w</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>O_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>epsclosure_steps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>impE</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"us"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"v@[x]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>O_assoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>epsclosure_steps</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"us@[v@[x]]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_True_steps_starI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀p. (p,q) : steps A w ⟹ (True#p,True#q) : steps (star A) w"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>True_True_eps_starI</span><span> </span><span>True_True_step_starI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_star_cycle</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀u ∈ set us. accepts A u) ⟹
 (True#start A,True#start A) ∈ steps (star A) (concat us)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"us"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>True_True_steps_starI</span><span> </span><span>True_start_eps_starI</span><span> </span><span>in_epsclosure_steps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Better stated directly with start(star A)? Loop in star A back to start(star A)?*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>True_start_steps_star</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(True#start A,rr) : steps (star A) w = 
 (∃us v. w = concat us @ v ∧
             (∀u∈set us. accepts A u) ∧
             (∃r. (start A,r) ∈ steps A v ∧ rr = True#r))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>True_start_steps_starD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>steps_star_cycle</span><span> </span><span>True_True_steps_starI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** the start state **)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_step_star</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀A. (start(star A),r) : step (star A) a = (a=None ∧ r = True#start A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>star_def</span><span> </span><span>step_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>epsclosure_start_step_star</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>in_unfold_rtrancl2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="var">?p</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"start (star A)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>start_steps_star</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(start(star A),r) : steps (star A) w = 
 ((w=[] ∧ r= start(star A)) | (True#start A,r) : steps (star A) w)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>epsclosure_start_step_star</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>epsclosure_start_step_star</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>in_steps_epsclosure</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_star_True</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A. fin (star A) (True#p) = fin A p"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>star_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fin_star_start</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀A. fin (star A) (start(star A))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>star_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* too complex! Simpler if loop back to start(star A)? *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_star</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"accepts (star A) w = 
 (∃us. (∀u ∈ set(us). accepts A u) ∧ (w = concat us))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>start_steps_star</span><span> </span><span>True_start_steps_star</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"us@[v]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>xs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"us"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>rev_exhaust</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(***** Correctness of r2n *****)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>accepts_rexp2nae</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀w. accepts (rexp2nae r) w = (w : lang r)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"r"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_atom</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_or</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_conc</span><span> </span><span>Regular_Set.conc_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>accepts_star</span><span> </span><span>in_star_iff_concat</span><span> </span><span>subset_iff</span><span> </span><span>Ball_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="AutoRegExp">
<div class="head"><h1>Theory AutoRegExp</h1>
<span class="command">theory</span> <span class="name">AutoRegExp</span><br/>
<span class="keyword">imports</span> <a href="Automata.html"><span class="name">Automata</span></a> <a href="RegExp2NA.html"><span class="name">RegExp2NA</span></a> <a href="RegExp2NAe.html"><span class="name">RegExp2NAe</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Combining automata and regular expressions"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>AutoRegExp</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Automata</span><span> </span><span>RegExp2NA</span><span> </span><span>RegExp2NAe</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DA.accepts (na2da(rexp2na r)) w = (w : lang r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NA_DA_equiv</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span> </span><span>accepts_rexp2na</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"DA.accepts (nae2da(rexp2nae r)) w = (w : lang r)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NAe_DA_equiv</span><span> </span><span>accepts_rexp2nae</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="MaxPrefix">
<div class="head"><h1>Theory MaxPrefix</h1>
<span class="command">theory</span> <span class="name">MaxPrefix</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Sublist.html"><span class="name">Sublist</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Maximal prefix"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>MaxPrefix</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Sublist"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>is_maxpref</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a list ⇒ bool) ⇒ 'a list ⇒ 'a list ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"is_maxpref P xs ys =
 (prefix xs ys ∧ (xs=[] ∨ P xs) ∧ (∀zs. prefix zs ys ∧ P zs ⟶ prefix zs xs))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>splitter</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a list * 'a list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>is_maxsplitter</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a list ⇒ bool) ⇒ 'a splitter ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"is_maxsplitter P f =
 (∀xs ps qs. f xs = (ps,qs) = (xs=ps@qs ∧ is_maxpref P ps xs))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>maxsplit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a list ⇒ bool) ⇒ 'a list * 'a list ⇒ 'a list ⇒ 'a splitter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"maxsplit P res ps []     = (if P ps then (ps,[]) else res)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"maxsplit P res ps (q#qs) = maxsplit P (if P ps then (ps,q#qs) else res)
                                     (ps@[q]) qs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>if_split</span><span class="delimiter">[</span><span>split</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>maxsplit_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(maxsplit P res ps qs = (xs,ys)) =
  (if ∃us. prefix us qs ∧ P(ps@us) then xs@ys=ps@qs ∧ is_maxpref P xs (ps@qs)
   else (xs,ys)=res)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induction</span><span> </span><span>P</span><span> </span><span>res</span><span> </span><span>ps</span><span> </span><span>qs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>maxsplit.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_maxpref_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>P</span><span> </span><span>res</span><span> </span><span>ps</span><span> </span><span>q</span><span> </span><span>qs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃us. prefix us qs ∧ P ((ps @ [q]) @ us)"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ex1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">guess</span></span></span></span><span> </span><span>us</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>us</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ex2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃us. prefix us (q # qs) ∧ P (ps @ us)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"q#us"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ex1</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ex1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃us. prefix us (q#qs) ∧ P (ps @ us)"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>ex1</span><span> </span><span>False</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>ex1</span><span> </span><span>False</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>prefix_Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>ex2</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"P ps"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(maxsplit P (ps, q # qs) (ps @ [q]) qs = (xs, ys)) ⟷ (xs = ps ∧ ys = q # qs)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>ex1</span><span> </span><span>ex2</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⟷ (xs @ ys = ps @ q # qs ∧ is_maxpref P xs (ps @ q # qs))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex1</span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_maxpref_def</span><span> </span><span>prefix_append</span><span> </span><span>prefix_Cons</span><span> </span><span>append_eq_append_conv2</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>ex1</span><span> </span><span>ex2</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(maxsplit P res (ps @ [q]) qs = (xs, ys)) ⟷ ((xs, ys) = res)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>ex1</span><span> </span><span>ex2</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… ⟷ (xs @ ys = ps @ q # qs ∧ is_maxpref P xs (ps @ q # qs))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ex1</span><span> </span><span>ex2</span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>append_eq_append_conv2</span><span> </span><span>is_maxpref_def</span><span> </span><span>prefix_Cons</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>ex1</span><span> </span><span>ex2</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>if_split</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_maxpref_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃us. prefix us xs ∧ P us) ⟹ is_maxpref P ps xs = (ps = [])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>is_maxpref_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_maxsplitter_maxsplit</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_maxsplitter P (λxs. maxsplit P ([],xs) [] xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>maxsplit_lemma</span><span> </span><span>is_maxsplitter_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>maxsplit_eq</span><span> </span><span class="delimiter">=</span><span> </span><span>is_maxsplitter_maxsplit</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>is_maxsplitter_def</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="MaxChop">
<div class="head"><h1>Theory MaxChop</h1>
<span class="command">theory</span> <span class="name">MaxChop</span><br/>
<span class="keyword">imports</span> <a href="MaxPrefix.html"><span class="name">MaxPrefix</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Generic scanner"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>MaxChop</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>MaxPrefix</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>chopper</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a list list * 'a list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>is_maxchopper</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a list ⇒ bool) ⇒ 'a chopper ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"is_maxchopper P chopper =
 (∀xs zs yss.
    (chopper(xs) = (yss,zs)) =
    (xs = concat yss @ zs ∧ (∀ys ∈ set yss. ys ≠ []) ∧
     (case yss of
        [] ⇒ is_maxpref P [] xs
      | us#uss ⇒ is_maxpref P us xs ∧ chopper(concat(uss)@zs) = (uss,zs))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>reducing</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a splitter ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"reducing splitf =
 (∀xs ys zs. splitf xs = (ys,zs) ∧ ys ≠ [] ⟶ length zs &lt; length xs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>chop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a splitter ⇒ 'a list ⇒ 'a list list × 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"chop splitf xs = (if reducing splitf
                      then let pp = splitf xs
                           in if fst pp = [] then ([], xs)
                           else let qq = chop splitf (snd pp)
                                in (fst pp # fst qq, snd qq)
                      else undefined)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"measure (length ∘ snd)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reducing_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"splitf xs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_rule</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reducing splitf ⟹
  chop splitf xs = (let (pre, post) = splitf xs
                    in if pre = [] then ([], xs)
                       else let (xss, zs) = chop splitf post
                            in (pre # xss,zs))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>chop.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reducing_maxsplit</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reducing(λqs. maxsplit P ([],qs) [] qs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reducing_def</span><span> </span><span>maxsplit_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_maxsplitter_reducing</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_maxsplitter P splitf ⟹ reducing splitf"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>is_maxsplitter_def</span><span> </span><span>reducing_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_concat</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_maxsplitter P splitf ⟹
  (∀yss zs. chop splitf xs = (yss,zs) ⟶ xs = concat yss @ zs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span>length_induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>if_split</span><span>
</span><span>            </span><span>add</span><span class="delimiter">:</span><span> </span><span>chop_rule</span><span class="delimiter">[</span><span>OF</span><span> </span><span>is_maxsplitter_reducing</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>is_maxsplitter_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>chop_nonempty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_maxsplitter P splitf ⟹
  ∀yss zs. chop splitf xs = (yss,zs) ⟶ (∀ys ∈ set yss. ys ≠ [])"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span>length_induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>chop_rule</span><span> </span><span>is_maxsplitter_reducing</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>is_maxsplitter_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_maxchopper_chop</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>prem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_maxsplitter P splitf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"is_maxchopper P (chop splitf)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>is_maxchopper_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>chop_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>prem</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>prem</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>chop_nonempty</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>spec</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>mp</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>prem</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>is_maxsplitter_reducing</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>chop_rule</span><span class="delimiter">]</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>prem</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>is_maxsplitter_def</span><span class="delimiter">]</span><span>
</span><span>             </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>chop_concat</span><span class="delimiter">[</span><span>OF</span><span> </span><span>prem</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>prem</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>is_maxsplitter_reducing</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>chop_rule</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Let_def</span><span> </span><span>prem</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>is_maxsplitter_def</span><span class="delimiter">]</span><span>
</span><span>             </span><span>split</span><span class="delimiter">:</span><span> </span><span>prod.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>xs1</span><span> </span><span>ys1</span><span> </span><span>xss1</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split_asm</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_maxpref_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>prefix_append</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_maxpref_def</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>prefix_append</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>us</span><span> </span><span>uss</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs1=us"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_maxpref_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>prefix_append</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">]</span><span> </span><span>prefix_order.antisym</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="AutoMaxChop">
<div class="head"><h1>Theory AutoMaxChop</h1>
<span class="command">theory</span> <span class="name">AutoMaxChop</span><br/>
<span class="keyword">imports</span> <a href="DA.html"><span class="name">DA</span></a> <a href="MaxChop.html"><span class="name">MaxChop</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Automata based scanner"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>AutoMaxChop</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>DA</span><span> </span><span>MaxChop</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>auto_split</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)da ⇒ 's  ⇒ 'a list * 'a list ⇒ 'a list ⇒ 'a splitter"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"auto_split A q res ps []     = (if fin A q then (ps,[]) else res)"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"auto_split A q res ps (x#xs) =
   auto_split A (next A x q) (if fin A q then (ps,x#xs) else res) (ps@[x]) xs"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>auto_chop</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,'s)da ⇒ 'a chopper"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"auto_chop A = chop (λxs. auto_split A (start A) ([],xs) [] xs)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>delta_snoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"delta A (xs@[y]) q = next A y (delta A xs q)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auto_split_lemma</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀q ps res. auto_split A (delta A ps q) res ps xs =
              maxsplit (λys. fin A (delta A ys q)) res ps xs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>delta_snoc</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>delta_append</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>auto_split_is_maxsplit</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"auto_split A (start A) res [] xs = maxsplit (accepts A) res [] xs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>accepts_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>delta_Nil</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="var">?s</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"start A"</span></span></span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subst</span><span> </span><span>auto_split_lemma</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_maxsplitter_auto_split</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_maxsplitter (accepts A) (λxs. auto_split A (start A) ([],xs) [] xs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>auto_split_is_maxsplit</span><span> </span><span>is_maxsplitter_maxsplit</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_maxchopper_auto_chop</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_maxchopper (accepts A) (auto_chop A)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>auto_chop_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_maxchopper_chop</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>is_maxsplitter_auto_split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="RegSet_of_nat_DA">
<div class="head"><h1>Theory RegSet_of_nat_DA</h1>
<span class="command">theory</span> <span class="name">RegSet_of_nat_DA</span><br/>
<span class="keyword">imports</span> <a href="Regular_Set.html"><span class="name">Regular_Set</span></a> <a href="DA.html"><span class="name">DA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:     Tobias Nipkow
    Copyright   1998 TUM

To generate a regular expression, the alphabet must be finite.
regexp needs to be supplied with an 'a list for a unique order

add_Atom d i j r a = (if d a i = j then Union r (Atom a) else r)
atoms d i j as = foldl (add_Atom d i j) Empty as

regexp as d i j 0 = (if i=j then Union (Star Empty) (atoms d i j as)
                        else atoms d i j as
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"From deterministic automata to regular sets"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>RegSet_of_nat_DA</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Regular-Sets.Regular_Set"</span></span></span><span> </span><span>DA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>nat_next</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ nat ⇒ nat"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>deltas</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a nat_next ⇒ 'a list ⇒ nat ⇒ nat"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"deltas ≡ foldl2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>trace</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a nat_next ⇒ nat ⇒ 'a list ⇒ nat list"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"trace d i [] = []"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"trace d i (x#xs) = d x i # trace d (d x i) xs"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* conversion a la Warshall *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>regset</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a nat_next ⇒ nat ⇒ nat ⇒ nat ⇒ 'a list set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"regset d i j 0 = (if i=j then insert [] {[a] | a. d a i = j}
                          else {[a] | a. d a i = j})"</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">"regset d i j (Suc k) =
  regset d i j k ∪
  (regset d i k k) @@ (star(regset d k k k)) @@ (regset d k j k)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>regset_of_DA</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a,nat)da ⇒ nat ⇒ 'a list set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"regset_of_DA A k = (⋃j∈{j. j&lt;k ∧ fin A j}. regset (next A) (start A) j k)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span> </span><span>bounded</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a nat_next ⇒ nat ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">"bounded d k = (∀n. n &lt; k ⟶ (∀x. d x n &lt; k))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span>
</span><span>  </span><span>in_set_butlast_appendI</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">]</span><span> </span><span>less_SucI</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span>image_eqI</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Lists *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>butlast_empty</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(butlast xs = []) = (case xs of [] ⇒ True | y#ys ⇒ ys=[])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_set_butlast_concatI</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"x:set(butlast xs) ⟹ xs:set xss ⟹ x:set(butlast(concat xss))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"xss"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>butlast_append</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>ball_simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs=[]"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_set_butlastD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Regular sets *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* The main lemma:
   how to decompose a trace into a prefix, a list of loops and a suffix.
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decompose</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i. k ∈ set(trace d i xs) ⟶ (∃pref mids suf.
  xs = pref @ concat mids @ suf ∧
  deltas d pref i = k ∧ (∀n∈set(butlast(trace d i pref)). n ≠ k) ∧
  (∀mid∈set mids. (deltas d mid k = k) ∧
                  (∀n∈set(butlast(trace d k mid)). n ≠ k)) ∧
  (∀n∈set(butlast(trace d k suf)). n ≠ k))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>strip</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"d a i = k"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[a]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"k : set(trace d (d a i) as)"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>impE</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"pref#mids"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"suf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"as"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>in_set_butlastD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>impE</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>assumption</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"a#pref"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"mids"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"suf"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>length_trace</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. length(trace d i xs) = length xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs"</span></span></span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deltas_append</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀i. deltas d (xs@ys) i = deltas d ys (deltas d xs i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs"</span></span></span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trace_append</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀i. trace d i (xs@ys) = trace d i xs @ trace d (deltas d xs i) ys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs"</span></span></span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trace_concat</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀xs ∈ set xss. deltas d xs i = i) ⟹
  trace d i (concat xss) = concat (map (trace d i) xss)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"xss"</span></span></span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trace_is_Nil</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. (trace d i xs = []) = (xs = [])"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs"</span></span></span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trace_is_Cons_conv</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(trace d i xs = n#ns) =
  (case xs of [] ⇒ False | y#ys ⇒ n = d y i ∧ ns = trace d n ys)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_trace_conv</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. set(trace d i xs) =
  (if xs=[] then {} else insert(deltas d xs i)(set(butlast(trace d i xs))))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_commute</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deltas_concat</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀mid∈set mids. deltas d mid k = k) ⟹ deltas d (concat mids) k = k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>mids</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| n &lt; Suc k; n ≠ k |] ==&gt; n &lt; k"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>arith</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>regset_spec</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i j xs. xs ∈ regset d i j k =
        ((∀n∈set(butlast(trace d i xs)). n &lt; k) ∧ deltas d xs i = j)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>k</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.split</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conc_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span> </span><span>conjE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"(∀m∈set(butlast(trace d k xsb)). m &lt; Suc k) ∧ deltas d xsb k = k"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>set_trace_conv</span><span> </span><span>butlast_append</span><span> </span><span>ball_Un</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>star_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>set_trace_conv</span><span> </span><span>butlast_append</span><span> </span><span>ball_Un</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"k : set(butlast(trace d i xs))"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI1</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lem</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>disjI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>in_set_butlastD</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>decompose</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"pref"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lem</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>bspec</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"concat mids"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>concat_in_star</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>subset_iff</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lem</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>bspec</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>image_eqI</span><span> </span><span>in_set_butlast_concatI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lem</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trace_below</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"bounded d k ⟹ ∀i. i &lt; k ⟶ (∀n∈set(trace d i xs). n &lt; k)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>bounded_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>regset_below</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| bounded d k; i &lt; k; j &lt; k |] ==&gt;
  regset d i j k = {xs. deltas d xs i = j}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>set_eqI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>regset_spec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trace_below</span><span> </span><span>in_set_butlastD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>deltas_below</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. bounded d k ⟹ i &lt; k ⟹ deltas d w i &lt; k"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>bounded_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"w"</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>regset_DA_equiv</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| bounded (next A) k; start A &lt; k; j &lt; k |] ==&gt;
  w : regset_of_DA A k = accepts A w"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>regset_of_DA_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>conj_cong</span><span>
</span><span>            </span><span>add</span><span class="delimiter">:</span><span> </span><span>regset_below</span><span> </span><span>deltas_below</span><span> </span><span>accepts_def</span><span> </span><span>delta_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Execute">
<div class="head"><h1>Theory Execute</h1>
<span class="command">theory</span> <span class="name">Execute</span><br/>
<span class="keyword">imports</span> <a href="AutoRegExp.html"><span class="name">AutoRegExp</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:    Lukas Bulwahn, TUM 2011 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Executing Automata and membership of Regular Expressions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Execute</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>AutoRegExp</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Example›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>example_expression</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"example_expression = (let r0 = Atom (0::nat); r1 = Atom (1::nat)
     in Times (Star (Plus (Times r1 r1) r0)) (Star (Plus (Times r0 r0) r1)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NA.accepts (rexp2na example_expression) [0,1,1,0,0,1]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DA.accepts (na2da (rexp2na example_expression)) [0,1,1,0,0,1]"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Functional_Automata">
<div class="head"><h1>Theory Functional_Automata</h1>
<span class="command">theory</span> <span class="name">Functional_Automata</span><br/>
<span class="keyword">imports</span> <a href="AutoMaxChop.html"><span class="name">AutoMaxChop</span></a> <a href="RegSet_of_nat_DA.html"><span class="name">RegSet_of_nat_DA</span></a> <a href="Execute.html"><span class="name">Execute</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Functional_Automata</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>AutoRegExp</span><span> </span><span>AutoMaxChop</span><span> </span><span>RegSet_of_nat_DA</span><span> </span><span>Execute</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>