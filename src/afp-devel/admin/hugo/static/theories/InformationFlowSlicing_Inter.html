<div id="NonInterferenceInter">
<div class="head"><h1>Theory NonInterferenceInter</h1>
<span class="command">theory</span> <span class="name">NonInterferenceInter</span><br/>
<span class="keyword">imports</span> <a href="../HRB-Slicing/FundamentalProperty.html"><span class="name">FundamentalProperty</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹HRB Slicing guarantees IFC Noninterference›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NonInterferenceInter</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"HRB-Slicing.FundamentalProperty"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Assumptions of this Approach›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Classical IFC noninterference, a special case of a noninterference
definition using partial equivalence relations (per)
\cite{SabelfeldS:01}, partitions the variables (i.e.\ locations) into
security levels. Usually, only levels for secret or high, written
‹H›, and public or low, written ‹L›, variables are
used. Basically, a program that is noninterferent has to fulfil one
basic property: executing the program in two different initial states
that may differ in the values of their ‹H›-variables yields two
final states that again only differ in the values of their 
‹H›-variables; thus the values of the ‹H›-variables did not
influence those of the ‹L›-variables.

Every per-based approach makes certain
assumptions: (i) all \mbox{‹H›-variables} are defined at the
beginning of the program, (ii) all ‹L›-variables are observed (or
used in our terms) at the end and (iii) every variable is either
‹H› or ‹L›. This security label is fixed for a variable
and can not be altered during a program run. Thus, we have to extend 
the prerequisites of the slicing framework in \cite{Wasserrab:09} accordingly
in a new locale:

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>NonInterferenceInterGraph</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>SDG</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> 
</span><span>    </span><span>get_proc</span><span> </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span> </span><span>Def</span><span> </span><span>Use</span><span> </span><span>ParamDefs</span><span> </span><span>ParamUses</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>sourcenode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'node"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>targetnode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'node"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ ('var,'val,'ret,'pname) edge_kind"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Entry</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'('_Entry'_')"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>get_proc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'pname"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>get_return_edges</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'edge set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>procs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pname × 'var list × 'var list) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Main</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'pname"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Exit</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'node"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'('_Exit'_')"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Def</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Use</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'var set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ParamDefs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'var list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ParamUses</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'var set list"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>High</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'('_High'_')"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Low</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node"</span></span></span><span>   </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'('_Low'_')"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Entry_edge_Exit_or_High</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦valid_edge a; sourcenode a = (_Entry_)⟧ 
    ⟹ targetnode a = (_Exit_) ∨ targetnode a = (_High_)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>High_target_Entry_edge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃a. valid_edge a ∧ sourcenode a = (_Entry_) ∧ targetnode a = (_High_) ∧
       kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Entry_predecessor_of_High</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦valid_edge a; targetnode a = (_High_)⟧ ⟹ sourcenode a = (_Entry_)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Exit_edge_Entry_or_Low</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦valid_edge a; targetnode a = (_Exit_)⟧ 
    ⟹ sourcenode a = (_Entry_) ∨ sourcenode a = (_Low_)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Low_source_Exit_edge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∃a. valid_edge a ∧ sourcenode a = (_Low_) ∧ targetnode a = (_Exit_) ∧ 
       kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Exit_successor_of_Low</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦valid_edge a; sourcenode a = (_Low_)⟧ ⟹ targetnode a = (_Exit_)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>DefHigh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Def (_High_) = H"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>UseHigh</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Use (_High_) = H"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>UseLow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Use (_Low_) = L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>HighLowDistinct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ∩ L = {}"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>HighLowUNIV</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ∪ L = UNIV"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Low_neq_Exit</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"L ≠ {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_) ≠ (_Exit_)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_) = (_Exit_)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Use (_Exit_) = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UseLow</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹L ≠ {}›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Low_) = (_Exit_)›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_node_High</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"valid_node (_High_)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>High_target_Entry_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>valid_node_Low</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"valid_node (_Low_)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Low_source_Exit_edge</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_proc_Low</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"get_proc (_Low_) = Main"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Low_source_Exit_edge</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = (_Exit_)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (kind a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc (sourcenode a) = get_proc (targetnode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>get_proc_intra</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = (_Exit_)›</span></span></span><span> </span><span>get_proc_Exit</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>get_proc_High</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"get_proc (_High_) = Main"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>High_target_Entry_edge</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = (_Entry_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = (_High_)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (kind a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc (sourcenode a) = get_proc (targetnode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>get_proc_intra</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = (_Entry_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = (_High_)›</span></span></span><span> </span><span>get_proc_Entry</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Entry_path_High_path</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -as→* n"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_node n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>a'</span><span> </span><span>as'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = a'#as'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) -as'→* n"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>atomize_elim</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -as→* n›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inner_node n›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a' as'. as = a'#as' ∧ (_High_) -as'→* n ∧ kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>n'</span><span class="delimiter">≡</span><span class="string"><span class="delete"><span class="delete">"(_Entry_)"</span></span></span><span> </span><span>as</span><span> </span><span>n</span><span> </span><span>rule</span><span class="delimiter">:</span><span>path.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons_path</span><span> </span><span>n''</span><span> </span><span>as</span><span> </span><span>n'</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n'' -as→* n'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inner_node n'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n'' ≠ (_Exit_)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>inner_node_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = (_Entry_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = n''›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n'' = (_High_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>Entry_edge_Exit_or_High</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>High_target_Entry_edge</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = (_Entry_)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a' = (_High_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = (_Entry_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = n''›</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹n'' = (_High_)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n'' -as→* n'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n'' = (_High_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Exit_path_Low_path</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n -as→* (_Exit_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_node n"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>a'</span><span> </span><span>as'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = as'@[a']"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n -as'→* (_Low_)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>atomize_elim</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n -as→* (_Exit_)›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃as' a'. as = as'@[a'] ∧ n -as'→* (_Low_) ∧ kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>as</span><span> </span><span>rule</span><span class="delimiter">:</span><span>rev_induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inner_node n›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>snoc</span><span> </span><span>a'</span><span> </span><span>as'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n -as'@[a']→* (_Exit_)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n -as'→* sourcenode a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a' = (_Exit_)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_snoc</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = (_Entry_)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n -as'→* sourcenode a'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = (_Entry_)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>path_Entry_target</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inner_node n›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>inner_node_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a' = (_Exit_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = (_Low_)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>Exit_edge_Entry_or_Low</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Low_source_Exit_edge</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ax</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = (_Low_)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax = (_Exit_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a' = (_Exit_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = (_Low_)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' = ax"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n -as'→* sourcenode a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_Low_High</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∉ L ⟹ V ∈ H"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HighLowUNIV</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_High_Low</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∉ H ⟹ V ∈ L"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>HighLowUNIV</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Low Equivalence›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
In classical noninterference, an external observer can only see public values,
in our case the ‹L›-variables. If two states agree in the values of all 
‹L›-variables, these states are indistinguishable for him. 
\emph{Low equivalence} groups those states in an equivalence class using 
the relation ‹≈<span class="hidden">⇩</span><sub>L</sub>›:
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lowEquivalence</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('var ⇀ 'val) list ⇒ ('var ⇀ 'val) list ⇒ bool"</span></span></span><span> 
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"≈<span class="hidden">⇩</span><sub>L</sub>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≈<span class="hidden">⇩</span><sub>L</sub> s' ≡ ∀V ∈ L. hd s V = hd s' V"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The following lemmas connect low equivalent states with
relevant variables as necessary in the correctness proof for slicing.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>relevant_vars_Entry</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ rv S (CFG_node (_Entry_))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ L"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ rv S (CFG_node (_Entry_))›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>n'</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -as→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' ∈ HRB_slice S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Use<span class="hidden">⇘</span><sub>SDG<span class="hidden">⇙</span></sub> n'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n''. valid_SDG_node n'' ∧ parent_node n'' ∈ set (sourcenodes as) 
          ⟶ V ∉ Def<span class="hidden">⇘</span><sub>SDG<span class="hidden">⇙</span></sub> n''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>rvE</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -as→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node (parent_node n')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>path_valid_node</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_path_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"parent_node n'"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span>valid_node_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Entry</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ Use<span class="hidden">⇘</span><sub>SDG<span class="hidden">⇙</span></sub> n'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>SDG_Use_parent_Use</span><span class="delimiter">,</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Entry_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Exit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ Use<span class="hidden">⇘</span><sub>SDG<span class="hidden">⇙</span></sub> n'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>SDG_Use_parent_Use</span><span class="delimiter">,</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Exit_empty</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>inner</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -as→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span>as'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = a'#as'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) -as'→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>Entry_path_High_path</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_path_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -as→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as = a'#as'›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = (_Entry_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path.cases</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_path_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"as' = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) -as'→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"parent_node n' = (_High_)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_path_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n' ∈ HRB_slice S›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>valid_SDG_node_in_slice_parent_node_in_slice</span><span> 
</span><span>                    </span><span>simp</span><span class="delimiter">:</span><span>SDG_to_CFG_set_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) -as'→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (sourcenodes as') = (_High_)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>path_sourcenode</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_path_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (sourcenodes as') ∈ set (sourcenodes as')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>hd_in_set</span><span> </span><span>simp</span><span class="delimiter">:</span><span>sourcenodes_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as = a'#as'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd (sourcenodes as') ∈ set (sourcenodes as)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>sourcenodes_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hd (sourcenodes as') = (_High_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node (hd (sourcenodes as'))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_SDG_node (CFG_node (_High_))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹hd (sourcenodes as') = (_High_)›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹hd (sourcenodes as') ∈ set (sourcenodes as)›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹∀n''. valid_SDG_node n'' ∧ parent_node n'' ∈ set (sourcenodes as) 
        ⟶ V ∉ Def<span class="hidden">⇘</span><sub>SDG<span class="hidden">⇙</span></sub> n''›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∉ Def (_High_)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>CFG_Def_SDG_Def</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node (hd (sourcenodes as'))›</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∉ H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>DefHigh</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>not_High_Low</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lowEquivalence_relevant_nodes_Entry</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ≈<span class="hidden">⇩</span><sub>L</sub> s'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ rv S (CFG_node (_Entry_)). hd s V = hd s' V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ rv S (CFG_node (_Entry_))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ L"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>relevant_vars_Entry</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s ≈<span class="hidden">⇩</span><sub>L</sub> s'›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hd s V = hd s' V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lowEquivalence_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The Correctness Proofs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
In the following, we present two correctness proofs that slicing
guarantees IFC noninterference. In both theorems, ‹CFG_node
(_High_) ∉ HRB_slice S›, where ‹CFG_node (_Low_) ∈ S›, makes
sure that no high variable (which are all defined in ‹(_High_)›)
can influence a low variable (which are all used in ‹(_Low_)›).


First, a theorem regarding ‹(_Entry_) -as→* (_Exit_)› paths in the 
control flow graph (CFG), which agree to a complete program execution:›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>slpa_rv_Low_Use_Low</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG_node (_Low_) ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦same_level_path_aux cs as; upd_cs cs as = []; same_level_path_aux cs as';
    ∀c ∈ set cs. valid_edge c; m -as→* (_Low_); m -as'→* (_Low_);
   ∀i &lt; length cs. ∀V ∈ rv S (CFG_node (sourcenode (cs!i))). 
    fst (s!Suc i) V = fst (s'!Suc i) V; ∀i &lt; Suc (length cs). snd (s!i) = snd (s'!i);
   ∀V ∈ rv S (CFG_node m). state_val s V = state_val s' V;
   preds (slice_kinds S as) s; preds (slice_kinds S as') s';
   length s = Suc (length cs); length s' = Suc (length cs)⟧
   ⟹ ∀V ∈ Use (_Low_). state_val (transfers(slice_kinds S as) s) V =
                      state_val (transfers(slice_kinds S as') s') V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>m</span><span> </span><span>as'</span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>rule</span><span class="delimiter">:</span><span>slpa_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>slpa_empty</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -[]→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -[]→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>path_valid_node</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Use (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_) -[]→<span class="hidden">⇩</span><sub>ι</sub>* (_Low_)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>empty_path</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_path_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹CFG_node (_Low_) ∈ S›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG_node (_Low_) ∈ HRB_slice S"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>HRB_slice_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ rv S (CFG_node m)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>rvI</span><span> </span><span>CFG_Use_SDG_Use</span><span> </span><span>simp</span><span class="delimiter">:</span><span>sourcenodes_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ Use (_Low_). V ∈ rv S (CFG_node m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"L = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UseLow</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→* (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as' = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>m</span><span> </span><span>as'</span><span> </span><span>m'</span><span class="delimiter">≡</span><span class="string"><span class="delete"><span class="delete">"(_Low_)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span>path.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons_path</span><span> </span><span>m''</span><span> </span><span>as</span><span> </span><span>a</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = (_Exit_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_successor_of_Low</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = m''›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m'' -as→* (_Low_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_) = (_Exit_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_Exit_source</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>Low_neq_Exit</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ Use (_Low_). V ∈ rv S (CFG_node m)›</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ rv S (CFG_node m). state_val s V = state_val s' V›</span></span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>slpa_intra</span><span> </span><span>cs</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀m as' s s'. ⟦upd_cs cs as = []; same_level_path_aux cs as'; 
    ∀a∈set cs. valid_edge a; m -as→* (_Low_); m -as'→* (_Low_);
    ∀i&lt;length cs. ∀V∈rv S (CFG_node (sourcenode (cs ! i))).
    fst (s ! Suc i) V = fst (s' ! Suc i) V; 
    ∀i&lt;Suc (length cs). snd (s ! i) = snd (s' ! i);
    ∀V∈rv S (CFG_node m). state_val s V = state_val s' V;
    preds (slice_kinds S as) s; preds (slice_kinds S as') s';
    length s = Suc (length cs); length s' = Suc (length cs)⟧
    ⟹ ∀V∈Use (_Low_). state_val (transfers(slice_kinds S as) s) V =
    state_val (transfers(slice_kinds S as') s') V›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>rvs</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i&lt;length cs. ∀V∈rv S (CFG_node (sourcenode (cs ! i))).
    fst (s ! Suc i) V = fst (s' ! Suc i) V›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -a # as→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -as→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"L = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UseLow</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>as'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = (_Exit_)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_successor_of_Low</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Low_source_Exit_edge</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a' = (_Exit_)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = (_Exit_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = (_Low_)›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a' = (_Exit_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = (_Exit_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* (_Low_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_) = (_Exit_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_Exit_source</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>Low_neq_Exit</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>ax</span><span> </span><span>asx</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax -asx→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cf</span><span> </span><span>cfs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s = cf#cfs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax # asx›</span></span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cf'</span><span> </span><span>cfs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s' = cf'#cfs'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s'</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (kind ax)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span>edge_kind_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Call</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"slice_kind S a = kind a"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>slice_intra_kind_in_slice</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unique</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∃!a'. valid_edge a' ∧ sourcenode a' = sourcenode ax ∧ 
            intra_kind(kind a')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>call_only_one_intra_edge</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ get_return_edges ax"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>get_return_edge_call</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = sourcenode ax"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = (λcf. False)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>call_return_node_edge</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span> </span><span>unique</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = (λcf. False)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹slice_kind S a = kind a›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a#as)) s›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"slice_kind S ax = (λcf. False):r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>slice_kind_Call</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax # asx›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s'</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Return</span><span> </span><span>Q</span><span> </span><span>p</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>return_edges_only</span><span class="delimiter">,</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹same_level_path_aux cs as'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax#asx›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"same_level_path_aux cs asx"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = targetnode ax"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = ax"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈rv S (CFG_node m). state_val s V = state_val s' V›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax # asx›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rv</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀V∈rv S (CFG_node (targetnode a)). 
          state_val (transfer (slice_kind S a) s) V =
          state_val (transfer (slice_kind S a) s') V"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>rv_edge_slice_kinds</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹upd_cs cs (a # as) = []›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"upd_cs cs as = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax -asx→* (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = ax›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -asx→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cfx</span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"transfer (slice_kind S a) s = cfx#cfs ∧ snd cfx = snd cf"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>cf</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>slice_intra_kind_in_slice</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>slice_kind_Upd</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>kind_Predicate_notin_slice_slice_kind_Predicate</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cfx'</span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfx'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"transfer (slice_kind S a) s' = cfx'#cfs' ∧ snd cfx' = snd cf'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>cf'</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>slice_intra_kind_in_slice</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>slice_kind_Upd</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>kind_Predicate_notin_slice_slice_kind_Predicate</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>cfx</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i &lt; Suc (length cs). snd (s!i) = snd (s'!i)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snds</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i&lt;Suc(length cs).
          snd (transfer (slice_kind S a) s ! i) = 
          snd (transfer (slice_kind S a) s' ! i)"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>i</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rvs</span><span> </span><span>cfx</span><span> </span><span>cfx'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rvs'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length cs.
          ∀V∈rv S (CFG_node (sourcenode (cs ! i))).
          fst (transfer (slice_kind S a) s ! Suc i) V =
          fst (transfer (slice_kind S a) s' ! Suc i) V"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S as) 
          (transfer (slice_kind S a) s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax # asx›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = ax›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S asx) (transfer (slice_kind S a) s')"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (transfer (slice_kind S a) s) = length s"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>slice_intra_kind_in_slice</span><span> </span><span>slice_kind_Upd</span><span>
</span><span>          </span><span>elim</span><span class="delimiter">:</span><span>kind_Predicate_notin_slice_slice_kind_Predicate</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s = Suc (length cs)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (transfer (slice_kind S a) s) = Suc (length cs)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (transfer (slice_kind S a) s') = length s'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>slice_intra_kind_in_slice</span><span> </span><span>slice_kind_Upd</span><span>
</span><span>          </span><span>elim</span><span class="delimiter">:</span><span>kind_Predicate_notin_slice_slice_kind_Predicate</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s' = Suc (length cs)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (transfer (slice_kind S a) s') = Suc (length cs)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹upd_cs cs as = []›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹same_level_path_aux cs asx›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set cs. valid_edge c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* (_Low_)›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -asx→* (_Low_)›</span></span></span><span> </span><span>rvs'</span><span> </span><span>snds</span><span> </span><span>rv</span><span> </span><span>calculation</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax # asx›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = ax›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i &lt; Suc(length cs). snd (s!i) = snd (s'!i)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (hd s) = snd (hd s')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax # asx›</span></span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind ax)›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈rv S (CFG_node m). state_val s V = state_val s' V›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹length s = Suc (length cs)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s' = Suc (length cs)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>rv_branching_edges_slice_kinds_False</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>ax</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>slpa_Call</span><span> </span><span>cs</span><span> </span><span>a</span><span> </span><span>as</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀m as' s s'. 
    ⟦upd_cs (a # cs) as = []; same_level_path_aux (a # cs) as';
    ∀c∈set (a # cs). valid_edge c; m -as→* (_Low_); m -as'→* (_Low_);
    ∀i&lt;length (a # cs). ∀V∈rv S (CFG_node (sourcenode ((a # cs) ! i))).
    fst (s ! Suc i) V = fst (s' ! Suc i) V;
    ∀i&lt;Suc (length (a # cs)). snd (s ! i) = snd (s' ! i);
    ∀V∈rv S (CFG_node m). state_val s V = state_val s' V;
    preds (slice_kinds S as) s; preds (slice_kinds S as') s';
    length s = Suc (length (a # cs)); length s' = Suc (length (a # cs))⟧
    ⟹ ∀V∈Use (_Low_). state_val (transfers(slice_kinds S as) s) V =
    state_val (transfers(slice_kinds S as') s') V›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>rvs</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i&lt;length cs. ∀V∈rv S (CFG_node (sourcenode (cs ! i))).
    fst (s ! Suc i) V = fst (s' ! Suc i) V›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -a # as→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -as→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set cs. valid_edge c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c∈set (a # cs). valid_edge c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"L = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UseLow</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>as'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = (_Exit_)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_successor_of_Low</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Low_source_Exit_edge</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a' = (_Exit_)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = (_Exit_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = (_Low_)›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a' = (_Exit_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = (_Exit_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* (_Low_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_) = (_Exit_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_Exit_source</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>Low_neq_Exit</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>ax</span><span> </span><span>asx</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax -asx→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cf</span><span> </span><span>cfs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s = cf#cfs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax # asx›</span></span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cf'</span><span> </span><span>cfs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"s' = cf'#cfs'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s'</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q r p fs. kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span>edge_kind_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Intra</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind ax)›</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"slice_kind S ax = kind ax"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>slice_intra_kind_in_slice</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>unique</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∃!a'. valid_edge a' ∧ sourcenode a' = sourcenode a ∧ 
            intra_kind(kind a')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>call_only_one_intra_edge</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ get_return_edges a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>get_return_edge_call</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span> 
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = sourcenode a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = (λcf. False)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>call_return_node_edge</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind ax)›</span></span></span><span> </span><span>unique</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' = ax"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = (λcf. False)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> 
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹slice_kind S ax = kind ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax # asx›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"slice_kind S a = (λcf. False):r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>slice_kind_Call</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Return</span><span> </span><span>Q'</span><span> </span><span>p'</span><span> </span><span>f'</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = Q'↩<span class="hidden">⇘</span><sub>p'<span class="hidden">⇙</span></sub>f'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>return_edges_only</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"slice_kind S a = (λcf. False):r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>slice_kind_Call</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (kind a) s"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>slice_kind_Call_in_slice</span><span> </span><span>simp</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax # asx›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹∃Q r p fs. kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (kind ax) s'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>slice_kind_Call_in_slice</span><span> </span><span>simp</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Use (sourcenode a)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a -[]→<span class="hidden">⇩</span><sub>ι</sub>* sourcenode a"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>empty_path</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_path_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ Use (sourcenode a)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ rv S (CFG_node (sourcenode a))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>rvI</span><span> </span><span>CFG_Use_SDG_Use</span><span> </span><span>simp</span><span class="delimiter">:</span><span>SDG_to_CFG_set_def</span><span> </span><span>sourcenodes_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈rv S (CFG_node m). state_val s V = state_val s' V›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Use</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀V ∈ Use (sourcenode a). state_val s V = state_val s' V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i&lt;Suc (length cs). snd (s ! i) = snd (s' ! i)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (hd s) = snd (hd s')"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹∃Q r p fs. kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (kind a) s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (kind ax) s'›</span></span></span><span> </span><span>Use</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s = Suc (length cs)›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹length s' = Suc (length cs)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ax = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>CFG_equal_Use_equal_call</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹same_level_path_aux cs as'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax#asx›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹∃Q r p fs. kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"same_level_path_aux (a # cs) asx"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax -asx→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -asx→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹upd_cs cs (a # as) = []›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"upd_cs (a # cs) as = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>slice_kind</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"slice_kind S a = 
        Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>(cspp (targetnode a) (HRB_slice S) fs)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>slice_kind_Call_in_slice</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i&lt;Suc (length cs). snd (s ! i) = snd (s' ! i)›</span></span></span><span> </span><span>slice_kind</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snds</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i&lt;Suc (length (a # cs)).
        snd (transfer (slice_kind S a) s ! i) =
        snd (transfer (slice_kind S a) s' ! i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>i</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ins</span><span> </span><span>outs</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p,ins,outs) ∈ set procs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>callee_in_procs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (ParamUses (sourcenode a)) = length ins"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>ParamUses_call_source_length</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; length ins. ∀V ∈ (ParamUses (sourcenode a))!i. V ∈ Use (sourcenode a)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>ParamUses_in_Use</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ Use (sourcenode a). state_val s V = state_val s' V›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; length ins. ∀V ∈ (ParamUses (sourcenode a))!i. 
        state_val s V = state_val s' V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p,ins,outs) ∈ set procs›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (kind a) s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (kind ax) s'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; length ins. (params fs (fst (hd s)))!i = (params fs (fst (hd s')))!i"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>CFG_call_edge_params</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p,ins,outs) ∈ set procs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length fs = length ins"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFG_call_edge_length</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length fs"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length fs = length ins›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ins"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length fs›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(params fs (fst cf))!i = (fs!i) (fst cf)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>params_nth</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length fs›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(params fs (fst cf'))!i = (fs!i) (fst cf')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>params_nth</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fs!i) (fst (hd s)) = (fs!i) (fst (hd s'))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length ins›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i &lt; length ins. (params fs (fst (hd s)))!i = (params fs (fst (hd s')))!i›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀i &lt; length fs. (fs ! i) (fst cf) = (fs ! i) (fst cf')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length fs"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i &lt; length fs. (fs ! i) (fst cf) = (fs ! i) (fst cf')›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fs ! i) (fst cf) = (fs ! i) (fst cf')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((csppa (targetnode a) (HRB_slice S) 0 fs)!i)(fst cf) =
          ((csppa (targetnode a) (HRB_slice S) 0 fs)!i)(fst cf')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Formal_in(targetnode a,i + 0) ∈  HRB_slice S"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length fs›</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(csppa (targetnode a) (HRB_slice S) 0 fs)!i = fs!i"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>csppa_Formal_in_in_slice</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(fs ! i) (fst cf) = (fs ! i) (fst cf')›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length fs›</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(csppa (targetnode a) (HRB_slice S) 0 fs)!i = Map.empty"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>csppa_Formal_in_notin_slice</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i &lt; length fs.
        ((cspp (targetnode a) (HRB_slice S) fs)!i)(fst cf) =
        ((cspp (targetnode a) (HRB_slice S) fs)!i)(fst cf')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cspp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length fs"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(params (cspp (targetnode a) (HRB_slice S) fs)
          (fst cf))!i =
          ((cspp (targetnode a) (HRB_slice S) fs)!i)(fst cf)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>params_nth</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length fs›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(params (cspp (targetnode a) (HRB_slice S) fs)
          (fst cf'))!i =
          ((cspp (targetnode a) (HRB_slice S) fs)!i)(fst cf')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>params_nth</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(params (cspp (targetnode a) (HRB_slice S) fs)
          (fst cf))!i =
          (params (cspp (targetnode a) (HRB_slice S) fs)(fst cf'))!i"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length fs›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"params (cspp (targetnode a) (HRB_slice S) fs)(fst cf) =
        params (cspp (targetnode a) (HRB_slice S) fs)(fst cf')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>list_eq_iff_nth_eq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>slice_kind</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p,ins,outs) ∈ set procs›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cfx</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"transfer (slice_kind S a) (cf#cfs) = cfx#cf#cfs"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"transfer (slice_kind S a) (cf'#cfs') = cfx#cf'#cfs'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>rv</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀V∈rv S (CFG_node (targetnode a)).
        state_val (transfer (slice_kind S a) s) V = 
        state_val (transfer (slice_kind S a) s') V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rvs</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈rv S (CFG_node m). state_val s V = state_val s' V›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rvs'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length (a # cs). 
        ∀V∈rv S (CFG_node (sourcenode ((a # cs) ! i))).
        fst ((transfer (slice_kind S a) s) ! Suc i) V = 
        fst ((transfer (slice_kind S a) s') ! Suc i) V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>i</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S as)
        (transfer (slice_kind S a) s)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax#asx›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S asx)
        (transfer (slice_kind S a) s')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s = Suc (length cs)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (transfer (slice_kind S a) s) = 
        Suc (length (a # cs))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s' = Suc (length cs)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (transfer (slice_kind S a) s') = 
        Suc (length (a # cs))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹upd_cs (a # cs) as = []›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹same_level_path_aux (a # cs) asx›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set (a # cs). valid_edge c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* (_Low_)›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -asx→* (_Low_)›</span></span></span><span> </span><span>rvs'</span><span> </span><span>snds</span><span> </span><span>rv</span><span> </span><span>calculation</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax#asx›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>slpa_Return</span><span> </span><span>cs</span><span> </span><span>a</span><span> </span><span>as</span><span> </span><span>Q</span><span> </span><span>p</span><span> </span><span>f</span><span> </span><span>c'</span><span> </span><span>cs'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀m as' s s'. ⟦upd_cs cs' as = []; same_level_path_aux cs' as'; 
    ∀c∈set cs'. valid_edge c; m -as→* (_Low_); m -as'→* (_Low_);
    ∀i&lt;length cs'. ∀V∈rv S (CFG_node (sourcenode (cs' ! i))).
    fst (s ! Suc i) V = fst (s' ! Suc i) V; 
    ∀i&lt;Suc (length cs'). snd (s ! i) = snd (s' ! i);
    ∀V∈rv S (CFG_node m). state_val s V = state_val s' V;
    preds (slice_kinds S as) s; preds (slice_kinds S as') s';
    length s = Suc (length cs'); length s' = Suc (length cs')⟧
    ⟹ ∀V∈Use (_Low_). state_val (transfers(slice_kinds S as) s) V =
                       state_val (transfers(slice_kinds S as') s') V›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>rvs</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ ∀i&lt;length cs. ∀V∈rv S (CFG_node (sourcenode (cs ! i))).
    fst (s ! Suc i) V = fst (s' ! Suc i) V›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -a # as→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -as→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set cs. valid_edge c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge c'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c∈set cs'. valid_edge c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"L = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UseLow</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>as'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = (_Exit_)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_successor_of_Low</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Low_source_Exit_edge</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a' = (_Exit_)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = (_Exit_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = (_Low_)›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a' = (_Exit_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = (_Exit_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* (_Low_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_) = (_Exit_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_Exit_source</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>Low_neq_Exit</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>ax</span><span> </span><span>asx</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax -asx→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q f. kind ax = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>return_edges_only</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹same_level_path_aux cs as'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax#asx›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ax ∈ get_return_edges c'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"same_level_path_aux cs' asx"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ax ∈ get_return_edges c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ∈ get_return_edges c'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"ax = a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>get_return_edges_unique</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax -asx→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -asx→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹upd_cs cs (a # as) = []›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹a ∈ get_return_edges c'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"upd_cs cs' as = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s = Suc (length cs)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cf</span><span> </span><span>cfx</span><span> </span><span>cfs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s = cf#cfx#cfs"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">,</span><span>case_tac</span><span> </span><span>list</span><span class="delimiter">,</span><span>fastforce</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s' = Suc (length cs)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cf'</span><span> </span><span>cfx'</span><span> </span><span>cfs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s' = cf'#cfx'#cfs'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s'</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">,</span><span>case_tac</span><span> </span><span>list</span><span class="delimiter">,</span><span>fastforce</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rvs</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s = cf#cfx#cfs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s' = cf'#cfx'#cfs'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rvs1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length cs'. 
        ∀V∈rv S (CFG_node (sourcenode (cs' ! i))).
        fst ((cfx#cfs) ! Suc i) V = fst ((cfx'#cfs') ! Suc i) V"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V∈rv S (CFG_node (sourcenode c')). 
        (fst cfx) V = (fst cfx') V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ∈ get_return_edges c'›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Qx</span><span> </span><span>rx</span><span> </span><span>px</span><span> </span><span>fsx</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind c' = Qx:rx↪<span class="hidden">⇘</span><sub>px<span class="hidden">⇙</span></sub>fsx"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>only_call_get_return_edges</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ rv S (CFG_node (targetnode a)).
        V ∈ rv S (CFG_node (sourcenode c'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ rv S (CFG_node (targetnode a))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ∈ get_return_edges c'›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>edge</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = sourcenode c'"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"targetnode a' = targetnode a"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (kind a')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>call_return_node_edge</span><span class="delimiter">,</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ rv S (CFG_node (targetnode a))›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>n'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -as→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' ∈ HRB_slice S"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Use<span class="hidden">⇘</span><sub>SDG<span class="hidden">⇙</span></sub> n'"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>all</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀n''. valid_SDG_node n'' ∧ parent_node n'' ∈ set (sourcenodes as) 
          ⟶ V ∉ Def<span class="hidden">⇘</span><sub>SDG<span class="hidden">⇙</span></sub> n''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>rvE</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'›</span></span></span><span> </span><span>edge</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode c' -a'#as→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>Cons_path</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_path_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind c' = Qx:rx↪<span class="hidden">⇘</span><sub>px<span class="hidden">⇙</span></sub>fsx›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Def (sourcenode c') = {}"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>call_source_Def_empty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n''. valid_SDG_node n'' ∧ parent_node n'' = sourcenode c'
          ⟶ V ∉ Def<span class="hidden">⇘</span><sub>SDG<span class="hidden">⇙</span></sub> n''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>SDG_Def_parent_Def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>all</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = sourcenode c'›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀n''. valid_SDG_node n'' ∧ parent_node n'' ∈ set (sourcenodes (a'#as)) 
          ⟶ V ∉ Def<span class="hidden">⇘</span><sub>SDG<span class="hidden">⇙</span></sub> n''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>sourcenodes_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode c' -a'#as→<span class="hidden">⇩</span><sub>ι</sub>* parent_node n'›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹n' ∈ HRB_slice S›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ Use<span class="hidden">⇘</span><sub>SDG<span class="hidden">⇙</span></sub> n'›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ rv S (CFG_node (sourcenode c'))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>rvI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ∈ get_return_edges c'›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc (targetnode c') = get_proc (sourcenode a)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>intra_proc_additional_edge</span><span class="delimiter">,</span><span>
</span><span>            </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>get_proc_intra</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind c' = Qx:rx↪<span class="hidden">⇘</span><sub>px<span class="hidden">⇙</span></sub>fsx›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc (targetnode c') = px"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>get_proc_call</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc (sourcenode a) = p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>get_proc_return</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"px = p"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind c' = Qx:rx↪<span class="hidden">⇘</span><sub>px<span class="hidden">⇙</span></sub>fsx›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ins</span><span> </span><span>outs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p,ins,outs) ∈ set procs"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>callee_in_procs</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>slice_kind</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"slice_kind S a = 
          Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>(λcf cf'. rspp (targetnode a) (HRB_slice S) outs cf' cf)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>slice_kind_Return_in_slice</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s = cf#cfx#cfs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s' = cf'#cfx'#cfs'›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"transfer (slice_kind S a) s = 
          (rspp (targetnode a) (HRB_slice S) outs (fst cfx) (fst cf),
          snd cfx)#cfs"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sx'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"transfer (slice_kind S a) s' = 
          (rspp (targetnode a) (HRB_slice S) outs (fst cfx') (fst cf'),
          snd cfx')#cfs'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rvs1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rvs'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length cs'. 
          ∀V∈rv S (CFG_node (sourcenode (cs' ! i))).
          fst ((transfer (slice_kind S a) s) ! Suc i) V = 
          fst ((transfer (slice_kind S a) s') ! Suc i) V"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>slice_kind</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i&lt;Suc (length cs). snd (s ! i) = snd (s' ! i)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹s = cf#cfx#cfs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s' = cf'#cfx'#cfs'›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snds</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i&lt;Suc (length cs').
          snd (transfer (slice_kind S a) s ! i) =
          snd (transfer (slice_kind S a) s' ! i)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"Suc (Suc nat)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V∈rv S (CFG_node (targetnode a)).
          (rspp (targetnode a) (HRB_slice S) outs 
          (fst cfx) (fst cf)) V =
          (rspp (targetnode a) (HRB_slice S) outs 
          (fst cfx') (fst cf')) V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ rv S (CFG_node (targetnode a))"</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(rspp (targetnode a) (HRB_slice S) outs 
            (fst cfx) (fst cf)) V =
            (rspp (targetnode a) (HRB_slice S) outs 
            (fst cfx') (fst cf')) V"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ set (ParamDefs (targetnode a))"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (ParamDefs (targetnode a))"</span></span></span><span>
</span><span>              </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ParamDefs (targetnode a))!i = V"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>in_set_conv_nth</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p,ins,outs) ∈ set procs›</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length(ParamDefs (targetnode a)) = length outs"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>ParamDefs_return_target_length</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Actual_out(targetnode a,i) ∈ HRB_slice S"</span></span></span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length (ParamDefs (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹length(ParamDefs (targetnode a)) = length outs›</span></span></span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹(ParamDefs (targetnode a))!i = V›</span></span></span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rspp_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(rspp (targetnode a) 
                (HRB_slice S) outs (fst cfx) (fst cf)) V = 
                (fst cf)(outs!i)"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"(rspp (targetnode a) 
                (HRB_slice S) outs (fst cfx') (fst cf')) V = 
                (fst cf')(outs!i)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>rspp_Actual_out_in_slice</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p,ins,outs) ∈ set procs›</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ set outs. V ∈ Use (sourcenode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>outs_in_Use</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ Use (sourcenode a). V ∈ rv S (CFG_node m)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Use (sourcenode a)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"parent_node (CFG_node m) -[]→<span class="hidden">⇩</span><sub>ι</sub>* parent_node (CFG_node m)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>empty_path</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_path_def</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a ∈ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>›</span></span></span><span> 
</span><span>                  </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ Use (sourcenode a)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span>
</span><span>                </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ rv S (CFG_node m)"</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>rvI</span><span class="delimiter">,</span><span>
</span><span>                    </span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>CFG_Use_SDG_Use</span><span> </span><span>simp</span><span class="delimiter">:</span><span>SDG_to_CFG_set_def</span><span> </span><span>sourcenodes_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ set outs. V ∈ Use (sourcenode a)›</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ set outs. V ∈ rv S (CFG_node m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈rv S (CFG_node m). state_val s V = state_val s' V›</span></span></span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹s = cf#cfx#cfs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s' = cf'#cfx'#cfs'›</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ set outs. (fst cf) V = (fst cf') V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length (ParamDefs (targetnode a))›</span></span></span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹length(ParamDefs (targetnode a)) = length outs›</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst cf)(outs!i) = (fst cf')(outs!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rspp_eq</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>            </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>              </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length (ParamDefs (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹length(ParamDefs (targetnode a)) = length outs›</span></span></span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹(ParamDefs (targetnode a))!i = V›</span></span></span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rspp_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(rspp (targetnode a) 
                (HRB_slice S) outs (fst cfx) (fst cf)) V = 
                (fst cfx)((ParamDefs (targetnode a))!i)"</span></span></span><span>
</span><span>                </span><span class="string"><span class="delete"><span class="delete">"(rspp (targetnode a) 
                (HRB_slice S) outs (fst cfx') (fst cf')) V = 
                (fst cfx')((ParamDefs (targetnode a))!i)"</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>rspp_Actual_out_notin_slice</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈rv S (CFG_node (sourcenode c')). 
                (fst cfx) V = (fst cfx') V›</span></span></span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ rv S (CFG_node (targetnode a))›</span></span></span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ rv S (CFG_node (targetnode a)).
                V ∈ rv S (CFG_node (sourcenode c'))›</span></span></span><span>
</span><span>                </span><span class="cartouche"><span class="delete"><span class="delete">‹(ParamDefs (targetnode a))!i = V›</span></span></span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(fst cfx) (ParamDefs (targetnode a) ! i) =
                (fst cfx') (ParamDefs (targetnode a) ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>              </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rspp_eq</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈rv S (CFG_node (sourcenode c')). 
              (fst cfx) V = (fst cfx') V›</span></span></span><span>
</span><span>              </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ rv S (CFG_node (targetnode a))›</span></span></span><span>
</span><span>              </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ rv S (CFG_node (targetnode a)).
              V ∈ rv S (CFG_node (sourcenode c'))›</span></span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>rspp_def</span><span> </span><span>map_merge_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>sx</span><span> </span><span>sx'</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rv'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀V∈rv S (CFG_node (targetnode a)).
          state_val (transfer (slice_kind S a) s) V =
          state_val (transfer (slice_kind S a) s') V"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S as) 
          (transfer (slice_kind S a) s)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax#asx›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S asx) 
          (transfer (slice_kind S a) s')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s = Suc (length cs)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span> </span><span>sx</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (transfer (slice_kind S a) s) = Suc (length cs')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">‹s = cf#cfx#cfs›</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s' = Suc (length cs)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span> </span><span>sx'</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (transfer (slice_kind S a) s') = Suc (length cs')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">‹s' = cf'#cfx'#cfs'›</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹upd_cs cs' as = []›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹same_level_path_aux cs' asx›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set cs'. valid_edge c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* (_Low_)›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -asx→* (_Low_)›</span></span></span><span> </span><span>rvs'</span><span> </span><span>snds</span><span> </span><span>rv'</span><span> </span><span>calculation</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax#asx›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>slice_kind</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"slice_kind S a = (λcf. True)↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>(λcf cf'. cf')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>slice_kind_Return</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s = cf#cfx#cfs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s' = cf'#cfx'#cfs'›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"transfer (slice_kind S a) s = cfx#cfs"</span></span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"transfer (slice_kind S a) s' = cfx'#cfs'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>slice_kind</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀i&lt;Suc (length cs). snd (s ! i) = snd (s' ! i)›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s = cf#cfx#cfs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹s' = cf'#cfx'#cfs'›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snds</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i&lt;Suc (length cs').
          snd (transfer (slice_kind S a) s ! i) =
          snd (transfer (slice_kind S a) s' ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rvs1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rvs'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀i&lt;length cs'. 
          ∀V∈rv S (CFG_node (sourcenode (cs' ! i))).
          fst ((transfer (slice_kind S a) s) ! Suc i) V = 
          fst ((transfer (slice_kind S a) s') ! Suc i) V"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ rv S (CFG_node (targetnode a)).
          V ∈ rv S (CFG_node (sourcenode c'))›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈rv S (CFG_node (sourcenode c')). 
          (fst cfx) V = (fst cfx') V›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>rv'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀V∈rv S (CFG_node (targetnode a)).
          state_val (transfer (slice_kind S a) s) V =
          state_val (transfer (slice_kind S a) s') V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S (a # as)) s›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S as) 
          (transfer (slice_kind S a) s)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') s'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax#asx›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S asx) 
          (transfer (slice_kind S a) s')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s = Suc (length cs)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (transfer (slice_kind S a) s) = Suc (length cs')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">‹s = cf#cfx#cfs›</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s' = Suc (length cs)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (transfer (slice_kind S a) s') = Suc (length cs')"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">‹s' = cf'#cfx'#cfs'›</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹upd_cs cs' as = []›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹same_level_path_aux cs' asx›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set cs'. valid_edge c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* (_Low_)›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -asx→* (_Low_)›</span></span></span><span> </span><span>rvs'</span><span> </span><span>snds</span><span> </span><span>rv'</span><span> </span><span>calculation</span><span class="delimiter">]</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax#asx›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rv_Low_Use_Low</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m -as→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m -as'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc m = Main"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ rv S (CFG_node m). cf V = cf' V"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S as) [(cf,undefined)]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S as') [(cf',undefined)]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG_node (_Low_) ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ Use (_Low_). 
    state_val (transfers(slice_kinds S as) [(cf,undefined)]) V =
    state_val (transfers(slice_kinds S as') [(cf',undefined)]) V"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = (_Low_)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>path_valid_node</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Use (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_) -[]→<span class="hidden">⇩</span><sub>ι</sub>* (_Low_)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>empty_path</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_path_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹CFG_node (_Low_) ∈ S›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG_node (_Low_) ∈ HRB_slice S"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>HRB_slice_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ rv S (CFG_node m)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>rvI</span><span> </span><span>CFG_Use_SDG_Use</span><span> </span><span>simp</span><span class="delimiter">:</span><span>sourcenodes_def</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ Use (_Low_). V ∈ rv S (CFG_node m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"L = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UseLow</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m -as'→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→* (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as' = []"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>m</span><span> </span><span>as'</span><span> </span><span>m'</span><span class="delimiter">≡</span><span class="string"><span class="delete"><span class="delete">"(_Low_)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span>path.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons_path</span><span> </span><span>m''</span><span> </span><span>as</span><span> </span><span>a</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = (_Exit_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_successor_of_Low</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = m''›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m'' -as→* (_Low_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_) = (_Exit_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_Exit_source</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>Low_neq_Exit</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Nil</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ rv S (CFG_node m). cf V = cf' V›</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ Use (_Low_). V ∈ rv S (CFG_node m)›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>slice_kinds_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>ax</span><span> </span><span>asx</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax -asx→* (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"L = {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>UseLow</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>as'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax = (_Exit_)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_successor_of_Low</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Low_source_Exit_edge</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a' = (_Exit_)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = (_Low_)›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax = (_Exit_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = (_Low_)›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a' = (_Exit_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ax = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax = (_Exit_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax -asx→* (_Low_)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_) = (_Exit_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_Exit_source</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>Low_neq_Exit</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>ax'</span><span> </span><span>asx'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path_aux [] as"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m -as→* (_Low_)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as = ax#asx›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹get_proc m = Main›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"same_level_path_aux [] as ∧ upd_cs [] as = []"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>vpa_Main_slpa</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_)"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>get_proc_Low</span><span> </span><span>simp</span><span class="delimiter">:</span><span>valid_call_list_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"same_level_path_aux [] as"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"upd_cs [] as = []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path_aux [] as'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m -as'→* (_Low_)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = ax'#asx'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹get_proc m = Main›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"same_level_path_aux [] as' ∧ upd_cs [] as' = []"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>vpa_Main_slpa</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>m</span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Low_)"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>        </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>get_proc_Low</span><span> </span><span>simp</span><span class="delimiter">:</span><span>valid_call_list_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"same_level_path_aux [] as'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹same_level_path_aux [] as›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹upd_cs [] as = []›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹same_level_path_aux [] as'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as→* (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -as'→* (_Low_)›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ rv S (CFG_node m). cf V = cf' V›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹CFG_node (_Low_) ∈ S›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as) [(cf,undefined)]›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S as') [(cf',undefined)]›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>erule</span><span> </span><span>slpa_rv_Low_Use_Low</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonInterference_path_to_Low</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[cf] ≈<span class="hidden">⇩</span><sub>L</sub> [cf']"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG_node (_Low_) ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -as→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (kinds as) [(cf,undefined)]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -as'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (kinds as') [(cf',undefined)]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst (transfers (kinds as) [(cf,undefined)]) ≈<span class="hidden">⇩</span><sub>L</sub> 
         map fst (transfers (kinds as') [(cf',undefined)])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -as→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds as) [(cf,undefined)]›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹CFG_node (_Low_) ∈ S›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>asx</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S asx) [(cf,undefined)]"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ Use (_Low_). 
    state_val (transfers (slice_kinds S asx) [(cf,undefined)]) V = 
    state_val (transfers (kinds as) [(cf,undefined)]) V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"slice_edges S [] as = slice_edges S [] asx"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transfers (kinds as) [(cf,undefined)] ≠ []"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -asx→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>fundamental_property_of_static_slicing</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -as'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds as') [(cf',undefined)]›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹CFG_node (_Low_) ∈ S›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>asx'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (slice_kinds S asx') [(cf',undefined)]"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ Use (_Low_). 
    state_val (transfers(slice_kinds S asx') [(cf',undefined)]) V = 
    state_val (transfers(kinds as') [(cf',undefined)]) V"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"slice_edges S [] as' = 
    slice_edges S [] asx'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transfers (kinds as') [(cf',undefined)] ≠ []"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -asx'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>fundamental_property_of_static_slicing</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹[cf] ≈<span class="hidden">⇩</span><sub>L</sub> [cf']›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ rv S (CFG_node (_Entry_)). cf V = cf' V"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>lowEquivalence_relevant_nodes_Entry</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -asx →<span class="hidden">⇩</span><sub>√</sub>*(_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -asx'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹CFG_node (_Low_) ∈ S›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S asx) [(cf,undefined)]›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (slice_kinds S asx') [(cf',undefined)]›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ Use (_Low_). 
    state_val (transfers(slice_kinds S asx) [(cf,undefined)]) V =
    state_val (transfers(slice_kinds S asx') [(cf',undefined)]) V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>rv_Low_Use_Low</span><span class="delimiter">,</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>get_proc_Entry</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ Use (_Low_). 
    state_val (transfers (slice_kinds S asx) [(cf,undefined)]) V = 
    state_val (transfers (kinds as) [(cf,undefined)]) V›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ Use (_Low_). 
    state_val (transfers(slice_kinds S asx') [(cf',undefined)]) V = 
    state_val (transfers(kinds as') [(cf',undefined)]) V›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹transfers (kinds as) [(cf,undefined)] ≠ []›</span></span></span><span> 
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹transfers (kinds as') [(cf',undefined)] ≠ []›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>lowEquivalence_def</span><span> </span><span>UseLow</span><span> </span><span>neq_Nil_conv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nonInterference_path</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[cf] ≈<span class="hidden">⇩</span><sub>L</sub> [cf']"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG_node (_Low_) ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -as→<span class="hidden">⇩</span><sub>√</sub>* (_Exit_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (kinds as) [(cf,undefined)]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -as'→<span class="hidden">⇩</span><sub>√</sub>* (_Exit_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (kinds as') [(cf',undefined)]"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst (transfers (kinds as) [(cf,undefined)]) ≈<span class="hidden">⇩</span><sub>L</sub> 
  map fst (transfers (kinds as') [(cf',undefined)])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -as→<span class="hidden">⇩</span><sub>√</sub>* (_Exit_)›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = x#xs"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) = sourcenode x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge x"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode x -xs→* (_Exit_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"as = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">,</span><span>drule</span><span> </span><span>empty_path_nodes</span><span class="delimiter">,</span><span>drule</span><span> </span><span>Entry_noteq_Exit</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -as→<span class="hidden">⇩</span><sub>√</sub>* (_Exit_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path as"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge x›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node (targetnode x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_node (targetnode x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>valid_node_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Entry</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge x›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Exit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode x -xs→* (_Exit_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = []"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_Exit_source</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Entry_Exit_edge</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge z"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode z = (_Entry_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode z = (_Exit_)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind z = (λs. False)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge x›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge z›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) = sourcenode x›</span></span></span><span> 
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode z = (_Entry_)›</span></span></span><span> </span><span>Exit</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode z = (_Exit_)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds as) [(cf,undefined)]›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as = x#xs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹xs = []›</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹kind z = (λs. False)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>kinds_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode x -xs→* (_Exit_)›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span> </span><span>xs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = xs'@[x']"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode x -xs'→* (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind x' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>Exit_path_Low_path</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) = sourcenode x›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge x›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -x#xs'→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>Cons_path</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_path as›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as = x#xs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹xs = xs'@[x']›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path (x#xs')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>valid_path_def</span><span> </span><span>del</span><span class="delimiter">:</span><span>valid_path_aux.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid_path_aux_split</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -x#xs'→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -x#xs'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as = x#xs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹xs = xs'@[x']›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as = (x#xs')@[x']"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds as) [(cf,undefined)]›</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (kinds (x#xs')) [(cf,undefined)]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>kinds_def</span><span> </span><span>preds_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -as'→<span class="hidden">⇩</span><sub>√</sub>* (_Exit_)›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as' = y#ys"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) = sourcenode y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge y"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode y -ys→* (_Exit_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"as' = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">,</span><span>drule</span><span> </span><span>empty_path_nodes</span><span class="delimiter">,</span><span>drule</span><span> </span><span>Entry_noteq_Exit</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -as'→<span class="hidden">⇩</span><sub>√</sub>* (_Exit_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path as'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge y›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node (targetnode y)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_node (targetnode y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>valid_node_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Entry</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge y›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Exit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode y -ys→* (_Exit_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ys = []"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_Exit_source</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Entry_Exit_edge</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge z"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode z = (_Entry_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode z = (_Exit_)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind z = (λs. False)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge y›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge z›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) = sourcenode y›</span></span></span><span> 
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode z = (_Entry_)›</span></span></span><span> </span><span>Exit</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode z = (_Exit_)›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y = z"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds as') [(cf',undefined)]›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = y#ys›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ys = []›</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹kind z = (λs. False)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>kinds_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode y -ys→* (_Exit_)›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y'</span><span> </span><span>ys'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ys = ys'@[y']"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode y -ys'→* (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind y' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>Exit_path_Low_path</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) = sourcenode y›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge y›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -y#ys'→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>Cons_path</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_path as'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = y#ys›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ys = ys'@[y']›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path (y#ys')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>valid_path_def</span><span> </span><span>del</span><span class="delimiter">:</span><span>valid_path_aux.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>rule</span><span> </span><span>valid_path_aux_split</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -y#ys'→* (_Low_)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -y#ys'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = y#ys›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ys = ys'@[y']›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"as' = (y#ys')@[y']"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds as') [(cf',undefined)]›</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (kinds (y#ys')) [(cf',undefined)]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>kinds_def</span><span> </span><span>preds_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹[cf] ≈<span class="hidden">⇩</span><sub>L</sub> [cf']›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹CFG_node (_Low_) ∈ S›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -x#xs'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds (x#xs')) [(cf,undefined)]›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -y#ys'→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds (y#ys')) [(cf',undefined)]›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst (transfers (kinds (x#xs')) [(cf,undefined)]) ≈<span class="hidden">⇩</span><sub>L</sub> 
    map fst (transfers (kinds (y#ys')) [(cf',undefined)])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nonInterference_path_to_Low</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹as = x#xs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹xs = xs'@[x']›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind x' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹as' = y#ys›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ys = ys'@[y']›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind y' = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"transfers (map kind xs') (transfer (kind x) [(cf,undefined)])"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>kinds_def</span><span> </span><span>transfers_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"transfers (map kind ys') (transfer (kind y) [(cf',undefined)])"</span></span></span><span class="delimiter">)</span><span class="delimiter">,</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>kinds_def</span><span> </span><span>transfers_split</span><span class="delimiter">)</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The second theorem assumes that we have a operational semantics,
whose evaluations are written ‹⟨c,s⟩ ⇒ ⟨c',s'⟩› and which conforms 
to the CFG. The correctness theorem then states that if no high variable
influenced a low variable and the initial states were low equivalent, the
reulting states are again low equivalent:›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>NonInterferenceInter</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>NonInterferenceInterGraph</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> 
</span><span>    </span><span>get_proc</span><span> </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span> </span><span>Def</span><span> </span><span>Use</span><span> </span><span>ParamDefs</span><span> </span><span>ParamUses</span><span> 
</span><span>    </span><span>H</span><span> </span><span>L</span><span> </span><span>High</span><span> </span><span>Low</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span>SemanticsProperty</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span>
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span> </span><span>Def</span><span> </span><span>Use</span><span> </span><span>ParamDefs</span><span> </span><span>ParamUses</span><span> </span><span>sem</span><span> </span><span>identifies</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>sourcenode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'node"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>targetnode</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'node"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kind</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ ('var,'val,'ret,'pname) edge_kind"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Entry</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'('_Entry'_')"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>get_proc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'pname"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>get_return_edges</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'edge set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>procs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('pname × 'var list × 'var list) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Main</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'pname"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Exit</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'node"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'('_Exit'_')"</span></span></span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Def</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Use</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'var set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ParamDefs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'var list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ParamUses</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'var set list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'com ⇒ ('var ⇀ 'val) list ⇒ 'com ⇒ ('var ⇀ 'val) list ⇒ bool"</span></span></span><span> 
</span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"((1⟨_,/_⟩) ⇒/ (1⟨_,/_⟩))"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">,</span><span>0</span><span class="delimiter">]</span><span> </span><span>81</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>identifies</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'com ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ≜ _"</span></span></span><span> </span><span class="delimiter">[</span><span>51</span><span class="delimiter">,</span><span>0</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>High</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'('_High'_')"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Low</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'node"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'('_Low'_')"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>final</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'com ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>final_edge_Low</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦final c; n ≜ c⟧ 
    ⟹ ∃a. valid_edge a ∧ sourcenode a = n ∧ targetnode a = (_Low_) ∧ kind a = ⇑id"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The following theorem needs the explicit edge from ‹(_High_)›
  to ‹n›. An approach using a ‹init› predicate for initial statements,
  being reachable from ‹(_High_)› via a ‹(λs. True)<span class="hidden">⇩</span><sub>√</sub>› edge,
  does not work as the same statement could be identified by several nodes, some
  initial, some not. E.g., in the program \texttt{while (True) Skip;;Skip}
  two nodes identify this inital statement: the initial node and the node
  within the loop (because of loop unrolling).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>nonInterference</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[cf<span class="hidden">⇩</span><sub>1</sub>] ≈<span class="hidden">⇩</span><sub>L</sub> [cf<span class="hidden">⇩</span><sub>2</sub>]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG_node (_Low_) ∈ S"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = (_High_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = n"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n ≜ c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"final c'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨c,[cf<span class="hidden">⇩</span><sub>1</sub>]⟩ ⇒ ⟨c',s<span class="hidden">⇩</span><sub>1</sub>⟩"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟨c,[cf<span class="hidden">⇩</span><sub>2</sub>]⟩ ⇒ ⟨c',s<span class="hidden">⇩</span><sub>2</sub>⟩"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s<span class="hidden">⇩</span><sub>1</sub> ≈<span class="hidden">⇩</span><sub>L</sub> s<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>High_target_Entry_edge</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ax</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = (_Entry_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax = (_High_)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n ≜ c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟨c,[cf<span class="hidden">⇩</span><sub>1</sub>]⟩ ⇒ ⟨c',s<span class="hidden">⇩</span><sub>1</sub>⟩›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>as<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>cfs<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n -as<span class="hidden">⇩</span><sub>1</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n<span class="hidden">⇩</span><sub>1</sub> ≜ c'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (kinds as<span class="hidden">⇩</span><sub>1</sub>) [(cf<span class="hidden">⇩</span><sub>1</sub>,undefined)]"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transfers (kinds as<span class="hidden">⇩</span><sub>1</sub>) [(cf<span class="hidden">⇩</span><sub>1</sub>,undefined)] = cfs<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst cfs<span class="hidden">⇩</span><sub>1</sub> = s<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>fundamental_property</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n -as<span class="hidden">⇩</span><sub>1</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = (_High_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = n›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) -a#as<span class="hidden">⇩</span><sub>1</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>Cons_path</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹final c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n<span class="hidden">⇩</span><sub>1</sub> ≜ c'›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a<span class="hidden">⇩</span><sub>1</sub> = n<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a<span class="hidden">⇩</span><sub>1</sub> = (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a<span class="hidden">⇩</span><sub>1</sub> = ⇑id"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>final_edge_Low</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n<span class="hidden">⇩</span><sub>1</sub> -[a<span class="hidden">⇩</span><sub>1</sub>]→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>path_edge</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) -a#as<span class="hidden">⇩</span><sub>1</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) -(a#as<span class="hidden">⇩</span><sub>1</sub>)@[a<span class="hidden">⇩</span><sub>1</sub>]→* (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>path_Append</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = (_Entry_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax = (_High_)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -ax#((a#as<span class="hidden">⇩</span><sub>1</sub>)@[a<span class="hidden">⇩</span><sub>1</sub>])→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>Cons_path</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) -a#as<span class="hidden">⇩</span><sub>1</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path_aux [] (a#as<span class="hidden">⇩</span><sub>1</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a<span class="hidden">⇩</span><sub>1</sub> = ⇑id›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path_aux [] ((a#as<span class="hidden">⇩</span><sub>1</sub>)@[a<span class="hidden">⇩</span><sub>1</sub>])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>valid_path_aux_Append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path_aux [] (ax#((a#as<span class="hidden">⇩</span><sub>1</sub>)@[a<span class="hidden">⇩</span><sub>1</sub>]))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -ax#((a#as<span class="hidden">⇩</span><sub>1</sub>)@[a<span class="hidden">⇩</span><sub>1</sub>])→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = (_High_)›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = n›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc n = get_proc (_High_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>get_proc_intra</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>get_proc_High</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc n = Main"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a<span class="hidden">⇩</span><sub>1</sub> = n<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a<span class="hidden">⇩</span><sub>1</sub> = (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a<span class="hidden">⇩</span><sub>1</sub> = ⇑id›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc n<span class="hidden">⇩</span><sub>1</sub> = get_proc (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>get_proc_intra</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>get_proc_Low</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc n<span class="hidden">⇩</span><sub>1</sub> = Main"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n -as<span class="hidden">⇩</span><sub>1</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n -as<span class="hidden">⇩</span><sub>1</sub>→<span class="hidden">⇘</span><sub>sl<span class="hidden">⇙</span></sub>* n<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>as<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>vpa_Main_slpa</span><span> </span><span>intro</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">‹get_proc n<span class="hidden">⇩</span><sub>1</sub> = Main›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹get_proc n = Main›</span></span></span><span>
</span><span>             </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span> </span><span>valid_call_list_def</span><span> </span><span>slp_def</span><span> 
</span><span>                  </span><span>same_level_path_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span>valid_path_aux.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cfx</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"transfers (map kind as<span class="hidden">⇩</span><sub>1</sub>) [(cf<span class="hidden">⇩</span><sub>1</sub>,undefined)] = [(cfx,r)]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>slp_callstack_length_equal</span><span> </span><span>simp</span><span class="delimiter">:</span><span>kinds_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> 
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds as<span class="hidden">⇩</span><sub>1</sub>) [(cf<span class="hidden">⇩</span><sub>1</sub>,undefined)]›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a<span class="hidden">⇩</span><sub>1</sub> = ⇑id›</span></span></span><span> </span><span>cfx</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (kinds (ax#((a#as<span class="hidden">⇩</span><sub>1</sub>)@[a<span class="hidden">⇩</span><sub>1</sub>]))) [(cf<span class="hidden">⇩</span><sub>1</sub>,undefined)]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>kinds_def</span><span> </span><span>preds_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n ≜ c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⟨c,[cf<span class="hidden">⇩</span><sub>2</sub>]⟩ ⇒ ⟨c',s<span class="hidden">⇩</span><sub>2</sub>⟩›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>as<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>cfs<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n -as<span class="hidden">⇩</span><sub>2</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n<span class="hidden">⇩</span><sub>2</sub> ≜ c'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (kinds as<span class="hidden">⇩</span><sub>2</sub>) [(cf<span class="hidden">⇩</span><sub>2</sub>,undefined)]"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transfers (kinds as<span class="hidden">⇩</span><sub>2</sub>) [(cf<span class="hidden">⇩</span><sub>2</sub>,undefined)] = cfs<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst cfs<span class="hidden">⇩</span><sub>2</sub> = s<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>fundamental_property</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n -as<span class="hidden">⇩</span><sub>2</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = (_High_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = n›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) -a#as<span class="hidden">⇩</span><sub>2</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>Cons_path</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹final c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n<span class="hidden">⇩</span><sub>2</sub> ≜ c'›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a<span class="hidden">⇩</span><sub>2</sub> = n<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a<span class="hidden">⇩</span><sub>2</sub> = (_Low_)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a<span class="hidden">⇩</span><sub>2</sub> = ⇑id"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>final_edge_Low</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n<span class="hidden">⇩</span><sub>2</sub> -[a<span class="hidden">⇩</span><sub>2</sub>]→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>path_edge</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) -a#as<span class="hidden">⇩</span><sub>2</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_High_) -(a#as<span class="hidden">⇩</span><sub>2</sub>)@[a<span class="hidden">⇩</span><sub>2</sub>]→* (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>path_Append</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax = (_Entry_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax = (_High_)›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -ax#((a#as<span class="hidden">⇩</span><sub>2</sub>)@[a<span class="hidden">⇩</span><sub>2</sub>])→* (_Low_)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>Cons_path</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) -a#as<span class="hidden">⇩</span><sub>2</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path_aux [] (a#as<span class="hidden">⇩</span><sub>2</sub>)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a<span class="hidden">⇩</span><sub>2</sub> = ⇑id›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path_aux [] ((a#as<span class="hidden">⇩</span><sub>2</sub>)@[a<span class="hidden">⇩</span><sub>2</sub>])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>valid_path_aux_Append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path_aux [] (ax#((a#as<span class="hidden">⇩</span><sub>2</sub>)@[a<span class="hidden">⇩</span><sub>2</sub>]))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(_Entry_) -ax#((a#as<span class="hidden">⇩</span><sub>2</sub>)@[a<span class="hidden">⇩</span><sub>2</sub>])→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = (_High_)›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a = n›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc n = get_proc (_High_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>get_proc_intra</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>get_proc_High</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc n = Main"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a<span class="hidden">⇩</span><sub>2</sub> = n<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a<span class="hidden">⇩</span><sub>2</sub> = (_Low_)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a<span class="hidden">⇩</span><sub>2</sub> = ⇑id›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc n<span class="hidden">⇩</span><sub>2</sub> = get_proc (_Low_)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>get_proc_intra</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>get_proc_Low</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc n<span class="hidden">⇩</span><sub>2</sub> = Main"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n -as<span class="hidden">⇩</span><sub>2</sub>→<span class="hidden">⇩</span><sub>√</sub>* n<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n -as<span class="hidden">⇩</span><sub>2</sub>→<span class="hidden">⇘</span><sub>sl<span class="hidden">⇙</span></sub>* n<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>as<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>vpa_Main_slpa</span><span> </span><span>intro</span><span class="delimiter">:</span><span class="cartouche"><span class="delete"><span class="delete">‹get_proc n<span class="hidden">⇩</span><sub>2</sub> = Main›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹get_proc n = Main›</span></span></span><span>
</span><span>             </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span> </span><span>valid_call_list_def</span><span> </span><span>slp_def</span><span> 
</span><span>                  </span><span>same_level_path_def</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span>valid_path_aux.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cfx'</span><span> </span><span>r'</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfx'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"transfers (map kind as<span class="hidden">⇩</span><sub>2</sub>) [(cf<span class="hidden">⇩</span><sub>2</sub>,undefined)] = [(cfx',r')]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>slp_callstack_length_equal</span><span> </span><span>simp</span><span class="delimiter">:</span><span>kinds_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> 
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds as<span class="hidden">⇩</span><sub>2</sub>) [(cf<span class="hidden">⇩</span><sub>2</sub>,undefined)]›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a<span class="hidden">⇩</span><sub>2</sub> = ⇑id›</span></span></span><span> </span><span>cfx'</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"preds (kinds (ax#((a#as<span class="hidden">⇩</span><sub>2</sub>)@[a<span class="hidden">⇩</span><sub>2</sub>]))) [(cf<span class="hidden">⇩</span><sub>2</sub>,undefined)]"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>kinds_def</span><span> </span><span>preds_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹[cf<span class="hidden">⇩</span><sub>1</sub>] ≈<span class="hidden">⇩</span><sub>L</sub> [cf<span class="hidden">⇩</span><sub>2</sub>]›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(_High_) ∉ ⌊HRB_slice S⌋<span class="hidden">⇘</span><sub>CFG<span class="hidden">⇙</span></sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹CFG_node (_Low_) ∈ S›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -ax#((a#as<span class="hidden">⇩</span><sub>1</sub>)@[a<span class="hidden">⇩</span><sub>1</sub>])→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> 
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds (ax#((a#as<span class="hidden">⇩</span><sub>1</sub>)@[a<span class="hidden">⇩</span><sub>1</sub>]))) [(cf<span class="hidden">⇩</span><sub>1</sub>,undefined)]›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹(_Entry_) -ax#((a#as<span class="hidden">⇩</span><sub>2</sub>)@[a<span class="hidden">⇩</span><sub>2</sub>])→<span class="hidden">⇩</span><sub>√</sub>* (_Low_)›</span></span></span><span> 
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹preds (kinds (ax#((a#as<span class="hidden">⇩</span><sub>2</sub>)@[a<span class="hidden">⇩</span><sub>2</sub>]))) [(cf<span class="hidden">⇩</span><sub>2</sub>,undefined)]›</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"map fst (transfers (kinds (ax#((a#as<span class="hidden">⇩</span><sub>1</sub>)@[a<span class="hidden">⇩</span><sub>1</sub>]))) [(cf<span class="hidden">⇩</span><sub>1</sub>,undefined)]) ≈<span class="hidden">⇩</span><sub>L</sub> 
        map fst (transfers (kinds (ax#((a#as<span class="hidden">⇩</span><sub>2</sub>)@[a<span class="hidden">⇩</span><sub>2</sub>]))) [(cf<span class="hidden">⇩</span><sub>2</sub>,undefined)])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nonInterference_path_to_Low</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a<span class="hidden">⇩</span><sub>1</sub> = ⇑id›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a<span class="hidden">⇩</span><sub>2</sub> = ⇑id›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹transfers (kinds as<span class="hidden">⇩</span><sub>1</sub>) [(cf<span class="hidden">⇩</span><sub>1</sub>,undefined)] = cfs<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹map fst cfs<span class="hidden">⇩</span><sub>1</sub> = s<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span>
</span><span>    </span><span class="cartouche"><span class="delete"><span class="delete">‹transfers (kinds as<span class="hidden">⇩</span><sub>2</sub>) [(cf<span class="hidden">⇩</span><sub>2</sub>,undefined)] = cfs<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹map fst cfs<span class="hidden">⇩</span><sub>2</sub> = s<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s<span class="hidden">⇩</span><sub>1</sub></span><span class="delimiter">)</span><span class="delimiter">(</span><span>cases</span><span> </span><span>s<span class="hidden">⇩</span><sub>2</sub></span><span class="delimiter">,</span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>kinds_def</span><span> </span><span>transfers_split</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>
</div>
</div><div id="LiftingInter">
<div class="head"><h1>Theory LiftingInter</h1>
<span class="command">theory</span> <span class="name">LiftingInter</span><br/>
<span class="keyword">imports</span> <a href="NonInterferenceInter.html"><span class="name">NonInterferenceInter</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Framework Graph Lifting for Noninterference›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>LiftingInter</span><span> 
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>NonInterferenceInter</span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹In this section, we show how a valid CFG from the slicing framework in
\cite{Wasserrab:08} can be lifted to fulfil all properties of the 
‹NonInterferenceIntraGraph› locale. Basically, we redefine the
hitherto existing ‹Entry› and ‹Exit› nodes as new
‹High› and ‹Low› nodes, and introduce two new nodes
‹NewEntry› and ‹NewExit›. Then, we have to lift all functions
to operate on this new graph.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Liftings›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The datatypes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'node</span><span> </span><span>LDCFG_node</span><span> </span><span class="delimiter">=</span><span> </span><span>Node</span><span> </span><span class="tfree">'node</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>NewEntry</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>NewExit</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'edge</span><span class="delimiter">,</span><span class="tfree">'node</span><span class="delimiter">,</span><span class="tfree">'var</span><span class="delimiter">,</span><span class="tfree">'val</span><span class="delimiter">,</span><span class="tfree">'ret</span><span class="delimiter">,</span><span class="tfree">'pname</span><span class="delimiter">)</span><span> </span><span>LDCFG_edge</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'node LDCFG_node × (('var,'val,'ret,'pname) edge_kind) × 'node LDCFG_node"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lifting basic definitions using @{typ 'edge} and @{typ 'node}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>lift_valid_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('edge ⇒ bool) ⇒ ('edge ⇒ 'node) ⇒ ('edge ⇒ 'node) ⇒
  ('edge ⇒ ('var,'val,'ret,'pname) edge_kind) ⇒ 'node ⇒ 'node ⇒ 
  ('edge,'node,'var,'val,'ret,'pname) LDCFG_edge ⇒ 
  bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>valid_edge</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>src</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'node"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trg</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'node"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>knd</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ ('var,'val,'ret,'pname) edge_kind"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E</span><span class="delimiter">::</span><span class="tfree">'node</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">::</span><span class="tfree">'node</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lve_edge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦valid_edge a; src a ≠ E ∨ trg a ≠ X; 
    e = (Node (src a),knd a,Node (trg a))⟧
  ⟹ lift_valid_edge valid_edge src trg knd E X e"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>lve_Entry_edge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"e = (NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node E) 
  ⟹ lift_valid_edge valid_edge src trg knd E X e"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>lve_Exit_edge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"e = (Node X,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit) 
  ⟹ lift_valid_edge valid_edge src trg knd E X e"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>lve_Entry_Exit_edge</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"e = (NewEntry,(λs. False)<span class="hidden">⇩</span><sub>√</sub>,NewExit) 
  ⟹ lift_valid_edge valid_edge src trg knd E X e"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ lift_valid_edge valid_edge src trg knd E X (Node E,et,Node X)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lift_get_proc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('node ⇒ 'pname) ⇒ 'pname ⇒ 'node LDCFG_node ⇒ 'pname"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main (Node n) = get_proc n"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main NewEntry = Main"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main NewExit = Main"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>lift_get_return_edges</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('edge ⇒ 'edge set) ⇒ ('edge ⇒ bool) ⇒ 
  ('edge ⇒ 'node) ⇒ ('edge ⇒ 'node) ⇒ ('edge ⇒ ('var,'val,'ret,'pname) edge_kind) 
  ⇒ ('edge,'node,'var,'val,'ret,'pname) LDCFG_edge 
  ⇒ ('edge,'node,'var,'val,'ret,'pname) LDCFG_edge set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>get_return_edges</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'edge set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>valid_edge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ bool"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>src</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'node"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trg</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ 'node"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>knd</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'edge ⇒ ('var,'val,'ret,'pname) edge_kind"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('edge,'node,'var,'val,'ret,'pname) LDCFG_edge"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lift_get_return_edgesI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦e = (Node (src a),knd a,Node (trg a)); valid_edge a; a' ∈ get_return_edges a; 
  e' = (Node (src a'),knd a',Node (trg a'))⟧
  ⟹ e' ∈ lift_get_return_edges get_return_edges valid_edge src trg knd e"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lifting the Def and Use sets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>lift_Def_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('node ⇒ 'var set) ⇒ 'node ⇒ 'node ⇒ 
                       'var set ⇒ 'var set ⇒ ('node LDCFG_node × 'var) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Def</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"('node ⇒ 'var set)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E</span><span class="delimiter">::</span><span class="tfree">'node</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">::</span><span class="tfree">'node</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>lift_Def_node</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"V ∈ Def n ⟹ (Node n,V) ∈ lift_Def_set Def E X H L"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>lift_Def_High</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"V ∈ H ⟹ (Node E,V) ∈ lift_Def_set Def E X H L"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lift_Def</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('node ⇒ 'var set) ⇒ 'node ⇒ 'node ⇒ 
                       'var set ⇒ 'var set ⇒ 'node LDCFG_node ⇒ 'var set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_Def Def E X H L n ≡ {V. (n,V) ∈ lift_Def_set Def E X H L}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>lift_Use_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('node ⇒ 'var set) ⇒ 'node ⇒ 'node ⇒ 
                       'var set ⇒ 'var set ⇒ ('node LDCFG_node × 'var) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Use</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'node ⇒ 'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E</span><span class="delimiter">::</span><span class="tfree">'node</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>X</span><span class="delimiter">::</span><span class="tfree">'node</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'var set"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span>lift_Use_node</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"V ∈ Use n ⟹ (Node n,V) ∈ lift_Use_set Use E X H L"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>lift_Use_High</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"V ∈ H ⟹ (Node E,V) ∈ lift_Use_set Use E X H L"</span></span></span><span>
</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>lift_Use_Low</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"V ∈ L ⟹ (Node X,V) ∈ lift_Use_set Use E X H L"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>lift_Use</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('node ⇒ 'var set) ⇒ 'node ⇒ 'node ⇒ 
                       'var set ⇒ 'var set ⇒ 'node LDCFG_node ⇒ 'var set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_Use Use E X H L n ≡ {V. (n,V) ∈ lift_Use_set Use E X H L}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lift_ParamUses</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('node ⇒ 'var set list) ⇒ 'node LDCFG_node ⇒ 'var set list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_ParamUses ParamUses (Node n) =  ParamUses n"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_ParamUses ParamUses NewEntry = []"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_ParamUses ParamUses NewExit = []"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lift_ParamDefs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('node ⇒ 'var list) ⇒ 'node LDCFG_node ⇒ 'var list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_ParamDefs ParamDefs (Node n) =  ParamDefs n"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_ParamDefs ParamDefs NewEntry = []"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_ParamDefs ParamDefs NewExit = []"</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The lifting lemmas›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lifting the CFG locales›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>src</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('edge,'node,'var,'val,'ret,'pname) LDCFG_edge ⇒ 'node LDCFG_node"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a ≡ fst a"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>trg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('edge,'node,'var,'val,'ret,'pname) LDCFG_edge ⇒ 'node LDCFG_node"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a ≡ snd(snd a)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>knd</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('edge,'node,'var,'val,'ret,'pname) LDCFG_edge ⇒ 
  ('var,'val,'ret,'pname) edge_kind"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a ≡ fst(snd a)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_CFG</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit Def Use ParamDefs ParamUses"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Postdomination sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG src trg knd
  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry
  (lift_get_proc get_proc Main) 
  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) 
  procs Main"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>CFGExit_wf</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span> </span><span>Def</span><span> </span><span>Use</span><span> </span><span>ParamDefs</span><span> </span><span>ParamUses</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Postdomination</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a = NewEntry"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main NewEntry = Main"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = NewEntry"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>a'</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = src a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a = trg a'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = a'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>lve_edge</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>erule</span><span> </span><span>lift_valid_edge.cases</span><span class="delimiter">,</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>f</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>Main<span class="hidden">⇙</span></sub>f"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span>Main_no_call_target</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q'</span><span> </span><span>f'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q'↩<span class="hidden">⇘</span><sub>Main<span class="hidden">⇙</span></sub>f'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span>Main_no_return_source</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ins outs. (p, ins, outs) ∈ set procs"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span>callee_in_procs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (knd a)"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main (src a) = lift_get_proc get_proc Main (trg a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span>get_proc_intra</span><span> 
</span><span>                  </span><span>simp</span><span class="delimiter">:</span><span>get_proc_Entry</span><span> </span><span>get_proc_Exit</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main (trg a) = p"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span>get_proc_call</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q'</span><span> </span><span>p</span><span> </span><span>f'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main (src a) = p"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span>get_proc_return</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ax</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax ≠ Entry ∨ targetnode ax ≠ Exit"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = Node (sourcenode ax)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a = Node (targetnode ax)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀a'. valid_edge a' ∧ targetnode a' = targetnode ax ⟶ 
               (∃Qx rx fsx. kind a' = Qx:rx↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fsx)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>call_edges_only</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a'</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a' = trg a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Qx rx fsx. knd a' = Qx:rx↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fsx"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>ax'</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg e = trg a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg a = Node (targetnode ax)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax' = targetnode ax"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax'›</span></span></span><span> </span><span>all</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Qx rx fsx. kind ax' = Qx:rx↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fsx"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (NewEntry, (λs. True)<span class="hidden">⇩</span><sub>√</sub>, Node Entry)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg e = trg a›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹trg a = Node (targetnode ax)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax = Entry"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Exit_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node Exit, (λs. True)<span class="hidden">⇩</span><sub>√</sub>, NewExit)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg e = trg a›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹trg a = Node (targetnode ax)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_Exit_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (NewEntry,(λs. False)<span class="hidden">⇩</span><sub>√</sub>,NewExit)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg e = trg a›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹trg a = Node (targetnode ax)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' ∧
               trg a' = trg a ⟶ (∃Qx rx fsx. knd a' = Qx:rx↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fsx)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q'</span><span> </span><span>p</span><span> </span><span>f'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ax</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax ≠ Entry ∨ targetnode ax ≠ Exit"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = Node (sourcenode ax)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a = Node (targetnode ax)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀a'. valid_edge a' ∧ sourcenode a' = sourcenode ax ⟶ 
            (∃Qx fx. kind a' = Qx↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fx)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>return_edges_only</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a'</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a' = src a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Qx fx. knd a' = Qx↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fx"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>ax'</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = src a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src a = Node (sourcenode ax)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax' = sourcenode ax"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax'›</span></span></span><span> </span><span>all</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Qx fx. kind ax' = Qx↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fx"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (NewEntry, (λs. True)<span class="hidden">⇩</span><sub>√</sub>, Node Entry)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = src a›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹src a = Node (sourcenode ax)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Exit_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node Exit, (λs. True)<span class="hidden">⇩</span><sub>√</sub>, NewExit)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = src a›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹src a = Node (sourcenode ax)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_source</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_Exit_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (NewEntry,(λs. False)<span class="hidden">⇩</span><sub>√</sub>,NewExit)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = src a›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹src a = Node (sourcenode ax)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' ∧
               src a' = src a ⟶ (∃Qx fx. knd a' = Qx↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fx)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_return_edges get_return_edges valid_edge 
      sourcenode targetnode kind a ≠ {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>ax</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_return_edges ax ≠ {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>get_return_edge_call</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ax'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ax' ∈ get_return_edges ax"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node (sourcenode ax'),kind ax',Node (targetnode ax')) ∈ 
        lift_get_return_edges get_return_edges valid_edge 
        sourcenode targetnode kind e"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_get_return_edgesI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>a'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ lift_get_return_edges get_return_edges valid_edge 
      sourcenode targetnode kind a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_get_return_edges.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lift_get_return_edgesI</span><span> </span><span>ax</span><span> </span><span>a'</span><span> </span><span>e'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a' ∈ get_return_edges ax›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>get_return_edges_valid</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a' ∈ get_return_edges ax›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>only_call_get_return_edges</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a' ∈ get_return_edges ax›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q'</span><span> </span><span>f'</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>call_return_edges</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"get_proc(sourcenode a') = p"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>get_proc_return</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' ≠ Entry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>get_proc_Entry</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹get_proc(sourcenode a') = p›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = Main"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = Q'↩<span class="hidden">⇘</span><sub>Main<span class="hidden">⇙</span></sub>f'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Main_no_return_source</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e' = (Node (sourcenode a'), kind a', Node (targetnode a'))›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_edge</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>a'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ lift_get_return_edges get_return_edges valid_edge sourcenode
      targetnode kind a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q r p fs. knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_get_return_edges.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lift_get_return_edgesI</span><span> </span><span>ax</span><span> </span><span>a'</span><span> </span><span>e'</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a' ∈ get_return_edges ax›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q r p fs. kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>only_call_get_return_edges</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span> </span><span>a'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ lift_get_return_edges get_return_edges 
      valid_edge sourcenode targetnode kind a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q' f'. knd a' = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_get_return_edges.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lift_get_return_edgesI</span><span> </span><span>ax</span><span> </span><span>a'</span><span> </span><span>e'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a' ∈ get_return_edges ax›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q' f'. kind a' = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>call_return_edges</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e' = (Node (sourcenode a'), kind a', Node (targetnode a'))›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q'</span><span> </span><span>p</span><span> </span><span>f'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃!a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' ∧
      (∃Q r fs. knd a' = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs) ∧ a ∈ lift_get_return_edges get_return_edges 
      valid_edge sourcenode targetnode kind a'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃!a'. valid_edge a' ∧ (∃Q r fs. kind a' = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs) ∧ 
        a ∈ get_return_edges a'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>return_needs_call</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>fs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ get_return_edges a'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>imp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀x. valid_edge x ∧ (∃Q r fs. kind x = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs) ∧ 
        a ∈ get_return_edges x ⟶ x = a'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>ex1E</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node (sourcenode a'),kind a',Node (targetnode a'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' ≠ Entry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_no_call_source</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_valid_edge.lve_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd ?e' = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ∈ get_return_edges a'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ lift_get_return_edges get_return_edges valid_edge
        sourcenode targetnode kind ?e'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_get_return_edgesI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q r fs. knd x = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ lift_get_return_edges get_return_edges valid_edge
          sourcenode targetnode kind x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹∃Q r fs. knd x = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge y"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = (Node (sourcenode y), kind y, Node (targetnode y))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e ∈ lift_get_return_edges get_return_edges valid_edge
          sourcenode targetnode kind x›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ?e'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_get_return_edges.induct</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lift_get_return_edgesI</span><span> </span><span>ax</span><span> </span><span>ax'</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ax' ∈ get_return_edges ax›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax'"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>get_return_edges_valid</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode ax'), kind ax', Node (targetnode ax'))›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = sourcenode ax'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = targetnode ax'"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a = ax'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹∃Q r fs. knd x = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q r fs. kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ax' ∈ get_return_edges ax›</span></span></span><span> </span><span>imp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ax = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span> 
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span>ex1I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>a'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ lift_get_return_edges get_return_edges valid_edge sourcenode
      targetnode kind a"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a''. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'' ∧
      src a'' = trg a ∧ trg a'' = src a' ∧ knd a'' = (λcf. False)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_get_return_edges.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lift_get_return_edgesI</span><span> </span><span>ax</span><span> </span><span>a'</span><span> </span><span>e'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a' ∈ get_return_edges ax›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ax'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax' = targetnode ax"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax' = sourcenode a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax' = (λcf. False)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>intra_proc_additional_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ex</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node (sourcenode ax'), kind ax', Node (targetnode ax'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax ≠ Entry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax = Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax' = targetnode ax›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax' ≠ Entry"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax'›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?ex"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e' = (Node (sourcenode a'), kind a', Node (targetnode a'))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹a = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹e' = (Node (sourcenode a'), kind a', Node (targetnode a'))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax' = targetnode ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax' = sourcenode a'›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax' = (λcf. False)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>a'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a' ∈ lift_get_return_edges get_return_edges valid_edge sourcenode
      targetnode kind a"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a''. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'' ∧
      src a'' = src a ∧ trg a'' = trg a' ∧ knd a'' = (λcf. False)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_get_return_edges.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lift_get_return_edgesI</span><span> </span><span>ax</span><span> </span><span>a'</span><span> </span><span>e'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a' ∈ get_return_edges ax›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ax'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax' = sourcenode ax"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax' = targetnode a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax' = (λcf. False)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>call_return_node_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?ex</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node (sourcenode ax'), kind ax', Node (targetnode ax'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a' ∈ get_return_edges ax›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span>only_call_get_return_edges</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax ≠ Entry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_no_call_source</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax' = sourcenode ax›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax' ≠ Entry"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax'›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?ex"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e' = (Node (sourcenode a'), kind a', Node (targetnode a'))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹a = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹e' = (Node (sourcenode a'), kind a', Node (targetnode a'))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax' = sourcenode ax›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax' = targetnode a'›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹kind ax' = (λcf. False)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃!a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' ∧
      src a' = src a ∧ intra_kind (knd a')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃!a'. valid_edge a' ∧ sourcenode a' = sourcenode a ∧
        intra_kind(kind a')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>call_only_one_intra_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = sourcenode a"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind(kind a')"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>imp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀x. valid_edge x ∧ sourcenode x = sourcenode a ∧ intra_kind(kind x)
        ⟶ x = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>ex1E</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node (sourcenode a'), kind a', Node (targetnode a'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a ≠ Entry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_no_call_source</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = sourcenode a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' ≠ Entry"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_valid_edge.lve_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = sourcenode a›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src ?e' = src e"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind(kind a')›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (knd ?e')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src x = src e"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (knd x)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ?e'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>ax</span><span> </span><span>ex</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (knd x)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = ex›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src x = src e›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (kind ax)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = sourcenode a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span>imp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ax = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = ex›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_edge</span><span> </span><span>ex</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src x = src e›</span></span></span><span> 
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Exit_edge</span><span> </span><span>ex</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src x = src e›</span></span></span><span> 
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_source</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_Exit_edge</span><span> </span><span>ex</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src x = src e›</span></span></span><span> 
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span>ex1I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q'</span><span> </span><span>p</span><span> </span><span>f'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃!a'. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a' ∧
      trg a' = trg a ∧ intra_kind (knd a')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃!a'. valid_edge a' ∧ targetnode a' = targetnode a ∧
        intra_kind(kind a')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>return_only_one_intra_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a' = targetnode a"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind(kind a')"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>imp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"∀x. valid_edge x ∧ targetnode x = targetnode a ∧ intra_kind(kind x)
        ⟶ x = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>ex1E</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node (sourcenode a'), kind a', Node (targetnode a'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Exit"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Exit"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_no_return_target</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a' = targetnode a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a' ≠ Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_valid_edge.lve_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a' = targetnode a›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg ?e' = trg e"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind(kind a')›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (knd ?e')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg x = trg e"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (knd x)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit x›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = ?e'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>ax</span><span> </span><span>ex</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (knd x)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = ex›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg x = trg e›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (kind ax)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax = targetnode a"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span>imp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ax = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x = ex›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ex = (Node (sourcenode ax), kind ax, Node (targetnode ax))›</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_edge</span><span> </span><span>ex</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg x = trg e›</span></span></span><span> 
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Entry"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Exit_edge</span><span> </span><span>ex</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg x = trg e›</span></span></span><span> 
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_Exit_edge</span><span> </span><span>ex</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg x = trg e›</span></span></span><span> 
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span>ex1I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>a'</span><span> </span><span>Q<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>r<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>p</span><span> </span><span>fs<span class="hidden">⇩</span><sub>1</sub></span><span> </span><span>Q<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>r<span class="hidden">⇩</span><sub>2</sub></span><span> </span><span>fs<span class="hidden">⇩</span><sub>2</sub></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q<span class="hidden">⇩</span><sub>1</sub>:r<span class="hidden">⇩</span><sub>1</sub>↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a' = Q<span class="hidden">⇩</span><sub>2</sub>:r<span class="hidden">⇩</span><sub>2</sub>↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge x"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a = (Node (sourcenode x),kind x,Node (targetnode x))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge x'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a' = (Node (sourcenode x'),kind x',Node (targetnode x'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd a = Q<span class="hidden">⇩</span><sub>1</sub>:r<span class="hidden">⇩</span><sub>1</sub>↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs<span class="hidden">⇩</span><sub>1</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd a' = Q<span class="hidden">⇩</span><sub>2</sub>:r<span class="hidden">⇩</span><sub>2</sub>↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs<span class="hidden">⇩</span><sub>2</sub>›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind x = Q<span class="hidden">⇩</span><sub>1</sub>:r<span class="hidden">⇩</span><sub>1</sub>↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs<span class="hidden">⇩</span><sub>1</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind x' = Q<span class="hidden">⇩</span><sub>2</sub>:r<span class="hidden">⇩</span><sub>2</sub>↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs<span class="hidden">⇩</span><sub>2</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge x›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge x'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode x = targetnode x'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>same_proc_call_unique_target</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span>a'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a = trg a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>unique_callers</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct_fst procs"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>ins</span><span> </span><span>outs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, ins, outs) ∈ set procs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>distinct_formal_ins</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct ins"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>p</span><span> </span><span>ins</span><span> </span><span>outs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, ins, outs) ∈ set procs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>distinct_formal_outs</span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct outs"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_CFG_wf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit Def Use ParamDefs ParamUses"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Postdomination sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG_wf src trg knd
  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry
  (lift_get_proc get_proc Main) 
  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) 
  procs Main (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)
  (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>CFGExit_wf</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span> </span><span>Def</span><span> </span><span>Use</span><span> </span><span>ParamDefs</span><span> </span><span>ParamUses</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Postdomination</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>CFG</span><span class="delimiter">:</span><span>CFG</span><span> </span><span>src</span><span> </span><span>trg</span><span> </span><span>knd</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit"</span></span></span><span> </span><span>NewEntry</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind"</span></span></span><span>
</span><span>    </span><span>procs</span><span> </span><span>Main</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_CFG</span><span> </span><span>wf</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_Def Def Entry Exit H L NewEntry = {} ∧
          lift_Use Use Entry Exit H L NewEntry = {}"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_Use_set.cases</span><span> </span><span>lift_Def_set.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span> </span><span>ins</span><span> </span><span>outs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, ins, outs) ∈ set procs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (lift_ParamUses ParamUses (src a)) = length ins"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src e = Node (sourcenode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p,ins,outs) ∈ set procs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length(ParamUses (sourcenode a)) = length ins"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>ParamUses_call_source_length</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = Node (sourcenode a)›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (lift_ParamDefs ParamDefs (trg a))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"distinct (ParamDefs (targetnode a))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>distinct_ParamDefs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ParamDefs Entry = []"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ParamDefs Entry ≠ []"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>V</span><span> </span><span>Vs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ParamDefs Entry = V#Vs"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ParamDefs Entry"</span></span></span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ set (ParamDefs Entry)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Def Entry"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>ParamDefs_in_Def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Entry_empty</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (NewEntry, (λs. True)<span class="hidden">⇩</span><sub>√</sub>, Node Entry)›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q'</span><span> </span><span>p</span><span> </span><span>f'</span><span> </span><span>ins</span><span> </span><span>outs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, ins, outs) ∈ set procs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (lift_ParamDefs ParamDefs (trg a)) = length outs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg e = Node (targetnode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p,ins,outs) ∈ set procs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length(ParamDefs (targetnode a)) = length outs"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>ParamDefs_return_target_length</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg e = Node (targetnode a)›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>V</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_node src trg 
      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ set (lift_ParamDefs ParamDefs n)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((n = NewEntry) ∨ n = NewExit) ∨ (∃m. n = Node m ∧ valid_node m)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFG.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ lift_Def Def Entry Exit H L n"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = NewEntry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ set (lift_ParamDefs ParamDefs n)›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = NewExit"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ set (lift_ParamDefs ParamDefs n)›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃m. n = Node m ∧ valid_node m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = Node m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = Node m›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ set (lift_ParamDefs ParamDefs n)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ set (ParamDefs m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Def m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ParamDefs_in_Def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = Node m›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_Def_node</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span> </span><span>ins</span><span> </span><span>outs</span><span> </span><span>V</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, ins, outs) ∈ set procs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ set ins"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ lift_Def Def Entry Exit H L (trg a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p, ins, outs) ∈ set procs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ set ins›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Def (targetnode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ins_in_Def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg e = Node (targetnode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ Def (targetnode a)›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_Def_node</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_Def Def Entry Exit H L (src a) = {}"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_Def Def Entry Exit H L (src e) ≠ {}"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ lift_Def Def Entry Exit H L (src e)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Def (sourcenode a) = {}"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>call_source_Def_empty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a ≠ Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = Entry"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_no_call_source</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src e = Node (sourcenode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Def (sourcenode a) = {}›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹x ∈ lift_Def Def Entry Exit H L (src e)›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a ≠ Entry›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_Def_set.cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>V</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_node src trg 
      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ ⋃(set (lift_ParamUses ParamUses n))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((n = NewEntry) ∨ n = NewExit) ∨ (∃m. n = Node m ∧ valid_node m)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFG.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ lift_Use Use Entry Exit H L n"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = NewEntry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ ⋃(set (lift_ParamUses ParamUses n))›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = NewExit"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ ⋃(set (lift_ParamUses ParamUses n))›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃m. n = Node m ∧ valid_node m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = Node m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ ⋃(set (lift_ParamUses ParamUses n))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = Node m›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ ⋃(set (ParamUses m))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Use m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ParamUses_in_Use</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = Node m›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_Use_node</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>p</span><span> </span><span>f</span><span> </span><span>ins</span><span> </span><span>outs</span><span> </span><span>V</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, ins, outs) ∈ set procs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ set outs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ lift_Use Use Entry Exit H L (src a)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p, ins, outs) ∈ set procs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ set outs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Use (sourcenode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>outs_in_Use</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src e = Node (sourcenode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ Use (sourcenode a)›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_Use_node</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>V</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∉ lift_Def Def Entry Exit H L (src a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (knd a)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (knd a) s"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"state_val (transfer (knd a) s) V = state_val s V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (knd e)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (kind a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (kind a) s"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd e = kind a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src e = Node (sourcenode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∉ lift_Def Def Entry Exit H L (src e)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = Node (sourcenode a)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∉ Def (sourcenode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>lift_Def_node</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∉ Def (sourcenode a)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (kind a) s›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"state_val (transfer (kind a) s) V = state_val s V"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFG_intra_edge_no_Def_equal</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = kind a›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (NewEntry, (λs. True)<span class="hidden">⇩</span><sub>√</sub>, Node Entry)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Exit_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node Exit, (λs. True)<span class="hidden">⇩</span><sub>√</sub>, NewExit)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_Exit_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (NewEntry, (λs. False)<span class="hidden">⇩</span><sub>√</sub>, NewExit)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"∀V∈lift_Use Use Entry Exit H L (src a). state_val s V = state_val s' V"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"intra_kind (knd a)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (knd a) s"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (knd a) s'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V∈lift_Def Def Entry Exit H L (src a).
      state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ lift_Def Def Entry Exit H L (src a)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"state_val (transfer (knd a) s) V = state_val (transfer (knd a) s') V"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (knd e)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (kind a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Node (sourcenode a) = Node Entry"</span></span></span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = Entry"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Entry_Exit_edge</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a'"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a' = Entry"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a' = Exit"</span></span></span><span>
</span><span>            </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a' = (λs. False)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q. kind a = (Q)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Exit"</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = Entry›</span></span></span><span>
</span><span>              </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = Entry›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a' = Exit›</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>edge_det</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = (λs. False)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a = Entry›</span></span></span><span>
</span><span>              </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a' = Entry›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a' = Exit›</span></span></span><span>
</span><span>              </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a' = (λs. False)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span>
</span><span>            </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>deterministic</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ lift_Def Def Entry Exit H L (src e)›</span></span></span><span> </span><span>Entry_empty</span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ H"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_Def_set.cases</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>True</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode a ≠ Entry ∨ targetnode a ≠ Exit›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V∈H. V ∈ lift_Use Use Entry Exit H L (src e)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_Use_High</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈lift_Use Use Entry Exit H L (src e). 
            state_val s V = state_val s' V›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ H›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"state_val s V = state_val s' V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> 
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹∃Q. kind a = (Q)<span class="hidden">⇩</span><sub>√</sub>›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s'›</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">,</span><span>cases</span><span> </span><span>s'</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>V'</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V' ∈ Use (sourcenode a)"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V' ∈ lift_Use Use Entry Exit H L (src e)"</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_Use_node</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈lift_Use Use Entry Exit H L (src e). 
            state_val s V = state_val s' V›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V∈Use (sourcenode a). state_val s V = state_val s' V"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s'›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (knd e)›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ Def (sourcenode a). state_val (transfer (kind a) s) V =
            state_val (transfer (kind a) s') V"</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>erule</span><span> </span><span>CFG_intra_edge_transfer_uses_only_Use</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ lift_Def Def Entry Exit H L (src e)›</span></span></span><span> </span><span>False</span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"V ∈ Def (sourcenode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_Def_set.cases</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V ∈ Def (sourcenode a). state_val (transfer (kind a) s) V =
            state_val (transfer (kind a) s') V›</span></span></span><span>
</span><span>            </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ lift_Def Def Entry Exit H L (src e)›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (NewEntry, (λs. True)<span class="hidden">⇩</span><sub>√</sub>, Node Entry)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_Def_set.cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Exit_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹V ∈ lift_Def Def Entry Exit H L (src e)›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node Exit, (λs. True)<span class="hidden">⇩</span><sub>√</sub>, NewExit)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_Def_set.cases</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span>Entry_noteq_Exit</span><span> </span><span>simp</span><span class="delimiter">:</span><span>Exit_empty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_Exit_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (knd a) s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"snd (hd s) = snd (hd s')"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V∈lift_Use Use Entry Exit H L (src a). state_val s V = state_val s' V"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length s = length s'"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (knd a) s'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (kind a) s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src e = Node (sourcenode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = Node (sourcenode a)›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈lift_Use Use Entry Exit H L (src e). state_val s V = state_val s' V›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ Use (sourcenode a). state_val s V = state_val s' V"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>lift_Use_node</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (kind a) s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹snd (hd s) = snd (hd s')›</span></span></span><span>
</span><span>        </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length s = length s'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (kind a) s'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFG_edge_Uses_pred_equal</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s'</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Exit_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s'</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Entry_Exit_edge</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span> </span><span>ins</span><span> </span><span>outs</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, ins, outs) ∈ set procs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length fs = length ins"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p, ins, outs) ∈ set procs›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFG_call_edge_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span> </span><span>a'</span><span> </span><span>Q'</span><span> </span><span>r'</span><span> </span><span>p'</span><span> </span><span>fs'</span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a' = Q':r'↪<span class="hidden">⇘</span><sub>p'<span class="hidden">⇙</span></sub>fs'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = src a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (knd a) s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (knd a') s"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a›</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd a) s›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a = (Node (sourcenode x),kind x,Node (targetnode x))"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = Node (sourcenode x)"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind x = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (kind x) s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'›</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹knd a' = Q':r'↪<span class="hidden">⇘</span><sub>p'<span class="hidden">⇙</span></sub>fs'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd a') s›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"a' = (Node (sourcenode x'),kind x',Node (targetnode x'))"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge x'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a' = Node (sourcenode x')"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind x' = Q':r'↪<span class="hidden">⇘</span><sub>p'<span class="hidden">⇙</span></sub>fs'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (kind x') s"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src a = Node (sourcenode x)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src a' = Node (sourcenode x')›</span></span></span><span> 
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹src a = src a'›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode x = sourcenode x'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge x›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind x = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge x'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind x' = Q':r'↪<span class="hidden">⇘</span><sub>p'<span class="hidden">⇙</span></sub>fs'›</span></span></span><span>
</span><span>      </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode x = sourcenode x'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (kind x) s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (kind x') s›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = x'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFG_call_determ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>a</span><span> </span><span>a'</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a = a'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span> </span><span>i</span><span> </span><span>ins</span><span> </span><span>outs</span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ins"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, ins, outs) ∈ set procs"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (knd a) s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (knd a) s'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V∈lift_ParamUses ParamUses (src a) ! i. state_val s V = state_val s' V"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"params fs (state_val s) ! i = CFG.params fs (state_val s') ! i"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (knd e) s'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (kind a) s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"pred (kind a) s'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src e = Node (sourcenode a)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀V∈lift_ParamUses ParamUses (src e) ! i. state_val s V = state_val s' V›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = Node (sourcenode a)›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀V ∈ (ParamUses (sourcenode a))!i. state_val s V = state_val s' V"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹i &lt; length ins›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹(p, ins, outs) ∈ set procs›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (kind a) s›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹pred (kind a) s'›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFG_call_edge_params</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q'</span><span> </span><span>p</span><span> </span><span>f'</span><span> </span><span>ins</span><span> </span><span>outs</span><span> </span><span>cf</span><span> </span><span>cf'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, ins, outs) ∈ set procs"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f' cf cf' = cf'(lift_ParamDefs ParamDefs (trg a) [:=] map cf outs)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd e = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg e = Node (targetnode a)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q'↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹(p, ins, outs) ∈ set procs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"f' cf cf' = cf'(ParamDefs (targetnode a) [:=] map cf outs)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFG_return_edge_fun</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg e = Node (targetnode a)›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>a'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = src a'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a ≠ trg a'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (knd a)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (knd a')"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Q Q'. knd a = (Q)<span class="hidden">⇩</span><sub>√</sub> ∧ knd a' = (Q')<span class="hidden">⇩</span><sub>√</sub> ∧ 
                 (∀s. (Q s ⟶ ¬ Q' s) ∧ (Q' s ⟶ ¬ Q s))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = src a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg e ≠ trg a'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (knd e)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (knd a')›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>lve_edge</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span>deterministic</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_Exit_edge</span><span> </span><span>e'</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹e' = (Node Exit, (λs. True)<span class="hidden">⇩</span><sub>√</sub>, NewExit)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = src e'›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_source</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_CFGExit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit Def Use ParamDefs ParamUses"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Postdomination sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFGExit src trg knd
  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry
  (lift_get_proc get_proc Main) 
  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) 
  procs Main NewExit"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>CFGExit_wf</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span> </span><span>Def</span><span> </span><span>Use</span><span> </span><span>ParamDefs</span><span> </span><span>ParamUses</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Postdomination</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>CFG</span><span class="delimiter">:</span><span>CFG</span><span> </span><span>src</span><span> </span><span>trg</span><span> </span><span>knd</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit"</span></span></span><span> </span><span>NewEntry</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind"</span></span></span><span>
</span><span>    </span><span>procs</span><span> </span><span>Main</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_CFG</span><span> </span><span>wf</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = NewExit"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main NewExit = Main"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>p</span><span> </span><span>f</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a = NewExit"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a. lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a ∧
      src a = NewEntry ∧ trg a = NewExit ∧ knd a = (λs. False)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Entry_Exit_edge</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_CFGExit_wf</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit Def Use ParamDefs ParamUses"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Postdomination sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFGExit_wf src trg knd
  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry
  (lift_get_proc get_proc Main) 
  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) 
  procs Main NewExit (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)
  (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>CFGExit_wf</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span> </span><span>Def</span><span> </span><span>Use</span><span> </span><span>ParamDefs</span><span> </span><span>ParamUses</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Postdomination</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>CFG_wf</span><span class="delimiter">:</span><span>CFG_wf</span><span> </span><span>src</span><span> </span><span>trg</span><span> </span><span>knd</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit"</span></span></span><span> </span><span>NewEntry</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind"</span></span></span><span>
</span><span>    </span><span>procs</span><span> </span><span>Main</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_Def Def Entry Exit H L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_Use Use Entry Exit H L"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_ParamDefs ParamDefs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_ParamUses ParamUses"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_CFG_wf</span><span> </span><span>wf</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>CFGExit</span><span class="delimiter">:</span><span>CFGExit</span><span> </span><span>src</span><span> </span><span>trg</span><span> </span><span>knd</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit"</span></span></span><span> </span><span>NewEntry</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind"</span></span></span><span>
</span><span>    </span><span>procs</span><span> </span><span>Main</span><span> </span><span>NewExit</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_CFGExit</span><span> </span><span>wf</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_Def Def Entry Exit H L NewExit = {} ∧
      lift_Use Use Entry Exit H L NewExit = {}"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_Def_set.cases</span><span> </span><span>lift_Use_set.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lifting the SDG›</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_Postdomination</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit Def Use ParamDefs ParamUses"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Postdomination sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inner</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Postdomination src trg knd
  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry
  (lift_get_proc get_proc Main) 
  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) 
  procs Main NewExit"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>CFGExit_wf</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span> </span><span>Def</span><span> </span><span>Use</span><span> </span><span>ParamDefs</span><span> </span><span>ParamUses</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>Postdomination</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>CFGExit</span><span class="delimiter">:</span><span>CFGExit</span><span> </span><span>src</span><span> </span><span>trg</span><span> </span><span>knd</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit"</span></span></span><span> </span><span>NewEntry</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind"</span></span></span><span>
</span><span>    </span><span>procs</span><span> </span><span>Main</span><span> </span><span>NewExit</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_CFGExit</span><span> </span><span>wf</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node m"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = sourcenode a ∨ m = targetnode a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span>valid_node_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = sourcenode a ∨ m = targetnode a›</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_node src trg
      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) (Node m)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = sourcenode a"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = Entry"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Entry_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = Entry›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = sourcenode a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (Node (sourcenode a),kind a,Node(targetnode a))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = sourcenode a›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = targetnode a"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m = Exit"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Exit_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = Exit›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = targetnode a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (Node (sourcenode a),kind a,Node(targetnode a))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = targetnode a›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>lift_valid_node</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>as</span><span> </span><span>n'</span><span> </span><span>cs</span><span> </span><span>m</span><span> </span><span>m'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_path_aux cs as"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m -as→* m'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c ∈ set cs. valid_edge c"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m ≠ Entry ∨ m' ≠ Exit"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃cs' es. CFG.CFG.valid_path_aux knd
      (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)
      cs' es ∧ 
      list_all2 (λc c'. c' = (Node (sourcenode c),kind c,Node (targetnode c))) cs cs' 
       ∧ CFG.CFG.path src trg
      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
      (Node m) es (Node m')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>m</span><span> </span><span>rule</span><span class="delimiter">:</span><span>vpa_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>vpa_empty</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -[]→* m'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"m = m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -[]→* m'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>path_valid_node</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cs' = 
        map (λc. (Node (sourcenode c),kind c,Node (targetnode c))) cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 
        (λc c'. c' = (Node (sourcenode c),kind c,Node (targetnode c))) cs cs'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>list_all2_conv_all_nth</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"cs'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"[]"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.empty_path</span><span> </span><span>lift_valid_node</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>vpa_intra</span><span> </span><span>cs</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀m. ⟦m -as→* m'; ∀c∈set cs. valid_edge c; m ≠ Entry ∨ m' ≠ Exit⟧ ⟹
        ∃cs' es. CFG.valid_path_aux knd
        (lift_get_return_edges get_return_edges valid_edge sourcenode
        targetnode kind) cs' es ∧
        list_all2 (λc c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) cs
        cs' ∧ CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (Node m) es (Node m')›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -a # as→* m'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = sourcenode a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -as→* m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = Entry ∧ targetnode a = Exit"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = sourcenode a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m ≠ Entry ∨ m' ≠ Exit›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m' ≠ Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* m'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m' = Exit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>drule</span><span> </span><span>path_Exit_source</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m' ≠ Exit›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node (sourcenode a),kind a,Node (targetnode a))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>False</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Entry"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Entry ∨ m' ≠ Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* m'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set cs. valid_edge c›</span></span></span><span> </span><span>this</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs'</span><span> </span><span>es</span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>valid_path</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.valid_path_aux knd
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) cs' es"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>list</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"list_all2 
          (λc c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) cs cs'"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>path</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (Node (targetnode a)) es (Node m')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind a)›</span></span></span><span> </span><span>valid_path</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.valid_path_aux knd
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) cs' (?e#es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>path</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = sourcenode a›</span></span></span><span> 
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (Node m) (?e#es) (Node m')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>vpa_Call</span><span> </span><span>cs</span><span> </span><span>a</span><span> </span><span>as</span><span> </span><span>Q</span><span> </span><span>r</span><span> </span><span>p</span><span> </span><span>fs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀m. ⟦m -as→* m'; ∀c∈set (a # cs). valid_edge c; 
        m ≠ Entry ∨ m' ≠ Exit⟧ ⟹
        ∃cs' es. CFG.valid_path_aux knd
        (lift_get_return_edges get_return_edges valid_edge sourcenode
        targetnode kind) cs' es ∧
        list_all2 (λc c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) 
        (a#cs) cs' ∧ CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (Node m) es (Node m')›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -a # as→* m'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = sourcenode a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -as→* m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set cs. valid_edge c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c∈set (a # cs). valid_edge c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node (sourcenode a),kind a,Node (targetnode a))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a ≠ Entry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_no_call_source</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Entry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Entry ∨ m' ≠ Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* m'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set (a # cs). valid_edge c›</span></span></span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cs'</span><span> </span><span>es</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>valid_path</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.valid_path_aux knd
        (lift_get_return_edges get_return_edges valid_edge sourcenode 
        targetnode kind) cs' es"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>list</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"list_all2 
        (λc c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) (a#cs) cs'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>path</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (Node (targetnode a)) es (Node m')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>list</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cx</span><span> </span><span>csx</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cs' = cx#csx"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cx</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"cx = (Node (sourcenode a), kind a, Node (targetnode a))"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>list'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"list_all2 
        (λc c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) cs csx"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>list_all2_Cons1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>valid_path</span><span> </span><span>cx</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs' = cx#csx›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q:r↪<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>fs›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.valid_path_aux knd
        (lift_get_return_edges get_return_edges valid_edge sourcenode 
        targetnode kind) csx (?e#es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>path</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = sourcenode a›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (Node m) (?e#es) (Node m')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>vpa_ReturnEmpty</span><span> </span><span>cs</span><span> </span><span>a</span><span> </span><span>as</span><span> </span><span>Q</span><span> </span><span>p</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀m. ⟦m -as→* m'; ∀c∈set []. valid_edge c; m ≠ Entry ∨ m' ≠ Exit⟧ ⟹
        ∃cs' es. CFG.valid_path_aux knd
        (lift_get_return_edges get_return_edges valid_edge sourcenode
        targetnode kind) cs' es ∧
        list_all2 (λc c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) 
        [] cs' ∧ CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (Node m) es (Node m')›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -a # as→* m'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = sourcenode a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -as→* m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node (sourcenode a),kind a,Node (targetnode a))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Exit"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Exit"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_no_return_target</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Entry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Entry ∨ m' ≠ Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* m'›</span></span></span><span> </span><span>_</span><span> </span><span>this</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>es</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>valid_path</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.valid_path_aux knd
        (lift_get_return_edges get_return_edges valid_edge sourcenode
        targetnode kind) [] es"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>path</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (Node (targetnode a)) es (Node m')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>valid_path</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.valid_path_aux knd
        (lift_get_return_edges get_return_edges valid_edge sourcenode 
        targetnode kind) [] (?e#es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>path</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = sourcenode a›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (Node m) (?e#es) (Node m')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = []›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>vpa_ReturnCons</span><span> </span><span>cs</span><span> </span><span>a</span><span> </span><span>as</span><span> </span><span>Q</span><span> </span><span>p</span><span> </span><span>f</span><span> </span><span>c'</span><span> </span><span>cs'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>IH</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹⋀m. ⟦m -as→* m'; ∀c∈set cs'. valid_edge c; m ≠ Entry ∨ m' ≠ Exit⟧ ⟹
        ∃csx es. CFG.valid_path_aux knd
        (lift_get_return_edges get_return_edges valid_edge sourcenode
        targetnode kind) csx es ∧
        list_all2 (λc c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) 
        cs' csx ∧ CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (Node m) es (Node m')›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m -a # as→* m'›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m = sourcenode a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge a"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a -as→* m'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>path_split_Cons</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set cs. valid_edge c›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge c'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀c∈set cs'. valid_edge c"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>      </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?e</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Node (sourcenode a),kind a,Node (targetnode a))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Exit"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Exit"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_no_return_target</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Entry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a ≠ Entry ∨ m' ≠ Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode a -as→* m'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹∀c∈set cs'. valid_edge c›</span></span></span><span> </span><span>this</span><span class="delimiter">]</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>csx</span><span> </span><span>es</span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>valid_path</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.valid_path_aux knd
        (lift_get_return_edges get_return_edges valid_edge sourcenode
        targetnode kind) csx es"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>list</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"list_all2 
        (λc c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) cs' csx"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>path</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (Node (targetnode a)) es (Node m')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge c'›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹a ∈ get_return_edges c'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?e ∈ lift_get_return_edges get_return_edges valid_edge sourcenode
        targetnode kind (Node (sourcenode c'),kind c',Node (targetnode c'))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_get_return_edgesI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>valid_path</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.valid_path_aux knd
        (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)
        ((Node (sourcenode c'),kind c',Node (targetnode c'))#csx) (?e#es)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>list</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹cs = c' # cs'›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 
        (λc c'. c' = (Node (sourcenode c), kind c, Node (targetnode c))) cs 
        ((Node (sourcenode c'),kind c',Node (targetnode c'))#csx)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>path</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = sourcenode a›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit ?e›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (Node m) (?e#es) (Node m')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹kind a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>lift_valid_path</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"⋀m as m'. ⟦m -as→<span class="hidden">⇩</span><sub>√</sub>* m'; m ≠ Entry ∨ m' ≠ Exit⟧ 
    ⟹ ∃es. CFG.CFG.valid_path' src trg knd
    (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
    (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)
    (Node m) es (Node m')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>vp_def</span><span> </span><span>valid_path_def</span><span> </span><span>CFGExit.vp_def</span><span> </span><span>CFGExit.valid_path_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_node src trg
      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((n = NewEntry) ∨ n = NewExit) ∨ (∃m. n = Node m ∧ valid_node m)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃as. CFG.CFG.valid_path' src trg knd
      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
      (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)
      NewEntry as n"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = NewEntry"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)
        NewEntry [] n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.empty_path</span><span> 
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.vp_def</span><span> </span><span>CFGExit.valid_path_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = NewExit"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
        (NewEntry,(λs. False)<span class="hidden">⇩</span><sub>√</sub>,NewExit)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Entry_Exit_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        NewEntry [(NewEntry,(λs. False)<span class="hidden">⇩</span><sub>√</sub>,NewExit)] NewExit"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>CFGExit.path_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = NewExit›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)
        NewEntry [(NewEntry,(λs. False)<span class="hidden">⇩</span><sub>√</sub>,NewExit)] n"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.vp_def</span><span> </span><span>CFGExit.valid_path_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃m. n = Node m ∧ valid_node m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = Node m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span> </span><span>rule</span><span class="delimiter">:</span><span>valid_node_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Entry</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Entry_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = Entry›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = Node m›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.path src trg
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          NewEntry [(NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)] n"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span> </span><span>CFGExit.empty_path</span><span>
</span><span>                       </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.vp_def</span><span> </span><span>CFGExit.valid_path_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Exit</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inner</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ax</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (kind ax)"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_node (sourcenode ax)"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax = Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>inner_node_Exit_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (Node (sourcenode ax),kind ax,Node Exit)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_valid_edge.lve_edge</span><span> </span><span>simp</span><span class="delimiter">:</span><span>inner_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (Node (sourcenode ax)) [(Node (sourcenode ax),kind ax,Node Exit)] 
          (Node Exit)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span> </span><span>CFGExit.empty_path</span><span>
</span><span>                       </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind ax)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>slp_edge</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.same_level_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind)
          (Node (sourcenode ax)) [(Node (sourcenode ax),kind ax,Node Exit)] 
          (Node Exit)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.slp_def</span><span> </span><span>CFGExit.same_level_path_def</span><span> 
</span><span>            </span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax ≠ Exit"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = Exit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_source</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Entry_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (NewEntry) [(NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)] (Node Entry)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span> </span><span>CFGExit.empty_path</span><span>
</span><span>                       </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>slp_edge'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.same_level_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind)
          (NewEntry) [(NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)] (Node Entry)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.slp_def</span><span> </span><span>CFGExit.same_level_path_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inner_node (sourcenode ax)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node (sourcenode ax)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>inner_is_valid</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>asx</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Entry -asx→<span class="hidden">⇩</span><sub>√</sub>* sourcenode ax"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>Entry_path</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹sourcenode ax ≠ Exit›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃es. CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) (Node Entry) es (Node (sourcenode ax))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_valid_path</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) (Node Entry) es (Node (sourcenode ax))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>slp_edge</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) 
          (Node Entry) (es@[(Node (sourcenode ax),kind ax,Node Exit)]) (Node Exit)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.vp_slp_Append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>slp_edge'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) NewEntry
          ([(NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)]@
          (es@[(Node (sourcenode ax),kind ax,Node Exit)])) (Node Exit)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.slp_vp_Append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = Exit›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = Node m›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>inner</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Entry_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (NewEntry) [(NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)] (Node Entry)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span> </span><span>CFGExit.empty_path</span><span>
</span><span>                       </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>slp_edge</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.same_level_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind)
          (NewEntry) [(NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)] (Node Entry)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.slp_def</span><span> </span><span>CFGExit.same_level_path_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Entry -as→<span class="hidden">⇩</span><sub>√</sub>* m"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>Entry_path</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inner_node m›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃es. CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) (Node Entry) es (Node m)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_valid_path</span><span> </span><span>simp</span><span class="delimiter">:</span><span>inner_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) (Node Entry) es (Node m)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>slp_edge</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) NewEntry ([(NewEntry,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,Node Entry)]@es) (Node m)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.slp_vp_Append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = Node m›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_node src trg
      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) n"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((n = NewEntry) ∨ n = NewExit) ∨ (∃m. n = Node m ∧ valid_node m)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃as. CFG.CFG.valid_path' src trg knd
      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
      (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)
      n as NewExit"</span></span></span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = NewEntry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
        (NewEntry,(λs. False)<span class="hidden">⇩</span><sub>√</sub>,NewExit)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Entry_Exit_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.path src trg
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        NewEntry [(NewEntry,(λs. False)<span class="hidden">⇩</span><sub>√</sub>,NewExit)] NewExit"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>CFGExit.path_edge</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = NewEntry›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)
        n [(NewEntry,(λs. False)<span class="hidden">⇩</span><sub>√</sub>,NewExit)] NewExit"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.vp_def</span><span> </span><span>CFGExit.valid_path_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = NewExit"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
        (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
        (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind)
        n [] NewExit"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.empty_path</span><span> 
</span><span>          </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.vp_def</span><span> </span><span>CFGExit.valid_path_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃m. n = Node m ∧ valid_node m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = Node m"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>m</span><span> </span><span>rule</span><span class="delimiter">:</span><span>valid_node_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Entry</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inner</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ax</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge ax"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"intra_kind (kind ax)"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"inner_node (targetnode ax)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode ax = Entry"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>inner_node_Entry_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (Node Entry,kind ax,Node (targetnode ax))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_valid_edge.lve_edge</span><span> </span><span>simp</span><span class="delimiter">:</span><span>inner_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (Node Entry) [(Node Entry,kind ax,Node (targetnode ax))] 
          (Node (targetnode ax))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span> </span><span>CFGExit.empty_path</span><span>
</span><span>                       </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹intra_kind (kind ax)›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>slp_edge</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.same_level_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind)
          (Node Entry) [(Node Entry,kind ax,Node (targetnode ax))] 
          (Node (targetnode ax))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.slp_def</span><span> </span><span>CFGExit.same_level_path_def</span><span> 
</span><span>            </span><span>intra_kind_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax ≠ Entry"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax = Entry"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge ax›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Exit_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (Node Exit) [(Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)] NewExit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span> </span><span>CFGExit.empty_path</span><span>
</span><span>                       </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>slp_edge'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.same_level_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind)
          (Node Exit) [(Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)] NewExit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.slp_def</span><span> </span><span>CFGExit.same_level_path_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inner_node (targetnode ax)›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_node (targetnode ax)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>inner_is_valid</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>asx</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode ax -asx→<span class="hidden">⇩</span><sub>√</sub>* Exit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>Exit_path</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹targetnode ax ≠ Entry›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃es. CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) (Node (targetnode ax)) es (Node Exit)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_valid_path</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) (Node (targetnode ax)) es (Node Exit)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>slp_edge</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) 
          (Node Entry) ([(Node Entry,kind ax,Node (targetnode ax))]@es) (Node Exit)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.slp_vp_Append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>slp_edge'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) (Node Entry)
          (([(Node Entry,kind ax,Node (targetnode ax))]@es)@
          [(Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)]) NewExit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.vp_slp_Append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = Entry›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = Node m›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Exit</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Exit_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹m = Exit›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = Node m›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.path src trg
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          n [(Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)] NewExit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span> </span><span>CFGExit.empty_path</span><span>
</span><span>                       </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.vp_def</span><span> </span><span>CFGExit.valid_path_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>inner</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit
          (Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Exit_edge</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.path src trg
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (Node Exit) [(Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)] NewExit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>CFGExit.Cons_path</span><span> </span><span>CFGExit.empty_path</span><span>
</span><span>                       </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.valid_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>slp_edge</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.same_level_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind)
          (Node Exit) [(Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)] NewExit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>CFGExit.slp_def</span><span> </span><span>CFGExit.same_level_path_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_node m›</span></span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m -as→<span class="hidden">⇩</span><sub>√</sub>* Exit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>Exit_path</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹inner_node m›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃es. CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) (Node m) es (Node Exit)"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_valid_path</span><span> </span><span>simp</span><span class="delimiter">:</span><span>inner_node_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) (Node m) es (Node Exit)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>slp_edge</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CFG.CFG.valid_path' src trg knd
          (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit)
          (lift_get_return_edges get_return_edges valid_edge sourcenode 
          targetnode kind) (Node m) (es@[(Node Exit,(λs. True)<span class="hidden">⇩</span><sub>√</sub>,NewExit)]) NewExit"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.vp_slp_Append</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = Node m›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>n</span><span> </span><span>n'</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>method_exit1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit.CFGExit.method_exit src knd
      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit n"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>method_exit2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit.CFGExit.method_exit src knd
      (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewExit n'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lift_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main n = lift_get_proc get_proc Main n'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>method_exit1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = n'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.method_exit_cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = NewExit"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>method_exit2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.method_exit_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' = NewExit"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = NewExit›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>f</span><span> </span><span>p</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' = src a"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main (src a) = p"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.get_proc_return</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>CFGExit.get_proc_Exit</span><span> </span><span>lift_eq</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n' = src a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = NewExit›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = Main"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q↩<span class="hidden">⇘</span><sub>Main<span class="hidden">⇙</span></sub>f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.Main_no_return_source</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span>Q</span><span> </span><span>f</span><span> </span><span>p</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n = src a"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = Node (sourcenode x)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind x = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"method_exit (sourcenode x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>method_exit_def</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>method_exit2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.method_exit_cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' = NewExit"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹knd a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main (src a) = p"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.get_proc_return</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>CFGExit.get_proc_Exit</span><span> </span><span>lift_eq</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = src a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n' = NewExit›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"p = Main"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹knd a = Q↩<span class="hidden">⇘</span><sub>p<span class="hidden">⇙</span></sub>f›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a = Q↩<span class="hidden">⇘</span><sub>Main<span class="hidden">⇙</span></sub>f"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CFGExit.Main_no_return_source</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a'</span><span> </span><span>Q'</span><span> </span><span>f'</span><span> </span><span>p'</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"n' = src a'"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a'"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knd a' = Q'↩<span class="hidden">⇘</span><sub>p'<span class="hidden">⇙</span></sub>f'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"valid_edge x'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a' = Node (sourcenode x')"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"kind x' = Q'↩<span class="hidden">⇘</span><sub>p'<span class="hidden">⇙</span></sub>f'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"method_exit (sourcenode x')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>method_exit_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹method_exit (sourcenode x)›</span></span></span><span> </span><span>lift_eq</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n = src a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n' = src a'›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹src a = Node (sourcenode x)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src a' = Node (sourcenode x')›</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode x = sourcenode x'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>method_exit_unique</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src a = Node (sourcenode x)›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src a' = Node (sourcenode x')›</span></span></span><span>
</span><span>          </span><span class="cartouche"><span class="delete"><span class="delete">‹n = src a›</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹n' = src a'›</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_SDG</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SDG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"SDG sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit Def Use ParamDefs ParamUses"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inner</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"SDG src trg knd
  (lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit) NewEntry
  (lift_get_proc get_proc Main) 
  (lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind) 
  procs Main NewExit (lift_Def Def Entry Exit H L) (lift_Use Use Entry Exit H L)
  (lift_ParamDefs ParamDefs) (lift_ParamUses ParamUses)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>SDG</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span> </span><span>Def</span><span> </span><span>Use</span><span> </span><span>ParamDefs</span><span> </span><span>ParamUses</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>SDG</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit_wf sourcenode targetnode kind valid_edge Entry get_proc
    get_return_edges procs Main Exit Def Use ParamDefs ParamUses"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>pd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Postdomination sourcenode targetnode kind valid_edge Entry get_proc 
    get_return_edges procs Main Exit"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>wf'</span><span class="delimiter">:</span><span>CFGExit_wf</span><span> </span><span>src</span><span> </span><span>trg</span><span> </span><span>knd</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit"</span></span></span><span> </span><span>NewEntry</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind"</span></span></span><span>
</span><span>    </span><span>procs</span><span> </span><span>Main</span><span> </span><span>NewExit</span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_Def Def Entry Exit H L"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_Use Use Entry Exit H L"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_ParamDefs ParamDefs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_ParamUses ParamUses"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_CFGExit_wf</span><span> </span><span>wf</span><span> </span><span>pd</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>pd'</span><span class="delimiter">:</span><span>Postdomination</span><span> </span><span>src</span><span> </span><span>trg</span><span> </span><span>knd</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit"</span></span></span><span> </span><span>NewEntry</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_proc get_proc Main"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind"</span></span></span><span> 
</span><span>    </span><span>procs</span><span> </span><span>Main</span><span> </span><span>NewExit</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_Postdomination</span><span> </span><span>wf</span><span> </span><span>pd</span><span> </span><span>inner</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Low-deterministic security via the lifted graph›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Lift_NonInterferenceGraph</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>valid_edge</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sourcenode</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>targetnode</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>kind</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Entry</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Exit</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>get_proc</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>get_return_edges</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>procs</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Main</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Def</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Use</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ParamDefs</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ParamUses</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>H</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>L</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">defines</span></span><span> </span><span>lve</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lve ≡ lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lget_proc</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lget_proc ≡ lift_get_proc get_proc Main"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lget_return_edges</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lget_return_edges ≡ 
  lift_get_return_edges get_return_edges valid_edge sourcenode targetnode kind"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lDef</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lDef ≡ lift_Def Def Entry Exit H L"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lUse</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lUse ≡ lift_Use Use Entry Exit H L"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lParamDefs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lParamDefs ≡ lift_ParamDefs ParamDefs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lParamUses</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lParamUses ≡ lift_ParamUses ParamUses"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>SDG</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"SDG sourcenode targetnode kind valid_edge Entry get_proc 
  get_return_edges procs Main Exit Def Use ParamDefs ParamUses"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>inner</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CFGExit.inner_node sourcenode targetnode valid_edge Entry Exit nx"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ∩ L = {}"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ∪ L = UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"NonInterferenceInterGraph src trg knd lve NewEntry lget_proc 
  lget_return_edges procs Main NewExit lDef lUse lParamDefs lParamUses H L 
  (Node Entry) (Node Exit)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>SDG</span><span> </span><span>sourcenode</span><span> </span><span>targetnode</span><span> </span><span>kind</span><span> </span><span>valid_edge</span><span> </span><span>Entry</span><span> </span><span>get_proc</span><span> 
</span><span>    </span><span>get_return_edges</span><span> </span><span>procs</span><span> </span><span>Main</span><span> </span><span>Exit</span><span> </span><span>Def</span><span> </span><span>Use</span><span> </span><span>ParamDefs</span><span> </span><span>ParamUses</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>SDG</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>SDG'</span><span class="delimiter">:</span><span>SDG</span><span> </span><span>src</span><span> </span><span>trg</span><span> </span><span>knd</span><span> </span><span>lve</span><span> </span><span>NewEntry</span><span> </span><span>lget_proc</span><span> </span><span>lget_return_edges</span><span>
</span><span>    </span><span>procs</span><span> </span><span>Main</span><span> </span><span>NewExit</span><span> </span><span>lDef</span><span> </span><span>lUse</span><span> </span><span>lParamDefs</span><span> </span><span>lParamUses</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_SDG</span><span> </span><span>SDG</span><span> </span><span>inner</span><span> </span><span>simp</span><span class="delimiter">:</span><span>lve</span><span> </span><span>lget_proc</span><span> </span><span>lget_return_edges</span><span> </span><span>lDef</span><span>
</span><span>                      </span><span>lUse</span><span> </span><span>lParamDefs</span><span> </span><span>lParamUses</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lve a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = NewEntry"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a = NewExit ∨ trg a = Node Entry"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>simp</span><span class="delimiter">:</span><span>lve</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a. lve a ∧ src a = NewEntry ∧ trg a = Node Entry ∧ knd a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Entry_edge</span><span> </span><span>simp</span><span class="delimiter">:</span><span>lve</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lve a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a = Node Entry"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lve a›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lve</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹trg a = Node Entry›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = NewEntry"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹trg e = Node Entry›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"targetnode a = Entry"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Entry_target</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lve a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a = NewExit"</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = NewEntry ∨ src a = Node Exit"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_valid_edge.cases</span><span> </span><span>simp</span><span class="delimiter">:</span><span>lve</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃a. lve a ∧ src a = Node Exit ∧ trg a = NewExit ∧ knd a = (λs. True)<span class="hidden">⇩</span><sub>√</sub>"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lve_Exit_edge</span><span> </span><span>simp</span><span class="delimiter">:</span><span>lve</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lve a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"src a = Node Exit"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹lve a›</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lift_valid_edge valid_edge sourcenode targetnode kind Entry Exit a"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lve</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹src a = Node Exit›</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"trg a = NewExit"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>lift_valid_edge.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>lve_edge</span><span> </span><span>a</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹e = (Node (sourcenode a), kind a, Node (targetnode a))›</span></span></span><span> 
</span><span>        </span><span class="cartouche"><span class="delete"><span class="delete">‹src e = Node Exit›</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"sourcenode a = Exit"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹valid_edge a›</span></span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>Exit_source</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lDef</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lDef (Node Entry) = H"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_Def_set.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_Def_High</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Entry_noteq_Exit</span><span> </span><span>lUse</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lUse (Node Entry) = H"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_Use_set.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_Use_High</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Entry_noteq_Exit</span><span> </span><span>lUse</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lUse (Node Exit) = L"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>lift_Use_set.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span>lift_Use_Low</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹H ∩ L = {}›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ∩ L = {}"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹H ∪ L = UNIV›</span></span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"H ∪ L = UNIV"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div>