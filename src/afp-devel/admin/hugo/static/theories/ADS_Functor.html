<div id="Merkle_Interface">
<div class="head"><h1>Theory Merkle_Interface</h1>
<span class="command">theory</span> <span class="name">Merkle_Interface</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL-Library/Conditional_Parametricity.html"><span class="name">Conditional_Parametricity</span></a> <a href="../../HOL/HOL-Library/Monad_Syntax.html"><span class="name">Monad_Syntax</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, Digital Asset
   Author: Ognjen Maric, Digital Asset *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Merkle_Interface</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Main</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Conditional_Parametricity"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Monad_Syntax"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">alias</span></span><span> </span><span>vimage2p</span><span> </span><span class="delimiter">=</span><span> </span><span>BNF_Def.vimage2p</span><span>
</span><span class="keyword1"><span class="command">alias</span></span><span> </span><span>Grp</span><span> </span><span class="delimiter">=</span><span> </span><span>BNF_Def.Grp</span><span>
</span><span class="keyword1"><span class="command">alias</span></span><span> </span><span>setl</span><span> </span><span class="delimiter">=</span><span> </span><span>Basic_BNFs.setl</span><span>
</span><span class="keyword1"><span class="command">alias</span></span><span> </span><span>setr</span><span> </span><span class="delimiter">=</span><span> </span><span>Basic_BNFs.setr</span><span>
</span><span class="keyword1"><span class="command">alias</span></span><span> </span><span>fsts</span><span> </span><span class="delimiter">=</span><span> </span><span>Basic_BNFs.fsts</span><span>
</span><span class="keyword1"><span class="command">alias</span></span><span> </span><span>snds</span><span> </span><span class="delimiter">=</span><span> </span><span>Basic_BNFs.snds</span><span>
</span><span>
</span><span class="keyword1"><span class="command">attribute_setup</span></span><span> </span><span>locale_witness</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Scan.succeed Locale.witness_add›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vimage2p_mono'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"R ≤ S ⟹ vimage2p f g R ≤ vimage2p f g S"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span> </span><span>le_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vimage2p_map_rel_prod</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vimage2p (map_prod f g) (map_prod f' g') (rel_prod A B) = rel_prod (vimage2p f f' A) (vimage2p g g' B)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span> </span><span>prod.rel_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vimage2p_map_list_all2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vimage2p (map f) (map g) (list_all2 A) = list_all2 (vimage2p f g A)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span> </span><span>list.rel_map</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equivclp_least</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>le</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"r ≤ s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"equivp s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equivclp r ≤ s"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>predicate2I</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>equivclp_induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>3</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>equivp_reflp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>equivp_transp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>equivp_symp</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>le</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reflp_eq_onp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reflp R ⟷ eq_onp (λx. True) ≤ R"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reflp_def</span><span> </span><span>eq_onp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_onpE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_onp P x y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_onp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>case_unit_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_fun A (rel_fun (=) A) case_unit case_unit"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>unit.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Authenticated Data Structures›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Interface›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Types ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>hash</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span> </span><span class="comment">― ‹Type of hash operation›</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span>blinding_of</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> ⇒ bool"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span>merge</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> option"</span></span></span><span> </span><span class="comment">― ‹ merging that can fail for values with different hashes›</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Properties ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>merkle_interface</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>merge_respects_hashes</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h a = h b ⟷ (∃ab. m a b = Some ab)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>idem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a a = Some a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>commute</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b = m b a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>assoc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b ⤜ m c = m b c ⤜ m a"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bo_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bo a b ⟷ m a b = Some b"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reflp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"reflp bo"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>reflpI</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>idem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>antisymp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"antisymp bo"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisympI</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>commute</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>transp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"transp bo"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>transpI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assoc</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>commute</span><span> </span><span>bo_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bo ≤ vimage2p h h (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bo_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span> </span><span>merge_respects_hashes</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>join</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b = Some ab ⟷ bo a ab ∧ bo b ab ∧ (∀u. bo a u ⟶ bo b u ⟶ bo ab u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>bo_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>smt</span><span> </span><span>Option.bind_cong</span><span> </span><span>bind.bind_lunit</span><span> </span><span>commute</span><span> </span><span>idem</span><span> </span><span>merkle_interface.assoc</span><span> </span><span>merkle_interface_axioms</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The equivalence closure of the blinding relation are the equivalence classes of the hash function (the kernel).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>equivclp_blinding_of</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"equivclp bo = vimage2p h h (=)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs ≤ ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>equivclp_least</span><span class="delimiter">[</span><span>OF</span><span> </span><span>hash</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>equivp_vimage2p</span><span class="delimiter">[</span><span>OF</span><span> </span><span>identity_equivp</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?rhs ≤ ?lhs"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>vimage2p_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>predicate2I</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h x = h y"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xy</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m x y = Some xy"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merge_respects_hashes</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo x xy"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo y xy"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>join</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equivclp bo x xy"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equivclp bo xy y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"equivclp bo x y"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>equivclp_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Auxiliary definitions ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Directly proving that an interface satisfies the specification of a Merkle interface as given
above is difficult. Instead, we provide several layers of auxiliary definitions that can easily be
proved layer-by-layer. 

In particular, proving that an interface on recursive datatypes is a Merkle interface requires
induction. As the induction hypothesis only applies to a subset of values of a type, we add
auxiliary definitions equipped with an explicit set @{term A} of values to which the definition
applies. Once the induction proof is complete, we can typically instantiate @{term A} with @{term
UNIV}. In particular, in the induction proof for a layer, we can assume that properties for the
earlier layers hold for ∗‹all› values, not just those in the induction hypothesis.
›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Blinding ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>blinding_respects_hashes</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>hash</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bo ≤ vimage2p h h (=)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_hash_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bo x y ⟹ h x = h y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>hash</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>blinding_of_on</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>blinding_respects_hashes</span><span> </span><span>h</span><span> </span><span>bo</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span>
</span><span>  </span><span class="delimiter">+</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ A ⟹ bo x x"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ bo x y; bo y z; x ∈ A ⟧ ⟹ bo x z"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>antisym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ bo x y; bo y x; x ∈ A ⟧ ⟹ x = y"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>refl_pointfree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_onp (λx. x ∈ A) ≤ bo"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>eq_onpE</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_respects_hashes</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_respects_hashes h bo"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hash</span><span> </span><span class="delimiter">=</span><span> </span><span>hash</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>trans_pointfree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_onp (λx. x ∈ A) OO bo OO bo ≤ bo"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>eq_onpE</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>antisym_pointfree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inf (eq_onp (λx. x ∈ A) OO bo) bo¯¯ ≤ (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>eq_onpE</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merging ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ In general, we prove the properties of blinding before the properties of merging. Thus,
  in the following definitions we assume that the blinding properties already hold on @{term UNIV}.
  The @{term Ball} restricts the argument of the merge operation on which induction will be done. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>merge_on</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>blinding_of_on</span><span> </span><span>UNIV</span><span> </span><span>h</span><span> </span><span>bo</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> set"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>join</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ h a = h b; a ∈ A ⟧ 
      ⟹ ∃ab. m a b = Some ab ∧ bo a ab ∧ bo b ab ∧ (∀u. bo a u ⟶ bo b u ⟶ bo ab u)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>undefined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ h a ≠ h b; a ∈ A ⟧ ⟹ m a b = None"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ A ⟹ m a a = Some a"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>join</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>refl</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>3</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_antisym_on</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on UNIV h bo"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>transp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"transp bo"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>transpI</span><span> </span><span>trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hash</span><span> </span><span class="delimiter">=</span><span> </span><span>hash</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>refl</span><span> </span><span class="delimiter">=</span><span> </span><span>refl</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>antisym</span><span> </span><span class="delimiter">=</span><span> </span><span>antisym</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>UNIV_I</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>respects_hashes</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a ∈ A ⟹ h a = h b ⟷ (∃ab. m a b = Some ab)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>join</span><span> </span><span>undefined</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>join'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a ∈ A ⟹ ∀ab. m a b = Some ab ⟷ bo a ab ∧ bo b ab ∧ (∀u. bo a u ⟶ bo b u ⟶ bo ab u)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>join</span><span> </span><span>undefined</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>hash</span><span> </span><span>local.antisym</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>option.sel</span><span> </span><span>predicate2D</span><span> </span><span>vimage2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_subset</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"B ⊆ A ⟹ merge_on B h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>same</span><span> </span><span>join</span><span> </span><span>undefined</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Interface equality ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Here, we prove that the auxiliary definitions specify the same interface as the original ones.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface h bo m = merge_on UNIV h bo m"</span></span></span><span> 
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>merkle_interface</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo ≤ vimage2p h h (=)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>hash</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo x x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>reflp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>reflp_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo x z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo y z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>transp</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>transpD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo y x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>antisymp</span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>antisympD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ab. m a b = Some ab ∧ bo a ab ∧ bo b ab ∧ (∀u. bo a u ⟶ bo b u ⟶ bo ab u)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h a = h b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_respects_hashes</span><span> </span><span>join</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h a ≠ h b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_respects_hashes</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>merge_on</span><span> </span><span>UNIV</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>that</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"h a = h b ⟷ (∃ab. m a b = Some ab)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>respects_hashes</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>idem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a a = Some a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>same</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>commute</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b = m b a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>join</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span>join</span><span class="delimiter">[</span><span>of</span><span> </span><span>b</span><span> </span><span>a</span><span class="delimiter">]</span><span> </span><span>undefined</span><span> </span><span>antisym</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b"</span></span></span><span class="delimiter">)</span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>undefined_partitioned</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a c = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b = None"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m b c = Some bc"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>bc</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>option.exhaust</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>merge_twice</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b = Some c ⟹ m a c = Some c"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>join'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b ⤜ m c = m b c ⤜ m a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>Option.bind_split</span><span class="delimiter">;</span><span> </span><span>safe</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"None = m a d"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b = None"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m b c = Some d"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>metis</span><span> </span><span>undefined_partitioned</span><span> </span><span>merge_twice</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m c d = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b = Some d"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m b c = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>d</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>metis</span><span> </span><span>commute</span><span> </span><span>merge_twice</span><span> </span><span>undefined_partitioned</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ab</span><span> </span><span>bc</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a b = Some ab"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m b c = Some bc"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cab</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>abc</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cab</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m c ab = Some cab"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>abc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m a bc = Some abc"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eq</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD2</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>exI</span><span class="delimiter">]</span><span> </span><span>eq</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>iffD1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>merge_twice</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m c ab = m a bc"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>join'</span><span class="delimiter">)</span><span class="delimiter">(</span><span>metis</span><span> </span><span>UNIV_I</span><span> </span><span>abc</span><span> </span><span>cab</span><span> </span><span>local.antisym</span><span> </span><span>local.trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo a b ⟷ m a b = Some b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>idem</span><span> </span><span>join'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_interfaceI</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on UNIV h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>merkle_interface</span><span class="delimiter">)</span><span> </span><span>merkle_interfaceD</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on UNIV h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>of</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span>m</span><span class="delimiter">,</span><span> </span><span>symmetric</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Parametricity rules ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>le_fun_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>le_fun_def</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>vimage2p_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>blinding_respects_hashes_parametric_aux</span><span class="delimiter">:</span><span> </span><span>blinding_respects_hashes_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_respects_hashes_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"((A1 ===&gt; A2) ===&gt; (A1 ===&gt; A1 ===&gt; (⟷)) ===&gt; (⟷))
   blinding_respects_hashes blinding_respects_hashes"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bi_unique A2"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bi_total A1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_respects_hashes_parametric_aux</span><span> </span><span>that</span><span> </span><span>le_fun_parametric</span><span> </span><span class="delimiter">|</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_eq</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>blinding_of_on_axioms_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span>blinding_of_on_axioms_def</span><span class="delimiter">[</span><span>folded</span><span> </span><span>Ball_def</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>le_fun_def</span><span> </span><span>le_bool_def</span><span> </span><span>eq_onp_def</span><span> </span><span>relcompp.simps</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>blinding_of_on_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>blinding_of_on_def</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>antisymp_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>antisymp_def</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>transp_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>transp_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>merge_on_axioms_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merge_on_axioms_def</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>merge_on_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merge_on_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>merkle_interface_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merkle_interface_def</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="ADS_Construction">
<div class="head"><h1>Theory ADS_Construction</h1>
<span class="command">theory</span> <span class="name">ADS_Construction</span><br/>
<span class="keyword">imports</span> <a href="Merkle_Interface.html"><span class="name">Merkle_Interface</span></a> <a href="../../HOL/HOL-Library/Simps_Case_Conv.html"><span class="name">Simps_Case_Conv</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, Digital Asset
   Author: Ognjen Maric, Digital Asset *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>ADS_Construction</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Merkle_Interface</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Simps_Case_Conv"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Building blocks for authenticated data structures on datatypes ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Building Block: Identity Functor ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹If nothing is blindable in a type, then the type itself is the hash and the ADS of itself.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_discrete</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'a) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_discrete ≡ id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_discrete</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_discrete ≡ (=)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>merge_discrete</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_discrete x y = (if x = y then Some y else None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_discrete_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_discrete ≤ vimage2p hash_discrete hash_discrete (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_on_discrete</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on UNIV hash_discrete blinding_of_discrete"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>OO_eq</span><span> </span><span>eq_onp_def</span><span> </span><span>blinding_of_discrete_hash</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_discrete</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_on UNIV hash_discrete blinding_of_discrete merge_discrete"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_discrete_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_discrete</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merkle_interface hash_discrete blinding_of_discrete merge_discrete"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>merge_discrete_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merge_discrete_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Example: instantiation for @{typ unit}›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_unit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, unit) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_unit ≡ hash_discrete"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>blinding_of_unit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_unit ≡ blinding_of_discrete"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>merge_unit</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_unit ≡ merge_discrete"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_unit_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_unit ≤ vimage2p hash_unit hash_unit (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>blinding_of_discrete_hash</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_on_unit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on UNIV hash_unit blinding_of_unit"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>blinding_of_on_discrete</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_unit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_on UNIV hash_unit blinding_of_unit merge_unit"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fact</span><span> </span><span>merge_on_discrete</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_interface_unit</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merkle_interface hash_unit blinding_of_unit merge_unit"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>merkle_interfaceI</span><span> </span><span>merge_on_unit</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Building Block: Blindable Position ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>blindable</span><span> </span><span class="delimiter">=</span><span> </span><span class="tfree">'a</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ The following type represents the hashes of a datatype. We model hashes as being injective,
  but not surjective; some hashes do not correspond to any values of the original datatypes. We
  model such values as "garbage" coming from a countable set (here, naturals). ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>garbage</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>Content</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">|</span><span> </span><span>Garbage</span><span> </span><span>garbage</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>Unblinded</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">|</span><span> </span><span>Blinded</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>h</sub> blindable<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Hashes ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>hash_blindable'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a<span class="hidden">⇩</span><sub>h</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> blindable<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_blindable' (Unblinded x) = Content x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_blindable' (Blinded x) = x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hash_blindable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ (('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> blindable<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_blindable h = hash_blindable' ∘ map_blindable<span class="hidden">⇩</span><sub>m</sub> h id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_blindable_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_blindable h (Unblinded x) = Content (h x)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_blindable h (Blinded y) = y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_blindable_def</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub>.map_id</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_map_blindable_simp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_blindable f (map_blindable<span class="hidden">⇩</span><sub>m</sub> f' id x) = hash_blindable (f o f') x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_blindable_def</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub>.map_comp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>hash_blindable'_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>hash_blindable'_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>hash_blindable_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>hash_blindable_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Blinding ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>blinding_of_blindable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable (Unblinded x) (Unblinded y)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo x y"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable (Blinded x) t"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_blindable h t = x"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_simps</span></span><span> </span><span>blinding_of_blindable_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable (Unblinded x) y"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable (Blinded x) y"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable z (Unblinded x)"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable z (Blinded x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_simps</span></span><span> </span><span>blinding_of_blindable_simps2</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable (Unblinded x) (Unblinded y)"</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable (Unblinded x) (Blinded y')"</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable (Blinded x') (Unblinded y)"</span></span></span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable (Blinded x') (Blinded y')"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_blindable_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo ≤ bo'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable h bo ≤ blinding_of_blindable h bo'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>predicate2I</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>blinding_of_blindable.cases</span><span class="delimiter">;</span><span> </span><span>hypsubst</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_blindable.intros</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>assms</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_blindable.intros</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_blindable_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo ≤ vimage2p h h (=)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable h bo ≤ vimage2p (hash_blindable h) (hash_blindable h) (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>predicate2I</span><span> </span><span>vimage2pI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>blinding_of_blindable.cases</span><span class="delimiter">;</span><span> </span><span>hypsubst</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_on_blindable</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on A h bo"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on {x. set1_blindable<span class="hidden">⇩</span><sub>m</sub> x ⊆ A} (hash_blindable h) (blinding_of_blindable h bo)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on ?A ?h ?bo"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>blinding_of_on</span><span> </span><span>A</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo ≤ vimage2p ?h ?h (=)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_blindable_hash</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>hash</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo y z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_blindable.cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>trans</span><span> </span><span>blinding_hash_eq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo y x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_blindable.cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_blindable</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_on_blindable</span><span class="delimiter">[</span><span>of</span><span> </span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">case_of_simps</span></span><span> </span><span>blinding_of_blindable_alt_def</span><span class="delimiter">:</span><span> </span><span>blinding_of_blindable_simps2</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>blinding_of_blindable_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>blinding_of_blindable_alt_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merging ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>merge_blindable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_blindable (Unblinded x) (Unblinded y) = map_option Unblinded (m x y)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_blindable (Blinded x) (Unblinded y) = (if x = Content (h y) then Some (Unblinded y) else None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_blindable (Unblinded y) (Blinded x) = (if x = Content (h y) then Some (Unblinded y) else None)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_blindable (Blinded t) (Blinded u) = (if t = u then Some (Blinded u) else None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_blindable</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on A h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on {x. set1_blindable<span class="hidden">⇩</span><sub>m</sub> x ⊆ A} (hash_blindable h) (blinding_of_blindable h bo) merge_blindable"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on ?A ?h ?bo ?m"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>merge_on</span><span> </span><span>A</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a = ?h b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>merge_blindable.cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>refl</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>join</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m a b = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a ≠ ?h b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>merge_blindable.cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>undefined</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_blindable</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>merge_on_blindable</span><span class="delimiter">[</span><span>of</span><span> </span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_blindable_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_blindable h m x y = (case (x, y) of
    (Unblinded x, Unblinded y) ⇒ map_option Unblinded (m x y)
  | (Blinded x, Unblinded y) ⇒ (if Content (h y) = x then Some (Unblinded y) else None)
  | (Unblinded y, Blinded x) ⇒ (if Content (h y) = x then Some (Unblinded y) else None)
  | (Blinded t, Blinded u) ⇒ (if t = u then Some (Blinded u) else None))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.split</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub>.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>merge_blindable_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merge_blindable_alt_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_blindable_cong</span><span> </span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. ⟦ a ∈ set1_blindable<span class="hidden">⇩</span><sub>m</sub> x; b ∈ set1_blindable<span class="hidden">⇩</span><sub>m</sub> y ⟧ ⟹ m a b = m' a b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_blindable h m x y = merge_blindable h m' x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_blindable_alt_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.split</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>assms</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"map_option _"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merkle interface ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_blindable</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface (hash_blindable h) (blinding_of_blindable h bo) (merge_blindable h m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>merge_on</span><span> </span><span>UNIV</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merkle_interface_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Non-recursive blindable positions ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ For a non-recursive data type @{typ 'a}, the type of hashes in @{type blindable<span class="hidden">⇩</span><sub>m</sub>} is fixed
to be simply @{typ "'a blindable<span class="hidden">⇩</span><sub>h</sub>"}. We obtain this by instantiating the type variable with the
identity building block. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>nr_blindable</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'a) blindable<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>hash_nr_blindable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a nr_blindable, 'a blindable<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_nr_blindable ≡ hash_blindable hash_discrete"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>blinding_of_nr_blindable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a nr_blindable blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_nr_blindable ≡ blinding_of_blindable hash_discrete blinding_of_discrete"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>merge_nr_blindable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a nr_blindable merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_nr_blindable ≡ merge_blindable hash_discrete merge_discrete"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_nr_blindable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_on UNIV hash_nr_blindable blinding_of_nr_blindable merge_nr_blindable"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_nr_blindable</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merkle_interface hash_nr_blindable blinding_of_nr_blindable merge_nr_blindable"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Building block: Sums ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We prove that we can lift the ADS construction through sums.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>sum<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>h</sub> + 'b<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_notation</span></span><span> </span><span>sum<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"+<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">)</span><span> </span><span>sum<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> + 'b<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹If a functor does not introduce blindable positions, then we don't need the type variable copies.›</span><span>
</span><span class="keyword1"><span class="command">type_notation</span></span><span> </span><span>sum<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"+<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Hashes ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_sum'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>h</sub> +<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> +<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_sum' ≡ id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_sum</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('a<span class="hidden">⇩</span><sub>m</sub> +<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> +<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_sum ≡ map_sum"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Blinding ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_sum</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ 'b<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ ('a<span class="hidden">⇩</span><sub>m</sub> +<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub>) blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_sum ≡ rel_sum"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_sum_mono</span><span> </span><span class="delimiter">=</span><span> </span><span>sum.rel_mono</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_sum_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"boa ≤ vimage2p rha rha (=)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bob ≤ vimage2p rhb rhb (=)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_sum boa bob ≤ vimage2p (hash_sum rha rhb) (hash_sum rha rhb) (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_sum.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_on_sum</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on A rha boa"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on B rhb bob"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on {x. setl x ⊆ A ∧ setr x ⊆ B} (hash_sum rha rhb) (blinding_of_sum boa bob)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on ?A ?h ?bo"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>A</span><span> </span><span>rha</span><span> </span><span>boa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>B</span><span> </span><span>rhb</span><span> </span><span>bob</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>sum.rel_refl_strong</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>a.refl</span><span> </span><span>b.refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo y z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_sum.cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>a.trans</span><span> </span><span>b.trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo y x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_sum.cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>a.antisym</span><span> </span><span>b.antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_sum_hash</span><span> </span><span>a.hash</span><span> </span><span>b.hash</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_sum</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_on_sum</span><span class="delimiter">[</span><span>of</span><span> </span><span>UNIV</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merging ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ma</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>mb</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>merge_sum</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub> +<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub>) merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_sum (Inl x) (Inl y) = map_option Inl (ma x y)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_sum (Inr x) (Inr y) = map_option Inr (mb x y)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_sum _ _ = None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_sum</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on A rha boa ma"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on B rhb bob mb"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on {x. setl x ⊆ A ∧ setr x ⊆ B} (hash_sum rha rhb) (blinding_of_sum boa bob) merge_sum"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on ?A ?h ?bo ?m"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>A</span><span> </span><span>rha</span><span> </span><span>boa</span><span> </span><span>ma</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>B</span><span> </span><span>rhb</span><span> </span><span>bob</span><span> </span><span>mb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a = ?h b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>merge_sum.cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>a.join</span><span> </span><span>b.join</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_sum.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m a b = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a ≠ ?h b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>merge_sum.cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>a.undefined</span><span> </span><span>b.undefined</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_sum</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_on_sum</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_sum_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_sum x y = (case (x, y) of
    (Inl x, Inl y) ⇒ map_option Inl (ma x y)
  | (Inr x, Inr y) ⇒ map_option Inr (mb x y)
  | _ ⇒ None)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>sum.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_sum_cong</span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ x = x'; y = y'; 
    ⋀xl yl. ⟦ x = Inl xl; y = Inl yl ⟧ ⟹ ma xl yl = ma' xl yl;
    ⋀xr yr. ⟦ x = Inr xr; y = Inr yr ⟧ ⟹ mb xr yr = mb' xr yr ⟧ ⟹
    merge_sum ma mb x y = merge_sum ma' mb' x' y'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>simp_all</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>y</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>merge_sum_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merge_sum_alt_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merkle interface ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_sum</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface rha boa ma"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface rhb bob mb"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface (hash_sum rha rhb) (blinding_of_sum boa bob) (merge_sum ma mb)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>UNIV</span><span> </span><span>rha</span><span> </span><span>boa</span><span> </span><span>ma</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>UNIV</span><span> </span><span>rhb</span><span> </span><span>bob</span><span> </span><span>mb</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Building Block: Products›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We prove that we can lift the ADS construction through products.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>prod<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>h</sub> × 'b<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_notation</span></span><span> </span><span>prod<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_ ×<span class="hidden">⇩</span><sub>h</sub>/ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>21</span><span class="delimiter">,</span><span> </span><span>20</span><span class="delimiter">]</span><span> </span><span>20</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">)</span><span> </span><span>prod<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> × 'b<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹If a functor does not introduce blindable positions, then we don't need the type variable copies.›</span><span>
</span><span class="keyword1"><span class="command">type_notation</span></span><span> </span><span>prod<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(_ ×<span class="hidden">⇩</span><sub>m</sub>/ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>21</span><span class="delimiter">,</span><span> </span><span>20</span><span class="delimiter">]</span><span> </span><span>20</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Hashes ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_prod'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_prod' ≡ id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_prod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('a<span class="hidden">⇩</span><sub>m</sub> ×<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_prod ≡ map_prod"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Blinding ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_prod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ 'b<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ ('a<span class="hidden">⇩</span><sub>m</sub> ×<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub>) blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_prod ≡ rel_prod"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_prod_mono</span><span> </span><span class="delimiter">=</span><span> </span><span>prod.rel_mono</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_prod_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"boa ≤ vimage2p rha rha (=)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bob ≤ vimage2p rhb rhb (=)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_prod boa bob ≤ vimage2p (hash_prod rha rhb) (hash_prod rha rhb) (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_on_prod</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on A rha boa"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on B rhb bob"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on {x. fsts x ⊆ A ∧ snds x ⊆ B} (hash_prod rha rhb) (blinding_of_prod boa bob)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on ?A ?h ?bo"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>A</span><span> </span><span>rha</span><span> </span><span>boa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>B</span><span> </span><span>rhb</span><span> </span><span>bob</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>a.refl</span><span> </span><span>b.refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo y z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_prod.cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>a.trans</span><span> </span><span>b.trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo y x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_prod.cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>a.antisym</span><span> </span><span>b.antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_prod_hash</span><span> </span><span>a.hash</span><span> </span><span>b.hash</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_prod</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_on_prod</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merging ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ma</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>mb</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>merge_prod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub> ×<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub>) merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_prod (x, y) (x', y') = Option.bind (ma x x') (λx''. map_option (Pair x'') (mb y y'))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_prod</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on A rha boa ma"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on B rhb bob mb"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on {x. fsts x ⊆ A ∧ snds x ⊆ B} (hash_prod rha rhb) (blinding_of_prod boa bob) merge_prod"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on ?A ?h ?bo ?m"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>A</span><span> </span><span>rha</span><span> </span><span>boa</span><span> </span><span>ma</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>B</span><span> </span><span>rhb</span><span> </span><span>bob</span><span> </span><span>mb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a = ?h b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>merge_prod.cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>a.join</span><span> </span><span>b.join</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m a b = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a ≠ ?h b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b)"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>merge_prod.cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>a.undefined</span><span> </span><span>b.undefined</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_prod</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_on_prod</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_prod_alt_def</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_prod = (λ(x, y) (x', y'). Option.bind (ma x x') (λx''. map_option (Pair x'') (mb y y')))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_prod_cong</span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. ⟦ a ∈ fsts p1; b ∈ fsts p2 ⟧ ⟹ ma a b = ma' a b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. ⟦ a ∈ snds p1; b ∈ snds p2 ⟧ ⟹ mb a b = mb' a b"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_prod ma mb p1 p2 = merge_prod ma' mb' p1 p2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>p1</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>p2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>merge_prod_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merge_prod_alt_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merkle Interface ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_product</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface rha boa ma"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface rhb bob mb"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface (hash_prod rha rhb) (blinding_of_prod boa bob) (merge_prod ma mb)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>UNIV</span><span> </span><span>rha</span><span> </span><span>boa</span><span> </span><span>ma</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>UNIV</span><span> </span><span>rhb</span><span> </span><span>bob</span><span> </span><span>mb</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Building Block: Lists›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The ADS construction on lists is done the easiest through a separate isomorphic datatype
  that has only a single constructor. We hide this construction in a locale. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>list_R1</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>list_F</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit + 'a × 'b"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_base_F<span class="hidden">⇩</span><sub>m</sub> ≡ λx. setr x ⤜ fsts"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_rec_F<span class="hidden">⇩</span><sub>m</sub> ≡ λA. setr A ⤜ snds"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_F ≡ λfb fr. map_sum id (map_prod fb fr)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>list_R1</span><span> </span><span class="delimiter">=</span><span> </span><span>list_R1</span><span> </span><span class="delimiter">(</span><span>unR</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'a list_R1) list_F"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_R1_const_into_dest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_R1 F = l ⟷ F = unR l"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>list_R1.split</span><span class="delimiter">[</span><span>split</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_R1_induct</span><span class="delimiter">[</span><span>case_names</span><span> </span><span>list_R1</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀F. ⟦ ⋀l'. l' ∈ set_rec_F<span class="hidden">⇩</span><sub>m</sub> F  ⟹ P l' ⟧ ⟹ P (list_R1 F)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P l"</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>list_R1.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_list_R1_eq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{x. set_base_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ A ∧ set_rec_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ B} =
   {x. setl x ⊆ UNIV ∧ setr x ⊆ {x. fsts x ⊆ A ∧ snds x ⊆ B}}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_UNION</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ The Isomorphism ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span> </span><span>list_R1_to_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list_R1 ⇒ 'a list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_R1_to_list (list_R1 l) = (case map_sum id (map_prod id list_R1_to_list) l of Inl () ⇒ [] | Inr (x, xs) ⇒ x # xs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_R1_to_list_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_R1_to_list (list_R1 (Inl ())) = []"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_R1_to_list (list_R1 (Inr (x, xs))) = x # list_R1_to_list xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>unit.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>list_R1_to_list.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span> </span><span>list_to_list_R1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'a list_R1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"list_to_list_R1 [] = list_R1 (Inl ())"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_to_list_R1 (x#xs) = list_R1 (Inr (x, list_to_list_R1 xs))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>R1_of_list</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_R1_to_list (list_to_list_R1 x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_of_R1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"list_to_list_R1 (list_R1_to_list x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_R1_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"type_definition list_to_list_R1 list_R1_to_list UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>R1_of_list</span><span> </span><span>list_of_R1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>list_R1_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_list_R1_list_to_list_R1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"map_list_R1 f (list_to_list_R1 xs) = list_to_list_R1 (map f xs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_R1_map_trans</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(((=) ===&gt; (=)) ===&gt; pcr_list (=) ===&gt; pcr_list (=)) map_list_R1 map"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>3</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list.pcr_cr_eq</span><span> </span><span>rel_fun_eq</span><span> </span><span>cr_list_def</span><span> </span><span>map_list_R1_list_to_list_R1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_list_R1_list_to_list_R1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_list_R1 (list_to_list_R1 xs) = set xs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_R1_set_trans</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(pcr_list (=) ===&gt; (=)) set_list_R1 set"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list.pcr_cr_eq</span><span> </span><span>cr_list_def</span><span> </span><span>set_list_R1_list_to_list_R1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rel_list_R1_list_to_list_R1</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"rel_list_R1 R (list_to_list_R1 xs) (list_to_list_R1 ys) ⟷ list_all2 R xs ys"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs ⟷ ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>xs'</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ys'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs' = list_to_list_R1 xs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ys' = list_to_list_R1 ys"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_list_R1 R xs' ys'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"list_all2 R (list_R1_to_list xs') (list_R1_to_list ys')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induction</span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>rel_sum.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs'_def</span><span> </span><span>ys'_def</span><span> </span><span>R1_of_list</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induction</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_R1_rel_trans</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(((=) ===&gt; (=) ===&gt; (=)) ===&gt; pcr_list (=) ===&gt; pcr_list (=) ===&gt; (=)) rel_list_R1 list_all2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>4</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list.pcr_cr_eq</span><span> </span><span>rel_fun_eq</span><span> </span><span>cr_list_def</span><span> </span><span>rel_list_R1_list_to_list_R1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Hashes ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>list_F<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit +<span class="hidden">⇩</span><sub>h</sub> 'a<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">)</span><span> </span><span>list_F<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"unit +<span class="hidden">⇩</span><sub>m</sub> 'a<span class="hidden">⇩</span><sub>m</sub> ×<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>list_R1<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>h</sub> list_R1"</span></span></span><span> 
</span><span>  </span><span class="comment">― ‹In theory, we should define a separate datatype here of the functor @{typ "('a<span class="hidden">⇩</span><sub>h</sub>, _) list_F<span class="hidden">⇩</span><sub>h</sub>"}.
    We take a shortcut because they're isomorphic.›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span>list_R1<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> list_R1"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹In theory, we should define a separate datatype here of the functor @{typ "('a<span class="hidden">⇩</span><sub>m</sub>, _) list_F<span class="hidden">⇩</span><sub>m</sub>"}.
    We take a shortcut because they're isomorphic.›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hash_F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ (('a<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>) list_F<span class="hidden">⇩</span><sub>m</sub>, ('a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) list_F<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_F h rhL = hash_sum hash_unit (hash_prod h rhL)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_R1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('a<span class="hidden">⇩</span><sub>m</sub> list_R1<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> list_R1<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_R1 ≡ map_list_R1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>hash_F_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>hash_F_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Blinding ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>blinding_of_F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ 'b<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>) list_F<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_F bo bL = blinding_of_sum blinding_of_unit (blinding_of_prod bo bL)"</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_R1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a blinding_of ⇒ 'a list_R1 blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_R1 ≡ rel_list_R1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_hash_R1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo ≤ vimage2p h h (=)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_R1 bo ≤ vimage2p (hash_R1 h) (hash_R1 h) (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>predicate2I</span><span> </span><span>vimage2pI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>predicate2D_vimage2p</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>list_R1.rel_induct</span><span> </span><span>rel_sum.cases</span><span> </span><span>rel_prod.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_on_R1</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on A h bo"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on {x. set_list_R1 x ⊆ A} (hash_R1 h) (blinding_of_R1 bo)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on ?A ?h ?bo"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>A</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>hash</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo ≤ vimage2p ?h ?h (=)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a.hash</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_hash_R1</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x x ∧ (?bo x y ⟶ ?bo y z ⟶ ?bo x z) ∧ (?bo x y ⟶ ?bo y x ⟶ x = y)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>list_R1</span><span> </span><span>x</span><span> </span><span>y'</span><span> </span><span>z'</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>list_R1.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_base_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>list_R1.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_rec_F<span class="hidden">⇩</span><sub>m</sub> x ⤜ set_list_R1 ⊆ A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>rev_bexI</span><span class="delimiter">)</span><span>
</span><span>     
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span class="string"><span class="delete"><span class="delete">"{y. set_base_F<span class="hidden">⇩</span><sub>m</sub> y ⊆ A ∧ set_rec_F<span class="hidden">⇩</span><sub>m</sub> y ⊆ set_rec_F<span class="hidden">⇩</span><sub>m</sub> x}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"hash_F h (hash_R1 h)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_F bo (blinding_of_R1 bo)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>hash_F_def</span><span> </span><span>blinding_of_F_def</span><span> </span><span>set_list_R1_eq</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?A'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"setr x ⤜ snds"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?bo'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_list_R1 bo"</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo' x x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>list_R1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_onp_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo' x z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo' x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo' y z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>list_R1.IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>list_R1.prems</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_UNION</span><span> </span><span>prod_set_defs</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo' x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo' y x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span>list_R1.IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>list_R1.prems</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>prod_set_defs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>hash</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list_R1.prems</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>F.refl</span><span class="delimiter">[</span><span>of</span><span> </span><span>x</span><span class="delimiter">]</span><span> </span><span>s1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>blinding_of_F_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>list_R1.rel_intros</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>list_R1.rel_cases</span><span> </span><span>F.trans</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>blinding_of_F_def</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>list_R1.rel_intros</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>list_R1.rel_cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>F.antisym</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>blinding_of_F_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A ⟹ ?bo x x"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ?bo x y; ?bo y z; x ∈ ?A ⟧ ⟹ ?bo x z"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ?bo x y; ?bo y x; x ∈ ?A ⟧ ⟹ x = y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_R1</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_on_R1</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>blinding_of_F_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>blinding_of_F_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merging ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>merge_F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge ⇒ 'b<span class="hidden">⇩</span><sub>m</sub> merge ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>) list_F<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_F m mL = merge_sum merge_unit (merge_prod m mL)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_F_cong</span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. ⟦ a ∈ set_base_F<span class="hidden">⇩</span><sub>m</sub> x; b ∈ set_base_F<span class="hidden">⇩</span><sub>m</sub> y ⟧ ⟹ m a b = m' a b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. ⟦ a ∈ set_rec_F<span class="hidden">⇩</span><sub>m</sub> x; b ∈ set_rec_F<span class="hidden">⇩</span><sub>m</sub> y ⟧ ⟹ mL a b = mL' a b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_F m mL x y = merge_F m' mL' x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_F_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"map_option _"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>merge_prod_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>setr.simps</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>merge_R1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> list_R1<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_R1 (list_R1 l1) (list_R1 l2) = map_option list_R1 (merge_F m merge_R1 l1 l2)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">case_of_simps</span></span><span> </span><span>merge_cases</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merge_R1.simps</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_R1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on A h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on {x. set_list_R1 x ⊆ A } (hash_R1 h) (blinding_of_R1 bo) (merge_R1 m)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on ?A ?h ?bo ?m"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>A</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?h a = ?h b ⟶ (∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u))) ∧
      (?h a ≠ ?h b ⟶ ?m a b = None)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mem_Collect_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>list_R1_induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>wfInd</span><span class="delimiter">:</span><span> </span><span class="delimiter">(</span><span>list_R1</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>merge_on</span><span> </span><span class="string"><span class="delete"><span class="delete">"{y. set_base_F<span class="hidden">⇩</span><sub>m</sub> y ⊆ A ∧ set_rec_F<span class="hidden">⇩</span><sub>m</sub> y ⊆ set_rec_F<span class="hidden">⇩</span><sub>m</sub> l}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"hash_F h ?h"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_F bo ?bo"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_F m ?m"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_list_R1_eq</span><span> </span><span>hash_F_def</span><span> </span><span>merge_F_def</span><span> </span><span>blinding_of_F_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set_rec_F<span class="hidden">⇩</span><sub>m</sub> l"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>wfInd.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set_list_R1 a ⊆ A"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_R1 h a = hash_R1 h b
           ⟹ ∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧
                    (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u)"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a ≠ ?h b ⟹ ?m a b = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>b</span><span>      
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wfInd.IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a</span><span> </span><span>a'</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>b</span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>wfInd.prems</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>strip</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>4</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>join</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>hash_F_def</span><span class="delimiter">]</span><span>
</span><span>              </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinding_of_F_def</span><span> </span><span>UN_subset_iff</span><span> </span><span>list_R1.rel_sel</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>3</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>undefined</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>hash_F_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"?h a = ?h b ⟹ ∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"?h a ≠ ?h b ⟹ ?m a b = None"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_R1</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_on_R1</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_list_R1</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface (hash_R1 h) (blinding_of_R1 bo) (merge_R1 m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>merge_on</span><span> </span><span>UNIV</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>merkle_interface_aux</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_R1_cong</span><span> </span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. ⟦ a ∈ set_list_R1 x; b ∈ set_list_R1 y ⟧ ⟹ m a b = m' a b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_R1 m x y = merge_R1 m' x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>merge_R1.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>merge_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"map_option _"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>merge_F_cong</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>bind_UNION</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>merge_F_parametric</span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merge_F_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_R1_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_cases</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"bi_unique A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((A ===&gt; A ===&gt; rel_option A) ===&gt; rel_list_R1 A ===&gt; rel_list_R1 A ===&gt; rel_option (rel_list_R1 A))
   merge_R1 merge_R1"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_funI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>prems</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>m1</span><span> </span><span>m2</span><span> </span><span>xs1</span><span> </span><span>xs2</span><span> </span><span>ys1</span><span> </span><span>ys2</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span> </span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>xs1</span><span> </span><span>ys1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs2</span><span> </span><span>ys2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>merge_R1.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>list_R1.rel_cases</span><span> </span><span>rel_sum.cases</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.rel_map</span><span> </span><span>merge_F_def</span><span> </span><span>merge_discrete_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>elim</span><span> </span><span>meta_allE</span><span class="delimiter">;</span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>meta_impE</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Transferring the Constructions to Lists ›</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>list<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>h</sub> list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span>list<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>list_R1</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('a<span class="hidden">⇩</span><sub>m</sub> list<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> list<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_list ≡ map"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> list<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_list ≡ list_all2"</span></span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>merge_list</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> list<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>merge_R1</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_list_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀x y. bo x y ⟶ bo' x y ⟧ ⟹ 
  blinding_of_list bo x y ⟶ blinding_of_list bo' x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>list_R1.rel_mono_strong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_list_hash</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_hash_R1</span><span class="delimiter">[</span><span>Transfer.transferred</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>blinding_of_on_list</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_on_R1</span><span class="delimiter">[</span><span>Transfer.transferred</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>blinding_of_list</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_R1</span><span class="delimiter">[</span><span>Transfer.transferred</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>merge_on_list</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_on_R1</span><span class="delimiter">[</span><span>Transfer.transferred</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>merge_list</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_R1</span><span class="delimiter">[</span><span>Transfer.transferred</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>merge_list_cong</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_R1_cong</span><span class="delimiter">[</span><span>Transfer.transferred</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_list_mono_pred</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"R ≤ R' ⟹ blinding_of_list R ≤ blinding_of_list R'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>list_R1.rel_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_list_simp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_list = list_all2"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_list</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface (hash_list h) (blinding_of_list bo) (merge_list m)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>transfer</span><span> </span><span>fixing</span><span class="delimiter">:</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span>m</span><span class="delimiter">)</span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>merge_list_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merge_list_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lifting_update</span></span><span> </span><span>list.lifting</span><span>
</span><span class="keyword1"><span class="command">lifting_forget</span></span><span> </span><span>list.lifting</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Building block: function space›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ We prove that we can lift the ADS construction through functions.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>fun<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_notation</span></span><span> </span><span>fun<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⇒<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span> </span><span>0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">)</span><span> </span><span>fun<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'b<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_notation</span></span><span> </span><span>fun<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⇒<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span>0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Hashes ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Only the range is live, the domain is dead like for BNFs. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_fun'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>h</sub>, 'a ⇒<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_fun' ≡ id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('a ⇒<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub>, 'a ⇒<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_fun ≡ comp"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Blinding ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ ('a ⇒<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub>) blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_fun ≡ rel_fun (=)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_fun_mono</span><span> </span><span class="delimiter">=</span><span> </span><span>fun.rel_mono</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_fun_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo ≤ vimage2p rh rh (=)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_fun bo ≤ vimage2p (hash_fun rh) (hash_fun rh) (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span> </span><span>rel_fun_def</span><span> </span><span>le_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_on_fun</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on A rh bo"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on {x. range x ⊆ A} (hash_fun rh) (blinding_of_fun bo)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on ?A ?h ?bo"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>A</span><span> </span><span>rh</span><span> </span><span>bo</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>a.refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo y z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>4</span><span> </span><span>3</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>a.trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo y x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>rel_fun_def</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>a.antisym</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_fun_hash</span><span> </span><span>a.hash</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_fun</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_on_fun</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merging ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>merge_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub>) merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_fun f g = (if ∀x. m (f x) (g x) ≠ None then Some (λx. the (m (f x) (g x))) else None)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_fun</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on A rh bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on {x. range x ⊆ A} (hash_fun rh) (blinding_of_fun bo) merge_fun"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on ?A ?h ?bo ?m"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>A</span><span> </span><span>rh</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a = ?h b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>fun_cong</span><span class="delimiter">,</span><span> </span><span>unfolded</span><span> </span><span>o_apply</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>a.join</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>that</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>mem_Collect_eq</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>rangeI</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>atomize</span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span>choice_iff</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_fun_def</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m a b = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a ≠ ?h b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_fun_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>a.undefined</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_fun</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_on_fun</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_fun_cong</span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. ⟦ a ∈ range f; b ∈ range g ⟧ ⟹ m a b = m' a b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_fun m f g = merge_fun m' f g"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">[</span><span>OF</span><span> </span><span>rangeI</span><span> </span><span>rangeI</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_none_alt_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Option.is_none x ⟷ (case x of None ⇒ True | Some _ ⇒ False)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Option.is_none_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>is_none_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>is_none_alt_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_fun_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"((A ===&gt; B ===&gt; rel_option C) ===&gt; ((=) ===&gt; A) ===&gt; ((=) ===&gt; B) ===&gt; rel_option ((=) ===&gt; C))
   merge_fun merge_fun"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>rel_funI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'c ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'c ⇒ 'b"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'c ⇒ 'a"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'c ⇒ 'b"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(A ===&gt; B ===&gt; rel_option C) m m'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; A) f f'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; B) g g'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cond</span><span> </span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>Option.is_none_def</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(∀x. ¬ Option.is_none (m (f x) (g x))) ⟷ (∀x. ¬ Option.is_none (m' (f' x) (g' x)))"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; C) (λx. the (m (f x) (g x))) (λx. the (m' (f' x) (g' x)))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. ¬ m (f x) (g x) = None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>fg</span><span> </span><span>fg'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m (f x) (g x) = Some (fg x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"m' (f' x) (g' x) = Some (fg' x)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>*</span><span> </span><span>*</span><span class="delimiter">[</span><span>simplified</span><span> </span><span>cond</span><span class="delimiter">]</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span class="delimiter">(</span><span>subst</span><span> </span><span class="delimiter">(</span><span>asm</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>2</span><span class="delimiter">)</span><span> </span><span>choice_iff</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_option C (Some (fg x)) (Some (fg' x))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>m</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>m'</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer_prover</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>m</span><span> </span><span>m'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"rel_option ((=) ===&gt; C) (merge_fun m f g) (merge_fun m' f' g')"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merge_fun_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merkle Interface ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_fun</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface rh bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface (hash_fun rh) (blinding_of_fun bo) (merge_fun m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>UNIV</span><span> </span><span>rh</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Rose trees›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ 
We now define an ADS over rose trees, which is like a arbitrarily branching Merkle tree where each
node in the tree can be blinded, including the root. The number of children and the position of a
child among its siblings cannot be hidden. The construction allows to plug in further blindable
positions in the labels of the nodes.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>rose_tree_F</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a × 'b list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>map_rose_tree_F</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_rose_tree_F f1 f2 ≡ map_prod f1 (map f2)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>map_rose_tree_F_const</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_rose_tree_F_const f1 f2 ≡ map_rose_tree_F f1 f2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>rose_tree</span><span> </span><span class="delimiter">=</span><span> </span><span>Tree</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'a rose_tree) rose_tree_F"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>rose_tree_F<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub> list<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>rose_tree<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>Tree<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>h</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> rose_tree<span class="hidden">⇩</span><sub>h</sub>) rose_tree_F<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>rose_tree_F<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub> ×<span class="hidden">⇩</span><sub>m</sub> 'b<span class="hidden">⇩</span><sub>m</sub> list<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> 'b<span class="hidden">⇩</span><sub>h</sub> list<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>rose_tree<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> rose_tree<span class="hidden">⇩</span><sub>h</sub>) rose_tree_F<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>map_rose_tree_F<span class="hidden">⇩</span><sub>m</sub></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('ma ⇒ 'a) ⇒ ('mr ⇒ 'r) ⇒ ('ma, 'ha, 'mr, 'hr) rose_tree_F<span class="hidden">⇩</span><sub>m</sub> ⇒ ('a, 'ha, 'r, 'hr) rose_tree_F<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_rose_tree_F<span class="hidden">⇩</span><sub>m</sub> f g ≡ map_blindable<span class="hidden">⇩</span><sub>m</sub> (map_prod f (map g)) id"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Hashes ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_rt_F'</span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a<span class="hidden">⇩</span><sub>h</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) rose_tree_F<span class="hidden">⇩</span><sub>m</sub>, ('a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) rose_tree_F<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_rt_F' ≡ hash_blindable id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ 
    (('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) rose_tree_F<span class="hidden">⇩</span><sub>m</sub>, ('a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) rose_tree_F<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_rt_F<span class="hidden">⇩</span><sub>m</sub> h rhm ≡ hash_rt_F' o map_rose_tree_F<span class="hidden">⇩</span><sub>m</sub> h rhm"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_alt_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_rt_F<span class="hidden">⇩</span><sub>m</sub> h rhm = hash_blindable (map_prod h (map rhm))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>hash_map_blindable_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">)</span><span> </span><span>hash_rt_tree'</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a<span class="hidden">⇩</span><sub>h</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> rose_tree<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_rt_tree' (Tree<span class="hidden">⇩</span><sub>m</sub> x) = Tree<span class="hidden">⇩</span><sub>h</sub> (hash_rt_F' (map_rose_tree_F<span class="hidden">⇩</span><sub>m</sub> id hash_rt_tree' x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>hash_tree</span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ (('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> rose_tree<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_tree h = hash_rt_tree' o map_rose_tree<span class="hidden">⇩</span><sub>m</sub> h id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>_map_compositionality</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"map_blindable<span class="hidden">⇩</span><sub>m</sub> f g o map_blindable<span class="hidden">⇩</span><sub>m</sub> f' g' = map_blindable<span class="hidden">⇩</span><sub>m</sub> (f o f') (g o g')"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_comp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_tree_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_tree h (Tree<span class="hidden">⇩</span><sub>m</sub> x) = Tree<span class="hidden">⇩</span><sub>h</sub> (hash_rt_F<span class="hidden">⇩</span><sub>m</sub> h (hash_tree h) x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_tree_def</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span> 
</span><span>      </span><span>map_prod.comp</span><span> </span><span>map_sum.comp</span><span> </span><span>rose_tree<span class="hidden">⇩</span><sub>h</sub>.map_comp</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_comp</span><span>
</span><span>      </span><span>prod.map_id0</span><span> </span><span>rose_tree<span class="hidden">⇩</span><sub>h</sub>.map_id0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_alt_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>hash_tree_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>hash_tree_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Blinding ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub></span><span>
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ ('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ 'b<span class="hidden">⇩</span><sub>m</sub> blinding_of
      ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) rose_tree_F<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub> ha boa hb bob ≡ blinding_of_blindable (hash_prod ha (map hb))
    (blinding_of_prod boa (blinding_of_list bob))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub>_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ boa ≤ boa'; bob ≤ bob' ⟧ ⟹ blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub> ha boa hb bob ≤ blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub> ha boa' hb bob'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>blinding_of_blindable_mono</span><span> </span><span>prod.rel_mono</span><span> </span><span>list.rel_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub>_mono_inductive</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. boa x y ⟶ boa' x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. bob x y ⟶ bob' x y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub> ha boa hb bob x y ⟶ blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub> ha boa' hb bob' x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub>_mono</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>blinding_of_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree (Tree<span class="hidden">⇩</span><sub>m</sub> t1) (Tree<span class="hidden">⇩</span><sub>m</sub> t2)"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub> h bo (hash_tree h) blinding_of_tree t1 t2"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">monos</span></span><span> </span><span>blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub>_mono_inductive</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_simps</span></span><span> </span><span>blinding_of_tree_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree h bo (Tree<span class="hidden">⇩</span><sub>m</sub> t1) (Tree<span class="hidden">⇩</span><sub>m</sub> t2)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub>_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"boa ≤ vimage2p ha ha (=)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bob ≤ vimage2p hb hb (=)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub> ha boa hb bob ≤ vimage2p (hash_rt_F<span class="hidden">⇩</span><sub>m</sub> ha hb) (hash_rt_F<span class="hidden">⇩</span><sub>m</sub> ha hb) (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_blindable_hash</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>fold</span><span> </span><span>relator_eq</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold</span><span> </span><span>vimage2p_map_rel_prod</span><span> </span><span>vimage2p_map_list_all2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>prod.rel_mono</span><span> </span><span>assms</span><span> </span><span>list.rel_mono</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span> </span><span>vimage2p_comp</span><span> </span><span>o_apply</span><span> </span><span>hash_blindable_def</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_id0</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>vimage2p_id</span><span> </span><span>id_apply</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_tree_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo ≤ vimage2p h h (=)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree h bo ≤ vimage2p (hash_tree h) (hash_tree h) (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>predicate2I</span><span> </span><span>vimage2pI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>blinding_of_tree.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub>_hash</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>predicate2D_vimage2p</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vimage2pI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>set1_rt_F<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>) rose_tree_F<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set1_rt_F<span class="hidden">⇩</span><sub>m</sub> x ≡ set1_blindable<span class="hidden">⇩</span><sub>m</sub> x ⤜ fsts"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>set3_rt_F<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) rose_tree_F<span class="hidden">⇩</span><sub>m</sub> ⇒ 'b<span class="hidden">⇩</span><sub>m</sub> set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"set3_rt_F<span class="hidden">⇩</span><sub>m</sub> x ≡ (set1_blindable<span class="hidden">⇩</span><sub>m</sub> x ⤜ snds) ⤜ set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>set_rt_F<span class="hidden">⇩</span><sub>m</sub>_eq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"{x. set1_rt_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ A ∧ set3_rt_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ B} = 
   {x. set1_blindable<span class="hidden">⇩</span><sub>m</sub> x ⊆ {x. fsts x ⊆ A ∧ snds x ⊆ {x. set x ⊆ B}}}"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_blindable_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_blindable f ∘ map_blindable<span class="hidden">⇩</span><sub>m</sub> g id = hash_blindable (f ∘ g)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_blindable_def</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_comp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_on_tree</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on A h bo"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on {x. set1_rose_tree<span class="hidden">⇩</span><sub>m</sub> x ⊆ A} (hash_tree h) (blinding_of_tree h bo)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on ?A ?h ?bo"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>A</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo ≤ vimage2p ?h ?h (=)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a.hash</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_tree_hash</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x x ∧ (?bo x y ⟶ ?bo y z ⟶ ?bo x z) ∧ (?bo x y ⟶ ?bo y x ⟶ x = y)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Tree<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on (set3_rt_F<span class="hidden">⇩</span><sub>m</sub> x) (hash_tree h) (blinding_of_tree h bo)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_tree_hash</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>a.hash</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub>.IH</span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub>.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_onp_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub>.IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">]</span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub>.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub>.IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">]</span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub>.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>blinding_of_on</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"{a. set1_rt_F<span class="hidden">⇩</span><sub>m</sub> a ⊆ A ∧ set3_rt_F<span class="hidden">⇩</span><sub>m</sub> a ⊆ set3_rt_F<span class="hidden">⇩</span><sub>m</sub> x}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"hash_rt_F<span class="hidden">⇩</span><sub>m</sub> h ?h"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub> h bo ?h ?bo"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_rt_F<span class="hidden">⇩</span><sub>m</sub>_eq</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_alt_def</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub>.prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_tree.intros</span><span> </span><span>refl</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_alt_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_tree.cases</span><span> </span><span>trans</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_alt_def</span><span class="delimiter">]</span><span> 
</span><span>                    </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_tree.intros</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_tree.cases</span><span> </span><span>antisym</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_alt_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A ⟹ ?bo x x"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ?bo x y; ?bo y z; x ∈ ?A ⟧ ⟹ ?bo x z"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ?bo x y; ?bo y x; x ∈ ?A ⟧ ⟹ x = y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_tree</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_on_tree</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_tree_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"bo ≤ bo' ⟹ blinding_of_tree h bo ≤ blinding_of_tree h bo'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>predicate2I</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>blinding_of_tree.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_tree.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub>_mono</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>blast</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merging ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>merge_rt_F<span class="hidden">⇩</span><sub>m</sub></span><span> 
</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> merge ⇒ ('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ 'b<span class="hidden">⇩</span><sub>m</sub> merge ⇒
      ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) rose_tree_F<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_rt_F<span class="hidden">⇩</span><sub>m</sub> ha ma hr mr ≡ merge_blindable (hash_prod ha (hash_list hr)) (merge_prod ma (merge_list mr))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_rt_F<span class="hidden">⇩</span><sub>m</sub>_cong</span><span> </span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. ⟦ a ∈ set1_rt_F<span class="hidden">⇩</span><sub>m</sub> x; b ∈ set1_rt_F<span class="hidden">⇩</span><sub>m</sub> y ⟧ ⟹ ma a b = ma' a b"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. ⟦ a ∈ set3_rt_F<span class="hidden">⇩</span><sub>m</sub> x; b ∈ set3_rt_F<span class="hidden">⇩</span><sub>m</sub> y ⟧ ⟹ mm a b = mm' a b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_rt_F<span class="hidden">⇩</span><sub>m</sub> ha ma hm mm x y = merge_rt_F<span class="hidden">⇩</span><sub>m</sub> ha ma' hm mm' x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>y</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span> </span><span>bind_UNION</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"map_option _"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>merge_prod_cong</span><span> </span><span>merge_list_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>in_set1_blindable<span class="hidden">⇩</span><sub>m</sub>_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ set1_blindable<span class="hidden">⇩</span><sub>m</sub> y ⟷ y = Unblinded x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ma</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span>in_set1_blindable<span class="hidden">⇩</span><sub>m</sub>_iff</span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>merge_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_tree (Tree<span class="hidden">⇩</span><sub>m</sub> x) (Tree<span class="hidden">⇩</span><sub>m</sub> y) = map_option Tree<span class="hidden">⇩</span><sub>m</sub> (
    merge_rt_F<span class="hidden">⇩</span><sub>m</sub> h ma (hash_tree h) merge_tree x y)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_tree</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on A h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on {x. set1_rose_tree<span class="hidden">⇩</span><sub>m</sub> x ⊆ A} (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on ?A ?h ?bo ?m"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>A</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?h a = ?h b ⟶ (∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u))) ∧
      (?h a ≠ ?h b ⟶ ?m a b = None)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mem_Collect_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>b</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rose_tree<span class="hidden">⇩</span><sub>m</sub>.induct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Tree<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>merge_on</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"{y. set1_rt_F<span class="hidden">⇩</span><sub>m</sub> y ⊆ A ∧ set3_rt_F<span class="hidden">⇩</span><sub>m</sub> y ⊆ set3_rt_F<span class="hidden">⇩</span><sub>m</sub> x}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"hash_rt_F<span class="hidden">⇩</span><sub>m</sub> h ?h"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"blinding_of_rt_F<span class="hidden">⇩</span><sub>m</sub> h bo ?h ?bo"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"merge_rt_F<span class="hidden">⇩</span><sub>m</sub> h m ?h ?m"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>set_rt_F<span class="hidden">⇩</span><sub>m</sub>_eq</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_alt_def</span><span> </span><span>merge_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set3_rt_F<span class="hidden">⇩</span><sub>m</sub> x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub>.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set1_rose_tree<span class="hidden">⇩</span><sub>m</sub> a ⊆ A"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_UNION</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ab</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ab ∈ set1_blindable<span class="hidden">⇩</span><sub>m</sub> x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"l ∈ snds ab"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set l"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_UNION</span><span class="delimiter">)</span><span>
</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub>.IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a''</span><span> </span><span>a'</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>b</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_tree h a = hash_tree h b
           ⟹ ∃ab. merge_tree h m a b = Some ab ∧ blinding_of_tree h bo a ab ∧ blinding_of_tree h bo b ab ∧
                    (∀u. blinding_of_tree h bo a u ⟶ blinding_of_tree h bo b u ⟶ blinding_of_tree h bo ab u)"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_tree h a ≠ hash_tree h b ⟹ merge_tree h m a b = None"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Tree<span class="hidden">⇩</span><sub>m</sub>.prems</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>strip</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>y</span><span class="delimiter">)</span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>join</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinding_of_tree.simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>y</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>undefined</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"?h a = ?h b ⟹ ∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"?h a ≠ ?h b ⟹ ?m a b = None"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_tree</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_on_tree</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>option_bind_comm</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"((x :: 'a option) ⤜ (λy. c ⤜ (λz. f y z))) = (c ⤜ (λy. x ⤜ (λz. f z y)))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>c</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">parametric_constant</span></span><span> </span><span>merge_rt_F<span class="hidden">⇩</span><sub>m</sub>_parametric</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span>merge_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span> 
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Merkle interface›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_tree</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface h bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface (hash_tree h) (blinding_of_tree h bo) (merge_tree h m)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>merge_on</span><span> </span><span>UNIV</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>merkle_interface_aux</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_tree_cong</span><span> </span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. ⟦ a ∈ set1_rose_tree<span class="hidden">⇩</span><sub>m</sub> x; b ∈ set1_rose_tree<span class="hidden">⇩</span><sub>m</sub> y ⟧ ⟹ m a b = m' a b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_tree h m x y = merge_tree h m' x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>merge_tree.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_UNION</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"map_option _"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>merge_rt_F<span class="hidden">⇩</span><sub>m</sub>_cong</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_UNION</span><span class="delimiter">;</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Generic_ADS_Construction">
<div class="head"><h1>Theory Generic_ADS_Construction</h1>
<span class="command">theory</span> <span class="name">Generic_ADS_Construction</span><br/>
<span class="keyword">imports</span> <a href="Merkle_Interface.html"><span class="name">Merkle_Interface</span></a> <a href="../../HOL/HOL-Library/BNF_Axiomatization.html"><span class="name">BNF_Axiomatization</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, Digital Asset
   Author: Ognjen Maric, Digital Asset *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Generic_ADS_Construction</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Merkle_Interface"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.BNF_Axiomatization"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Generic construction of authenticated data structures›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Functors›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Source functor›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹

We want to allow ADSs of arbitrary ADTs, which we call "source trees". The ADTs we are interested in can
in general be represented as the least fixpoints of some bounded natural (bi-)functor (BNF) ‹('a, 'b) F›, where
@{typ 'a} is the type of "source" data, and @{typ 'b} is a recursion "handle".
However, Isabelle's type system does not support higher kinds, necessary to parameterize our definitions
over functors.
Instead, we first develop a general theory of ADSs over an arbitrary, but fixed functor,
and its least fixpoint. We show that the theory is compositional, in that the functor's least fixed point
can then be reused as the "source" data of another functor.

We start by defining the arbitrary fixed functor, its fixpoints, and showing how composition can be
done. A higher-level explanation is found in the paper.
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">bnf_axiomatization</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>F</span><span> </span><span class="delimiter">[</span><span>wits</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('a, 'b) F"</span></span></span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>typedef_overloaded</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a</span><span> </span><span>T</span><span> </span><span class="delimiter">=</span><span> </span><span>T</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'a T) F"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Base Merkle functor›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This type captures the ADS hashes.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">bnf_axiomatization</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>F<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">[</span><span>wits</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ ('a, 'b) F<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
It intuitively contains mixed garbage and source values.
The functor's recursive handle @{typ 'b} might contain partial garbage.
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
This type captures the ADS inclusion proofs.
The functor ‹('a, 'a', 'b, 'b') F<span class="hidden">⇩</span><sub>m</sub>› has all type variables doubled.
This type represents all values including the information which parts are blinded.
The original type variable @{typ 'a} now represents the source data, which for compositionality can contain blindable positions.
The type @{typ 'b} is a recursive handle to inclusion sub-proofs (which can be partialy blinded). 
The type @{typ 'a'} represent "hashes" of the source data in @{typ 'a}, i.e., a mix of source values and garbage.
The type @{typ 'b'} is a recursive handle to ADS hashes of subtrees.

The corresponding type of recursive authenticated trees is then a fixpoint of this functor.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">bnf_axiomatization</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>F<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">[</span><span>wits</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>h</sub> ⇒ 'b<span class="hidden">⇩</span><sub>h</sub> ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Least fixpoint›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>typedef_overloaded</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span>T<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>T<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>h</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> T<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>typedef_overloaded</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">(</span><span>the_T<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) T<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> T<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Composition ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Finally, we show how to compose two Merkle functors.
For simplicity, we reuse @{typ ‹('a, 'b) F›} and @{typ ‹'a T›}.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">notes</span></span><span> </span><span class="delimiter">[</span><span class="delimiter">[</span><span>typedef_overloaded</span><span class="delimiter">]</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a</span><span class="delimiter">,</span><span> </span><span class="tfree">'b</span><span class="delimiter">)</span><span> </span><span>G</span><span> </span><span class="delimiter">=</span><span> </span><span>G</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a T, 'b) F"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>G<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>G<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">(</span><span>the_G<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>h</sub> T<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>G<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>G<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">(</span><span>the_G<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) T<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> T<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Root hash›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Base functor›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The root hash of an authenticated value is modelled as a blindable value of type @{typ "('a', 'b') F<span class="hidden">⇩</span><sub>h</sub>"}.
(Actually, we want to use an abstract datatype for root hashes, but we omit this distinction here for simplicity.)
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>root_hash_F'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a<span class="hidden">⇩</span><sub>h</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>m</sub>, ('a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹Root hash operation where we assume that all atoms have already been replaced by root hashes.
     This assumption is reflected in the equality of the type parameters of @{type F<span class="hidden">⇩</span><sub>m</sub>} ›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>hash_F</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ (('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>m</sub>, ('a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>root_hash_F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash_F"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"root_hash_F rha rhb = root_hash_F' ∘ map_F<span class="hidden">⇩</span><sub>m</sub> rha id rhb id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Least fixpoint›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>root_hash_T'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a<span class="hidden">⇩</span><sub>h</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) T<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> T<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"root_hash_T' (T<span class="hidden">⇩</span><sub>m</sub> x) = T<span class="hidden">⇩</span><sub>h</sub> (root_hash_F' (map_F<span class="hidden">⇩</span><sub>m</sub> id id root_hash_T' id x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>root_hash_T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ (('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) T<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub> T<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"root_hash_T rha = root_hash_T' ∘ map_T<span class="hidden">⇩</span><sub>m</sub> rha id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>root_hash_T_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"root_hash_T rha (T<span class="hidden">⇩</span><sub>m</sub> x) = T<span class="hidden">⇩</span><sub>h</sub> (root_hash_F rha (root_hash_T rha) x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>root_hash_T_def</span><span> </span><span>F<span class="hidden">⇩</span><sub>m</sub>.map_comp</span><span> </span><span>root_hash_F_def</span><span> </span><span>T<span class="hidden">⇩</span><sub>h</sub>.map_id0</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Composition›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>root_hash_G'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(('a<span class="hidden">⇩</span><sub>h</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) G<span class="hidden">⇩</span><sub>m</sub>, ('a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) G<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"root_hash_G' (G<span class="hidden">⇩</span><sub>m</sub> x) = G<span class="hidden">⇩</span><sub>h</sub> (root_hash_F' (map_F<span class="hidden">⇩</span><sub>m</sub> root_hash_T' id id id x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>root_hash_G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ ('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ (('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) G<span class="hidden">⇩</span><sub>m</sub>, ('a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) G<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"root_hash_G rha rhb = root_hash_G' ∘ map_G<span class="hidden">⇩</span><sub>m</sub> rha id rhb id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>root_hash_G_unfold</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"root_hash_G rha rhb = G<span class="hidden">⇩</span><sub>h</sub> ∘ root_hash_F (root_hash_T rha) rhb ∘ the_G<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>root_hash_G_def</span><span> </span><span>fun_eq_iff</span><span> </span><span>root_hash_F_def</span><span> </span><span>root_hash_T_def</span><span> </span><span>F<span class="hidden">⇩</span><sub>m</sub>.map_comp</span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.map_comp</span><span> </span><span>o_def</span><span> </span><span>T<span class="hidden">⇩</span><sub>h</sub>.map_id</span><span> </span><span>id_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>root_hash_G_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"root_hash_G rha rhb (G<span class="hidden">⇩</span><sub>m</sub> x) = G<span class="hidden">⇩</span><sub>h</sub> (root_hash_F (root_hash_T rha) rhb x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>root_hash_G_def</span><span> </span><span>root_hash_T_def</span><span> </span><span>F<span class="hidden">⇩</span><sub>m</sub>.map_comp</span><span> </span><span>root_hash_F_def</span><span> </span><span>T<span class="hidden">⇩</span><sub>h</sub>.map_id0</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Blinding relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The blinding relation determines whether one ADS value is a blinding of another.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Blinding on the base functor (@{type F<span class="hidden">⇩</span><sub>m</sub>}) ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'b<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>blinding_of_F</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ ('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ 'b<span class="hidden">⇩</span><sub>m</sub> blinding_of ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span>
</span><span>
</span><span class="comment">― ‹ Computes whether a partially blinded ADS is a blinding of another one ›</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span> </span><span>blinding_of_F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) blinding_of_F"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>blinding_of_F_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ boa ≤ boa'; bob ≤ bob' ⟧
    ⟹ blinding_of_F rha boa rhb bob ≤ blinding_of_F rha boa' rhb bob'"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹ Monotonicity must be unconditional (without the assumption @{text "blinding_of_on"}) 
         such that we can justify the recursive definition for the least fixpoint. ›</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>blinding_respects_hashes_F</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ blinding_respects_hashes rha boa; blinding_respects_hashes rhb bob ⟧
   ⟹ blinding_respects_hashes (root_hash_F rha rhb) (blinding_of_F rha boa rhb bob)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>blinding_of_on_F</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ blinding_of_on A rha boa; blinding_of_on B rhb bob ⟧
   ⟹ blinding_of_on {x. set1_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ A ∧ set3_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ B} (root_hash_F rha rhb) (blinding_of_F rha boa rhb bob)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_F_mono_inductive</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. boa x y ⟶ boa' x y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. bob x y ⟶ bob' x y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_F rha boa rhb bob x y ⟶ blinding_of_F rha boa' rhb bob' x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>blinding_of_F_mono</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>predicate2I</span><span> </span><span>predicate2I</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Blinding on least fixpoints ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>rh</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bo</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>blinding_of_T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) T<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_T (T<span class="hidden">⇩</span><sub>m</sub> x) (T<span class="hidden">⇩</span><sub>m</sub> y)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_F rh bo (root_hash_T rh) blinding_of_T x y"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">monos</span></span><span> </span><span>blinding_of_F_mono_inductive</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_T_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo ≤ bo'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_T rh bo ≤ blinding_of_T rh bo'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>predicate2I</span><span class="delimiter">;</span><span> </span><span>erule</span><span> </span><span>blinding_of_T.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>blinding_of_T.intros</span><span> </span><span>blinding_of_F_mono</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>assms</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_T_root_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo ≤ vimage2p rh rh (=)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_T rh bo ≤ vimage2p (root_hash_T rh) (root_hash_T rh) (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>predicate2I</span><span> </span><span>vimage2pI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>blinding_of_T.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>blinding_respects_hashes_F</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>blinding_respects_hashes_def</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">,</span><span> </span><span>rotated</span><span> </span><span>-</span><span>1</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vimage2pI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_respects_hashes_T</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_respects_hashes rh bo ⟹ blinding_respects_hashes (root_hash_T rh) (blinding_of_T rh bo)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>blinding_respects_hashes_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_T_root_hash</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_on_T</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on A rh bo"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on {x. set1_T<span class="hidden">⇩</span><sub>m</sub> x ⊆ A} (root_hash_T rh) (blinding_of_T rh bo)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on ?A ?h ?bo"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>A</span><span> </span><span>rh</span><span> </span><span>bo</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x x ∧ (?bo x y ⟶ ?bo y z ⟶ ?bo x z) ∧ (?bo x y ⟶ ?bo y x ⟶ x = y)"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>y</span><span> </span><span>z</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>T<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>blinding_of_on</span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"{a. set1_F<span class="hidden">⇩</span><sub>m</sub> a ⊆ A ∧ set3_F<span class="hidden">⇩</span><sub>m</sub> a ⊆ set3_F<span class="hidden">⇩</span><sub>m</sub> x}"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"root_hash_F rh ?h"</span></span></span><span> 
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"blinding_of_F rh bo ?h ?bo"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_on_F</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>unfold_locales</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.IH</span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_onp_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.IH</span><span class="delimiter">[</span><span>of</span><span> </span><span>a</span><span> </span><span>b</span><span class="delimiter">]</span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.prems</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>blinding_of_T.intros</span><span> </span><span>refl</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_T.cases</span><span> </span><span>trans</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_T.intros</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_T.cases</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>antisym</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A ⟹ ?bo x x"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ?bo x y; ?bo y z; x ∈ ?A ⟧ ⟹ ?bo x z"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ?bo x y; ?bo y x; x ∈ ?A ⟧ ⟹ x = y"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_T</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_on_T</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Blinding on composition ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>rha</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>boa</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>rhb</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>bob</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> </span><span>blinding_of_G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) G<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_G (G<span class="hidden">⇩</span><sub>m</sub> x) (G<span class="hidden">⇩</span><sub>m</sub> y)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_F (root_hash_T rha) (blinding_of_T rha boa) rhb bob x y"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_G_unfold</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_G = vimage2p the_G<span class="hidden">⇩</span><sub>m</sub> the_G<span class="hidden">⇩</span><sub>m</sub> (blinding_of_F (root_hash_T rha) (blinding_of_T rha boa) rhb bob)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>y</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinding_of_G.simps</span><span> </span><span>fun_eq_iff</span><span> </span><span>vimage2p_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_G_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"boa ≤ boa'"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bob ≤ bob'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_G rha boa rhb bob ≤ blinding_of_G rha boa' rhb bob'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>blinding_of_G_unfold</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>vimage2p_mono'</span><span> </span><span>blinding_of_F_mono</span><span> </span><span>blinding_of_T_mono</span><span> </span><span>assms</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_G_root_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"boa ≤ vimage2p rha rha (=)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bob ≤ vimage2p rhb rhb (=)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_G rha boa rhb bob ≤ vimage2p (root_hash_G rha rhb) (root_hash_G rha rhb) (=)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>blinding_of_G_unfold</span><span> </span><span>root_hash_G_unfold</span><span> </span><span>vimage2p_comp</span><span> </span><span>o_apply</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>vimage2p_mono'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>order_trans</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_respects_hashes_F</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>blinding_respects_hashes_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_T_root_hash</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>assms</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>vimage2p_mono'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_on_G</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on A rha boa"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on B rhb bob"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on {x. set1_G<span class="hidden">⇩</span><sub>m</sub> x ⊆ A ∧ set3_G<span class="hidden">⇩</span><sub>m</sub> x ⊆ B} (root_hash_G rha rhb) (blinding_of_G rha boa rhb bob)"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on ?A ?h ?bo"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>A</span><span> </span><span>rha</span><span> </span><span>boa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>B</span><span> </span><span>rhb</span><span> </span><span>bob</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>FT</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"{x. set1_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ {x. set1_T<span class="hidden">⇩</span><sub>m</sub> x ⊆ A} ∧ set3_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ B}"</span></span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"root_hash_F (root_hash_T rha) rhb"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"blinding_of_F (root_hash_T rha) (blinding_of_T rha boa) rhb bob"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo ≤ vimage2p ?h ?h (=)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a.hash</span><span> </span><span>b.hash</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_G_root_hash</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>hypsubst</span><span class="delimiter">)</span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_G.intros</span><span class="delimiter">;</span><span> </span><span>rule</span><span> </span><span>FT.refl</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x z"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo y z"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>z</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_G.cases</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_G.intros</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>FT.trans</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo x y"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?bo y x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>blinding_of_G.cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>FT.antisym</span><span class="delimiter">;</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_G</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_on_G</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Merging›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Two Merkle values with the same root hash can be merged into a less blinded Merkle value.
The operation is unspecified for trees with different root hashes.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merging on the base functor ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span> </span><span>merge_F</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> merge ⇒ ('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash ⇒ 'b<span class="hidden">⇩</span><sub>m</sub> merge 
  ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) F<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>merge_F_cong</span><span> </span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀a b. a ∈ set1_F<span class="hidden">⇩</span><sub>m</sub> x ⟹ ma a b = ma' a b; ⋀a b. a ∈ set3_F<span class="hidden">⇩</span><sub>m</sub> x ⟹ mb a b = mb' a b ⟧
   ⟹ merge_F rha ma rhb mb x y = merge_F rha ma' rhb mb' x y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>  </span><span>merge_on_F</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ merge_on A rha boa ma; merge_on B rhb bob mb ⟧
  ⟹ merge_on {x. set1_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ A ∧ set3_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ B} (root_hash_F rha rhb) (blinding_of_F rha boa rhb bob) (merge_F rha ma rhb mb)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_F</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_on_F</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merging on the least fixpoint ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wfP_subterm_T</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"wfP (λx y. x ∈ set3_F<span class="hidden">⇩</span><sub>m</sub> (the_T<span class="hidden">⇩</span><sub>m</sub> y))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>wfPUNIVI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword2"><span class="keyword">premises</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span> </span><span>x</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>IH</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>rh</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>m</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">function</span></span><span> </span><span>merge_T</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) T<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_T (T<span class="hidden">⇩</span><sub>m</sub> x) (T<span class="hidden">⇩</span><sub>m</sub> y) = map_option T<span class="hidden">⇩</span><sub>m</sub> (merge_F rh m (root_hash_T rh) merge_T x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>pat_completeness</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">termination</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>relation</span><span> </span><span class="string"><span class="delete"><span class="delete">"{(x, y). x ∈ set3_F<span class="hidden">⇩</span><sub>m</sub> (the_T<span class="hidden">⇩</span><sub>m</sub> y)} &lt;*lex*&gt; {(x, y). x ∈ set3_F<span class="hidden">⇩</span><sub>m</sub> (the_T<span class="hidden">⇩</span><sub>m</sub> y)}"</span></span></span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>wfP_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span> </span><span>wfP_subterm_T</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_T</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on A rh bo m"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on {x. set1_T<span class="hidden">⇩</span><sub>m</sub> x ⊆ A} (root_hash_T rh) (blinding_of_T rh bo) merge_T"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on ?A ?h ?bo ?m"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>A</span><span> </span><span>rh</span><span> </span><span>bo</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?h a = ?h b ⟶ (∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u))) ∧
      (?h a ≠ ?h b ⟶ ?m a b = None)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>mem_Collect_eq</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>a</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>T<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span>x</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>merge_on</span><span> </span><span class="string"><span class="delete"><span class="delete">"{y. set1_F<span class="hidden">⇩</span><sub>m</sub> y ⊆ A ∧ set3_F<span class="hidden">⇩</span><sub>m</sub> y ⊆ set3_F<span class="hidden">⇩</span><sub>m</sub> x}"</span></span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">"root_hash_F rh ?h"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_F rh bo ?h ?bo"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_F rh m ?h ?m"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>a</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ set3_F<span class="hidden">⇩</span><sub>m</sub> x"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.prems</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"set1_T<span class="hidden">⇩</span><sub>m</sub> a ⊆ A"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>b</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a</span><span> </span><span>a'</span><span class="delimiter">,</span><span> </span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>b</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"root_hash_T rh a = root_hash_T rh b
           ⟹ ∃ab. merge_T a b = Some ab ∧ blinding_of_T rh bo a ab ∧ blinding_of_T rh bo b ab ∧
                    (∀u. blinding_of_T rh bo a u ⟶ blinding_of_T rh bo b u ⟶ blinding_of_T rh bo ab u)"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"root_hash_T rh a ≠ root_hash_T rh b ⟹ merge_T a b = None"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>T<span class="hidden">⇩</span><sub>m</sub>.prems</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>conjI</span><span> </span><span>strip</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>y</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>join</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinding_of_T.simps</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>y</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>undefined</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"?h a = ?h b ⟹ ∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u)"</span></span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"?h a ≠ ?h b ⟹ ?m a b = None"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_T</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_on_T</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_T_cong</span><span> </span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀a b. a ∈ set1_T<span class="hidden">⇩</span><sub>m</sub> x ⟹ m a b = m' a b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_T rh m x y = merge_T rh m' x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span> </span><span>y</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>merge_T.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"map_option _"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>merge_F_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Merging and composition ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>rha</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>ma</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>rhb</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>mb</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>merge_G</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>, 'b<span class="hidden">⇩</span><sub>m</sub>, 'b<span class="hidden">⇩</span><sub>h</sub>) G<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_G (G<span class="hidden">⇩</span><sub>m</sub> x) y' = (case y' of G<span class="hidden">⇩</span><sub>m</sub> y ⇒
    map_option G<span class="hidden">⇩</span><sub>m</sub> (merge_F (root_hash_T rha) (merge_T rha ma) rhb mb x y))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_G_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_G (G<span class="hidden">⇩</span><sub>m</sub> x) (G<span class="hidden">⇩</span><sub>m</sub> y) = map_option G<span class="hidden">⇩</span><sub>m</sub> (merge_F (root_hash_T rha) (merge_T rha ma) rhb mb x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>merge_G.simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_on_G</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on A rha boa ma"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on B rhb bob mb"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on {x. set1_G<span class="hidden">⇩</span><sub>m</sub> x ⊆ A ∧ set3_G<span class="hidden">⇩</span><sub>m</sub> x ⊆ B} (root_hash_G rha rhb) (blinding_of_G rha boa rhb bob) merge_G"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"merge_on ?A ?h ?bo ?m"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>A</span><span> </span><span>rha</span><span> </span><span>boa</span><span> </span><span>ma</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>b</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> </span><span>B</span><span> </span><span>rhb</span><span> </span><span>bob</span><span> </span><span>mb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>F</span><span class="delimiter">:</span><span> </span><span>merge_on</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"{x. set1_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ {x. set1_T<span class="hidden">⇩</span><sub>m</sub> x ⊆ A} ∧ set3_F<span class="hidden">⇩</span><sub>m</sub> x ⊆ B}"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"root_hash_F (root_hash_T rha) rhb"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"blinding_of_F (root_hash_T rha) (blinding_of_T rha boa) rhb bob"</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"merge_F (root_hash_T rha) (merge_T rha ma) rhb mb"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ab. ?m a b = Some ab ∧ ?bo a ab ∧ ?bo b ab ∧ (∀u. ?bo a u ⟶ ?bo b u ⟶ ?bo ab u)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a = ?h b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F.join</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blinding_of_G.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?m a b = None"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?h a ≠ ?h b"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ ?A"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>a</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>F.undefined</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_G</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_on_G</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>A</span><span class="delimiter">=</span><span>UNIV</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>B</span><span class="delimiter">=</span><span>UNIV</span><span class="delimiter">,</span><span> </span><span>simplified</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_G_cong</span><span> </span><span class="delimiter">[</span><span>fundef_cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀a b. a ∈ set1_G<span class="hidden">⇩</span><sub>m</sub> x ⟹ ma a b = ma' a b; ⋀a b. a ∈ set3_G<span class="hidden">⇩</span><sub>m</sub> x ⟹ mb a b = mb' a b ⟧
   ⟹ merge_G rha ma rhb mb x y = merge_G rha ma' rhb mb' x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span>y</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>arg_cong</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"map_option _"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>merge_F_cong</span><span> </span><span>merge_T_cong</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Inclusion_Proof_Construction">
<div class="head"><h1>Theory Inclusion_Proof_Construction</h1>
<span class="command">theory</span> <span class="name">Inclusion_Proof_Construction</span><br/>
<span class="keyword">imports</span> <a href="ADS_Construction.html"><span class="name">ADS_Construction</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Author: Andreas Lochbihler, Digital Asset
   Author: Ognjen Maric, Digital Asset *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Inclusion_Proof_Construction</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>ADS_Construction</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>blind_blindable</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>h</sub>) ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>m</sub> ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blind_blindable h (Blinded x) = Blinded x"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"blind_blindable h (Unblinded x) = Blinded (Content (h x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_blind_blindable</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_blindable h (blind_blindable h x) = hash_blindable h x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inclusion proof construction for rose trees›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Hashing, embedding and blinding source trees ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>hash_source_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rose_tree ⇒ 'a<span class="hidden">⇩</span><sub>h</sub> rose_tree<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_source_tree (Tree (data, subtrees)) = Tree<span class="hidden">⇩</span><sub>h</sub> (Content (h data, map hash_source_tree subtrees))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>e</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>embed_source_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rose_tree ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"embed_source_tree (Tree (data, subtrees)) =
    Tree<span class="hidden">⇩</span><sub>m</sub> (Unblinded (e data, map embed_source_tree subtrees))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>blind_source_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rose_tree ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blind_source_tree (Tree (data, subtrees)) = Tree<span class="hidden">⇩</span><sub>m</sub> (Blinded (Content (h data, map (hash_source_tree h) subtrees)))"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">case_of_simps</span></span><span> </span><span>blind_source_tree_cases</span><span class="delimiter">:</span><span> </span><span>blind_source_tree.simps</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>is_blinded</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub> ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_blinded (Tree<span class="hidden">⇩</span><sub>m</sub> (Blinded _)) = True"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"is_blinded _ = False"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_blinded_simp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_tree h' (blind_source_tree h st) = hash_source_tree h st"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>st</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>blind_source_tree.cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_embedded_simp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_tree h (embed_source_tree e st) = hash_source_tree (h ∘ e) st"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>st</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>embed_source_tree.induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinded_embedded_same_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_tree h'' (blind_source_tree (h o e) st) = hash_tree h (embed_source_tree e st)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_blinded_simp</span><span> </span><span>hash_embedded_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_blinds</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"is_blinded (blind_source_tree h t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blind_source_tree_cases</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>rose_tree.split</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinded_blinds_embedded</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree h bo (blind_source_tree (h o e) st) (embed_source_tree e st)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>st</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>blind_source_tree.cases</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_embedded_simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>embed_hash_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'ha rose_tree<span class="hidden">⇩</span><sub>h</sub> ⇒ ('a, 'ha) rose_tree<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"embed_hash_tree (Tree<span class="hidden">⇩</span><sub>h</sub> h) = Tree<span class="hidden">⇩</span><sub>m</sub> (Blinded h)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Auxiliary definitions: selectors and list splits›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>children</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rose_tree ⇒ 'a rose_tree list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"children (Tree (data, subtrees)) = subtrees"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>children<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub> ⇒ ('a, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub> list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"children<span class="hidden">⇩</span><sub>m</sub> (Tree<span class="hidden">⇩</span><sub>m</sub> (Unblinded (data, subtrees))) = subtrees"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"children<span class="hidden">⇩</span><sub>m</sub> _ = undefined"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>splits</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ ('a list × 'a × 'a list) list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"splits [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"splits (x#xs) = ([], x, xs) # map (λ(l, y, r). (x # l, y, r)) (splits xs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>splits_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(l, a, r) ∈ set (splits ll) = (ll = l @ a # r)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>ll</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>l</span><span> </span><span>a</span><span> </span><span>r</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_eq_append_conv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Zippers ›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹ Zippers provide a neat representation of tree-like ADSs when they have only a single 
  unblinded subtree. The zipper path provides the "inclusion proof" that the unblinded subtree is
  included in a larger structure. ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>path_elem</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a × 'a rose_tree list × 'a rose_tree list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>path</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a path_elem list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'a</span><span> </span><span>zipper</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a path × 'a rose_tree"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>zipper_of_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a rose_tree ⇒ 'a zipper"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"zipper_of_tree t ≡ ([], t)"</span></span></span><span>
</span><span>               
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_of_zipper</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a zipper ⇒ 'a rose_tree"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_of_zipper ([], t) = t"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_of_zipper ((a, l, r) # z, t) = tree_of_zipper (z, (Tree (a, (l @ t # r))))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">case_of_simps</span></span><span> </span><span>tree_of_zipper_cases</span><span class="delimiter">:</span><span> </span><span>tree_of_zipper.simps</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_of_zipper_id</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_of_zipper (zipper_of_tree t) = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zipper_of_tree_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>zipper_children</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a zipper ⇒ 'a zipper list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"zipper_children (p, Tree (a, ts)) = map (λ(l, t, r). ((a, l, r) # p, t)) (splits ts)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zipper_children_same_tree</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z' ∈ set (zipper_children z)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_of_zipper z' = tree_of_zipper z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>a</span><span> </span><span>ts</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z = (p, Tree (a, ts))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>z</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>zipper_children.cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span>t</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ltr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z' = ((a, l, r) # p, t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(l, t, r) ∈ set (splits ts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>z</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splits_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>path_elem<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> × ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub> list × ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub> list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>path<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) path_elem<span class="hidden">⇩</span><sub>m</sub> list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'a<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">,</span><span> </span><span class="tfree">'a<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">)</span><span> </span><span>zipper<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) path<span class="hidden">⇩</span><sub>m</sub> × ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>zipper_of_tree<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub> ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) zipper<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"zipper_of_tree<span class="hidden">⇩</span><sub>m</sub> t ≡ ([], t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>tree_of_zipper<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) zipper<span class="hidden">⇩</span><sub>m</sub> ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> ([], t) = t"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> ((m, l, r) # z, t) = tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (z, Tree<span class="hidden">⇩</span><sub>m</sub> (Unblinded (m, l @ t # r)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_of_zipper<span class="hidden">⇩</span><sub>m</sub>_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (p @ p', t) = tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (p', tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (p, t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>p'</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>zipper_children<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) zipper<span class="hidden">⇩</span><sub>m</sub> ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) zipper<span class="hidden">⇩</span><sub>m</sub> list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"zipper_children<span class="hidden">⇩</span><sub>m</sub> (p, Tree<span class="hidden">⇩</span><sub>m</sub> (Unblinded (a, ts))) = map (λ(l, t, r). ((a, l, r) # p, t)) (splits ts) "</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"zipper_children<span class="hidden">⇩</span><sub>m</sub> _ = []"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zipper_children_same_tree<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z' ∈ set (zipper_children<span class="hidden">⇩</span><sub>m</sub> z)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> z' = tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> z"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>a</span><span> </span><span>ts</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z = (p, Tree<span class="hidden">⇩</span><sub>m</sub> (Unblinded (a, ts)))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>z</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>zipper_children<span class="hidden">⇩</span><sub>m</sub>.cases</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>l</span><span> </span><span>t</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ltr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z' = ((a, l, r) # p, t)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(l, t, r) ∈ set (splits ts)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>z</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splits_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>blind_path_elem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a<span class="hidden">⇩</span><sub>m</sub>) ⇒ ('a<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>h</sub>) ⇒ 'a path_elem ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) path_elem<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blind_path_elem e h (x, l, r) = (e x, map (blind_source_tree (h ∘ e)) l, map (blind_source_tree (h ∘ e)) r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">case_of_simps</span></span><span> </span><span>blind_path_elem_cases</span><span class="delimiter">:</span><span> </span><span>blind_path_elem.simps</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>blind_path</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a<span class="hidden">⇩</span><sub>m</sub>) ⇒ ('a<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>h</sub>) ⇒ 'a path ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) path<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blind_path e h ≡ map (blind_path_elem e h)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>embed_path_elem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a<span class="hidden">⇩</span><sub>m</sub>) ⇒ 'a path_elem ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) path_elem<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"embed_path_elem e (d, l, r) = (e d, map (embed_source_tree e) l, map (embed_source_tree e) r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>embed_path</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'a<span class="hidden">⇩</span><sub>m</sub>) ⇒ 'a path ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) path<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"embed_path embed_elem ≡ map (embed_path_elem embed_elem)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_tree_of_zipper_same_path</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_tree h (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (p, v)) = hash_tree h (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (p, v'))
        ⟷ hash_tree h v = hash_tree h v'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>v</span><span> </span><span>v'</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>hash_path_elem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>h</sub>) ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) path_elem<span class="hidden">⇩</span><sub>m</sub> ⇒ ('a<span class="hidden">⇩</span><sub>h</sub> × 'a<span class="hidden">⇩</span><sub>h</sub> rose_tree<span class="hidden">⇩</span><sub>h</sub> list × 'a<span class="hidden">⇩</span><sub>h</sub> rose_tree<span class="hidden">⇩</span><sub>h</sub> list)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_path_elem h (e, l, r) = (h e, map (hash_tree h) l, map (hash_tree h) r)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_view_zipper_eqI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ hash_list (hash_path_elem h) p = hash_list (hash_path_elem h') p';
    hash_tree h v = hash_tree h' v' ⟧ ⟹
    hash_tree h (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (p, v)) = hash_tree h' (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (p', v'))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>p'</span><span> </span><span>v</span><span> </span><span>v'</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blind_embed_path_same_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_tree h (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (blind_path e h p, t)) = hash_tree h (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (embed_path e p, t))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_path_elem h ∘ blind_path_elem e h = hash_path_elem h ∘ embed_path_elem e"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_blinded_simp</span><span> </span><span>hash_embedded_simp</span><span> </span><span>fun_eq_iff</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>arg_cong2</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>hash_source_tree</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>refl</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>hash_view_zipper_eqI</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>embed_path_def</span><span> </span><span>blind_path_def</span><span> </span><span>list.map_comp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tree_of_embed_commute</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (embed_path e p, embed_source_tree e t) = embed_source_tree e (tree_of_zipper (p, t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, t)"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>p</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>tree_of_zipper.induct</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>embed_path_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>childz_same_tree</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(l, t, r) ∈ set (splits ts) ⟹
  tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (embed_path e p, embed_source_tree e (Tree (d, ts))) 
  = tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (embed_path e ((d, l, r) # p), embed_source_tree e t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tree_of_embed_commute</span><span> </span><span>splits_iff</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>embed_source_tree.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_same_path</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bo</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on UNIV h bo"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree h bo (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (p, t)) (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (p, t'))
  ⟷ blinding_of_tree h bo t t'"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>UNIV</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>tree</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>UNIV</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_tree h"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree h bo"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>p</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>t</span><span> </span><span>t'</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list_all2_append</span><span> </span><span>list.rel_refl</span><span> </span><span>a.refl</span><span> </span><span>tree.refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zipper_children_size_change</span><span> </span><span class="delimiter">[</span><span>termination_simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(a, b) ∈ set (zipper_children (p, v)) ⟹ size b &lt; size v"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>v</span><span class="delimiter">)</span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splits_iff</span><span> </span><span>Set.image_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹All zippers of a rose tree›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>e</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a ⇒ 'a<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>h</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> ⇒ 'a<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>zippers_rose_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a zipper ⇒ ('a<span class="hidden">⇩</span><sub>m</sub>, 'a<span class="hidden">⇩</span><sub>h</sub>) zipper<span class="hidden">⇩</span><sub>m</sub> list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"zippers_rose_tree (p, t) = (blind_path e h p, embed_source_tree e t) # 
    concat (map zippers_rose_tree (zipper_children (p, t)))"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>zippers_rose_tree.simps</span><span> </span><span>zipper_children.simps</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zippers_rose_tree_same_hash'</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ set (zippers_rose_tree e h (p, t))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_tree h (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> z) = 
    hash_tree h (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (embed_path e p, embed_source_tree e t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, t)"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>p</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>zippers_rose_tree.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>p</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1.prems"</span></span></span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>zippers_rose_tree.simps</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>find</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"z = (blind_path e h p, embed_source_tree e t)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>rec</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span>ts</span><span> </span><span>l</span><span> </span><span>t'</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Tree (x, ts)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(l, t', r) ∈ set (splits ts)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ set (zippers_rose_tree e h ((x, l, r) # p, t'))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zipper_children.simps</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>rec</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>subst</span><span> </span><span class="string"><span class="delete"><span class="delete">"1.hyps"</span></span></span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"(x, l, r) # p"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t'"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rev_image_eqI</span><span> </span><span>zipper_children.simps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>childz_same_tree</span><span> </span><span>comp_apply</span><span> </span><span>embed_source_tree.simps</span><span> </span><span>rec</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blind_embed_path_same_hash</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zippers_rose_tree_blinding_of</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_on UNIV h bo"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>z</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ set (zippers_rose_tree e h (p, t))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree h bo (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> z) (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (blind_path e h p, embed_source_tree e t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>z</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span class="string"><span class="delete"><span class="delete">"(p, t)"</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>p</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>zippers_rose_tree.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>1</span><span> </span><span>p</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>UNIV</span><span> </span><span>h</span><span> </span><span>bo</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">interpret</span></span><span> </span><span>rt</span><span class="delimiter">:</span><span> </span><span>blinding_of_on</span><span> </span><span>UNIV</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_tree h"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree h bo"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"1.prems"</span></span></span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>zippers_rose_tree.simps</span><span class="delimiter">]</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">consider</span></span><span> </span><span class="delimiter">(</span><span>find</span><span class="delimiter">)</span><span> </span><span class="string"><span class="delete"><span class="delete">"z = (blind_path e h p, embed_source_tree e t)"</span></span></span><span>
</span><span>    </span><span class="delimiter">|</span><span> </span><span class="delimiter">(</span><span>rec</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span>ts</span><span> </span><span>l</span><span> </span><span>t'</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t = Tree (x, ts)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(l, t', r) ∈ set (splits ts)"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ set (zippers_rose_tree e h ((x, l, r) # p, t'))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zipper_children.simps</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>find</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rt.refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>rec</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree h bo 
      (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> z) 
      (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (blind_path e h ((x, l, r) # p), embed_source_tree e t'))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>1</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rev_image_eqI</span><span> </span><span>zipper_children.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree h bo 
      (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (blind_path e h ((x, l, r) # p), embed_source_tree e t'))
      (tree_of_zipper<span class="hidden">⇩</span><sub>m</sub> (blind_path e h p, embed_source_tree e (Tree (x, ts))))"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rec</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blind_path_def</span><span> </span><span>splits_iff</span><span> </span><span>blinding_of_same_path</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>a.refl</span><span> </span><span>list_all2_append</span><span> </span><span>list_all2_same</span><span> </span><span>list.rel_map</span><span> </span><span>blinded_blinds_embedded</span><span> </span><span>rt.refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="delimiter">(</span><span>rt.trans</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>rec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zippers_rose_tree_neq_Nil</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"zippers_rose_tree e h (p, t) ≠ []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zippers_rose_tree.simps</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>comp_fun_idem</span><span class="delimiter">)</span><span> </span><span>fold_set_union</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite B"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite_Set.fold f z (A ∪ B) = Finite_Set.fold f (Finite_Set.fold f z A) B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>2</span><span class="delimiter">,</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>merkle_interface</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>comp_fun_idem_merge</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"comp_fun_idem (λx yo. yo ⤜ m x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>unfold_locales</span><span class="delimiter">;</span><span> </span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>bind_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>assoc</span><span> </span><span>bind.bind_lunit</span><span> </span><span>bind.bind_lzero</span><span> </span><span>idem</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">subgoal</span></span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>join</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>merge</span><span class="delimiter">:</span><span> </span><span>comp_fun_idem</span><span> </span><span class="string"><span class="delete"><span class="delete">"λx yo. yo ⤜ m x"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>comp_fun_idem_merge</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Merge</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a<span class="hidden">⇩</span><sub>m</sub> set ⇒ 'a<span class="hidden">⇩</span><sub>m</sub> option"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Merge A = (if A = {} ∨ infinite A then None else Finite_Set.fold (λx yo. yo ⤜ m x) (Some (SOME x. x ∈ A)) A)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Merge {} = None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Merge_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_infinite</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"infinite A ⟹ Merge A = None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Merge_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_cong_start</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Finite_Set.fold (λx yo. yo ⤜ m x) (Some x) A = Finite_Set.fold (λx yo. yo ⤜ m x) (Some y) A"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = Finite_Set.fold (λx yo. yo ⤜ m x) (Some x) (insert y A)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = Finite_Set.fold (λx yo. yo ⤜ m x) (m x y) A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>merge.fold_insert_idem2</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = Finite_Set.fold (λx yo. yo ⤜ m x) (Some y) (insert x A)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>merge.fold_insert_idem2</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_insert</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Merge (insert x A) = (if A = {} then Some x else Merge A ⤜ m x)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A ∧ A ≠ {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = Finite_Set.fold (λx yo. yo ⤜ m x) (Some (SOME x. x ∈ A)) (insert x A)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Merge_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Merge_cong_start</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"SOME x. x ∈ A"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>someI</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>someI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Merge_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Merge_def</span><span> </span><span>idem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_insert_alt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Merge (insert x A) = Finite_Set.fold (λx yo. yo ⤜ m x) (Some x) A"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = Finite_Set.fold (λx yo. yo ⤜ m x) (Some x) (insert x A)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Merge_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Merge_cong_start</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span>x</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>someI</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = ?rhs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>merge.fold_insert_idem2</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>idem</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_None</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite_Set.fold (λx yo. yo ⤜ m x) None A = None"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_union</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Merge (A ∪ B) = (if A = {} then Merge B else if B = {} then Merge A else (Merge A ⤜ (λa. Merge B ⤜ m a)))"</span></span></span><span>
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite (A ∪ B) ∧ A ≠ {} ∧ B ≠ {}"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = Finite_Set.fold (λx yo. yo ⤜ m x) (Some (SOME x. x ∈ B)) (B ∪ A)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Merge_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>subst</span><span> </span><span>Merge_cong_start</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>y</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"SOME x. x ∈ B"</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>someI</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>someI</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Un_commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = Finite_Set.fold (λx yo. yo ⤜ m x) (Merge B) A"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Merge_def</span><span> </span><span>merge.fold_set_union</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = Merge A ⤜ (λa. Merge B ⤜ m a)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Merge B"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span class="delimiter">(</span><span>subst</span><span> </span><span>Merge_insert_alt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>commute</span><span class="delimiter">;</span><span> </span><span>metis</span><span> </span><span>commute</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_upper</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Merge A = Some x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y ∈ A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo y x"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Merge A = Merge (insert y A)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"… = Merge A ⤜ m y"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>y</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m y x = Some x"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bo_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_least</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Merge A = Some x"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>u</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈A. bo a u"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo x u"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≡ SOME x. x ∈ A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>A</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≠ {}"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>*</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite_Set.fold (λx yo. yo ⤜ m x) (Some a) A = Some x"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Merge_def</span><span> </span><span>a_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"bo a u"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>someI</span><span> </span><span>u</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A</span><span> </span><span>*</span><span> </span><span>u</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>A</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m x a"</span></span></span><span class="delimiter">;</span><span> </span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A = {}"</span></span></span><span class="delimiter">;</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>merge.fold_insert_idem2</span><span class="delimiter">;</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>join</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_defined</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"finite A"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A ≠ {}"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀a∈A. ∀b ∈ A. h a = h b"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Merge A ≠ None"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">define</span></span><span> </span><span>a</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ≡ SOME a. a ∈ A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ A"</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>a_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>someI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ha</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀b ∈ A. h b = h a"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Merge A = None"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Finite_Set.fold (λx yo. yo ⤜ m x) (Some a) A = None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Merge_def</span><span> </span><span>a_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ha</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>x</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"m x a"</span></span></span><span class="delimiter">;</span><span> </span><span>use</span><span> </span><span>nothing</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹simp only: merge.fold_insert_idem2›</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>merge_respects_hashes</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>join</span><span> </span><span>vimage2p_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>hash</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>predicate2D</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Merge_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Merge A = Some x"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"a ∈ A"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"h a = h x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Merge_upper</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span> </span><span>hash</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>vimage2p_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div><div id="Canton_Transaction_Tree">
<div class="head"><h1>Theory Canton_Transaction_Tree</h1>
<span class="command">theory</span> <span class="name">Canton_Transaction_Tree</span><br/>
<span class="keyword">imports</span> <a href="Inclusion_Proof_Construction.html"><span class="name">Inclusion_Proof_Construction</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Canton_Transaction_Tree</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Inclusion_Proof_Construction</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Canton's hierarchical transaction trees›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>view_data</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>view_metadata</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>common_metadata</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>participant_metadata</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>view</span><span> </span><span class="delimiter">=</span><span> </span><span>View</span><span> </span><span>view_metadata</span><span> </span><span>view_data</span><span> </span><span class="delimiter">(</span><span>subviews</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"view list"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>transaction</span><span> </span><span class="delimiter">=</span><span> </span><span>Transaction</span><span> </span><span>common_metadata</span><span> </span><span>participant_metadata</span><span> </span><span class="delimiter">(</span><span>views</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"view list"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Views as authenticated data structures›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_metadata<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_metadata blindable<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_data<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_data blindable<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>view<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>View<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="string"><span class="delete"><span class="delete">"((view_metadata<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> view_data<span class="hidden">⇩</span><sub>h</sub>) ×<span class="hidden">⇩</span><sub>h</sub> view<span class="hidden">⇩</span><sub>h</sub> list<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_metadata<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view_metadata, view_metadata) blindable<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_data<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view_data, view_data) blindable<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>view<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>View<span class="hidden">⇩</span><sub>m</sub></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"((view_metadata<span class="hidden">⇩</span><sub>m</sub> ×<span class="hidden">⇩</span><sub>m</sub> view_data<span class="hidden">⇩</span><sub>m</sub>) ×<span class="hidden">⇩</span><sub>m</sub> view<span class="hidden">⇩</span><sub>m</sub> list<span class="hidden">⇩</span><sub>m</sub>,
    (view_metadata<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> view_data<span class="hidden">⇩</span><sub>h</sub>) ×<span class="hidden">⇩</span><sub>h</sub> view<span class="hidden">⇩</span><sub>h</sub> list<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_view_data</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view_data<span class="hidden">⇩</span><sub>m</sub>, view_data<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_view_data ≡ hash_blindable id"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_view_data</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_data<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_view_data ≡ blinding_of_blindable id (=)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>merge_view_data</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_data<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_view_data ≡ merge_blindable id merge_discrete"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_view_data</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merkle_interface hash_view_data blinding_of_view_data merge_view_data"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_view_metadata</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view_metadata<span class="hidden">⇩</span><sub>m</sub>, view_metadata<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_view_metadata ≡ hash_blindable id"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_view_metadata</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_metadata<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_view_metadata ≡ blinding_of_blindable id (=)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>merge_view_metadata</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_metadata<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_view_metadata ≡ merge_blindable id merge_discrete"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_view_metadata</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merkle_interface hash_view_metadata blinding_of_view_metadata merge_view_metadata"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_content</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_metadata × view_data"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_content<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_metadata<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> view_data<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_content<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_metadata<span class="hidden">⇩</span><sub>m</sub> ×<span class="hidden">⇩</span><sub>m</sub> view_data<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>view_merkle</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view<span class="hidden">⇩</span><sub>h</sub>'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_content<span class="hidden">⇩</span><sub>h</sub> rose_tree<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>from_view<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view<span class="hidden">⇩</span><sub>h</sub> ⇒ view<span class="hidden">⇩</span><sub>h</sub>'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"from_view<span class="hidden">⇩</span><sub>h</sub> (View<span class="hidden">⇩</span><sub>h</sub> x) = Tree<span class="hidden">⇩</span><sub>h</sub> (map_blindable<span class="hidden">⇩</span><sub>h</sub> (map_prod id (map from_view<span class="hidden">⇩</span><sub>h</sub>)) x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>to_view<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view<span class="hidden">⇩</span><sub>h</sub>' ⇒ view<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"to_view<span class="hidden">⇩</span><sub>h</sub> (Tree<span class="hidden">⇩</span><sub>h</sub> x) = View<span class="hidden">⇩</span><sub>h</sub> (map_blindable<span class="hidden">⇩</span><sub>h</sub> (map_prod id (map to_view<span class="hidden">⇩</span><sub>h</sub>)) x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>from_to_view<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"from_view<span class="hidden">⇩</span><sub>h</sub> (to_view<span class="hidden">⇩</span><sub>h</sub> x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub>.map_comp</span><span> </span><span>o_def</span><span> </span><span>prod.map_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub>.map_cong</span><span> </span><span>prod.map_cong</span><span> </span><span>list.map_cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub>.map_id</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>id_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_from_view<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_view<span class="hidden">⇩</span><sub>h</sub> (from_view<span class="hidden">⇩</span><sub>h</sub> x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub>.map_comp</span><span> </span><span>o_def</span><span> </span><span>prod.map_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub>.map_cong</span><span> </span><span>prod.map_cong</span><span> </span><span>list.map_cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub>.map_id</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>id_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_view<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"type_definition from_view<span class="hidden">⇩</span><sub>h</sub> to_view<span class="hidden">⇩</span><sub>h</sub> UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>iso_view<span class="hidden">⇩</span><sub>h</sub></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cr_view<span class="hidden">⇩</span><sub>h</sub>_Grp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cr_view<span class="hidden">⇩</span><sub>h</sub> = Grp UNIV to_view<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cr_view<span class="hidden">⇩</span><sub>h</sub>_def</span><span> </span><span>Grp_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>View<span class="hidden">⇩</span><sub>h</sub>_transfer</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(rel_blindable<span class="hidden">⇩</span><sub>h</sub> (rel_prod (=) (list_all2 pcr_view<span class="hidden">⇩</span><sub>h</sub>)) ===&gt; pcr_view<span class="hidden">⇩</span><sub>h</sub>) Tree<span class="hidden">⇩</span><sub>h</sub> View<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>view<span class="hidden">⇩</span><sub>h</sub>.pcr_cr_eq</span><span> </span><span>cr_view<span class="hidden">⇩</span><sub>h</sub>_Grp</span><span> </span><span>list.rel_Grp</span><span> </span><span>eq_alt</span><span> </span><span>prod.rel_Grp</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>h</sub>.rel_Grp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Grp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view<span class="hidden">⇩</span><sub>m</sub>'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view_content<span class="hidden">⇩</span><sub>m</sub>, view_content<span class="hidden">⇩</span><sub>h</sub>) rose_tree<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>from_view<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view<span class="hidden">⇩</span><sub>m</sub> ⇒ view<span class="hidden">⇩</span><sub>m</sub>'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"from_view<span class="hidden">⇩</span><sub>m</sub> (View<span class="hidden">⇩</span><sub>m</sub> x) = Tree<span class="hidden">⇩</span><sub>m</sub> (map_blindable<span class="hidden">⇩</span><sub>m</sub> (map_prod id (map from_view<span class="hidden">⇩</span><sub>m</sub>)) (map_prod id (map from_view<span class="hidden">⇩</span><sub>h</sub>)) x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>to_view<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view<span class="hidden">⇩</span><sub>m</sub>' ⇒ view<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"to_view<span class="hidden">⇩</span><sub>m</sub> (Tree<span class="hidden">⇩</span><sub>m</sub> x) = View<span class="hidden">⇩</span><sub>m</sub> (map_blindable<span class="hidden">⇩</span><sub>m</sub> (map_prod id (map to_view<span class="hidden">⇩</span><sub>m</sub>)) (map_prod id (map to_view<span class="hidden">⇩</span><sub>h</sub>)) x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>from_to_view<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"from_view<span class="hidden">⇩</span><sub>m</sub> (to_view<span class="hidden">⇩</span><sub>m</sub> x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_comp</span><span> </span><span>o_def</span><span> </span><span>prod.map_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_cong</span><span> </span><span>prod.map_cong</span><span> </span><span>list.map_cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_id</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>id_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_from_view<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_view<span class="hidden">⇩</span><sub>m</sub> (from_view<span class="hidden">⇩</span><sub>m</sub> x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_comp</span><span> </span><span>o_def</span><span> </span><span>prod.map_comp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_cong</span><span> </span><span>prod.map_cong</span><span> </span><span>list.map_cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_id</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>id_def</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_view<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"type_definition from_view<span class="hidden">⇩</span><sub>m</sub> to_view<span class="hidden">⇩</span><sub>m</sub> UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>iso_view<span class="hidden">⇩</span><sub>m</sub></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cr_view<span class="hidden">⇩</span><sub>m</sub>_Grp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cr_view<span class="hidden">⇩</span><sub>m</sub> = Grp UNIV to_view<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cr_view<span class="hidden">⇩</span><sub>m</sub>_def</span><span> </span><span>Grp_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>View<span class="hidden">⇩</span><sub>m</sub>_transfer</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(rel_blindable<span class="hidden">⇩</span><sub>m</sub> (rel_prod (=) (list_all2 pcr_view<span class="hidden">⇩</span><sub>m</sub>)) (rel_prod (=) (list_all2 pcr_view<span class="hidden">⇩</span><sub>h</sub>)) ===&gt; pcr_view<span class="hidden">⇩</span><sub>m</sub>) Tree<span class="hidden">⇩</span><sub>m</sub> View<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>rel_fun_def</span><span> </span><span>view<span class="hidden">⇩</span><sub>h</sub>.pcr_cr_eq</span><span> </span><span>view<span class="hidden">⇩</span><sub>m</sub>.pcr_cr_eq</span><span> </span><span>cr_view<span class="hidden">⇩</span><sub>h</sub>_Grp</span><span> </span><span>cr_view<span class="hidden">⇩</span><sub>m</sub>_Grp</span><span> </span><span>list.rel_Grp</span><span> </span><span>eq_alt</span><span> </span><span>prod.rel_Grp</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.rel_Grp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Grp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_datatype</span></span><span> </span><span>View<span class="hidden">⇩</span><sub>h</sub></span><span>
</span><span class="keyword1"><span class="command">code_datatype</span></span><span> </span><span>View<span class="hidden">⇩</span><sub>m</sub></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>view_merkle</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_view_content</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view_content<span class="hidden">⇩</span><sub>m</sub>, view_content<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_view_content ≡ hash_prod hash_view_metadata hash_view_data"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_view_content</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_content<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_view_content ≡ blinding_of_prod blinding_of_view_metadata blinding_of_view_data"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>merge_view_content</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_content<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_view_content ≡ merge_prod merge_view_metadata merge_view_data"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>hash_view</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view<span class="hidden">⇩</span><sub>m</sub>, view<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_tree hash_view_content"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>blinding_of_view</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_tree hash_view_content blinding_of_view_content"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>merge_view</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_tree hash_view_content merge_view_content"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_view</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"merkle_interface hash_view blinding_of_view merge_view"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_view_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_view (View<span class="hidden">⇩</span><sub>m</sub> x) = 
   View<span class="hidden">⇩</span><sub>h</sub> (hash_blindable (hash_prod hash_view_content (hash_list hash_view)) x)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_rt_F<span class="hidden">⇩</span><sub>m</sub>_def</span><span> </span><span>prod.map_comp</span><span> </span><span>hash_blindable_def</span><span> </span><span>blindable<span class="hidden">⇩</span><sub>m</sub>.map_id</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_view_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_view (View<span class="hidden">⇩</span><sub>m</sub> x) (View<span class="hidden">⇩</span><sub>m</sub> y) ⟷
   blinding_of_blindable (hash_prod hash_view_content (hash_list hash_view))
     (blinding_of_prod blinding_of_view_content (blinding_of_list blinding_of_view)) x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_view_induct</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>pred</span><span class="delimiter">:</span><span> </span><span>blinding_of_view</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_view x y"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x y. blinding_of_blindable (hash_prod hash_view_content (hash_list hash_view))
             (blinding_of_prod blinding_of_view_content (blinding_of_list (λx y. blinding_of_view x y ∧ P x y))) x y
         ⟹ P (View<span class="hidden">⇩</span><sub>m</sub> x) (View<span class="hidden">⇩</span><sub>m</sub> y)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P x y"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>rule</span><span> </span><span>blinding_of_tree.induct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_view_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_view (View<span class="hidden">⇩</span><sub>m</sub> x) (View<span class="hidden">⇩</span><sub>m</sub> y) =
   map_option View<span class="hidden">⇩</span><sub>m</sub> (merge_rt_F<span class="hidden">⇩</span><sub>m</sub> hash_view_content merge_view_content hash_view merge_view x y)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Transaction trees as authenticated data structures›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>common_metadata<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"common_metadata blindable<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>common_metadata<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(common_metadata, common_metadata) blindable<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>participant_metadata<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"participant_metadata blindable<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>participant_metadata<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(participant_metadata, participant_metadata) blindable<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>transaction<span class="hidden">⇩</span><sub>h</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>Transaction<span class="hidden">⇩</span><sub>h</sub></span><span> 
</span><span>  </span><span class="delimiter">(</span><span>the_Transaction<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((common_metadata<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> participant_metadata<span class="hidden">⇩</span><sub>h</sub>) ×<span class="hidden">⇩</span><sub>h</sub> view<span class="hidden">⇩</span><sub>h</sub> list<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>transaction<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span>Transaction<span class="hidden">⇩</span><sub>m</sub></span><span> 
</span><span>  </span><span class="delimiter">(</span><span>the_Transaction<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"((common_metadata<span class="hidden">⇩</span><sub>m</sub> ×<span class="hidden">⇩</span><sub>m</sub> participant_metadata<span class="hidden">⇩</span><sub>m</sub>) ×<span class="hidden">⇩</span><sub>m</sub> view<span class="hidden">⇩</span><sub>m</sub> list<span class="hidden">⇩</span><sub>m</sub>,
    (common_metadata<span class="hidden">⇩</span><sub>h</sub> ×<span class="hidden">⇩</span><sub>h</sub> participant_metadata<span class="hidden">⇩</span><sub>h</sub>) ×<span class="hidden">⇩</span><sub>h</sub> view<span class="hidden">⇩</span><sub>h</sub> list<span class="hidden">⇩</span><sub>h</sub>) blindable<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_common_metadata</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(common_metadata<span class="hidden">⇩</span><sub>m</sub>, common_metadata<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_common_metadata ≡ hash_blindable id"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_common_metadata</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"common_metadata<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_common_metadata ≡ blinding_of_blindable id (=)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>merge_common_metadata</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"common_metadata<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_common_metadata ≡ merge_blindable id merge_discrete"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>hash_participant_metadata</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(participant_metadata<span class="hidden">⇩</span><sub>m</sub>, participant_metadata<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_participant_metadata ≡ hash_blindable id"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>blinding_of_participant_metadata</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"participant_metadata<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_participant_metadata ≡ blinding_of_blindable id (=)"</span></span></span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>merge_participant_metadata</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"participant_metadata<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_participant_metadata ≡ merge_blindable id merge_discrete"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">locale</span></span><span> </span><span>transaction_merkle</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_transaction<span class="hidden">⇩</span><sub>h</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"type_definition the_Transaction<span class="hidden">⇩</span><sub>h</sub> Transaction<span class="hidden">⇩</span><sub>h</sub> UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>iso_transaction<span class="hidden">⇩</span><sub>h</sub></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Transaction<span class="hidden">⇩</span><sub>h</sub>_transfer</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; pcr_transaction<span class="hidden">⇩</span><sub>h</sub>) id Transaction<span class="hidden">⇩</span><sub>h</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>transaction<span class="hidden">⇩</span><sub>h</sub>.pcr_cr_eq</span><span> </span><span>cr_transaction<span class="hidden">⇩</span><sub>h</sub>_def</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_transaction<span class="hidden">⇩</span><sub>m</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"type_definition the_Transaction<span class="hidden">⇩</span><sub>m</sub> Transaction<span class="hidden">⇩</span><sub>m</sub> UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>iso_transaction<span class="hidden">⇩</span><sub>m</sub></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Transaction<span class="hidden">⇩</span><sub>m</sub>_transfer</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; pcr_transaction<span class="hidden">⇩</span><sub>m</sub>) id Transaction<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>transaction<span class="hidden">⇩</span><sub>m</sub>.pcr_cr_eq</span><span> </span><span>cr_transaction<span class="hidden">⇩</span><sub>m</sub>_def</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_datatype</span></span><span> </span><span>Transaction<span class="hidden">⇩</span><sub>h</sub></span><span>
</span><span class="keyword1"><span class="command">code_datatype</span></span><span> </span><span>Transaction<span class="hidden">⇩</span><sub>m</sub></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>transaction_merkle</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>hash_transaction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(transaction<span class="hidden">⇩</span><sub>m</sub>, transaction<span class="hidden">⇩</span><sub>h</sub>) hash"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_blindable (hash_prod (hash_prod hash_common_metadata hash_participant_metadata) (hash_list hash_view))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>blinding_of_transaction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction<span class="hidden">⇩</span><sub>m</sub> blinding_of"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_blindable 
     (hash_prod (hash_prod hash_common_metadata hash_participant_metadata) (hash_list hash_view))
     (blinding_of_prod (blinding_of_prod blinding_of_common_metadata blinding_of_participant_metadata) (blinding_of_list blinding_of_view))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>merge_transaction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction<span class="hidden">⇩</span><sub>m</sub> merge"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merge_blindable
     (hash_prod (hash_prod hash_common_metadata hash_participant_metadata) (hash_list hash_view))
     (merge_prod (merge_prod merge_common_metadata merge_participant_metadata) (merge_list merge_view))"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merkle_transaction</span><span> </span><span class="delimiter">[</span><span>locale_witness</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"merkle_interface hash_transaction blinding_of_transaction merge_transaction"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>unfold_locales</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>hash_transaction_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>hash_transaction.abs_eq</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>blinding_of_transaction_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>blinding_of_transaction.abs_eq</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_transaction_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_transaction.abs_eq</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>transaction</span><span class="delimiter">:</span><span>
</span><span>  </span><span>merkle_interface</span><span> </span><span>hash_transaction</span><span> </span><span>blinding_of_transaction</span><span> </span><span>merge_transaction</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>merkle_transaction</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
Constructing authenticated data structures for views
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>view_merkle</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view'</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view_metadata × view_data) rose_tree"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>from_view</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view ⇒ view'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"from_view (View vm vd vs) = Tree ((vm, vd), map from_view vs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>to_view</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view' ⇒ view"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"to_view (Tree x) = View (fst (fst x)) (snd (fst x)) (snd (map_prod id (map to_view) x))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>from_to_view</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"from_view (to_view x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>map_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>to_from_view</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"to_view (from_view x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>cong</span><span class="delimiter">:</span><span> </span><span>map_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_view</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"type_definition from_view to_view UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>iso_view</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>View'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view_metadata × view_data) × view list ⇒ view"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"View' = (λ((vm, vd), vs). View vm vd vs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>View_View'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"View = (λvm vd vs. View' ((vm, vd), vs))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>View'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cr_view_Grp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cr_view = Grp UNIV to_view"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cr_view_def</span><span> </span><span>Grp_def</span><span> </span><span>fun_eq_iff</span><span class="delimiter">)</span><span class="delimiter">(</span><span>transfer</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>View'_transfer</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(rel_prod (=) (list_all2 pcr_view) ===&gt; pcr_view) Tree View'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>view.pcr_cr_eq</span><span> </span><span>cr_view_Grp</span><span> </span><span>eq_alt</span><span> </span><span>prod.rel_Grp</span><span> </span><span>rose_tree.rel_Grp</span><span> </span><span>list.rel_Grp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Grp_def</span><span> </span><span>View'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_datatype</span></span><span> </span><span>View</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>view_merkle</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>embed_view_content</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_metadata × view_data ⇒ view_metadata<span class="hidden">⇩</span><sub>m</sub> × view_data<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"embed_view_content ≡ map_prod Unblinded Unblinded"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>embed_view</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view ⇒ view<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"embed_source_tree embed_view_content"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>embed_view_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"embed_view (View vm vd vs) = View<span class="hidden">⇩</span><sub>m</sub> (Unblinded ((Unblinded vm, Unblinded vd), map embed_view vs))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>View_View'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span>transaction_merkle</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>the_Transaction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction ⇒ (common_metadata × participant_metadata) × view list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"the_Transaction (Transaction cm pm views) = ((cm, pm), views)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>views</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Transaction'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(common_metadata × participant_metadata) × view list ⇒ transaction"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Transaction' = (λ((cm, pm), views). Transaction cm pm views)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Transaction_Transaction'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Transaction = (λcm pm views. Transaction' ((cm, pm), views))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Transaction'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>the_Transaction_inverse</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Transaction' (the_Transaction x) = x"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Transaction'_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Transaction'_inverse</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"the_Transaction (Transaction' x) = x"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Transaction'_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>iso_transaction</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"type_definition the_Transaction Transaction' UNIV"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>unfold_locales</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">setup_lifting</span></span><span> </span><span>iso_transaction</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Transaction'_transfer</span><span> </span><span class="delimiter">[</span><span>transfer_rule</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">includes</span></span><span> </span><span>lifting_syntax</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"((=) ===&gt; pcr_transaction) id Transaction'"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>transaction.pcr_cr_eq</span><span> </span><span>cr_transaction_def</span><span> </span><span>rel_fun_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_datatype</span></span><span> </span><span>Transaction</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>transaction_merkle</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>embed_transaction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction ⇒ transaction<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Unblinded ∘ map_prod (map_prod Unblinded Unblinded) (map embed_view)"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>embed_transaction_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"embed_transaction (Transaction cm pm views) =
   Transaction<span class="hidden">⇩</span><sub>m</sub> (Unblinded ((Unblinded cm, Unblinded pm), map embed_view views))"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>views</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>Transaction_Transaction'</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inclusion proof for the mediator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>mediator_view</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view ⇒ view<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mediator_view (View vm vd vs) =
   View<span class="hidden">⇩</span><sub>m</sub> (Unblinded ((Unblinded vm, Blinded (Content vd)), map mediator_view vs))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>mediator_transaction_tree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction ⇒ transaction<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mediator_transaction_tree (Transaction cm pm views) =
   Transaction<span class="hidden">⇩</span><sub>m</sub> (Unblinded ((Unblinded cm, Blinded (Content pm)), map mediator_view views))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>views</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_mediator_view</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_view (mediator_view view) (embed_view view)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>view</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list.rel_map</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>list.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>blinding_of_mediator_transaction_tree</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blinding_of_transaction (mediator_transaction_tree tt) (embed_transaction tt)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>tt</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>list.rel_map</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>list.rel_refl_strong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Inclusion proofs for participants›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Next, we define a function for producing all transaction views from a given view,
  and prove its properties.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_path_elem</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view_metadata × view_data) blindable × view list × view list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_path</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_path_elem list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_zipper</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_path × view"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_path_elem<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(view_metadata<span class="hidden">⇩</span><sub>m</sub> ×<span class="hidden">⇩</span><sub>m</sub> view_data<span class="hidden">⇩</span><sub>m</sub>) × view<span class="hidden">⇩</span><sub>m</sub> list<span class="hidden">⇩</span><sub>m</sub> × view<span class="hidden">⇩</span><sub>m</sub> list<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_path<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_path_elem<span class="hidden">⇩</span><sub>m</sub> list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>view_zipper<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_path<span class="hidden">⇩</span><sub>m</sub> × view<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span class="keyword1"><span class="command">interpretation</span></span><span> </span><span>view_merkle</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zipper_of_view</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view ⇒ view_zipper"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>zipper_of_tree</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>view_of_zipper</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_zipper ⇒ view"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>tree_of_zipper</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zipper_of_view<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view<span class="hidden">⇩</span><sub>m</sub> ⇒ view_zipper<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>zipper_of_tree<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>view_of_zipper<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_zipper<span class="hidden">⇩</span><sub>m</sub> ⇒ view<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span>tree_of_zipper<span class="hidden">⇩</span><sub>m</sub></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>view_of_zipper<span class="hidden">⇩</span><sub>m</sub>_Nil</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_of_zipper<span class="hidden">⇩</span><sub>m</sub> ([], t) = t"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>blind_view_path_elem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_path_elem ⇒ view_path_elem<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blind_path_elem embed_view_content hash_view_content"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>blind_view_path</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_path ⇒ view_path<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blind_path embed_view_content hash_view_content"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>embed_view_path_elem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_path_elem ⇒ view_path_elem<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"embed_path_elem embed_view_content"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>embed_view_path</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_path ⇒ view_path<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"embed_path embed_view_content"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>hash_view_path_elem</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_path_elem<span class="hidden">⇩</span><sub>m</sub> ⇒ (view_content<span class="hidden">⇩</span><sub>h</sub> × view<span class="hidden">⇩</span><sub>h</sub> list × view<span class="hidden">⇩</span><sub>h</sub> list)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_path_elem hash_view_content"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lift_definition</span></span><span> </span><span>zippers_view</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_zipper ⇒ view_zipper<span class="hidden">⇩</span><sub>m</sub> list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"zippers_rose_tree embed_view_content hash_view_content"</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>embed_view_path_Nil</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"embed_view_path [] = []"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>embed_path_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zippers_view_same_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ set (zippers_view (p, t))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_view (view_of_zipper<span class="hidden">⇩</span><sub>m</sub> z) = hash_view (view_of_zipper<span class="hidden">⇩</span><sub>m</sub> (embed_view_path p, embed_view t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>rule</span><span> </span><span>zippers_rose_tree_same_hash'</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>zippers_view_blinding_of</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"z ∈ set (zippers_view (p, t))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_view (view_of_zipper<span class="hidden">⇩</span><sub>m</sub> z) (view_of_zipper<span class="hidden">⇩</span><sub>m</sub> (blind_view_path p, embed_view t))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>transfer</span><span class="delimiter">(</span><span>rule</span><span> </span><span>zippers_rose_tree_blinding_of</span><span class="delimiter">,</span><span> </span><span>unfold_locales</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>blind_view</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view ⇒ view<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blind_view (View vm vd subviews) = 
   View<span class="hidden">⇩</span><sub>m</sub> (Blinded (Content ((Content vm, Content vd), map (hash_view ∘ embed_view) subviews)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>subviews</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_blind_view</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"hash_view (blind_view view) = hash_view (embed_view view)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>view</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>blind_transaction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction ⇒ transaction<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"blind_transaction (Transaction cm pm views) = 
   Transaction<span class="hidden">⇩</span><sub>m</sub> (Blinded (Content ((Content cm, Content pm), map (hash_view ∘ blind_view) views)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>views</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hash_blind_transaction</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_transaction (blind_transaction transaction) = hash_transaction (embed_transaction transaction)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>transaction</span><span class="delimiter">)</span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hash_blind_view</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">typedecl</span></span><span> </span><span>participant</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>recipients</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_metadata ⇒ participant list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>view_recipients</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view<span class="hidden">⇩</span><sub>m</sub> ⇒ participant set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"view_recipients (View<span class="hidden">⇩</span><sub>m</sub> (Unblinded ((Unblinded vm, vd), subviews))) = set (recipients vm)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>subviews</span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"view_recipients _ = {}"</span></span></span><span> </span><span class="comment">― ‹Sane default case›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span> </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>participant</span><span> </span><span class="delimiter">::</span><span> </span><span>participant</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>view_trees_for</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"view ⇒ view<span class="hidden">⇩</span><sub>m</sub> list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"view_trees_for view =
   map view_of_zipper<span class="hidden">⇩</span><sub>m</sub>
     (filter (λ(_, t). participant ∈ view_recipients t) 
       (zippers_view ([], view)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>transaction_views_for</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction ⇒ transaction<span class="hidden">⇩</span><sub>m</sub> list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"transaction_views_for (Transaction cm pm views) =
   map (λview<span class="hidden">⇩</span><sub>m</sub>. Transaction<span class="hidden">⇩</span><sub>m</sub> (Unblinded ((Unblinded cm, Unblinded pm), view<span class="hidden">⇩</span><sub>m</sub>)))
  (concat (map (λ(l, v, r). map (λv<span class="hidden">⇩</span><sub>m</sub>. map blind_view l @ [v<span class="hidden">⇩</span><sub>m</sub>] @ map blind_view r) (view_trees_for v)) (splits views)))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>views</span><span>
</span><span>   
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>view_trees_for_same_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vt ∈ set (view_trees_for view) ⟹ hash_view vt = hash_view (embed_view view)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>view_trees_for_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>zippers_view_same_hash</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>transaction_views_for_same_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>m</sub> ∈ set (transaction_views_for t) ⟹ hash_transaction t<span class="hidden">⇩</span><sub>m</sub> = hash_transaction (embed_transaction t)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>t</span><span class="delimiter">)</span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>splits_iff</span><span> </span><span>hash_blind_view</span><span> </span><span>view_trees_for_same_hash</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>transaction_projection_for</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction ⇒ transaction<span class="hidden">⇩</span><sub>m</sub>"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"transaction_projection_for t =
   (let tvs = transaction_views_for t
    in if tvs = [] then blind_transaction t else the (transaction.Merge (set tvs)))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>transaction_projection_for_same_hash</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hash_transaction (transaction_projection_for t) = hash_transaction (embed_transaction t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction_views_for t = []"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>transaction_projection_for_def</span><span> </span><span>Let_def</span><span> </span><span>hash_blind_transaction</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction.Merge (set (transaction_views_for t)) ≠ None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>transaction.Merge_defined</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>transaction_views_for_same_hash</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>False</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>transaction_projection_for_def</span><span> </span><span>neq_Nil_conv</span><span> </span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>transaction.Merge_insert</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>transaction.Merge_hash</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>transaction_views_for_same_hash</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>transaction_projection_for_upper</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"t<span class="hidden">⇩</span><sub>m</sub> ∈ set (transaction_views_for t)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"blinding_of_transaction t<span class="hidden">⇩</span><sub>m</sub> (transaction_projection_for t)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"transaction.Merge (set (transaction_views_for t)) ≠ None"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>intro</span><span> </span><span>transaction.Merge_defined</span><span class="delimiter">)</span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>transaction_views_for_same_hash</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>transaction_projection_for_def</span><span> </span><span>Let_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>transaction.Merge_upper</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>
</div>
</div>