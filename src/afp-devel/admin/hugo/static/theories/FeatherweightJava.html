<div id="FJDefs">
<div class="head"><h1>Theory FJDefs</h1>
<span class="command">theory</span> <span class="name">FJDefs</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       A theory of Featherweight Java in Isabelle/HOL
    Author:      Nate Foster &lt;jnfoster at cis.upenn.edu&gt;, 
                 Dimitrios Vytiniotis &lt;dimitriv at cis.upenn.edu&gt;, 2006
    Maintainer:  Nate Foster &lt;jnfoster at cis.upenn.edu&gt;,
                 Dimitrios Vytiniotis &lt;dimitriv at cis.upenn.edu&gt;
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{\tt FJDefs}: Basic Definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FJDefs</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Syntax›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We use a named representation for terms: variables, method
names, and class names, are all represented as {\tt nat}s. We use the
finite maps defined in {\tt Map.thy} to represent typing contexts and
the static class table. This section defines the representations of
each syntactic category (expressions, methods, constructors, classes,
class tables) and defines several constants ({\tt Object} and {\tt this}).
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Type definitions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>varName</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>methodName</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>className</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>varDef</span><span>     </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>vdName</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"varName"</span></span></span><span>
</span><span>  </span><span>vdType</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"className"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>varCtx</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"varName ⇀ className"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Constants›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>Object</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"className"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Object = 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>this</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"varName"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"this == 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Expressions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>exp</span><span> </span><span class="delimiter">=</span><span> 
</span><span>    </span><span>Var</span><span> </span><span class="string"><span class="delete"><span class="delete">"varName"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>FieldProj</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"varName"</span></span></span><span>              
</span><span>  </span><span class="delimiter">|</span><span> </span><span>MethodInvk</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"methodName"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp list"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>New</span><span> </span><span class="string"><span class="delete"><span class="delete">"className"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp list"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Cast</span><span> </span><span class="string"><span class="delete"><span class="delete">"className"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exp"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Methods›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>methodDef</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>mReturn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"className"</span></span></span><span>
</span><span>  </span><span>mName</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"methodName"</span></span></span><span>
</span><span>  </span><span>mParams</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"varDef list"</span></span></span><span>
</span><span>  </span><span>mBody</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Constructors›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>constructorDef</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>kName</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"className"</span></span></span><span>
</span><span>  </span><span>kParams</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"varDef list"</span></span></span><span>
</span><span>  </span><span>kSuper</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"varName list"</span></span></span><span>
</span><span>  </span><span>kInits</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"varName list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Classes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span>classDef</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>cName</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"className"</span></span></span><span>
</span><span>  </span><span>cSuper</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"className"</span></span></span><span>
</span><span>  </span><span>cFields</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"varDef list"</span></span></span><span>
</span><span>  </span><span>cConstructor</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"constructorDef"</span></span></span><span>
</span><span>  </span><span>cMethods</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"methodDef list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Class Tables›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>classTable</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"className ⇀ classDef"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Sub-expression Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The sub-expression relation, written $t \in
\mathit{subexprs}(s)$, is defined as the reflexive and transitive
closure of the immediate subexpression relation.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>isubexprs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(exp * exp) set"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>isubexprs'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[exp,exp] ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ∈ isubexprs'(_')"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"e' ∈ isubexprs(e) ≡ (e',e) ∈ isubexprs"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>se_field</span><span>    </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ isubexprs(FieldProj e fi)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>se_invkrecv</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ isubexprs(MethodInvk e m es)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>se_invkarg</span><span>  </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ei ∈ set es ⟧ ⟹ ei ∈ isubexprs(MethodInvk e m es)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>se_newarg</span><span>   </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ei ∈ set es ⟧ ⟹ ei ∈ isubexprs(New C es)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>se_cast</span><span>     </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e ∈ isubexprs(Cast C e)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>subexprs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[exp,exp] ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ∈ subexprs'(_')"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"e' ∈ subexprs(e) ≡ (e',e) ∈ isubexprs^*"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Values›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A {\em value} is an expression of the form $\mathtt{new}\
\mathtt{C}(\mathit{overline{vs}})$, where $\mathit{\overline{vs}}$ is a list
of values.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>vals</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[exp list] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"vals'(_')"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>val</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[exp] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"val'(_')"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span>vals_nil</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vals([])"</span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>vals_cons</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ val(vh); vals(vt) ⟧ ⟹ vals((vh # vt))"</span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>val</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ vals(vs) ⟧ ⟹ val(New C vs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Substitution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The substitutions of a list of expressions $\mathit{ds}$ for a
list of variables $\mathit{xs}$ in another expression $e$ or a list of
expressions $\mathit{es}$ are defined in the obvious way, and written
$(\mathit{ds}/\mathit{xs})e$ and $[\mathit{ds}/\mathit{xs}]es$
respecitvely. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>substs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(varName ⇀ exp) ⇒ exp ⇒ exp"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subst_list1</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(varName ⇀ exp) ⇒ exp list ⇒ exp list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subst_list2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(varName ⇀ exp) ⇒ exp list ⇒ exp list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"substs σ (Var x) =             (case (σ(x)) of None ⇒ (Var x) | Some p ⇒ p)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"substs σ (FieldProj e f) =     FieldProj (substs σ e) f"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"substs σ (MethodInvk e m es) = MethodInvk (substs σ e) m (subst_list1 σ es)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"substs σ (New C es) =          New C (subst_list2 σ es)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"substs σ (Cast C e) =          Cast C (substs σ e)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_list1 σ [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_list1 σ (h # t) = (substs σ h) # (subst_list1 σ t)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_list2 σ [] = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"subst_list2 σ (h # t) = (substs σ h) # (subst_list2 σ t)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>substs_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[exp list] ⇒ [varName list] ⇒ [exp] ⇒ exp"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'(_'/_')_"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(ds/xs)e ≡ substs (map_upds Map.empty xs ds) e"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>subst_list_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[exp list] ⇒ [varName list] ⇒ [exp list] ⇒ exp list"</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"'[_'/_']_"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"[ds/xs]es ≡ map (substs (map_upds Map.empty xs ds)) es"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Lookup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The fuction $\mathit{lookup}\ f\ l$ function returns an option
containing the first element of $l$ satisfying $f$, or $\mathtt{None}$
if no such element exists 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>lookup</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ ('a ⇒ bool) ⇒ 'a option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lookup [] P = None"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup (h#t) P = (if P h then Some h else lookup t P)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>lookup2</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'a list ⇒ 'b list ⇒ ('a ⇒ bool) ⇒ 'b option"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lookup2 [] l2 P = None"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup2 (h1#t1) l2 P = (if P h1 then Some(hd l2) else lookup2 t1 (tl l2) P)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Variable Definition Accessors›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This section contains several helper functions for reading off
the names and types of variable definitions (e.g., in field
 and method parameter declarations).›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>varDefs_names</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"varDef list ⇒ varName list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"varDefs_names = map vdName"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>varDefs_types</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"varDef list ⇒ className list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"varDefs_types = map vdType"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Subtyping Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The subtyping relation, written $\mathit{CT} \vdash C
\mathtt{\lt:} D$ is just the reflexive and transitive closure of the
immediate subclass relation. (For the sake of simplicity, we define
subtyping directly instead of using the reflexive and transitive
closure operator.) The subtyping relation is extended to lists of
classes, written $\mathit{CT} \vdash\mathtt{+} \mathit{Cs} \mathtt{\lt:}
\mathit{Ds}$.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>subtyping</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, className, className] ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢ _ &lt;: _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>s_refl</span><span>  </span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: C"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>s_trans</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ CT ⊢ C &lt;: D; CT ⊢ D &lt;: E ⟧ ⟹ CT ⊢ C &lt;: E"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>s_super</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ CT(C) = Some(CDef); cSuper CDef = D ⟧ ⟹ CT ⊢ C &lt;: D"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>neg_subtyping</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, className, className] ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢ _ ¬&lt;: _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ S ¬&lt;: T ≡ ¬ CT ⊢ S &lt;: T"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>subtypings</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, className list, className list] ⇒ bool"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢+ _ &lt;: _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>ss_nil</span><span>  </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ [] &lt;: []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>ss_cons</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ CT ⊢ C0 &lt;: D0; CT ⊢+ Cs &lt;: Ds ⟧ ⟹ CT ⊢+ (C0 # Cs) &lt;: (D0 # Ds)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{\tt fields} Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The {\tt fields} relation, written
$\mathtt{fields}(\mathit{CT},C) = \mathit{Cf}$, relates $\mathit{Cf}$
to $C$ when $\mathit{Cf}$ is the list of fields declared directly or
indirectly (i.e., by a superclass) in $C$.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>fields</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, className, varDef list] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"fields'(_,_') = _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>f_obj</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fields(CT,Object) = []"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>f_class</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT(C) = Some(CDef); cSuper CDef = D; cFields CDef = Cf; fields(CT,D) = Dg; DgCf = Dg @ Cf ⟧ 
  ⟹ fields(CT,C) = DgCf"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{\tt mtype } Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The {\tt mtype} relation, written
$\mathtt{mtype}(\mathit{CT},m,C) = \mathit{Cs} \rightarrow C_0$ relates
a class $C$, method name $m$, and the arrow type $\mathit{Cs}
\rightarrow C_0$. It either returns the type of the declaration of $m$
in $C$, if any such declaration exists, and otherwise returning the
type of $m$ from $C$'s superclass.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>mtype</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, methodName, className, className list, className] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"mtype'(_,_,_') = _ → _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>mt_class</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT(C) = Some(CDef);
    lookup (cMethods CDef) (λmd.(mName md = m)) = Some(mDef);
    varDefs_types (mParams mDef) = Bs;
    mReturn mDef = B ⟧
  ⟹ mtype(CT,m,C) = Bs → B"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>mt_super</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT(C) = Some (CDef);
    lookup (cMethods CDef) (λmd.(mName md = m)) = None;
    cSuper CDef = D;
    mtype(CT,m,D) = Bs → B ⟧
  ⟹ mtype(CT,m,C) = Bs → B"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{\tt mbody} Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The {\tt mtype} relation, written
$\mathtt{mbody}(\mathit{CT},m,C) = \mathit{xs} . e_0$ relates a class
$C$, method name $m$, and the names of the parameters $\mathit{xs}$
and the body of the method $e_0$. It either returns the parameter
names and body of the declaration of $m$ in $C$, if any such
declaration exists, and otherwise the parameter names and body of $m$
from $C$'s superclass.  
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>mbody</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, methodName, className, varName list, exp] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"mbody'(_,_,_') = _ . _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>mb_class</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT(C) = Some(CDef);
     lookup (cMethods CDef) (λmd.(mName md = m)) = Some(mDef);
     varDefs_names (mParams mDef) = xs;
     mBody mDef = e ⟧
  ⟹ mbody(CT,m,C) = xs . e"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>mb_super</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT(C) = Some(CDef);
     lookup (cMethods CDef) (λmd.(mName md = m)) = None;
     cSuper CDef = D;
     mbody(CT,m,D) = xs . e ⟧
  ⟹ mbody(CT,m,C) = xs . e"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Typing Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
The typing relation, written $\mathit{CT};\Gamma \vdash e : C$
relates an expression $e$ to its type $C$, under the typing context
$\Gamma$. The multi-typing relation, written $\mathit{CT};\Gamma
\vdash\mathtt{+} \mathit{es}:\mathit{Cs}$ relates lists of expressions
to lists of types. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>typings</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, varCtx, exp list, className list] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_;_ ⊢+ _ : _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>typing</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, varCtx, exp, className] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_;_ ⊢ _ : _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>ts_nil</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ [] : []"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>ts_cons</span><span>  </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT;Γ ⊢ e0 : C0; CT;Γ ⊢+ es : Cs ⟧ 
  ⟹ CT;Γ ⊢+ (e0 # es) : (C0 # Cs)"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>t_var</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ Γ(x) = Some C ⟧ ⟹ CT;Γ ⊢ (Var x) : C"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>t_field</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT;Γ ⊢ e0 : C0;
     fields(CT,C0) = Cf;
     lookup Cf (λfd.(vdName fd = fi)) = Some(fDef);
     vdType fDef = Ci ⟧
  ⟹ CT;Γ ⊢ FieldProj e0 fi : Ci"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>t_invk</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT;Γ ⊢ e0 : C0;
     mtype(CT,m,C0) = Ds → C;
     CT;Γ ⊢+ es : Cs;
     CT ⊢+ Cs &lt;: Ds;
     length es = length Ds ⟧
  ⟹ CT;Γ ⊢ MethodInvk e0 m es : C"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>t_new</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ fields(CT,C) = Df;
     length es = length Df;
     varDefs_types Df = Ds;
     CT;Γ ⊢+ es : Cs;
     CT ⊢+ Cs &lt;: Ds ⟧
  ⟹ CT;Γ ⊢ New C es : C"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>t_ucast</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT;Γ ⊢ e0 : D; 
     CT ⊢ D &lt;: C ⟧
  ⟹ CT;Γ ⊢ Cast C e0 : C"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>t_dcast</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT;Γ ⊢ e0 : D; 
     CT ⊢ C &lt;: D; C ≠ D ⟧
  ⟹ CT;Γ ⊢ Cast C e0 : C"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>t_scast</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT;Γ ⊢ e0 : D;
     CT ⊢ C ¬&lt;: D;
     CT ⊢ D ¬&lt;: C ⟧
  ⟹ CT;Γ ⊢ Cast C e0 : C"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We occasionally find the following induction principle, which
only mentions the typing of a single expression, more useful than the
mutual induction principle generated by Isabelle, which mentions the
typings of single expressions and of lists of expressions. 
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>typing_induct</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e : C"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?T</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C CT Γ x. Γ x = Some C ⟹ P CT Γ (Var x) C"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C0 CT Cf Ci Γ e0 fDef fi. ⟦CT;Γ ⊢ e0 : C0; P CT Γ e0 C0; fields(CT,C0) = Cf; lookup Cf (λfd. vdName fd = fi) = Some fDef; vdType fDef = Ci⟧ ⟹ P CT Γ (FieldProj e0 fi) Ci"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C C0 CT Cs Ds Γ e0 es m. ⟦CT;Γ ⊢ e0 : C0; P CT Γ e0 C0; mtype(CT,m,C0) = Ds → C; CT;Γ ⊢+ es : Cs; ⋀i . ⟦ i &lt; length es ⟧ ⟹  P CT Γ (es!i) (Cs!i); CT ⊢+ Cs &lt;: Ds; length es = length Ds⟧ ⟹ P CT Γ (MethodInvk e0 m es) C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C CT Cs Df Ds Γ es. ⟦fields(CT,C) = Df; length es = length Df; varDefs_types Df = Ds; CT;Γ ⊢+ es : Cs; ⋀i. ⟦ i &lt; length es ⟧ ⟹ P CT Γ (es!i) (Cs!i); CT ⊢+ Cs &lt;: Ds⟧ ⟹ P CT Γ (New C es) C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C CT D Γ e0. ⟦CT;Γ ⊢ e0 : D; P CT Γ e0 D; CT ⊢ D &lt;: C⟧ ⟹ P CT Γ (Cast C e0) C"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C CT D Γ e0. ⟦CT;Γ ⊢ e0 : D; P CT Γ e0 D; CT ⊢ C &lt;: D; C ≠ D⟧ ⟹ P CT Γ (Cast C e0) C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C CT D Γ e0. ⟦CT;Γ ⊢ e0 : D; P CT Γ e0 D; CT ⊢ C ¬&lt;: D; CT ⊢ D ¬&lt;: C⟧ ⟹ P CT Γ (Cast C e0) C"</span></span></span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P CT Γ e C"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="var">?P</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>es</span><span> </span><span>Cs</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?IH</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ es : Cs ⟶ (∀i &lt; length es.  P CT Γ (es!i) (Cs!i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?IH ∧ (?T ⟶ ?P)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>typings_typing.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ts_nil</span><span> </span><span>CT</span><span> </span><span>Γ</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ts_cons</span><span> </span><span>CT</span><span> </span><span>Γ</span><span> </span><span>e0</span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>Cs</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length (e0#es) ⟶ P CT Γ ((e0#es)!i) ((C0#Cs)!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ts_cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_var</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_field</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_invk</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_new</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_ucast</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_dcast</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>t_scast</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Method Typing Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A method definition $\mathit{md}$, declared in a class $C$, is
well-typed, written $\mathit{CT} \vdash \mathit{md} \texttt{OK IN}\ C$
if its body is well-typed and it has the same type (i.e., overrides)
any method with the same name declared in the superclass of $C$.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>method_typing</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, methodDef, className] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢ _ OK IN _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>m_typing</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT(C) = Some(CDef);
     cName CDef = C;
     cSuper CDef = D;
     mName mDef = m;
     lookup (cMethods CDef) (λmd.(mName md = m)) = Some(mDef);
     mReturn mDef = C0; mParams mDef = Cxs; mBody mDef = e0;
     varDefs_types Cxs = Cs;
     varDefs_names Cxs = xs;
     Γ = (map_upds Map.empty xs Cs)(this ↦ C); 
     CT;Γ ⊢ e0 : E0;
     CT ⊢ E0 &lt;: C0;
     ∀Ds D0. (mtype(CT,m,D) = Ds → D0) ⟶ (Cs=Ds ∧ C0=D0) ⟧
  ⟹ CT ⊢ mDef OK IN C"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>method_typings</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, methodDef list, className] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢+ _ OK IN _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>ms_nil</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ [] OK IN C"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>ms_cons</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT ⊢ m OK IN C; 
     CT ⊢+ ms OK IN C ⟧
  ⟹ CT ⊢+ (m # ms) OK IN C"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Class Typing Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A class definition $\mathit{cd}$ is well-typed, written
$\mathit{CT}\vdash \mathit{cd} \texttt{OK}$ if its constructor
initializes each field, and all of its methods are well-typed.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>class_typing</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, classDef] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢ _ OK"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>t_class</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ cName CDef = C;            
            cSuper CDef = D;
            cConstructor CDef = KDef;
            cMethods CDef = M;
            kName KDef = C;
            kParams KDef = (Dg@Cf);
            kSuper KDef = varDefs_names Dg;
            kInits KDef = varDefs_names Cf;
            fields(CT,D) = Dg;
            CT ⊢+ M OK IN C ⟧
  ⟹ CT ⊢ CDef OK"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Class Table Typing Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A class table is well-typed, written $\mathit{CT}\
\texttt{OK}$ if for every class name $C$, the class definition mapped
to by $\mathit{CT}$ is is well-typed and has name $C$.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>ct_typing</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"classTable ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ OK"</span></span></span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>ct_all_ok</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ Object ∉ dom(CT); 
     ∀C CDef. CT(C) = Some(CDef) ⟶ (CT ⊢ CDef OK) ∧ (cName CDef = C) ⟧
  ⟹ CT OK"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Evaluation Relation›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The single-step and multi-step evaluation relations are
written $\mathit{CT} \vdash e \rightarrow e'$ and $\mathit{CT} \vdash
e \rightarrow^* e'$ respectively.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>reduction</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, exp, exp] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢ _ → _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>
</span><span>  </span><span>r_field</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ fields(CT,C) = Cf;                   
     lookup2 Cf es (λfd.(vdName fd = fi)) = Some(ei) ⟧
  ⟹ CT ⊢ FieldProj (New C es) fi → ei"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>r_invk</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ mbody(CT,m,C) = xs . e0;
     substs ((map_upds Map.empty xs ds)(this ↦ (New C es))) e0 = e0' ⟧
  ⟹ CT ⊢ MethodInvk (New C es) m ds → e0'"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>r_cast</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT ⊢ C &lt;: D ⟧ 
  ⟹ CT ⊢ Cast D (New C es) → New C es"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>rc_field</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT ⊢ e0 → e0' ⟧ 
  ⟹ CT ⊢ FieldProj e0 f → FieldProj e0' f"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>rc_invk_recv</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT ⊢ e0 → e0' ⟧ 
  ⟹ CT ⊢ MethodInvk e0 m es → MethodInvk e0' m es"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>rc_invk_arg</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT ⊢ ei → ei' ⟧
  ⟹ CT ⊢ MethodInvk e0 m (el@ei#er) → MethodInvk e0 m (el@ei'#er)"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>rc_new_arg</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT ⊢ ei → ei' ⟧ 
  ⟹ CT ⊢ New C (el@ei#er) → New C (el@ei'#er)"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>rc_cast</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ CT ⊢ e0 → e0' ⟧ 
  ⟹ CT ⊢ Cast C e0 → Cast C e0'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>reductions</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[classTable, exp, exp] ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ ⊢ _ →* _"</span></span></span><span> </span><span class="delimiter">[</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">,</span><span>80</span><span class="delimiter">]</span><span> </span><span>80</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>rs_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ e →* e"</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span>rs_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ CT ⊢ e → e'; CT ⊢ e' →* e'' ⟧ ⟹  CT ⊢ e →* e''"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="FJAux">
<div class="head"><h1>Theory FJAux</h1>
<span class="command">theory</span> <span class="name">FJAux</span><br/>
<span class="keyword">imports</span> <a href="FJDefs.html"><span class="name">FJDefs</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       A theory of Featherweight Java in Isabelle/HOL
    Author:      Nate Foster &lt;jnfoster at cis.upenn.edu&gt;, 
                 Dimitrios Vytiniotis &lt;dimitriv at cis.upenn.edu&gt;, 2006
    Maintainer:  Nate Foster &lt;jnfoster at cis.upenn.edu&gt;,
                 Dimitrios Vytiniotis &lt;dimitriv at cis.upenn.edu&gt;
    License:     LGPL

  Auxiliary lemmas
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{\tt FJAux}: Auxiliary Lemmas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FJAux</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>FJDefs</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Non-FJ Lemmas›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Lists›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_ith</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ei ∈ set es"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ el er. es = el@ei#er"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>es</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>esh</span><span> </span><span>est</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"esh = ei"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"esh ≠ ei"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ei ∈ set est"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>el</span><span> </span><span>er</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"esh # est = (esh#el) @ (ei#er)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ith_mem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. ⟦ i &lt; length es ⟧ ⟹ es!i ∈ set es"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>es</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>h</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>   
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Maps›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_shuffle</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length ys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[xs[↦]ys,x↦y] = [(xs@[x])[↦](ys@[y])]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ys"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span>list_induct2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>map_upds_append1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_upds_index</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length As"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[xs[↦]As]x = Some Ai"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i.(As!i = Ai) 
         ∧ (i &lt; length As) 
         ∧ (∀(Bs::'c list).((length Bs = length As) 
                            ⟶ ([xs[↦]Bs] x = Some (Bs !i))))"</span></span></span><span> 
</span><span>  </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. ?P i xs As"</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i.(?P1 i As) ∧ (?P2 i As) ∧ (∀Bs::('c list).(?P3 i xs As Bs))"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"xs"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"As"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[[][↦][]] x = Some Ai"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬[[][↦][]] x = Some Ai"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. ?P i [] []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>contradiction</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xa</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>length_xs_ys</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length ys"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[xs [↦] ys] x = Some Ai ⟹ ∃i. ?P i xs ys"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>map_eq_Some</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[xa # xs [↦] y # ys] x = Some Ai"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>map_decomp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[xa#xs [↦] y#ys] = [xa↦y] ++ [xs[↦]ys]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i. ?P i (xa#xs) (y # ys)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"[xs[↦]ys]x"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>Some</span><span> </span><span>Ai'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([xa ↦y] ++ [xs[↦]ys]) x = Some Ai'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>map_add_find_right</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[xs[↦]ys] x = Some Ai"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_eq_Some</span><span> </span><span>Some</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>P</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>R1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ys ! i = Ai"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>R2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ys"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>pre_r3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀(Bs::'c list). ?P3 i xs ys Bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Bs</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'c list"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>length_Bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length Bs = length (y#ys)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (y#ys) = Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>length_Bs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Bs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Bs = b#bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>length_Suc_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>length_Bs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ys = length bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pre_r3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([xa↦b] ++ [xs[↦]bs]) x = Some (bs!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>map_add_find_right</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>pre_r3</span><span> </span><span>Bs_def</span><span> </span><span>length_Bs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P3 (i+1) (xa#xs) (y#ys) Bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>R1</span><span> </span><span>R2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P (i+1) (xa#xs) (y#ys)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>map_decomp</span><span> </span><span>map_eq_Some</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[xa↦y] x = Some Ai"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>map_add_SomeD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ai_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"y = Ai"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_eq_xa</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"x=xa"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>map_upd_Some_unfold</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>Bs</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">"'c list"</span></span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>length_Bs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length Bs = length (y#ys)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (y#ys) = Suc n"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>length_Bs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>b</span><span> </span><span>bs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Bs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Bs = b#bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>length_Suc_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>length_Bs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ys = length bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"dom([xs[↦]ys]) = dom([xs[↦]bs])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>None</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[xs[↦]bs] x = None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>domIff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x_eq_xa</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sing_map</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[xa↦b] x = Some b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>map_upd_Some_unfold</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"([xa↦b] ++ [xs[↦]bs]) x = Some b"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>map_add_Some_iff</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Bs_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P3 0 (xa#xs) (y#ys) Bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ai_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P 0 (xa#xs) (y#ys)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹FJ Lemmas›</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Substitution›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_list1_eq_map_substs</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀σ. subst_list1 σ l = map (substs σ) l"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subst_list2_eq_map_substs</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"∀σ. subst_list2 σ l = map (substs σ) l"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Lookup›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_functional</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup l f = o1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup l f = o2"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"o1 = o2"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_true</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lookup l f = Some r ⟹ f r"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>Cons</span><span> </span><span>h</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f h"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lookup.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_hd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ length l &gt; 0; f (l!0) ⟧ ⟹ lookup l f = Some (l!0)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_split</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup l f = None ∨ (∃h. lookup l f = Some h)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_index</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup l1 f = Some e"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">" ⋀l2. ∃i &lt; (length l1). e = l1!i ∧ ((length l1 = length l2) ⟶ lookup2 l1 l2 f = Some (l2!i))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>l1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>h1</span><span> </span><span>t1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f h1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0&lt;length (h1 # t1) ∧ e = (h1 # t1) ! 0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lookup.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (h1 # t1) = length l2"</span></span></span><span>  
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length l2 = Suc (length t1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h2</span><span> </span><span>t2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l2_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"l2 = h2#t2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>length_Suc_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup2 (h1 # t1) l2 f = Some (l2 ! 0)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lookup2.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ (f h1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup t1 f = Some e"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lookup.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"i&lt;length t1"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e = t1 ! i"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>ih</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"(length t1 = length (tl l2) ⟶ lookup2 t1 (tl l2) f = Some ((tl l2) ! i))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc i &lt; length (h1#t1) ∧ e = (h1#t1)!(Suc i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (h1 # t1) = length l2"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>lens</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"length l2 = Suc (length t1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h2</span><span> </span><span>t2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l2_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"l2 = h2#t2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>length_Suc_conv</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup2 t1 t2 f = Some (t2 ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ih</span><span> </span><span>l2_def</span><span> </span><span>lens</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup2 (h1 # t1) l2 f = Some (l2!(Suc i))"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span>l2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lookup2.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup2_index</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀l2. ⟦ lookup2 l1 l2 f = Some e; 
  length l1 = length l2 ⟧ ⟹ ∃i &lt; (length l2). e = (l2!i) ∧ lookup l1 f = Some (l1!i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>l1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>h1</span><span> </span><span>t1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length l2 = Suc (length t1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>h2</span><span> </span><span>t2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>l2_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"l2 = h2#t2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>length_Suc_conv</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"f h1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e = h2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>l2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lookup2.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"0&lt;length (h2#t2) ∧ e = (h2#t2) ! 0 ∧ lookup (h1 # t1) f = Some ((h1 # t1) ! 0)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lookup.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"¬ (f h1)"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i&lt;length t2. e = t2 ! i ∧ lookup t1 f = Some (t1 ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>l2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i&lt;length t2 ∧  e = t2 ! i ∧ lookup t1 f = Some (t1 ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Suc i) &lt; length(h2#t2) ∧ e = ((h2#t2) ! (Suc i)) ∧ lookup (h1#t1) f = Some ((h1#t1) ! (Suc i))"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lookup.simps</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lookup_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup l f = Some r"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup (l@l') f = Some r"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>l</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>method_typings_lookup</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lookup_eq_Some</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup M f = Some mDef"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>M_ok</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ M OK IN C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ mDef OK IN C"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lookup_eq_Some</span><span> </span><span>M_ok</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>M</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>h</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"f h"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>method_typings.cases</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lookup.simps</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Functional›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹These lemmas prove that several relations are actually functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mtype_functional</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C) = Cs → C0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C) = Ds → D0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ds=Cs ∧ D0=C0"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>mtype.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mbody_functional</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mb1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mbody(CT,m,C) = xs . e0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>     </span><span>mb2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mbody(CT,m,C) = ys . d0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"xs = ys ∧ e0 = d0"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>mbody.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fields_functional</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C) = Cf"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Cf'. ⟦ fields(CT,C) = Cf'⟧ ⟹ Cf = Cf'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>f_obj</span><span> </span><span>CT</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT(Object) = None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>ct_typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_obj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>fields.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>f_class</span><span> </span><span>CT</span><span> </span><span>C</span><span> </span><span>CDef</span><span> </span><span>D</span><span> </span><span>Cf</span><span> </span><span>Dg</span><span> </span><span>DgCf</span><span> </span><span>DgCf'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>f_class_inv</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"(CT C = Some CDef) ∧ (cSuper CDef = D) ∧ (cFields CDef = Cf)"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>c_not_obj</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"C ≠ Object"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span>ct_typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>f_class</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>flds</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fields(CT,C) = DgCf'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Dg'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"fields(CT,D) = Dg'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"DgCf' = Dg' @ Cf"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_class_inv</span><span> </span><span>c_not_obj</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>fields.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Dg' = Dg"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f_class</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹DgCf = Dg @ Cf›</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹DgCf' = Dg' @ Cf›</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Subtyping and Typing›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>typings_lengths</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ es:Cs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length es = length Cs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"es"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Cs"</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typings.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>typings_index</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ es:Cs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. ⟦ i &lt; length es ⟧ ⟹ CT;Γ ⊢ (es!i) : (Cs!i)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length es = length Cs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>typings_lengths</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. ⟦ i &lt; length es ⟧ ⟹ CT;Γ ⊢ (es!i) : (Cs!i)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>es</span><span> </span><span>Cs</span><span> </span><span>rule</span><span class="delimiter">:</span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>esh</span><span> </span><span>est</span><span> </span><span>hCs</span><span> </span><span>tCs</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>i</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typings.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtypings_index</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs &lt;: Ds"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀i. ⟦ i &lt; length Cs ⟧ ⟹ CT ⊢ (Cs!i) &lt;: (Ds!i)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>ss_nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ss_cons</span><span> </span><span>hCs</span><span> </span><span>CT</span><span> </span><span>tCs</span><span> </span><span>hDs</span><span> </span><span>tDs</span><span> </span><span>i</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"i"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtyping_append</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs &lt;: Ds"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: D"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ (Cs@[C]) &lt;: (Ds@[D])"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>subtypings.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtypings.intros</span><span> </span><span>elim</span><span class="delimiter">:</span><span>subtypings.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>typings_append</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ es : Cs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e : C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (es@[e]) : (Cs@[C])"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length es = length Cs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_lengths</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (es@[e]) : (Cs@[C])"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"es"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Cs"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ []:[]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.ts_nil</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ ([]@[e]) : ([]@[C])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.ts_cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span> </span><span>xs</span><span> </span><span>y</span><span> </span><span>ys</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length ys"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦CT;Γ ⊢+ xs : ys; CT;Γ ⊢ e : C⟧ ⟹ CT;Γ ⊢+ (xs @ [e]) : (ys @ [C])"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>x_xs_typs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (x # xs) : (y # ys)"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e : C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x_xs_typs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ x : y"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ xs : ys"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typings.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IH</span><span> </span><span>e_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (xs@[e]) : (ys@[C])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ ((x#xs)@[e]) : ((y#ys)@[C])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.ts_cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ ((x # xs) @ [e]) : ((y # ys) @ [C])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.ts_cons</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ith_typing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Cs. ⟦ CT;Γ ⊢+ (es@(h#t)) : Cs ⟧ ⟹ CT;Γ ⊢ h : (Cs!(length es))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"es"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typings.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ith_subtyping</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Ds. ⟦ CT ⊢+ (Cs@(h#t)) &lt;: Ds ⟧ ⟹ CT ⊢ h &lt;: (Ds!(length Cs))"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cs"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>subtypings.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtypings_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs &lt;: Cs"</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cs"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subtyping.s_refl</span><span> </span><span>subtypings.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtypings_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Ds Es. ⟦ CT ⊢+ Cs &lt;: Ds;  CT ⊢+ Ds &lt;: Es ⟧ ⟹ CT ⊢+ Cs &lt;: Es"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cs"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>subtypings.cases</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtypings.ss_nil</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>hCs</span><span> </span><span>tCs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>hDs</span><span> </span><span>tDs</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT ⊢ hCs &lt;: hDs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ tCs &lt;: tDs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ds = hDs#tDs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>subtypings.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>hEs</span><span> </span><span>tEs</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>h2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT ⊢ hDs &lt;: hEs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ tDs &lt;: tEs"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Es = hEs#tEs"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>subtypings.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>subtyping.s_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>h1</span><span> </span><span>h2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ hCs &lt;: hEs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>t1</span><span> </span><span>t2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ tCs &lt;: tEs"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtypings.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ith_typing_sub</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀Cs. ⟦ CT;Γ ⊢+ (es@(h#t)) : Cs; 
     CT;Γ ⊢ h' : Ci'; 
     CT ⊢ Ci' &lt;: (Cs!(length es)) ⟧
  ⟹ ∃Cs'. (CT;Γ ⊢+ (es@(h'#t)) : Cs' ∧ CT ⊢+ Cs' &lt;: Cs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>es</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>hCs</span><span> </span><span>tCs</span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ t : tCs"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cs = hCs # tCs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typings.cases</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cs_def</span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ Ci' &lt;: hCs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cs_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ (Ci'#tCs) &lt;: Cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtypings.ss_cons</span><span> </span><span>subtypings_refl</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ts</span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (h'#t) : (Ci'#tCs)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.ts_cons</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>eh</span><span> </span><span>et</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>hCs</span><span> </span><span>tCs</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ eh : hCs"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (et@(h#t)) : tCs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cs_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cs = hCs # tCs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typings.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>tCs'</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (et@(h'#t)) : tCs'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ tCs' &lt;: tCs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (eh#(et@(h'#t))) : (hCs#tCs')"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ (hCs#tCs') &lt;: Cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.ts_cons</span><span> </span><span>subtypings.ss_cons</span><span> </span><span>subtyping.s_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mem_typings</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⋀Cs. ⟦ CT;Γ ⊢+ es:Cs; ei ∈ set es⟧ ⟹ ∃Ci. CT;Γ ⊢ ei:Ci"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>es</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>eh</span><span> </span><span>et</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"ei=eh"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typings.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>typings_proj</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ ds : As"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ As &lt;: Bs"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ds = length As"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ds = length Bs"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length ds"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ ds!i : As!i"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ As!i &lt;: Bs!i"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_index</span><span> </span><span>subtypings_index</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subtypings_length</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ As &lt;: Bs ⟹ length As = length Bs"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>subtypings.induct</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_subtypes_aux</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: Da"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ Da"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT C = Some CDef"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cSuper CDef = D"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ D &lt;: Da"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>subtyping.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>subtyping.intros</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_subtypes</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ A &lt;: C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀D. ⟦ CT ⊢ D ¬&lt;: C;  CT ⊢ C ¬&lt;: D⟧ ⟹ CT ⊢ A ¬&lt;: D"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>subtyping.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>s_refl</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>s_trans</span><span> </span><span>CT</span><span> </span><span>C</span><span> </span><span>D</span><span> </span><span>E</span><span> </span><span>Da</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>da_nsub_d</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT ⊢ Da ¬&lt;: D"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ CT ⊢ Da ¬&lt;: D"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>da_sub_d</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT ⊢ Da &lt;: D"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d_sub_e</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT ⊢ D &lt;: E"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping.s_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>da_sub_d</span><span> </span><span>d_sub_e</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>d_nsub_da</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT ⊢ D ¬&lt;: Da"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_trans</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>da_nsub_d</span><span> </span><span>d_nsub_da</span><span> </span><span>s_trans</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C ¬&lt;: Da"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>s_super</span><span> </span><span>CT</span><span> </span><span>C</span><span> </span><span>CDef</span><span> </span><span>D</span><span> </span><span>Da</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C ≠ Da"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ C ≠ Da"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C = Da"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ Da &lt;: D"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_super</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subtyping.s_super</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_super</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_super</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_subtypes_aux</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Sub-Expressions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isubexpr_typing</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e1 ∈ isubexprs(e0)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C. ⟦ CT;Map.empty ⊢ e0 : C ⟧ ⟹ ∃D. CT;Map.empty ⊢ e1 : D"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>isubexprs.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>mem_typings</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subexpr_typing</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e1 ∈ subexprs(e0)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C. ⟦ CT;Map.empty ⊢ e0 : C ⟧ ⟹ ∃D. CT;Map.empty ⊢ e1 : D"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>rtrancl.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>isubexpr_typing</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>isubexpr_reduct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d1 ∈ isubexprs(e1)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀d2. ⟦ CT ⊢ d1 → d2 ⟧ ⟹ ∃e2. CT ⊢ e1 → e2"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>mem_ith</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span>
</span><span>    </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>isubexprs.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span>reduction.intros</span><span class="delimiter">,</span><span>
</span><span>      </span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>reduction.intros</span><span class="delimiter">,</span><span> 
</span><span>      </span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>reduction.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subexpr_reduct</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"d1 ∈ subexprs(e1)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀d2. ⟦ CT ⊢ d1 → d2 ⟧ ⟹ ∃e2. CT ⊢ e1 → e2"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>rtrancl.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>isubexpr_reduct</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span></pre>
</div>
</div><div id="FJSound">
<div class="head"><h1>Theory FJSound</h1>
<span class="command">theory</span> <span class="name">FJSound</span><br/>
<span class="keyword">imports</span> <a href="FJAux.html"><span class="name">FJAux</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:       A theory of Featherweight Java in Isabelle/HOL
    Author:      Nate Foster &lt;jnfoster at cis.upenn.edu&gt;, 
                 Dimitrios Vytiniotis &lt;dimitriv at cis.upenn.edu&gt;, 2006
    Maintainer:  Nate Foster &lt;jnfoster at cis.upenn.edu&gt;,
                 Dimitrios Vytiniotis &lt;dimitriv at cis.upenn.edu&gt;
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹{\tt FJSound}: Type Soundness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>FJSound</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>FJAux</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Type soundness is proved using the standard technique of
progress and subject reduction. The numbered lemmas and theorems in
this section correspond to the same results in the ACM TOPLAS paper.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Method Type and Body Connection›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mtype_mbody</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>Cs</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"nat list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C) = Cs → C0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃xs e. mbody(CT,m,C) = xs . e ∧ length xs = length Cs"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>mtype.induct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>mt_class</span><span> </span><span>C0</span><span> </span><span>Cs</span><span> </span><span>C</span><span> </span><span>CDef</span><span> </span><span>CT</span><span> </span><span>m</span><span> </span><span>mDef</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>varDefs_types_def</span><span> </span><span>varDefs_names_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span>mtype.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span>mbody.mb_class</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>mt_super</span><span> </span><span>CT</span><span> </span><span>C0</span><span> </span><span>CDef</span><span> </span><span>m</span><span> </span><span>D</span><span> </span><span>Cs</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>e</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mbody(CT,m,D) = xs . e"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length Cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mt_super</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>mbody.mb_super</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mtype_mbody_length</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>mt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C) = Cs → C0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mb</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mbody(CT,m,C) = xs . e"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length Cs"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mtype_mbody</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mt</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs'</span><span> </span><span>e'</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>mb2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mbody(CT,m,C) = xs' . e'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">"length xs' = length Cs"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mbody_functional</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mb</span><span> </span><span>mb2</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Method Types and Field Declarations of Subtypes›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_1_1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: D"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(mtype(CT,m,D) = Cs → C0) ⟹ (mtype(CT,m,C) = Cs → C0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>subtyping.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>s_refl</span><span> </span><span>C</span><span> </span><span>CT</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>s_trans</span><span> </span><span>C</span><span> </span><span>CT</span><span> </span><span>D</span><span> </span><span>E</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>s_super</span><span> </span><span>CT</span><span> </span><span>C</span><span> </span><span>CDef</span><span> </span><span>D</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ CDef OK"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cName CDef = C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>ct_typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s_super</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>M</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>M</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ M OK IN C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cMethods</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"cMethods CDef = M"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>class_typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?lookup_m</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup M (λmd. (mName md =m))"</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃mDef. ?lookup_m = Some mDef"</span></span></span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>mDef</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?lookup_m = Some mDef"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>mDef_name</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mName mDef = m"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>lookup_true</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ mDef OK IN C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>M</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>method_typings_lookup</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>CDef'</span><span> </span><span>m'</span><span> </span><span>D'</span><span> </span><span>Cs'</span><span> </span><span>C0'</span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>CT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT C = Some CDef'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cSuper CDef' = D'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mName mDef = m'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mReturn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mReturn mDef = C0'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>varDefs_types</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"varDefs_types (mParams mDef) = Cs'"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀Ds D0. (mtype(CT,m',D') = Ds → D0) ⟶ Cs'=Ds ∧ C0'=D0"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>method_typing.cases</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s_super</span><span> </span><span>mDef_name</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CDef=CDef'"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"D=D'"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"m=m'"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀Ds D0. (mtype(CT,m,D) = Ds → D0) ⟶ Cs'=Ds ∧ C0' = D0"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_super</span><span> </span><span>cMethods</span><span> </span><span>m</span><span> </span><span>CT</span><span> </span><span>mReturn</span><span> </span><span>varDefs_types</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>mtype.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lookup_m = None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lookup_split</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_super</span><span> </span><span>cMethods</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>mtype.intros</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sub_fields</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: D"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀Dg. fields(CT,D) = Dg ⟹ ∃Cf. fields(CT,C) = (Dg@Cf)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>s_refl</span><span> </span><span>CT</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C) = (Dg@[])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>s_trans</span><span> </span><span>CT</span><span> </span><span>C</span><span> </span><span>D</span><span> </span><span>E</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Df</span><span> </span><span>Cf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C) = ((Dg@Df)@Cf)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>s_super</span><span> </span><span>CT</span><span> </span><span>C</span><span> </span><span>CDef</span><span> </span><span>D</span><span> </span><span>Dg</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cFields CDef = Cf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>s_super</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C) = (Dg@Cf)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>f_class</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Substitution Lemma›</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_1_2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ = Γ1 ++ Γ2"</span></span></span><span>                            
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ2 = [xs [↦] Bs]"</span></span></span><span>                         
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length ds"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length Bs = length ds"</span></span></span><span>                      
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃As. CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ es:Ds ⟹ ∃Cs. (CT;Γ1 ⊢+ ([ds/xs]es):Cs ∧ CT ⊢+ Cs &lt;: Ds)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?TYPINGS ⟹ ?P1"</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e:D ⟹ ∃C. (CT;Γ1 ⊢ ((ds/xs)e):C ∧ CT ⊢ C &lt;: D)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?TYPING ⟹ ?P2"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?COMMON_ASMS</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT OK) ∧ (Γ = Γ1 ++ Γ2) ∧ (Γ2 = [xs [↦] Bs]) ∧ (length Bs = length ds) ∧ (∃As. CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>RESULT</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"  (?TYPINGS ⟶ ?COMMON_ASMS ⟶ ?P1)
               ∧ (?TYPING ⟶ ?COMMON_ASMS ⟶ ?P2)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>typings_typing.induct</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>ts_nil</span><span> </span><span>CT</span><span> </span><span>Γ</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT;Γ1 ⊢+ ([ds/xs][]):[]) ∧ (CT ⊢+ [] &lt;: [])"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_typing.intros</span><span> </span><span>subtypings.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Cs.(CT;Γ1 ⊢+ ([ds/xs][]):Cs) ∧ (CT ⊢+ Cs &lt;: [])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>ts_cons</span><span> </span><span>CT</span><span> </span><span>Γ</span><span> </span><span>e0</span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>Cs'</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT OK) ∧ (Γ = Γ1 ++ Γ2) ∧ (Γ2 = [xs [↦] Bs]) ∧ (length Bs = length ds) ∧ (∃As. CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ts_cons</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e0_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e0 : C0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>ts_cons</span><span> </span><span>asms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"∃C.(CT;Γ1 ⊢ (ds/xs) e0 : C) ∧ (CT ⊢ C &lt;: C0)"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Cs.(CT;Γ1 ⊢+ [ds/xs]es : Cs) ∧ (CT ⊢+ Cs &lt;: Cs')"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span>Cs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"(CT;Γ1 ⊢ (ds/xs) e0 : C) ∧ (CT ⊢ C &lt;: C0)"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT;Γ1 ⊢+ [ds/xs]es : Cs) ∧ (CT ⊢+ Cs &lt;: Cs')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢+ [ds/xs](e0#es) : (C#Cs)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ (C#Cs) &lt;: (C0#Cs')"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_typing.intros</span><span> </span><span>subtypings.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Cs. CT;Γ1 ⊢+ map (substs [xs [↦] ds]) (e0 # es) : Cs ∧ CT ⊢+ Cs &lt;: (C0 # Cs')"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>t_var</span><span> </span><span>Γ</span><span> </span><span>x</span><span> </span><span>C'</span><span> </span><span>CT</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT OK) ∧ (Γ = Γ1 ++ Γ2) ∧ (Γ2 = [xs [↦] Bs]) ∧ (length Bs = length ds) ∧ (∃As. CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> 
</span><span>        </span><span>lengths</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ds = length Bs"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>G_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ = Γ1 ++ Γ2"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>G2_def</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ2 = [xs[↦]Bs]"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lengths</span><span> </span><span>G2_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>same_doms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"dom([xs[↦]ds]) = dom(Γ2)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asms</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃C. CT;Γ1 ⊢ substs [xs [↦] ds] (Var x) : C ∧ CT ⊢ C &lt;: C'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ2 x"</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>None</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>G_def</span><span> </span><span>t_var</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>G1_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ1 x = Some C'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>map_add_Some_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>None</span><span> </span><span>same_doms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∉ dom([xs[↦]ds])"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>domIff</span><span class="delimiter">)</span><span>      
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"[xs[↦]ds]x = None"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>map_add_Some_iff</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ds/xs)(Var x) = (Var x)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>G1_x</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)(Var x) : C'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C' &lt;: C'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.intros</span><span> </span><span>subtyping.intros</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Some</span><span> </span><span>Bi</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>G_def</span><span> </span><span>t_var</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c'_eq_bi</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C' = Bi"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_add_SomeD</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹length xs = length ds›</span></span></span><span> </span><span>asms</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length Bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Some</span><span> </span><span>G2_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i.(Bs!i = Bi) ∧ (i &lt; length Bs) ∧
            (∀l.((length l = length Bs) ⟶ ([xs[↦]l] x = Some (l!i))))"</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_upds_index</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>bs_i_proj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Bs!i = Bi)"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>i_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length Bs"</span></span></span><span>
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋀(l::exp list).((length l = length Bs) ⟶ ([xs[↦]l] x = Some (l!i))))"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lengths</span><span> </span><span>P</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subst_x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"([xs[↦]ds]x = Some (ds!i))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>As</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>as_ex</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length As = length Bs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subtypings_length</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>proj_i</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ ds!i : As!i ∧ CT ⊢ As!i &lt;: Bs!i"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_len</span><span> </span><span>lengths</span><span> </span><span>as_ex</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_proj</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)(Var x) : As!i ∧ CT ⊢ As!i &lt;: C'"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c'_eq_bi</span><span> </span><span>bs_i_proj</span><span> </span><span>subst_x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>t_field</span><span> </span><span>CT</span><span> </span><span>Γ</span><span> </span><span>e0</span><span> </span><span>C0</span><span> </span><span>Cf</span><span> </span><span>fi</span><span> </span><span>fDef</span><span> </span><span>Ci</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT OK) ∧ (Γ = Γ1 ++ Γ2) ∧
        (Γ2 = [xs [↦] Bs]) ∧ (length Bs = length ds) ∧ (∃As. CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_field</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>flds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C0) = Cf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_field</span><span> </span><span>asms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e0_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)e0 : C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: C0"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sub_fields</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sub</span><span> </span><span>flds</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Dg</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>flds_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C) = (Cf@Dg)"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_field</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lookup_CfDg</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup (Cf@Dg) (λfd. vdName fd = fi) = Some fDef"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lookup_append</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>e0_typ</span><span> </span><span>flds_C</span><span> </span><span>lookup_CfDg</span><span> </span><span>t_field</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)(FieldProj e0 fi) : Ci"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ Ci &lt;: Ci"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃C. CT;Γ1 ⊢ (ds/xs)(FieldProj e0 fi) : C ∧ CT ⊢ C &lt;: Ci"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>t_invk</span><span> </span><span>CT</span><span> </span><span>Γ</span><span> </span><span>e0</span><span> </span><span>C0</span><span> </span><span>m</span><span> </span><span>Ds</span><span> </span><span>C</span><span> </span><span>es</span><span> </span><span>Cs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT OK) ∧ (Γ = Γ1 ++ Γ2) ∧ (Γ2 = [xs [↦] Bs])
          ∧ (length Bs = length ds) ∧ (∃As. CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ct_ok</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_invk</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mtyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C0) = Ds → C"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs &lt;: Ds"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lens</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length es = length Ds"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_invk</span><span> </span><span>asms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span>e0_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)e0 : C'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sub'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C' &lt;: C0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_invk</span><span> </span><span>asms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span>es_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢+ [ds/xs]es : Cs'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subs'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs' &lt;: Cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subst_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ds/xs)(MethodInvk e0 m es) = MethodInvk ((ds/xs)e0) m ([ds/xs]es)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_list1_eq_map_substs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> 
</span><span>        </span><span>e0_typ</span><span>
</span><span>        </span><span>A_1_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sub'</span><span> </span><span>ct_ok</span><span> </span><span>mtyp</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>es_typ</span><span>
</span><span>        </span><span>subtypings_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subs'</span><span> </span><span>subs</span><span class="delimiter">]</span><span> 
</span><span>        </span><span>lens</span><span> 
</span><span>        </span><span>subst_e</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)(MethodInvk e0 m es) : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃C'. CT;Γ1 ⊢ (ds/xs)(MethodInvk e0 m es) : C' ∧ CT ⊢ C' &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>t_new</span><span> </span><span>CT</span><span> </span><span>C</span><span> </span><span>Df</span><span> </span><span>es</span><span> </span><span>Ds</span><span> </span><span>Γ</span><span> </span><span>Cs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT OK) ∧ (Γ = Γ1 ++ Γ2) ∧ (Γ2 = [xs [↦] Bs]) ∧ (length Bs = length ds) ∧ (∃As. CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ct_ok</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_new</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>        </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs &lt;: Ds"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>flds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C) = Df"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length es = length Df"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>vdts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"varDefs_types Df = Ds"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_new</span><span> </span><span>asms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cs'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>es_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢+ [ds/xs]es : Cs'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subs'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs' &lt;: Cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>subst_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ds/xs)(New C es) = New C ([ds/xs]es)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subst_list2_eq_map_substs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>es_typ</span><span> </span><span>subtypings_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>subs'</span><span> </span><span>subs</span><span class="delimiter">]</span><span> </span><span>flds</span><span> </span><span>subst_e</span><span> </span><span>len</span><span> </span><span>vdts</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)(New C es) : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃C'. CT;Γ1 ⊢ (ds/xs)(New C es) : C' ∧ CT ⊢ C' &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>t_ucast</span><span> </span><span>CT</span><span> </span><span>Γ</span><span> </span><span>e0</span><span> </span><span>D</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT OK) ∧ (Γ = Γ1 ++ Γ2) ∧ (Γ2 = [xs [↦] Bs]) ∧ (length Bs = length ds) ∧ (∃As. CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_ucast</span><span> </span><span>asms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e0_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)e0 : C'"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>sub1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C' &lt;: D"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>sub2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT ⊢ D &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sub1</span><span> </span><span>sub2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C' &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>s_trans</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e0_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)(Cast C e0) : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_typing.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>s_refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃C'. CT;Γ1 ⊢ (ds/xs)(Cast C e0) : C' ∧ CT ⊢ C' &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>t_dcast</span><span> </span><span>CT</span><span> </span><span>Γ</span><span> </span><span>e0</span><span> </span><span>D</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT OK) ∧ (Γ = Γ1 ++ Γ2) ∧ (Γ2 = [xs [↦] Bs]) ∧ (length Bs = length ds) ∧ (∃As. CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_dcast</span><span> </span><span>asms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e0_typ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)e0 : C'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT ⊢ C' &lt;: C)  ∨ 
        (C ≠ C' ∧ CT ⊢ C &lt;: C') ∨ 
        (CT ⊢ C ¬&lt;: C' ∧ CT ⊢ C' ¬&lt;: C)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C' &lt;: C"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e0_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs) (Cast C e0) : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_typing.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C ≠ C' ∧ CT ⊢ C &lt;: C')"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e0_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs) (Cast C e0) : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_typing.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT ⊢ C ¬&lt;: C' ∧ CT ⊢ C' ¬&lt;: C)"</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e0_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs) (Cast C e0) : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_typing.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs) (Cast C e0) : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>s_refl</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃C'. CT;Γ1 ⊢ (ds/xs)(Cast C e0) : C' ∧ CT ⊢ C' &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>t_scast</span><span> </span><span>CT</span><span> </span><span>Γ</span><span> </span><span>e0</span><span> </span><span>D</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asms</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT OK) ∧ (Γ = Γ1 ++ Γ2) ∧ (Γ2 = [xs [↦] Bs]) ∧ (length Bs = length ds) ∧ (∃As. CT;Γ1 ⊢+ ds : As ∧ CT ⊢+ As &lt;: Bs)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>t_scast</span><span> </span><span>asms</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e0_typ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs)e0 : C'"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sub1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C' &lt;: D"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nsub1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C ¬&lt;: D"</span></span></span><span>  
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>nsub2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ D ¬&lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>not_subtypes</span><span class="delimiter">[</span><span>OF</span><span> </span><span>sub1</span><span> </span><span>nsub1</span><span> </span><span>nsub2</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C' ¬&lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C ¬&lt;: C'"</span></span></span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ CT ⊢ C ¬&lt;: C'"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: C'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: D"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sub1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>s_trans</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>nsub1</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"False"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ1 ⊢ (ds/xs) (Cast C e0) : C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e0_typ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_typing.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃C'. CT;Γ1 ⊢ (ds/xs)(Cast C e0) : C' ∧ CT ⊢ C' &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>s_refl</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?TYPINGS ⟹ ?P1"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?TYPING ⟹ ?P2"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Weakening Lemma›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹This lemma is not in the same form as in TOPLAS, but rather as
we need it in subject reduction›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_1_3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT;Γ2 ⊢+ es : Cs) ⟹ (CT;Γ1++Γ2 ⊢+ es : Cs)"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P1 ⟹ ?P2"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ2 ⊢ e : C ⟹ CT;Γ1++Γ2 ⊢ e : C"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q1 ⟹ ?Q2"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(?P1 ⟶ ?P2) ∧ (?Q1 ⟶ ?Q2)"</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>typings_typing.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>map_add_find_right</span><span> </span><span>typings_typing.intros</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?P1 ⟹ ?P2"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q1 ⟹ ?Q2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Method Body Typing Lemma›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_1_4</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ct_ok</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mb</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mbody(CT,m,C) = xs . e"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C) = Ds → D"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃D0 C0. (CT ⊢ C &lt;: D0) ∧ 
                (CT ⊢ C0 &lt;: D) ∧ 
                (CT;[xs[↦]Ds](this ↦ D0) ⊢ e : C0)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mb</span><span> </span><span>ct_ok</span><span> </span><span>mt</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>mbody.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>mb_class</span><span> </span><span>CT</span><span> </span><span>C</span><span> </span><span>CDef</span><span> </span><span>m</span><span> </span><span>mDef</span><span> </span><span>xs</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span>
</span><span>    </span><span>m_param</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"varDefs_types (mParams mDef) = Ds"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>m_ret</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mReturn mDef = D"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ CDef OK"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cName CDef = C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>mtype.cases</span><span> </span><span>ct_typing.cases</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ (cMethods CDef) OK IN C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>class_typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ mDef OK IN C"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mb_class</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>method_typings_lookup</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃ E0. ((CT;[xs[↦]Ds,this↦C] ⊢ e : E0) ∧ (CT ⊢ E0 &lt;: D))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mb_class</span><span> </span><span>m_param</span><span> </span><span>m_ret</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>method_typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>E0</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;[xs[↦]Ds,this↦C] ⊢ e : E0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ E0 &lt;: D"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>s_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>mb_super</span><span> </span><span>CT</span><span> </span><span>C</span><span> </span><span>CDef</span><span> </span><span>m</span><span> </span><span>Da</span><span> </span><span>xs</span><span> </span><span>e</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>ct</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦CT OK; mtype(CT,m,Da) = Ds → D⟧ 
    ⟹ ∃D0 C0. (CT ⊢ Da &lt;: D0) ∧ (CT ⊢ C0 &lt;: D) 
              ∧ (CT;[xs [↦] Ds, this ↦ D0] ⊢ e:C0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mb_super</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c_sub_da</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C &lt;: Da"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>s_super</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>mb_super</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,Da) = Ds → D"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>mtype.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ct</span><span> </span><span>mt</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D0</span><span> </span><span>C0</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ Da &lt;: D0"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C0 &lt;: D"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;[xs [↦] Ds, this ↦ D0] ⊢ e : C0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>c_sub_da</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Subject Reduction Theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Thm_2_4_1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ e → e'"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C. ⟦ CT;Γ ⊢ e : C ⟧ 
  ⟹ ∃C'. (CT;Γ ⊢ e' : C' ∧ CT ⊢ C' &lt;: C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reduction.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>r_field</span><span> </span><span>CT</span><span> </span><span>Ca</span><span> </span><span>Cf</span><span> </span><span>es</span><span> </span><span>fi</span><span> </span><span>e'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ FieldProj (New Ca es) fi : C"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ct_ok</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>flds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,Ca) = Cf"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lkup2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup2 Cf es (λfd. vdName fd = fi) = Some e'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Ca'</span><span> </span><span>Cf'</span><span> </span><span>fDef</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>new_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ New Ca es : Ca'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>flds'</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"fields(CT,Ca') = Cf'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lkup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup Cf' (λfd. vdName fd = fi) = Some fDef"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vdType fDef = C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>Ca_Ca'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ca = Ca'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>flds'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Cf_Cf'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cf = Cf'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fields_functional</span><span class="delimiter">[</span><span>OF</span><span> </span><span>flds</span><span> </span><span>ct_ok</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>new_typ</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cs</span><span> </span><span>Ds</span><span> </span><span>Cf''</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,Ca') = Cf''"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>es_typs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ es:Cs"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ds_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"varDefs_types Cf'' = Ds"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>length_Cf_es</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length Cf'' = length es"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs &lt;: Ds"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Ca_Ca'</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span>Cf_Cf''</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cf = Cf''"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>fields_functional</span><span class="delimiter">[</span><span>OF</span><span> </span><span>flds</span><span> </span><span>ct_ok</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>length_Cf_es</span><span> </span><span>Cf_Cf''</span><span> </span><span>lookup2_index</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lkup2</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>i_bound</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length es"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e' = es!i"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup Cf (λfd. vdName fd = fi) = Some (Cf!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>C_def</span><span> </span><span>Ds_def</span><span> </span><span>lkup</span><span> </span><span>lkup2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Ds!i = C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ca_Ca'</span><span> </span><span>Cf_Cf'</span><span> </span><span>Cf_Cf''</span><span> </span><span>i_bound</span><span> </span><span>length_Cf_es</span><span> </span><span>flds'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>nth_map</span><span> </span><span>varDefs_types_def</span><span> </span><span>fields_functional</span><span class="delimiter">[</span><span>OF</span><span> </span><span>flds</span><span> </span><span>ct_ok</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>subs</span><span> </span><span>es_typs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ (es!i):(Cs!i)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ (Cs!i) &lt;: (Ds!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>i_bound</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_index</span><span> </span><span>subtypings_index</span><span> </span><span>typings_lengths</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>r_invk</span><span> </span><span>CT</span><span> </span><span>m</span><span> </span><span>Ca</span><span> </span><span>xs</span><span> </span><span>e</span><span> </span><span>ds</span><span> </span><span>es</span><span> </span><span>e'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>r_invk</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mbody(CT,m,Ca) = xs . e"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>r_invk</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Ca'</span><span> </span><span>Ds</span><span> </span><span>Cs</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ New Ca es : Ca'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,Ca') = Cs → C"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ds_typs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ ds : Ds"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ds_subs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Ds &lt;: Cs"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>l1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length ds = length Cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>new_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ New Ca es : Ca"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,Ca) = Cs → C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ds_typs</span><span> </span><span>new_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (ds @[New Ca es]) : (Ds @[Ca])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A_1_4</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>mb</span><span> </span><span>mt</span><span class="delimiter">]</span><span> </span><span>r_invk</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Da</span><span> </span><span>E</span><span>  
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ Ca &lt;: Da"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E_sub_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ E &lt;: C"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e0_typ1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;[xs[↦]Cs,this↦Da] ⊢ e : E"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Ds_subs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ (Ds@[Ca]) &lt;: (Cs@[Da])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃As. CT;Γ ⊢+ (ds @[New Ca es]) : As ∧ CT ⊢+ As &lt;: (Cs@[Da])"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>e0_typ1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e0_typ2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;(Γ ++ [xs[↦]Cs,this↦Da]) ⊢ e : E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>A_1_3</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>e0_typ2</span><span> </span><span>mtype_mbody_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mt</span><span> </span><span>mb</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>e0_typ3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;(Γ ++ [(xs@[this])[↦](Cs@[Da])]) ⊢ e : E"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>map_shuffle</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?Γ1</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="var">?Γ2</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"[(xs@[this])[↦](Cs@[Da])]"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>g_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(?Γ1 ++ ?Γ2) = (?Γ1 ++ ?Γ2)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>g2_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?Γ2 = ?Γ2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>A_1_2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>g_def</span><span> </span><span>g2_def</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>ex</span><span class="delimiter">]</span><span> </span><span>e0_typ3</span><span> </span><span>r_invk</span><span> </span><span>l1</span><span> </span><span>mtype_mbody_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mt</span><span> </span><span>mb</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>E'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e'_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ substs [(xs@[this])[↦](ds@[New Ca es])] e : E'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E'_sub_E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ E' &lt;: E"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>e'_typ</span><span> </span><span>l1</span><span> </span><span>mtype_mbody_length</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mt</span><span> </span><span>mb</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ substs [xs[↦]ds,this↦(New Ca es)] e : E'"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span>map_shuffle</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>E'_sub_E</span><span> </span><span>E_sub_C</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ E' &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subtyping.s_trans</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_invk</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>r_cast</span><span> </span><span>CT</span><span> </span><span>Ca</span><span> </span><span>D</span><span> </span><span>es</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Ca'</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C = D"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ New Ca es : Ca'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r_cast</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rc_field</span><span> </span><span>CT</span><span> </span><span>e0</span><span> </span><span>e0'</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>Cf</span><span> </span><span>fd</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e0 : C0"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cf_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C0) = Cf"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>fd_def</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"lookup Cf (λfd. (vdName fd = f))  = Some fd"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vdType fd = C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rc_field</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C'</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e0' : C'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C' &lt;: C0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>sub_fields</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>Cf_def</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cf'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C') = (Cf@Cf')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>rule</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹CT ⊢ C' &lt;: C0›</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fd_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup (Cf@Cf') (λfd. (vdName fd = f)) = Some fd"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lookup_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ FieldProj e0' f : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.t_field</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping.s_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rc_invk_recv</span><span> </span><span>CT</span><span> </span><span>e0</span><span> </span><span>e0'</span><span> </span><span>m</span><span> </span><span>es</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>Ds</span><span> </span><span>Cs</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ct_ok</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e0 : C0"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C0) = Ds → C"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ es : Cs"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length es = length Ds"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs &lt;: Ds"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rc_invk_recv</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0'</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e0' : C0'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C0' &lt;: C0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>A_1_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>ct_ok</span><span> </span><span>mt</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C0') = Ds → C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ MethodInvk e0' m es : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.t_invk</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping.s_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rc_invk_arg</span><span> </span><span>CT</span><span> </span><span>ei</span><span> </span><span>ei'</span><span> </span><span>e0</span><span> </span><span>m</span><span> </span><span>el</span><span> </span><span>er</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cs</span><span> </span><span>Ds</span><span> </span><span>C0</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>typs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (el@(ei#er)) : Cs"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e0_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e0 : C0"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C0) = Ds → C"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cs_sub_Ds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs &lt;: Ds"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (el@(ei#er)) = length Ds"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ ei:(Cs!(length el))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>ith_typing</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rc_invk_arg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Ci'</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ei_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ ei':Ci'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ci_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ Ci' &lt;: (Cs!(length el))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ith_typing_sub</span><span class="delimiter">[</span><span>OF</span><span> </span><span>typs</span><span> </span><span>ei_typ</span><span> </span><span>Ci_sub</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cs'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>es'_typs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (el@(ei'#er)) : Cs'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cs'_sub_Cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs' &lt;: Cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>len</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (el@(ei'#er)) = length Ds"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>es'_typs</span><span> </span><span>subtypings_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cs'_sub_Cs</span><span> </span><span>Cs_sub_Ds</span><span class="delimiter">]</span><span>  </span><span>e0_typ</span><span> </span><span>mt</span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ MethodInvk e0 m (el@(ei'#er)) : C"</span></span></span><span>      
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.t_invk</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping.s_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rc_new_arg</span><span> </span><span>CT</span><span> </span><span>ei</span><span> </span><span>ei'</span><span> </span><span>Ca</span><span> </span><span>el</span><span> </span><span>er</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cs</span><span> </span><span>Df</span><span> </span><span>Ds</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>typs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (el@(ei#er)) : Cs"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>flds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C) = Df"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length (el@(ei#er)) = length Df"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ds_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"varDefs_types Df = Ds"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cs_sub_Ds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs &lt;: Ds"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ca = C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ ei:(Cs!(length el))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>ith_typing</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rc_new_arg</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Ci'</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ei_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ ei':Ci'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ci_sub</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ Ci' &lt;: (Cs!(length el))"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ith_typing_sub</span><span class="delimiter">[</span><span>OF</span><span> </span><span>typs</span><span> </span><span>ei_typ</span><span> </span><span>Ci_sub</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cs'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>es'_typs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (el@(ei'#er)) : Cs'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Cs'_sub_Cs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢+ Cs' &lt;: Cs"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>len</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length (el@(ei'#er)) = length Df"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>es'_typs</span><span> </span><span>subtypings_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cs'_sub_Cs</span><span> </span><span>Cs_sub_Ds</span><span class="delimiter">]</span><span> </span><span>flds</span><span> </span><span>Ds_def</span><span> </span><span>C_def</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ New Ca (el@(ei'#er)) : C"</span></span></span><span>      
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_typing.t_new</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping.s_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rc_cast</span><span> </span><span>CT</span><span> </span><span>e0</span><span> </span><span>e0'</span><span> </span><span>C</span><span> </span><span>Ca</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e0 : D"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Ca_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Ca = C"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>rc_cast</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D'</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e0'_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e0':D'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ D' &lt;: D"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT ⊢ D' &lt;: C)  ∨ 
    (C ≠ D' ∧ CT ⊢ C &lt;: D') ∨ 
    (CT ⊢ C ¬&lt;: D' ∧ CT ⊢ D' ¬&lt;: C)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ D' &lt;: C"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e0'_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ Cast C e0' : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_typing.t_ucast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(C ≠ D' ∧ CT ⊢ C &lt;: D')"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e0'_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ Cast C e0' : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_typing.t_dcast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(CT ⊢ C ¬&lt;: D' ∧ CT ⊢ D' ¬&lt;: C)"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>e0'_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ Cast C e0' : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>typings_typing.t_scast</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ Cast C e0' : C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Ca_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping.s_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Multi-Step Subject Reduction Theorem›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">corollary</span></span><span> </span><span>Cor_2_4_1_multi</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ e →* e'"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀C. ⟦ CT;Γ ⊢ e : C ⟧ ⟹ ∃C'. (CT;Γ ⊢ e' : C' ∧ CT ⊢ C' &lt;: C)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>induct</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>rs_refl</span><span> </span><span>CT</span><span> </span><span>e</span><span> </span><span>C</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subtyping.s_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span class="delimiter">(</span><span>rs_trans</span><span> </span><span>CT</span><span> </span><span>e</span><span> </span><span>e'</span><span> </span><span>e''</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>e_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e : C"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>e_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ e → e'"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ct_ok</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>IH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀D. ⟦CT;Γ ⊢ e' : D; CT OK⟧ ⟹ ∃E. CT;Γ ⊢ e'' : E ∧ CT ⊢ E &lt;: D"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Thm_2_4_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>e_step</span><span> </span><span>ct_ok</span><span> </span><span>e_typ</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e'_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e' : D"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D_sub_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ D &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>IH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>e'_typ</span><span> </span><span>ct_ok</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>E</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e'': E"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>E_sub_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ E &lt;: D"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>s_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>E_sub_D</span><span> </span><span>D_sub_C</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ E &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Progress›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The two "progress lemmas" proved in the TOPLAS paper alone are
not quite enough to prove type soundness. We prove an additional lemma
showing that every well-typed expression is either a value or contains
a potential redex as a sub-expression.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Thm_2_4_2_1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ e : C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"FieldProj (New C0 es) fi ∈ subexprs(e)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃Cf fDef. fields(CT, C0) = Cf ∧ lookup Cf (λfd. (vdName fd = fi)) = Some fDef"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Ci</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ (FieldProj (New C0 es) fi) : Ci"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subexpr_typing</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cf</span><span> </span><span>fDef</span><span> </span><span>C0'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ (New C0 es) : C0'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C0') = Cf"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup Cf (λfd. (vdName fd = fi)) = Some fDef"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Thm_2_4_2_2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>es</span><span> </span><span>ds</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"exp list"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ e : C"</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"MethodInvk (New C0 es) m ds ∈ subexprs(e)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃xs e0. mbody(CT,m,C0) = xs . e0 ∧ length xs = length ds"</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ MethodInvk (New C0 es) m ds : D"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subexpr_typing</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0'</span><span> </span><span>Cs</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ (New C0 es) : C0'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>mt</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C0') = Cs → D"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ds = length Cs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mtype_mbody</span><span class="delimiter">[</span><span>OF</span><span> </span><span>mt</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>closed_subterm_split</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ e : C"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ = Map.empty"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"
  ((∃C0 es fi. (FieldProj (New C0 es) fi) ∈ subexprs(e))  
  ∨ (∃C0 es m ds. (MethodInvk (New C0 es) m ds) ∈ subexprs(e))
  ∨ (∃C0 D es. (Cast D (New C0 es)) ∈ subexprs(e))
  ∨ val(e))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F e ∨ ?M e ∨ ?C e ∨ ?V e"</span></span></span><span> </span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?IH e"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>CT</span><span> </span><span>Γ</span><span> </span><span>e</span><span> </span><span>C</span><span> </span><span>rule</span><span class="delimiter">:</span><span>typing_induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>1</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>C</span><span> </span><span>CT</span><span> </span><span>Γ</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>3</span><span> </span><span>C0</span><span> </span><span>Ct</span><span> </span><span>Cf</span><span> </span><span>Ci</span><span> </span><span>Γ</span><span> </span><span>e0</span><span> </span><span>fDef</span><span> </span><span>fi</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e0 ∈ subexprs(FieldProj e0 fi)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>isubexprs.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?IH e0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>fi'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FieldProj (New C0 es) fi' ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>m</span><span> </span><span>ds</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"MethodInvk (New C0 es) m ds ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>D</span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cast D (New C0 es) ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e0 = (New C0 es)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vals(es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span>val.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>isubexprs.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>4</span><span> </span><span>C</span><span> </span><span>C0</span><span> </span><span>CT</span><span> </span><span>Cs</span><span> </span><span>Ds</span><span> </span><span>Γ</span><span> </span><span>e0</span><span> </span><span>es</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e0 ∈ subexprs(MethodInvk e0 m es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>isubexprs.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>4</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?IH e0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>fi</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FieldProj (New C0 es) fi ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es'</span><span> </span><span>m'</span><span> </span><span>ds</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"MethodInvk (New C0 es') m' ds ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>D</span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cast D (New C0 es) ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e0 = (New C0 es')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vals(es')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span>val.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>isubexprs.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>5</span><span> </span><span>C</span><span> </span><span>CT</span><span> </span><span>Cs</span><span> </span><span>Df</span><span> </span><span>Ds</span><span> </span><span>Γ</span><span> </span><span>es</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"length es = length Cs"</span></span></span><span>    
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⋀ i. ⟦i &lt; length es; CT;Γ ⊢ (es!i) : (Cs!i); Γ = Map.empty⟧ ⟹ ?IH (es!i)"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ es : Cs"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>typings_lengths</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(∃i &lt; length es. (?F (es!i) ∨ ?M (es!i) ∨ ?C (es!i))) ∨ (vals(es))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q es"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">"es"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Cs"</span></span></span><span> </span><span>rule</span><span class="delimiter">:</span><span>list_induct2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q []"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>vals_val.intros</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>h</span><span> </span><span>t</span><span> </span><span>Ch</span><span> </span><span>Ct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>5</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>h_t_typs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ (h#t) : (Ch#Ct)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>OIH</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀ i. ⟦i &lt; length (h#t); CT;Γ ⊢ ((h#t)!i) : ((Ch#Ct)!i); Γ = Map.empty⟧ ⟹ ?IH ((h#t)!i)"</span></span></span><span>
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>G_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Γ = Map.empty"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>h_t_typs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>        </span><span>h_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢ (h#t)!0 : (Ch#Ct)!0"</span></span></span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>t_typs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Γ ⊢+ t : Ct"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typings.cases</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length t"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>s_i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Suc i &lt; length (h#t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>OIH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s_i</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦i &lt; length t; CT;Γ ⊢ (t!i) : (Ct!i); Γ = Map.empty⟧ ⟹ ?IH (t!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>t_typs</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q t"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i &lt; length t. (?F (t!i) ∨ ?M (t!i) ∨ ?C (t!i))"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length t"</span></span></span><span> 
</span><span>          </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F (t!i) ∨ ?M (t!i) ∨ ?C (t!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(Suc i &lt; length (h#t)) ∧ (?F ((h#t)!(Suc i)) ∨ ?M ((h#t)!(Suc i)) ∨ ?C ((h#t)!(Suc i)))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i &lt; length (h#t). (?F ((h#t)!i) ∨ ?M ((h#t)!i) ∨ ?C ((h#t)!i))"</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q (h#t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>v_t</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"vals(t)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>OIH</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>h_typ</span><span> </span><span>G_def</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?IH h"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F h ∨ ?M h ∨ ?C h"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F ((h#t)!0) ∨ ?M ((h#t)!0) ∨ ?C ((h#t)!0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q (h#t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V h"</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>v_t</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vals((h#t))"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>vals_val.intros</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q(h#t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q(h#t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?Q(h#t)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃i&lt;length es. ?F (es!i) ∨ ?M (es!i) ∨ ?C(es!i)"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>i_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"i &lt; length es"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"?F (es!i) ∨ ?M (es!i) ∨ ?C(es!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ith_mem</span><span class="delimiter">[</span><span>OF</span><span> </span><span>i_len</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"es!i ∈ subexprs(New C es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>isubexprs.se_newarg</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F (es!i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es'</span><span> </span><span>fi</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FieldProj (New C0 es') fi ∈ subexprs(es!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F(New C es) ∨ ?M(New C es) ∨ ?C(New C es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M (es!i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es'</span><span> </span><span>m'</span><span> </span><span>ds</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"MethodInvk (New C0 es') m' ds ∈ subexprs(es!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F(New C es) ∨ ?M(New C es) ∨ ?C(New C es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C (es!i)"</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>D</span><span> </span><span>es'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cast D (New C0 es') ∈ subexprs(es!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F(New C es) ∨ ?M(New C es) ∨ ?C(New C es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F(New C es) ∨ ?M(New C es) ∨ ?C(New C es)"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>r</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vals(es)"</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>vals_val.intros</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>6</span><span> </span><span>C</span><span> </span><span>CT</span><span> </span><span>D</span><span> </span><span>Γ</span><span> </span><span>e0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e0 ∈ subexprs(Cast C e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>isubexprs.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>6</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?IH e0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>fi</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FieldProj (New C0 es) fi ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>m</span><span> </span><span>ds</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"MethodInvk (New C0 es) m ds ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>D'</span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cast D' (New C0 es) ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e0 = (New C0 es')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vals(es')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span>val.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>isubexprs.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>7</span><span> </span><span>C</span><span> </span><span>CT</span><span> </span><span>D</span><span> </span><span>Γ</span><span> </span><span>e0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e0 ∈ subexprs(Cast C e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>isubexprs.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>7</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?IH e0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>fi</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FieldProj (New C0 es) fi ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>m</span><span> </span><span>ds</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"MethodInvk (New C0 es) m ds ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>D'</span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cast D' (New C0 es) ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e0 = (New C0 es')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vals(es')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span>val.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>isubexprs.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>8</span><span> </span><span>C</span><span> </span><span>CT</span><span> </span><span>D</span><span> </span><span>Γ</span><span> </span><span>e0</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"e0 ∈ subexprs(Cast C e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>isubexprs.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>8</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?IH e0"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>fi</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FieldProj (New C0 es) fi ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>m</span><span> </span><span>ds</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"MethodInvk (New C0 es) m ds ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>D'</span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cast D' (New C0 es) ∈ subexprs(e0)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>rtrancl_trans</span><span class="delimiter">[</span><span>OF</span><span> </span><span>s2</span><span> </span><span>s1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V e0"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"e0 = (New C0 es')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"vals(es')"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span>val.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>isubexprs.intros</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Type Soundness Theorem›</span></span></span><span>     
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Thm_2_4_3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>e_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ e : C"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ct_ok</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT OK"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>multisteps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ e →* e1"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>no_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬(∃e2. CT ⊢ e1 → e2)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(val(e1) ∧ (∃D. CT;Map.empty ⊢ e1 : D ∧ CT ⊢ D &lt;: C))
      ∨ (∃D C es. (Cast D (New C es) ∈ subexprs(e1) ∧ CT ⊢ C ¬&lt;: D))"</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>assms</span><span> </span><span>Cor_2_4_1_multi</span><span class="delimiter">[</span><span>OF</span><span> </span><span>multisteps</span><span> </span><span>ct_ok</span><span> </span><span>e_typ</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C1</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>e1_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ e1 : C1"</span></span></span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>C1_sub_C</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C1 &lt;: C"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>e1_typ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"((∃C0 es fi. (FieldProj (New C0 es) fi) ∈ subexprs(e1))  
    ∨ (∃C0 es m ds. (MethodInvk (New C0 es) m ds) ∈ subexprs(e1))
    ∨ (∃C0 D es. (Cast D (New C0 es)) ∈ subexprs(e1))
    ∨ val(e1))"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F e1 ∨ ?M e1 ∨ ?C e1 ∨ ?V e1"</span></span></span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>closed_subterm_split</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?F e1"</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>fi</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>fp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"FieldProj (New C0 es) fi ∈ subexprs(e1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Ci</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ FieldProj (New C0 es) fi : Ci"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e1_typ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subexpr_typing</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>new_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ New C0 es : C0'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"C0 = C0'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>new_typ</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Df</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C0) = Df"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lens</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"length es = length Df"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Thm_2_4_2_1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>e1_typ</span><span> </span><span>fp</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Cf</span><span> </span><span>fDef</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"fields(CT,C0) = Cf"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>lkup</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup Cf (λfd. vdName fd = fi) = Some(fDef)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>fields_functional</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f1</span><span> </span><span>ct_ok</span><span> </span><span>f2</span><span class="delimiter">]</span><span> </span><span>lens</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length es = length Cf"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>lookup_index</span><span class="delimiter">[</span><span>OF</span><span> </span><span>lkup</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"i&lt;length Cf"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fDef = Cf ! i"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(length Cf = length es) ⟶ lookup2 Cf es (λfd. vdName fd = fi) = Some (es ! i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"lookup2 Cf es (λfd. vdName fd = fi) = Some (es!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ FieldProj(New C0 es) fi → (es!i)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span>reduction.intros</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>fp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃e2. CT ⊢ e1 → e2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subexpr_reduct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>no_step</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?M e1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>es</span><span> </span><span>m</span><span> </span><span>ds</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>mi</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"MethodInvk (New C0 es) m ds ∈ subexprs(e1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ MethodInvk (New C0 es) m ds : D"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e1_typ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subexpr_typing</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0'</span><span> </span><span>Es</span><span> </span><span>E</span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ New C0 es : C0'"</span></span></span><span> 
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,C0') = Es → E"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length ds = length Es"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Thm_2_4_2_2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>e1_typ</span><span> </span><span>mi</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>e0</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>mb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"mbody(CT, m, C0) = xs . e0"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"length xs = length ds"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ (MethodInvk (New C0 es) m ds) → (substs[xs[↦]ds,this↦(New C0 es)]e0)"</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>reduction.intros</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>mi</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃e2. CT ⊢ e1 → e2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subexpr_reduct</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>no_step</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?C e1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0</span><span> </span><span>D</span><span> </span><span>es</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>c_def</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Cast D (New C0 es) ∈ subexprs(e1)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>D'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ Cast D (New C0 es) : D'"</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e1_typ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subexpr_typing</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>C0'</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>new_typ</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT;Map.empty ⊢ New C0 es : C0'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>D_eq_D'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"D = D'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>C0_eq_C0'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"C0 = C0'"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span>typing.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ C0 &lt;: D"</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ Cast D (New C0 es) → (New C0 es)"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>reduction.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c_def</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃e2. CT ⊢ e1 → e2"</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>subexpr_reduct</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>no_step</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>c_def</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?V e1"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Cor_2_4_1_multi</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span> 
</span></pre>
</div>
</div><div id="Execute">
<div class="head"><h1>Theory Execute</h1>
<span class="command">theory</span> <span class="name">Execute</span><br/>
<span class="keyword">imports</span> <a href="FJSound.html"><span class="name">FJSound</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Author:      Lukas Bulwahn, TU Muenchen, 2009  *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Execute</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>FJSound</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹Executing FeatherweightJava programs›</span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We execute FeatherweightJava programs using the predicate compiler.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_pred</span></span><span> </span><span class="delimiter">(</span><span>modes</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>bool</span><span class="delimiter">,</span><span>
</span><span>  </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>o</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>bool</span><span> </span><span>as</span><span> </span><span>supertypes_of</span><span class="delimiter">)</span><span> </span><span>subtyping</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>subtyping.equation</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹The reduction relation requires that we inverse the @{term List.append} function.
Therefore, we define a new predicate append and derive introduction rules.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>append</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"append xs ys zs = (zs = xs @ ys)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code_pred_intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"append [] xs xs"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code_pred_intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"append xs ys zs ⟹ append (x#xs) ys (x#zs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹With this at hand, we derive new introduction rules for the reduction relation:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rc_invk_arg'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ ei → ei' ⟹ append el (ei # er) e' ⟹ append el (ei' # er) e'' ⟹
CT ⊢ MethodInvk e m e' → MethodInvk e m e''"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduction.intros</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>rc_new_arg'</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"CT ⊢ ei → ei' ⟹ append el (ei # er) e ⟹ append el (ei' # er) e'
   ==&gt; CT ⊢ New C e → New C e'"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>reduction.intros</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span class="delimiter">[</span><span>code_pred_intro</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>reduction.intros</span><span class="delimiter">(</span><span>1</span><span>-</span><span>5</span><span class="delimiter">)</span><span>
</span><span>  </span><span>rc_invk_arg'</span><span> </span><span>rc_new_arg'</span><span> </span><span>reduction.intros</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_pred</span></span><span> </span><span class="delimiter">(</span><span>modes</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>bool</span><span class="delimiter">,</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>o</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>bool</span><span> </span><span>as</span><span> </span><span>reduce</span><span class="delimiter">)</span><span> </span><span>reduction</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>append</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xa</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>reduction</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>reduction.prems</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reduction.cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>r_field</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reduction</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>r_invk</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reduction</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>r_cast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reduction</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>rc_field</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reduction</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>rc_invk_recv</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reduction</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>rc_invk_arg</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reduction</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>rc_new_arg</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reduction</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>rc_cast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>reduction</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>reduction.equation</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_pred</span></span><span> </span><span>reductions</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>reductions.equation</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We also make the class typing executable: this requires that
  we derive rules for @{term "method_typing"}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>method_typing_aux</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"method_typing_aux CT m D Cs C = (¬ (∀Ds D0. mtype(CT,m,D) = Ds → D0 ⟶ Cs = Ds ∧ C = D0))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>method_typing_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀Ds D0. mtype(CT,m,D) = Ds → D0 ⟶ Cs = Ds ∧ C = D0) = (¬ method_typing_aux CT m D Cs C)"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>method_typing_aux_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code_pred_intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,D) = Ds → D0 ⟹ Cs ≠ Ds ⟹ method_typing_aux CT m D Cs C"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>method_typing_aux_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>code_pred_intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mtype(CT,m,D) = Ds → D0 ⟹ C ≠ D0 ⟹ method_typing_aux CT m D Cs C"</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>method_typing_aux_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>method_typing.intros</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>method_typing_aux</span><span class="delimiter">,</span><span> </span><span>code_pred_intro</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>class_typing.intros</span><span class="delimiter">[</span><span>unfolded</span><span> </span><span>append_def</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>code_pred_intro</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">code_pred</span></span><span> </span><span class="delimiter">(</span><span>modes</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>i</span><span> </span><span class="delimiter">=&gt;</span><span> </span><span>bool</span><span class="delimiter">)</span><span> </span><span>class_typing</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>class_typing</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>class_typing.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>class_typing.prems</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>thesis</span><span class="delimiter">]</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>method_typing</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>method_typing.cases</span><span class="delimiter">[</span><span>OF</span><span> </span><span>method_typing.prems</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>thesis</span><span class="delimiter">]</span><span> </span><span>this</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>append_def</span><span> </span><span>method_typing_aux_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>method_typing_aux</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span>thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>method_typing_aux_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹A simple example›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹We now execute a simple FJ example program:›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>A</span><span> </span><span class="delimiter">::</span><span> </span><span>className</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A == Suc 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>B</span><span> </span><span class="delimiter">::</span><span> </span><span>className</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"B == 2"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>cPair</span><span> </span><span class="delimiter">::</span><span> </span><span>className</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"cPair == 3"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>classA_Def</span><span> </span><span class="delimiter">::</span><span> </span><span>classDef</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"classA_Def = ⦇ cName = A, cSuper = Object, cFields = [], cConstructor = ⦇kName = A, kParams = [], kSuper = [], kInits = []⦈, cMethods = []⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"classB_Def = ⦇ cName = B, cSuper = Object, cFields = [], cConstructor = ⦇kName = B, kParams = [], kSuper = [], kInits = []⦈, cMethods = []⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ffst</span><span> </span><span class="delimiter">::</span><span> </span><span>varName</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ffst == 4"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>fsnd</span><span> </span><span class="delimiter">::</span><span> </span><span>varName</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fsnd == 5"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>setfst</span><span> </span><span class="delimiter">::</span><span> </span><span>methodName</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"setfst == 6"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>newfst</span><span> </span><span class="delimiter">::</span><span> </span><span>varName</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"newfst == 7"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>classPair_Def</span><span> </span><span class="delimiter">::</span><span> </span><span>classDef</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"classPair_Def = ⦇ cName = cPair, cSuper = Object,
    cFields = [⦇ vdName = ffst, vdType = Object ⦈, ⦇ vdName = fsnd, vdType = Object ⦈],
    cConstructor = ⦇ kName = cPair, kParams = [⦇ vdName = ffst, vdType = Object ⦈, ⦇ vdName = fsnd, vdType = Object ⦈], kSuper = [], kInits = [ffst, fsnd]⦈ ,
    cMethods = [⦇ mReturn = cPair, mName = setfst, mParams = [⦇vdName = newfst, vdType = Object ⦈],
      mBody = New cPair [Var newfst, FieldProj (Var this) fsnd]  ⦈]⦈"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>exampleProg</span><span> </span><span class="delimiter">::</span><span> </span><span>classTable</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exampleProg = (((%x. None)(A := Some classA_Def))(B := Some classB_Def))(cPair := Some classPair_Def)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exampleProg ⊢ classA_Def OK"</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exampleProg ⊢ classB_Def OK"</span></span></span><span>
</span><span class="keyword1"><span class="command">value</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"exampleProg ⊢ classPair_Def OK"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">values</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x. exampleProg ⊢ MethodInvk (New cPair [New A [], New B []]) setfst [New B []] →* x}"</span></span></span><span>
</span><span class="keyword1"><span class="command">values</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"{x. exampleProg ⊢ FieldProj (FieldProj (New cPair [New cPair [New A [], New B []], New A []]) ffst) fsnd →* x}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Featherweight_Java">
<div class="head"><h1>Theory Featherweight_Java</h1>
<span class="command">theory</span> <span class="name">Featherweight_Java</span><br/>
<span class="keyword">imports</span> <a href="Execute.html"><span class="name">Execute</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Featherweight_Java</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>FJSound</span><span> </span><span>Execute</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>