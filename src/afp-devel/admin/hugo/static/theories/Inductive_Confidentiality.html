<div id="Message">
<div class="head">
<h1>Theory Message</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      HOL/Auth/Message.thy
    Author:     Lawrence C Paulson, Cambridge University Computer Laboratory
    Copyright   1996  University of Cambridge

Datatypes of agents and messages;
Inductive relations "parts", "analz" and "synth"
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Theory of Agents and Messages for Security Protocols against Dolev-Yao›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Message
<span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*Needed occasionally with spy_analz_tac, e.g. in analz_insert_Key_newK*)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∪</span> <span class="main">(</span><span class="free">B</span> <span class="main">∪</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="free">B</span> <span class="main">∪</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">type_synonym</span></span>
  key <span class="main">=</span> <span class="quoted">nat</span>

<span class="keyword1"><span class="command">consts</span></span>
  all_symmetric <span class="main">::</span> <span class="quoted">bool</span>        <span class="comment1">― ‹true if all keys are symmetric›</span>
  invKey        <span class="main">::</span> <span class="quoted"><span class="quoted">"key<span class="main">=&gt;</span>key"</span></span>  <span class="comment1">― ‹inverse of a symmetric key›</span>

<span class="keyword1"><span class="command">specification</span></span> <span class="main">(</span><span class="quoted">invKey</span><span class="main">)</span>
  invKey <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"invKey <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">=</span> <span class="free">K</span>"</span></span>
  invKey_symmetric<span class="main">:</span> <span class="quoted"><span class="quoted">"all_symmetric <span class="main">--&gt;</span> invKey <span class="main">=</span> id"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">id</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The inverse of a symmetric key is itself; that of a public key
      is the private key and vice versa›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">symKeys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"key set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">symKeys</span> <span class="main">==</span> <span class="main">{</span><span class="bound">K</span><span class="main">.</span> invKey <span class="bound">K</span> <span class="main">=</span> <span class="bound">K</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">datatype</span></span>  <span class="comment1">― ‹We allow any number of friendly agents›</span>
  agent <span class="main">=</span> Server <span class="main">|</span> Friend <span class="quoted">nat</span> <span class="main">|</span> Spy

<span class="keyword1"><span class="command">datatype</span></span>
     msg <span class="main">=</span> Agent  <span class="quoted">agent</span>     <span class="comment1">― ‹Agent names›</span>
         <span class="main">|</span> Number <span class="quoted">nat</span>       <span class="comment1">― ‹Ordinary integers, timestamps, ...›</span>
         <span class="main">|</span> Nonce  <span class="quoted">nat</span>       <span class="comment1">― ‹Unguessable nonces›</span>
         <span class="main">|</span> Key    <span class="quoted">key</span>       <span class="comment1">― ‹Crypto keys›</span>
         <span class="main">|</span> Hash   <span class="quoted">msg</span>       <span class="comment1">― ‹Hashing›</span>
         <span class="main">|</span> MPair  <span class="quoted">msg</span> <span class="quoted">msg</span>   <span class="comment1">― ‹Compound messages›</span>
         <span class="main">|</span> Crypt  <span class="quoted">key</span> <span class="quoted">msg</span>   <span class="comment1">― ‹Encryption, public- or shared-key›</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Concrete syntax: messages appear as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⦃A,B,NA⦄›</span></span></span></span>, etc...›</span></span>
<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_MTuple"</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'a</span><span class="main">,</span> args<span class="main">]</span> <span class="main">=&gt;</span> <span class="tfree">'a</span> <span class="main">*</span> <span class="tfree">'b</span>"</span></span>  <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span><span class="keyword1">⦃</span>_<span class="keyword1">,</span><span class="keyword3">/ </span>_<span class="keyword1">⦄</span><span class="keyword3">)</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"<span class="main">⦃</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">⦄</span>"</span>   <span class="main">==</span> <span class="quoted">"<span class="main">⦃</span><span class="free">x</span><span class="main">,</span> <span class="main">⦃</span><span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">⦄</span><span class="main">⦄</span>"</span>
  <span class="quoted">"<span class="main">⦃</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">⦄</span>"</span>      <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> MPair <span class="free">x</span> <span class="free">y</span>"</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">HPair</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>msg<span class="main">,</span>msg<span class="main">]</span> <span class="main">=&gt;</span> msg"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(4</span><span class="keyword1">Hash[</span>_<span class="keyword1">]</span> <span class="keyword3">/</span>_<span class="keyword3">)</span>"</span> <span class="main">[</span>0<span class="main">,</span> 1000<span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="comment1">― ‹Message Y paired with a MAC computed with the help of X›</span>
    <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">Hash[</span></span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main"><span class="free">]</span></span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">==</span> <span class="main">⦃</span> Hash<span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">keysFor</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set <span class="main">=&gt;</span> key set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="comment1">― ‹Keys useful to decrypt elements of a message set›</span>
  <span class="quoted"><span class="quoted">"<span class="free">keysFor</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> invKey <span class="main">`</span> <span class="main">{</span><span class="bound">K</span><span class="main">.</span> <span class="main">∃</span><span class="bound">X</span><span class="main">.</span> Crypt <span class="bound">K</span> <span class="bound">X</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Inductive definition of all parts of a message›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span>
  <span class="entity">parts</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set <span class="main">=&gt;</span> msg set"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">H</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    Inj <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>               <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">H</span> <span class="main">==&gt;</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Fst<span class="main">:</span>         <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span>   <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span> <span class="main">==&gt;</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Snd<span class="main">:</span>         <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span>   <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span> <span class="main">==&gt;</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Body<span class="main">:</span>        <span class="quoted"><span class="quoted">"Crypt <span class="free"><span class="bound"><span class="entity">K</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span> <span class="main">==&gt;</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Monotonicity›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> parts_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">⊆</span> <span class="free">H</span> <span class="main">==&gt;</span> parts<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> parts<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> parts.Fst parts.Snd parts.Body<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Equations hold because constructors are injective.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Friend_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Friend <span class="free">x</span> <span class="main">∈</span> Friend<span class="main">`</span><span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">:</span><span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Key_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Key <span class="free">x</span> <span class="main">∈</span> Key<span class="main">`</span><span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">∈</span><span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_Key_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nonce <span class="free">x</span> <span class="main">∉</span> Key<span class="main">`</span><span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Inverse of keys›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> invKey_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>invKey <span class="free">K</span> <span class="main">=</span> invKey <span class="free">K'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">K</span><span class="main">=</span><span class="free">K'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> invKey<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹keysFor operator›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_Un <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span><span class="free">H</span> <span class="main">∪</span> <span class="free">H'</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span> <span class="main">∪</span> keysFor <span class="free">H'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_UN <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> keysFor <span class="main">(</span><span class="free">H</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Monotonicity›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> keysFor_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">⊆</span> <span class="free">H</span> <span class="main">==&gt;</span> keysFor<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> keysFor<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Agent <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Agent <span class="free">A</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Nonce <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Nonce <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Number <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Number <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Hash <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Hash <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_MPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Crypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">(</span>keysFor <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_image_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>Key<span class="main">`</span><span class="free">E</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_imp_invKey_keysFor<span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> <span class="free">H</span> <span class="main">==&gt;</span> invKey <span class="free">K</span> <span class="main">∈</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Inductive relation "parts"›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> MPair_parts<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> parts <span class="free">H</span><span class="main">;</span>        
         <span class="main">[|</span> <span class="free">X</span> <span class="main">∈</span> parts <span class="free">H</span><span class="main">;</span> <span class="free">Y</span> <span class="main">∈</span> parts <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">P</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> parts.Fst parts.Snd<span class="main">)</span> 

<span class="keyword1"><span class="command">declare</span></span> MPair_parts <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main">!</span></span><span class="main">]</span>  parts.Body <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹NB These two rules are UNSAFE in the formal sense, as they discard the
     compound message.  They work well on THIS FILE.  
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>MPair_parts›</span></span></span></span> is left as SAFE because it speeds up proofs.
  The Crypt rule is normally kept UNSAFE to avoid breaking up certificates.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_increasing<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">H</span> <span class="main">⊆</span> parts<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> parts_insertI <span class="main">=</span> subset_insertI <span class="main">[</span><span class="operator">THEN</span> parts_mono<span class="main">,</span> <span class="operator">THEN</span> subsetD<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_emptyE <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> parts<span class="main">{}</span> <span class="main">==&gt;</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹WARNING: loops if H = {Y}, therefore must not be repeated!›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> parts_singleton<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> parts <span class="free">H</span> <span class="main">==&gt;</span> <span class="main">∃</span><span class="bound">Y</span><span class="main">∈</span><span class="free">H</span><span class="main">.</span> <span class="free">X</span><span class="main">∈</span> parts <span class="main">{</span><span class="bound">Y</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">fast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Unions›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_Un_subset1<span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">∪</span> parts<span class="main">(</span><span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> parts<span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Un_least parts_mono Un_upper1 Un_upper2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_Un_subset2<span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> parts<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">∪</span> parts<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_Un <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">∪</span> parts<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI parts_Un_subset1 parts_Un_subset2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="main">{</span><span class="free">X</span><span class="main">}</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insert_is_Un parts_Un<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹TWO inserts to avoid looping.  This rewrite is better than nothing.
  Not suitable for Addsimps: its behaviour can be strange.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> parts_insert2<span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="free">X</span> <span class="main">(</span>insert <span class="free">Y</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> parts <span class="main">{</span><span class="free">X</span><span class="main">}</span> <span class="main">∪</span> parts <span class="main">{</span><span class="free">Y</span><span class="main">}</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_commute Un_empty_right Un_insert_right insert_is_Un parts_Un<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_UN_subset1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> parts<span class="main">(</span><span class="free">H</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> parts<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> UN_least parts_mono UN_upper<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_UN_subset2<span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> parts<span class="main">(</span><span class="free">H</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_UN <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> parts<span class="main">(</span><span class="free">H</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI parts_UN_subset1 parts_UN_subset2<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Added to simplify arguments to parts, analz and synth.
  NOTE: the UN versions are no longer used!›</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This allows <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>blast›</span></span></span></span> to simplify occurrences of 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"parts<span class="main"><span class="main">(</span></span><span class="free"><span class="free">G</span></span><span class="main"><span class="main">∪</span></span><span class="free"><span class="free">H</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the assumption.›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> in_parts_UnE <span class="main">=</span> parts_Un <span class="main">[</span><span class="operator">THEN</span> equalityD1<span class="main">,</span> <span class="operator">THEN</span> subsetD<span class="main">,</span> <span class="operator">THEN</span> UnE<span class="main">]</span> 
<span class="keyword1"><span class="command">declare</span></span> in_parts_UnE <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main">!</span></span><span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> parts_insert_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="free">X</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> parts<span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> parts_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Idempotence and transitivity›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_partsD <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> parts <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span> <span class="main">==&gt;</span> <span class="free">X</span><span class="main">∈</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_subset_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>parts <span class="free">G</span> <span class="main">⊆</span> parts <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">G</span> <span class="main">⊆</span> parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> parts_idem parts_increasing parts_mono subset_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">X</span><span class="main">∈</span> parts <span class="free">G</span><span class="main">;</span>  <span class="free">G</span> <span class="main">⊆</span> parts <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">X</span><span class="main">∈</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> parts_subset_iff subsetD<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Cut›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> parts_cut<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">Y</span><span class="main">∈</span> parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">G</span><span class="main">)</span><span class="main">;</span>  <span class="free">X</span><span class="main">∈</span> parts <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">Y</span><span class="main">∈</span> parts <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> parts_trans<span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> parts_cut_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> parts <span class="free">H</span> <span class="main">==&gt;</span> parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insert_absorb parts_idem parts_insert<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Rewrite rules for pulling out atomic messages›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> parts_insert_eq_I <span class="main">=</span> equalityI <span class="main">[</span><span class="operator">OF</span> subsetI parts_insert_subset<span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Agent <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Agent <span class="free">agt</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Agent <span class="free">agt</span><span class="main">)</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parts_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Nonce <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Nonce <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Nonce <span class="free">N</span><span class="main">)</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parts_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Number <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Number <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Number <span class="free">N</span><span class="main">)</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parts_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parts_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Hash <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Hash <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Hash <span class="free">X</span><span class="main">)</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parts_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Crypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> parts.Body<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_MPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>  
          insert <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">(</span>parts <span class="main">(</span>insert <span class="free">X</span> <span class="main">(</span>insert <span class="free">Y</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> parts.Fst parts.Snd<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_image_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>Key<span class="main">`</span><span class="free">N</span><span class="main">)</span> <span class="main">=</span> Key<span class="main">`</span><span class="free">N</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In any message, there is an upper bound N on its greatest nonce.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> msg_Nonce_supply<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">N</span><span class="main">.</span> <span class="main">∀</span><span class="bound">n</span><span class="main">.</span> <span class="bound">N</span><span class="main">≤</span><span class="bound">n</span> <span class="main">--&gt;</span> Nonce <span class="bound">n</span> <span class="main">∉</span> parts <span class="main">{</span><span class="free">msg</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">msg</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exI parts_insert2<span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Nonce case›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Suc_n_not_le_n<span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹MPair case: metis works out the necessary sum itself!›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> le_trans nat_le_linear<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Inductive relation "analz"›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Inductive definition of "analz" -- what can be broken down from a set of
    messages, including keys.  A form of downward closure.  Pairs can
    be taken apart; messages decrypted with known keys.›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span>
  <span class="entity">analz</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set <span class="main">=&gt;</span> msg set"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">H</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    Inj <span class="main">[</span><span class="operator">intro</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span>    <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">H</span> <span class="main">==&gt;</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Fst<span class="main">:</span>     <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span> <span class="main">==&gt;</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Snd<span class="main">:</span>     <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span> <span class="main">==&gt;</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Decrypt <span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span> 
             <span class="quoted"><span class="quoted">"<span class="main">[|</span>Crypt <span class="free"><span class="bound"><span class="entity">K</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span><span class="main">;</span> Key<span class="main">(</span>invKey <span class="free"><span class="bound"><span class="entity">K</span></span></span><span class="main">)</span><span class="main">:</span> <span class="free">analz</span> <span class="free">H</span><span class="main">|]</span> <span class="main">==&gt;</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Monotonicity; Lemma 1 of Lowe's paper›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G</span><span class="main">⊆</span><span class="free">H</span> <span class="main">==&gt;</span> analz<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> analz<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz.Fst analz.Snd<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Making it safe speeds up proofs›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> MPair_analz <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span>        
             <span class="main">[|</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span> <span class="free">Y</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">P</span>   
          <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz.Fst analz.Snd<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_increasing<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">H</span> <span class="main">⊆</span> analz<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_subset_parts<span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="free">H</span> <span class="main">⊆</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> analz_into_parts <span class="main">=</span> analz_subset_parts <span class="main">[</span><span class="operator">THEN</span> subsetD<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> not_parts_not_analz <span class="main">=</span> analz_subset_parts <span class="main">[</span><span class="operator">THEN</span> contra_subsetD<span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> parts_analz <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> analz_increasing analz_subset_parts equalityI parts_mono parts_subset_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_parts <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> analz_insertI <span class="main">=</span> subset_insertI <span class="main">[</span><span class="operator">THEN</span> analz_mono<span class="main">,</span> <span class="operator">THEN</span> <span class="main"><span class="main">[</span></span>2<span class="main"><span class="main">]</span></span> rev_subsetD<span class="main">]</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹General equational properties›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz<span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Converse fails: we can analz more from the union than from the 
  separate parts, as a key in one might decrypt a message in the other›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"analz<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">∪</span> analz<span class="main">(</span><span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> analz<span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Un_least analz_mono Un_upper1 Un_upper2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="free">X</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> analz<span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Rewrite rules for pulling out atomic messages›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> analz_insert_eq_I <span class="main">=</span> equalityI <span class="main">[</span><span class="operator">OF</span> subsetI analz_insert<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Agent <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Agent <span class="free">agt</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Agent <span class="free">agt</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Nonce <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Nonce <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Nonce <span class="free">N</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Number <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Number <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Number <span class="free">N</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Hash <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Hash <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Hash <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Can only pull out Keys if they are not needed to decrypt the rest›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="free">K</span> <span class="main">∉</span> keysFor <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">==&gt;</span>   
          analz <span class="main">(</span>insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_MPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>  
          insert <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="main">(</span>insert <span class="free">Y</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz.Fst analz.Snd<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Can pull out enCrypted message if the Key is not known›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Crypt<span class="main">:</span>
     <span class="quoted"><span class="quoted">"Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∉</span> analz <span class="free">H</span> 
      <span class="main">==&gt;</span> analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 

<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lemma1<span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">==&gt;</span>   
               analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span>  
               insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lemma2<span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">==&gt;</span>   
               insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span>  
               analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_insertI analz.Decrypt<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Decrypt<span class="main">:</span>
     <span class="quoted"><span class="quoted">"Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">==&gt;</span>   
               analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>  
               insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI lemma1 lemma2<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Case analysis: either the message is secure, or it is not! Effective,
but can cause subgoals to blow up! Use with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>if_split›</span></span></span></span>; apparently
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>split_tac›</span></span></span></span> does not cope with patterns such as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span><span class="quoted"><span class="quoted">"analz <span class="main"><span class="main">(</span></span>insert
<span class="main"><span class="main">(</span></span>Crypt <span class="free"><span class="free">K</span></span> <span class="free"><span class="free">X</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">H</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span> 
<span class="keyword1"><span class="command">lemma</span></span> analz_Crypt_if <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>                 
          <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">)</span>                 
           <span class="keyword1">then</span> insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>  
           <span class="keyword1">else</span> insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> analz_insert_Crypt analz_insert_Decrypt<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This rule supposes "for the sake of argument" that we have the key.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Crypt_subset<span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span>   
           insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> analz_image_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>Key<span class="main">`</span><span class="free">N</span><span class="main">)</span> <span class="main">=</span> Key<span class="main">`</span><span class="free">N</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Idempotence and transitivity›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_analzD <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> analz <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">==&gt;</span> <span class="free">X</span><span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_subset_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>analz <span class="free">G</span> <span class="main">⊆</span> analz <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">G</span> <span class="main">⊆</span> analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> analz_idem analz_increasing analz_mono subset_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">X</span><span class="main">∈</span> analz <span class="free">G</span><span class="main">;</span>  <span class="free">G</span> <span class="main">⊆</span> analz <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">X</span><span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> analz_mono<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Cut; Lemma 2 of Lowe›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_cut<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">Y</span><span class="main">∈</span> analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">;</span>  <span class="free">X</span><span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">Y</span><span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> analz_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="comment1">(*Cut can be proved easily by induction on
   "Y: analz (insert X H) ==&gt; X: analz H --&gt; Y: analz H"
*)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This rewrite rule helps in the simplification of messages that involve
  the forwarding of unknown components (X).  Without it, removing occurrences
  of X can be very complicated.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_insert_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> analz <span class="free">H</span> <span class="main">==&gt;</span> analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> analz_cut analz_insert_eq_I insert_absorb<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹A congruence rule for "analz"›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_subset_cong<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> analz <span class="free">G</span> <span class="main">⊆</span> analz <span class="free">G'</span><span class="main">;</span> analz <span class="free">H</span> <span class="main">⊆</span> analz <span class="free">H'</span> <span class="main">|]</span> 
      <span class="main">==&gt;</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> analz <span class="main">(</span><span class="free">G'</span> <span class="main">∪</span> <span class="free">H'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_mono analz_Un analz_subset_iff subset_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_cong<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> analz <span class="free">G</span> <span class="main">=</span> analz <span class="free">G'</span><span class="main">;</span> analz <span class="free">H</span> <span class="main">=</span> analz <span class="free">H'</span> <span class="main">|]</span> 
      <span class="main">==&gt;</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="main">(</span><span class="free">G'</span> <span class="main">∪</span> <span class="free">H'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI analz_subset_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_cong<span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="free">H</span> <span class="main">=</span> analz <span class="free">H'</span> <span class="main">==&gt;</span> analz<span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz<span class="main">(</span>insert <span class="free">X</span> <span class="free">H'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> insert_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> analz_cong<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹If there are no pairs or encryptions then analz does nothing›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_trivial<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="main">∀</span><span class="bound">X</span> <span class="bound">Y</span><span class="main">.</span> <span class="main">⦃</span><span class="bound">X</span><span class="main">,</span><span class="bound">Y</span><span class="main">⦄</span> <span class="main">∉</span> <span class="free">H</span><span class="main">;</span>  <span class="main">∀</span><span class="bound">X</span> <span class="bound">K</span><span class="main">.</span> Crypt <span class="bound">K</span> <span class="bound">X</span> <span class="main">∉</span> <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> analz <span class="free">H</span> <span class="main">=</span> <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹These two are obsolete (with a single Spy) but cost little to prove...›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_UN_analz_lemma<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> analz <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> analz <span class="main">(</span><span class="free">H</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">==&gt;</span> <span class="free">X</span><span class="main">∈</span> analz <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_UN_analz <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> analz <span class="main">(</span><span class="free">H</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> analz <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_UN_analz_lemma analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Inductive relation "synth"›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Inductive definition of "synth" -- what can be built up from a set of
    messages.  A form of upward closure.  Pairs can be built, messages
    encrypted with known keys.  Agent names are public domain.
    Numbers can be guessed, but Nonces cannot be.›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span>
  <span class="entity">synth</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set <span class="main">=&gt;</span> msg set"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">H</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    Inj    <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">H</span> <span class="main">==&gt;</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Agent  <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"Agent <span class="free"><span class="bound"><span class="entity">agt</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Number <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"Number <span class="free"><span class="bound"><span class="entity">n</span></span></span>  <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Hash   <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span> <span class="main">==&gt;</span> Hash <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> MPair  <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="main">[|</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span><span class="main">;</span>  <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span><span class="main">|]</span> <span class="main">==&gt;</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Crypt  <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="main">[|</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span><span class="main">;</span>  Key<span class="main">(</span><span class="free"><span class="bound"><span class="entity">K</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">H</span><span class="main">|]</span> <span class="main">==&gt;</span> Crypt <span class="free"><span class="bound"><span class="entity">K</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Monotonicity›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> synth_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G</span><span class="main">⊆</span><span class="free">H</span> <span class="main">==&gt;</span> synth<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> synth<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> synth.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>  

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹NO <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Agent_synth›</span></span></span></span>, as any Agent name can be synthesized.  
  The same holds for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Number</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">inductive_simps</span></span> synth_simps <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
 <span class="quoted"><span class="quoted">"Nonce <span class="free">n</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
 <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
 <span class="quoted"><span class="quoted">"Hash <span class="free">X</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
 <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
 <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> synth_increasing<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">H</span> <span class="main">⊆</span> synth<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Unions›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Converse fails: we can synth more from the union than from the 
  separate parts, building a compound message using elements of each.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> synth_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"synth<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">∪</span> synth<span class="main">(</span><span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> synth<span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Un_least synth_mono Un_upper1 Un_upper2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="free">X</span> <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> synth<span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> synth_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Idempotence and transitivity›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> synth_synthD <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> synth <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">==&gt;</span> <span class="free">X</span><span class="main">∈</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> synth.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_idem<span class="main">:</span> <span class="quoted"><span class="quoted">"synth <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_subset_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>synth <span class="free">G</span> <span class="main">⊆</span> synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">G</span> <span class="main">⊆</span> synth <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> subset_trans synth_idem synth_increasing synth_mono<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">X</span><span class="main">∈</span> synth <span class="free">G</span><span class="main">;</span>  <span class="free">G</span> <span class="main">⊆</span> synth <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">X</span><span class="main">∈</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> synth_mono<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Cut; Lemma 2 of Lowe›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> synth_cut<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">Y</span><span class="main">∈</span> synth <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">;</span>  <span class="free">X</span><span class="main">∈</span> synth <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">Y</span><span class="main">∈</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> synth_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Agent_synth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Agent <span class="free">A</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Number_synth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Number <span class="free">n</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_synth_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nonce <span class="free">N</span> <span class="main">∈</span> synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Nonce <span class="free">N</span> <span class="main">∈</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Key_synth_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_synth_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">∉</span> <span class="free">H</span> <span class="main">==&gt;</span> <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">lemma</span></span> keysFor_synth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span> <span class="main">∪</span> invKey<span class="main">`</span><span class="main">{</span><span class="bound">K</span><span class="main">.</span> Key <span class="bound">K</span> <span class="main">∈</span> <span class="free">H</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Combinations of parts, analz and synth›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_synth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="free">H</span> <span class="main">∪</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> synth_increasing <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts_mono<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span> 
                    parts.Fst parts.Snd parts.Body<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_analz_Un <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>analz <span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> equalityI analz_subset_cong<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_synth_Un <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>synth <span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">∪</span> synth <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 5 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz.Fst analz.Snd analz.Decrypt<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_synth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="free">H</span> <span class="main">∪</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_empty_right analz_synth_Un<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹For reasoning about the Fake rule in traces›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_subset_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> <span class="free">G</span> <span class="main">==&gt;</span> parts<span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> parts <span class="free">G</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnCI Un_upper2 insert_subset parts_Un parts_mono<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹More specifically for Fake. See also <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Fake_parts_sing›</span></span></span></span> below›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Fake_parts_insert<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">==&gt;</span>  
      parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_commute analz_increasing insert_subset parts_analz parts_mono 
          parts_synth synth_mono synth_subset_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Fake_parts_insert_in_Un<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span><span class="free">Z</span> <span class="main">∈</span> parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">;</span>  <span class="free">X</span><span class="main">:</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">|]</span> 
      <span class="main">==&gt;</span> <span class="free">Z</span> <span class="main">∈</span>  synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Fake_parts_insert subsetD<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">H</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is sometimes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span><span class="quoted"><span class="quoted">"Key <span class="main"><span class="main">`</span></span> <span class="free"><span class="free">KK</span></span> <span class="main"><span class="main">∪</span></span> <span class="free"><span class="free">spies</span></span> <span class="free"><span class="free">evs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, so can't put 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">G</span></span><span class="main"><span class="main">=</span></span><span class="free"><span class="free">H</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Fake_analz_insert<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">G</span><span class="main">)</span> <span class="main">==&gt;</span>  
      analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> synth <span class="main">(</span>analz <span class="free">G</span><span class="main">)</span> <span class="main">∪</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">x</span> <span class="main">∈</span> analz <span class="main">(</span>synth <span class="main">(</span>analz <span class="free">G</span><span class="main">)</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> synth_mono<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_conj_parts <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">∧</span> <span class="free">X</span> <span class="main">∈</span> parts <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_subset_parts <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_disj_parts <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|</span> <span class="free">X</span> <span class="main">∈</span> parts <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">∈</span> parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_subset_parts <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Without this equation, other rules for synth and analz would yield
  redundant cases›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> MPair_synth_analz <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  
      <span class="main">(</span><span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">∧</span> <span class="free">Y</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_synth_analz<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> Key <span class="free">K</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span>  Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span>  
       <span class="main">==&gt;</span> <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">lemma</span></span> Hash_synth_analz <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∉</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>  
      <span class="main">==&gt;</span> <span class="main">(</span>Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹HPair: a combination of Hash and MPair›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Freeness›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Agent_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Agent <span class="free">A</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Number_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Number <span class="free">N</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Key_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Hash_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Hash <span class="free">Z</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X'</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> HPair_neqs <span class="main">=</span> Agent_neq_HPair Nonce_neq_HPair Number_neq_HPair 
                    Key_neq_HPair Hash_neq_HPair Crypt_neq_HPair

<span class="keyword1"><span class="command">declare</span></span> HPair_neqs <span class="main">[</span><span class="operator">iff</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> HPair_neqs <span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">iff</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> HPair_eq <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X'</span><span class="main">]</span> <span class="free">Y'</span> <span class="main">=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X'</span> <span class="main">=</span> <span class="free">X</span> <span class="main">∧</span> <span class="free">Y'</span><span class="main">=</span><span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> MPair_eq_HPair <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⦃</span><span class="free">X'</span><span class="main">,</span><span class="free">Y'</span><span class="main">⦄</span> <span class="main">=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X'</span> <span class="main">=</span> Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∧</span> <span class="free">Y'</span><span class="main">=</span><span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> HPair_eq_MPair <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span> <span class="main">=</span> <span class="main">⦃</span><span class="free">X'</span><span class="main">,</span><span class="free">Y'</span><span class="main">⦄</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X'</span> <span class="main">=</span> Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∧</span> <span class="free">Y'</span><span class="main">=</span><span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Specialized laws, proved in terms of those for Hash and MPair›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_HPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_HPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>  
     insert <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="main">(</span>insert <span class="main">(</span>Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span><span class="main">)</span> <span class="main">(</span>parts <span class="main">(</span>insert <span class="free">Y</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_HPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>  
     insert <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="main">(</span>insert <span class="main">(</span>Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">Y</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> HPair_synth_analz <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∉</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>  
    <span class="main">==&gt;</span> <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  
        <span class="main">(</span>Hash <span class="main">⦃</span><span class="free">X</span><span class="main">,</span> <span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">∧</span> <span class="free">Y</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We do NOT want Crypt... messages broken up in protocols!!›</span></span>
<span class="keyword1"><span class="command">declare</span></span> parts.Body <span class="main">[</span><span class="operator">rule</span> <span class="quasi_keyword">del</span><span class="main">]</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Rewrites to push in Key and Crypt messages, so that other messages can
    be pulled out using the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>analz_insert›</span></span></span></span> rules›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pushKeys <span class="main">=</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Agent <span class="free">C</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Number <span class="free">N</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Hash <span class="free">X</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"MPair <span class="free">X</span> <span class="free">Y</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K'</span>"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">K</span> <span class="free">C</span> <span class="free">N</span> <span class="free">X</span> <span class="free">Y</span> <span class="free">K'</span>

<span class="keyword1"><span class="command">lemmas</span></span> pushCrypts <span class="main">=</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Agent <span class="free">C</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Agent <span class="free">C</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Number <span class="free">N</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Hash <span class="free">X'</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"MPair <span class="free">X'</span> <span class="free">Y</span>"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">X</span> <span class="free">K</span> <span class="free">C</span> <span class="free">N</span> <span class="free">X'</span> <span class="free">Y</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Cannot be added with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>[simp]›</span></span></span></span> -- messages should not always be
  re-ordered.›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> pushes <span class="main">=</span> pushKeys pushCrypts


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The set of key-free messages›</span></span>

<span class="comment1">(*Note that even the encryption of a key-free message remains key-free.
  This concept is valuable because of the theorem analz_keyfree_into_Un, proved below. *)</span>

<span class="keyword1"><span class="command">inductive_set</span></span>
  <span class="entity">keyfree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    Agent<span class="main">:</span>  <span class="quoted"><span class="quoted">"Agent <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>
  <span class="main">|</span> Number<span class="main">:</span> <span class="quoted"><span class="quoted">"Number <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>
  <span class="main">|</span> Nonce<span class="main">:</span>  <span class="quoted"><span class="quoted">"Nonce <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>
  <span class="main">|</span> Hash<span class="main">:</span>   <span class="quoted"><span class="quoted">"Hash <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>
  <span class="main">|</span> MPair<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">[|</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span><span class="main">;</span>  <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span><span class="main">|]</span> <span class="main">==&gt;</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>
  <span class="main">|</span> Crypt<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">[|</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span><span class="main">|]</span> <span class="main">==&gt;</span> Crypt <span class="free"><span class="bound"><span class="entity">K</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>


<span class="keyword1"><span class="command">declare</span></span> keyfree.intros <span class="main">[</span><span class="operator">intro</span><span class="main">]</span> 

<span class="keyword1"><span class="command">inductive_cases</span></span> keyfree_KeyE<span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">∈</span> keyfree"</span></span>
<span class="keyword1"><span class="command">inductive_cases</span></span> keyfree_MPairE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> keyfree"</span></span>
<span class="keyword1"><span class="command">inductive_cases</span></span> keyfree_CryptE<span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> keyfree"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_keyfree<span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>keyfree<span class="main">)</span> <span class="main">⊆</span> keyfree"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarify</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> keyfree_KeyE keyfree_MPairE keyfree_CryptE<span class="main">)</span>

<span class="comment1">(*The key-free part of a set of messages can be removed from the scope of the analz operator.*)</span>
<span class="keyword1"><span class="command">lemma</span></span> analz_keyfree_into_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">X</span> <span class="main">∈</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span><span class="main">;</span> <span class="free">G</span> <span class="main">⊆</span> keyfree<span class="main">⟧</span> <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> parts <span class="free">G</span> <span class="main">∪</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>parts.Body<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> parts.Body<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Un_absorb2 keyfree_KeyE parts_Un parts_keyfree UnI2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Tactics useful for many protocol proofs›</span></span>
<span class="keyword1"><span class="command">ML</span></span>
<span class="quoted">‹
<span class="comment1">(*Analysis of Fake cases.  Also works for messages that forward unknown parts,
  but this application is no longer necessary if analz_insert_eq is used.
  DEPENDS UPON "X" REFERRING TO THE FRADULENT MESSAGE *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">impOfSubs</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">th</span> RSN <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> rev_subsetD<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="comment1">(*Apply rules to break down assumptions of the form
  Y ∈ parts(insert X H)  and  Y ∈ analz(insert X H)
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">Fake_insert_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> 
    dresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">impOfSubs</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fake_analz_insert<span class="antiquote">}</span></span></span><span class="main">,</span>
                  <span class="entity">impOfSubs</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fake_parts_insert<span class="antiquote">}</span></span></span><span class="main">]</span> THEN'
    eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span>asm_rl<span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> synth.Inj<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">Fake_insert_simp_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span> <span class="main">=</span> 
  REPEAT <span class="main">(</span><span class="entity">Fake_insert_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">)</span> THEN <span class="entity">asm_full_simp_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomic_spy_analz_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  SELECT_GOAL
   <span class="main">(</span><span class="entity">Fake_insert_simp_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span> THEN
    IF_UNSOLVED
      <span class="main">(</span><span class="entity">Blast.depth_tac</span>
        <span class="main">(</span><span class="entity">ctxt</span> <span class="entity">addIs</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> analz_insertI<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">impOfSubs</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> analz_subset_parts<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span> <span class="inner_numeral">4</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">spy_analz_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span> <span class="main">=</span>
  DETERM
   <span class="main">(</span>SELECT_GOAL
     <span class="main">(</span>EVERY 
      <span class="main">[</span>  <span class="comment1">(*push in occurrences of X...*)</span>
       <span class="main">(</span>REPEAT o CHANGED<span class="main">)</span>
         <span class="main">(</span><span class="entity">Rule_Insts.res_inst_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span> Position.none<span class="main">)</span><span class="main">,</span> <span class="inner_quoted">"X"</span><span class="main">)</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span>
          <span class="main">(</span><span class="entity">insert_commute</span> RS <span class="entity">ssubst</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span>
       <span class="comment1">(*...allowing further simplifications*)</span>
       <span class="entity">simp_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">,</span>
       REPEAT <span class="main">(</span>FIRSTGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">allI</span><span class="main">,</span><span class="entity">impI</span><span class="main">,</span><span class="entity">notI</span><span class="main">,</span><span class="entity">conjI</span><span class="main">,</span><span class="entity">iffI</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
       DEPTH_SOLVE <span class="main">(</span><span class="entity">atomic_spy_analz_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">i</span><span class="main">)</span><span class="main">;</span>
›</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹By default only <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>o_apply›</span></span></span></span> is built-in.  But in the presence of
eta-expansion this means that some terms displayed as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="keyword1"><span class="keyword1">o</span></span> <span class="free"><span class="free">g</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> will be
rewritten, and others will not!›</span></span>
<span class="keyword1"><span class="command">declare</span></span> o_def <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> Crypt_notin_image_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∉</span> Key <span class="main">`</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Hash_notin_image_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span><span class="quoted"><span class="quoted">"Hash <span class="free">X</span> <span class="main">∉</span> Key <span class="main">`</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_analz_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G</span><span class="main">⊆</span><span class="free">H</span> <span class="main">==&gt;</span> synth <span class="main">(</span>analz<span class="main">(</span><span class="free">G</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> synth <span class="main">(</span>analz<span class="main">(</span><span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> synth_mono analz_mono<span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> Fake_analz_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> synth<span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">==&gt;</span> synth <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Fake_analz_insert Un_absorb Un_absorb1 Un_commute 
          subset_insertI synth_analz_mono synth_increasing synth_subset_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Two generalizations of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>analz_insert_eq›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> gen_analz_insert_eq <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">==&gt;</span> <span class="main">∀</span><span class="bound">G</span><span class="main">.</span> <span class="free">H</span> <span class="main">⊆</span> <span class="bound">G</span> <span class="main">--&gt;</span> analz <span class="main">(</span>insert <span class="free">X</span> <span class="bound">G</span><span class="main">)</span> <span class="main">=</span> analz <span class="bound">G</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_cut analz_insertI analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_analz_insert_eq <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> 
      <span class="main">==&gt;</span> <span class="main">∀</span><span class="bound">G</span><span class="main">.</span> <span class="free">H</span> <span class="main">⊆</span> <span class="bound">G</span> <span class="main">--&gt;</span> <span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> analz <span class="main">(</span>insert <span class="free">X</span> <span class="bound">G</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> analz <span class="bound">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> synth.induct<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_analz_insert_eq subset_trans <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ subset_insertI<span class="main"><span class="main">]</span></span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Fake_parts_sing<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">==&gt;</span> parts<span class="main">{</span><span class="free">X</span><span class="main">}</span> <span class="main">⊆</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Fake_parts_insert empty_subsetI insert_mono parts_mono subset_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> Fake_parts_sing_imp_Un <span class="main">=</span> Fake_parts_sing <span class="main">[</span><span class="operator">THEN</span> <span class="main"><span class="main">[</span></span>2<span class="main"><span class="main">]</span></span> rev_subsetD<span class="main">]</span>

<span class="keyword1"><span class="command">method_setup</span></span> spy_analz <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> o <span class="entity">spy_analz_tac</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving the Fake case when analz is involved"</span>

<span class="keyword1"><span class="command">method_setup</span></span> atomic_spy_analz <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> o <span class="entity">atomic_spy_analz_tac</span><span class="main">)</span>›</span>
    <span class="quoted">"for debugging spy_analz"</span>

<span class="keyword1"><span class="command">method_setup</span></span> Fake_insert_simp <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> o <span class="entity">Fake_insert_simp_tac</span><span class="main">)</span>›</span>
    <span class="quoted">"for debugging spy_analz"</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Event">
<div class="head">
<h1>Theory Event</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      HOL/Auth/Event.thy
    Author:     Lawrence C Paulson, Cambridge University Computer Laboratory
    Copyright   1996  University of Cambridge

Datatype of events; function "spies"; freshness

"bad" agents have been broken by the Spy; their private keys and internal
    stores are visible to him
*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Theory of Events for Security Protocols against Dolev-Yao›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Event <span class="keyword2"><span class="keyword">imports</span></span> <a href="Message.html">Message</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">consts</span></span>  <span class="comment1">(*Initial states of agents -- parameter of the construction*)</span>
  initState <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> msg set"</span></span>

<span class="keyword1"><span class="command">datatype</span></span>
  event <span class="main">=</span> Says  <span class="quoted">agent</span> <span class="quoted">agent</span> <span class="quoted">msg</span>
        <span class="main">|</span> Gets  <span class="quoted">agent</span>       <span class="quoted">msg</span>
        <span class="main">|</span> Notes <span class="quoted">agent</span>       <span class="quoted">msg</span>
       
<span class="keyword1"><span class="command">consts</span></span> 
  bad    <span class="main">::</span> <span class="quoted"><span class="quoted">"agent set"</span></span>                         <span class="comment1">― ‹compromised agents›</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Spy has access to his own key for spoof messages, but Server is secure›</span></span>
<span class="keyword1"><span class="command">specification</span></span> <span class="main">(</span><span class="quoted">bad</span><span class="main">)</span>
  Spy_in_bad     <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Spy <span class="main">∈</span> bad"</span></span>
  Server_not_bad <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Server <span class="main">∉</span> bad"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main"><span class="main">{</span></span></span>Spy<span class="main"><span class="main"><span class="main">}</span></span></span>"</span></span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">knows</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> event list <span class="main">=&gt;</span> msg set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  knows_Nil<span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">[]</span> <span class="main">=</span> initState <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>
<span class="main">|</span> knows_Cons<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ev</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span> <span class="main">=</span>
       <span class="main">(</span><span class="keyword1">if</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">=</span> Spy <span class="keyword1">then</span> 
        <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ev</span></span></span> <span class="keyword1">of</span>
           Says <span class="bound">A'</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">=&gt;</span> insert <span class="bound">X</span> <span class="main">(</span><span class="free">knows</span> Spy <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span>
         <span class="main">|</span> Gets <span class="bound">A'</span> <span class="bound">X</span> <span class="main">=&gt;</span> <span class="free">knows</span> Spy <span class="free"><span class="bound"><span class="entity">evs</span></span></span>
         <span class="main">|</span> Notes <span class="bound">A'</span> <span class="bound">X</span>  <span class="main">=&gt;</span> 
             <span class="keyword1">if</span> <span class="bound">A'</span> <span class="main">∈</span> bad <span class="keyword1">then</span> insert <span class="bound">X</span> <span class="main">(</span><span class="free">knows</span> Spy <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">knows</span> Spy <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span>
        <span class="keyword1">else</span>
        <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ev</span></span></span> <span class="keyword1">of</span>
           Says <span class="bound">A'</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">=&gt;</span> 
             <span class="keyword1">if</span> <span class="bound">A'</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> insert <span class="bound">X</span> <span class="main">(</span><span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span>
         <span class="main">|</span> Gets <span class="bound">A'</span> <span class="bound">X</span>    <span class="main">=&gt;</span> 
             <span class="keyword1">if</span> <span class="bound">A'</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> insert <span class="bound">X</span> <span class="main">(</span><span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span>
         <span class="main">|</span> Notes <span class="bound">A'</span> <span class="bound">X</span>    <span class="main">=&gt;</span> 
             <span class="keyword1">if</span> <span class="bound">A'</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> insert <span class="bound">X</span> <span class="main">(</span><span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span><span class="main">)</span>"</span></span>

<span class="comment1">(*
  Case A=Spy on the Gets event
  enforces the fact that if a message is received then it must have been sent,
  therefore the oops case must use Notes
*)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The constant "spies" is retained for compatibility's sake›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="main">(</span>input<span class="main">)</span>
  <span class="entity">spies</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"event list <span class="main">=&gt;</span> msg set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">spies</span> <span class="main">==</span> knows Spy"</span></span>


<span class="comment1">(*Set of items that might be visible to somebody:
    complement of the set of fresh items*)</span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">used</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"event list <span class="main">=&gt;</span> msg set"</span></span>
<span class="keyword2"><span class="keyword">where</span></span>
  used_Nil<span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free">used</span> <span class="main">[]</span>         <span class="main">=</span> <span class="main">(</span><span class="keyword1">UN</span> <span class="bound">B</span><span class="main">.</span> parts <span class="main">(</span>initState <span class="bound">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="main">|</span> used_Cons<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="free">used</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ev</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span> <span class="main">=</span>
                     <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ev</span></span></span> <span class="keyword1">of</span>
                        Says <span class="bound">A</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">=&gt;</span> parts <span class="main">{</span><span class="bound">X</span><span class="main">}</span> <span class="main">∪</span> <span class="free">used</span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span>
                      <span class="main">|</span> Gets <span class="bound">A</span> <span class="bound">X</span>   <span class="main">=&gt;</span> <span class="free">used</span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span>
                      <span class="main">|</span> Notes <span class="bound">A</span> <span class="bound">X</span>  <span class="main">=&gt;</span> parts <span class="main">{</span><span class="bound">X</span><span class="main">}</span> <span class="main">∪</span> <span class="free">used</span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span>"</span></span>
    <span class="comment1">― ‹The case for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Gets</span><span class="antiquote">}</span></span> seems anomalous, but <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Gets</span><span class="antiquote">}</span></span> always
        follows <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Says</span><span class="antiquote">}</span></span> in real protocols.  Seems difficult to change.
        See <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">Gets_correct</span><span class="antiquote">}</span></span> in theory <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"Guard/Extensions.thy"</span><span class="antiquote">}</span></span>.›</span>

<span class="keyword1"><span class="command">lemma</span></span> Notes_imp_used <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">--&gt;</span> <span class="free">X</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">evs</span></span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Says_imp_used <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Says <span class="free">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">--&gt;</span> <span class="free">X</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">evs</span></span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">knows</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="comment1">(*Simplifying   
 parts(insert X (knows Spy evs)) = parts{X} ∪ parts(knows Spy evs).
  This version won't loop with the simplifier.*)</span>
<span class="keyword1"><span class="command">lemmas</span></span> parts_insert_knows_A <span class="main">=</span> parts_insert <span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span>"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">evs</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Spy_Says <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"knows Spy <span class="main">(</span>Says <span class="free">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">X</span> <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Letting the Spy see "bad" agents' notes avoids redundant case-splits
      on whether <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span><span class="main"><span class="main">=</span></span>Spy"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and whether <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span><span class="main"><span class="main">∈</span></span>bad"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> knows_Spy_Notes <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"knows Spy <span class="main">(</span>Notes <span class="free">A</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span>  
          <span class="main">(</span><span class="keyword1">if</span> <span class="free">A</span><span class="main">:</span>bad <span class="keyword1">then</span> insert <span class="free">X</span> <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="keyword1">else</span> knows Spy <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Spy_Gets <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"knows Spy <span class="main">(</span>Gets <span class="free">A</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> knows Spy <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Spy_subset_knows_Spy_Says<span class="main">:</span>
     <span class="quoted"><span class="quoted">"knows Spy <span class="free">evs</span> <span class="main">⊆</span> knows Spy <span class="main">(</span>Says <span class="free">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_insertI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Spy_subset_knows_Spy_Notes<span class="main">:</span>
     <span class="quoted"><span class="quoted">"knows Spy <span class="free">evs</span> <span class="main">⊆</span> knows Spy <span class="main">(</span>Notes <span class="free">A</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Spy_subset_knows_Spy_Gets<span class="main">:</span>
     <span class="quoted"><span class="quoted">"knows Spy <span class="free">evs</span> <span class="main">⊆</span> knows Spy <span class="main">(</span>Gets <span class="free">A</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_insertI<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Spy sees what is sent on the traffic›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Says_imp_knows_Spy <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"Says <span class="free">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">--&gt;</span> <span class="free">X</span> <span class="main">∈</span> knows Spy <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Notes_imp_knows_Spy <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">--&gt;</span> <span class="free">A</span><span class="main">:</span> bad <span class="main">--&gt;</span> <span class="free">X</span> <span class="main">∈</span> knows Spy <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Elimination rules: derive contradictions from old Says events containing
  items known to be fresh›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> Says_imp_parts_knows_Spy <span class="main">=</span> 
       Says_imp_knows_Spy <span class="main">[</span><span class="operator">THEN</span> parts.Inj<span class="main">,</span> <span class="operator">THEN</span> revcut_rl<span class="main">]</span> 

<span class="keyword1"><span class="command">lemmas</span></span> knows_Spy_partsEs <span class="main">=</span>
     Says_imp_parts_knows_Spy parts.Body <span class="main">[</span><span class="operator">THEN</span> revcut_rl<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> Says_imp_analz_Spy <span class="main">=</span> Says_imp_knows_Spy <span class="main">[</span><span class="operator">THEN</span> analz.Inj<span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Compatibility for the old "spies" function›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> spies_partsEs <span class="main">=</span> knows_Spy_partsEs
<span class="keyword1"><span class="command">lemmas</span></span> Says_imp_spies <span class="main">=</span> Says_imp_knows_Spy
<span class="keyword1"><span class="command">lemmas</span></span> parts_insert_spies <span class="main">=</span> parts_insert_knows_A <span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted">Spy</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Knowledge of Agents›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Says<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="main">(</span>Says <span class="free">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">X</span> <span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Notes<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="main">(</span>Notes <span class="free">A</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">X</span> <span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Gets<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> Spy <span class="main">--&gt;</span> knows <span class="free">A</span> <span class="main">(</span>Gets <span class="free">A</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">X</span> <span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>


<span class="keyword1"><span class="command">lemma</span></span> knows_subset_knows_Says<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span> <span class="main">⊆</span> knows <span class="free">A</span> <span class="main">(</span>Says <span class="free">A'</span> <span class="free">B</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_insertI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_subset_knows_Notes<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span> <span class="main">⊆</span> knows <span class="free">A</span> <span class="main">(</span>Notes <span class="free">A'</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_insertI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_subset_knows_Gets<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span> <span class="main">⊆</span> knows <span class="free">A</span> <span class="main">(</span>Gets <span class="free">A'</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_insertI<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Agents know what they say›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Says_imp_knows <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Says <span class="free">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">--&gt;</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Agents know what they note›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Notes_imp_knows <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">--&gt;</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Agents know what they receive›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Gets_imp_knows_agents <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">≠</span> Spy <span class="main">--&gt;</span> Gets <span class="free">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">--&gt;</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹What agents DIFFERENT FROM Spy know 
  was either said, or noted, or got, or known initially›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> knows_imp_Says_Gets_Notes_initState <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span><span class="main">;</span> <span class="free">A</span> <span class="main">≠</span> Spy <span class="main">|]</span> <span class="main">==&gt;</span> <span class="main">∃</span><span class="bound">B</span><span class="main">.</span>  
  Says <span class="free">A</span> <span class="bound">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">|</span> Gets <span class="free">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">|</span> Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">|</span> <span class="free">X</span> <span class="main">∈</span> initState <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹What the Spy knows -- for the time being --
  was either said or noted, or known initially›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> knows_Spy_imp_Says_Notes_initState <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">X</span> <span class="main">∈</span> knows Spy <span class="free">evs</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="main">∃</span><span class="bound">A</span> <span class="bound">B</span><span class="main">.</span>  
  Says <span class="bound">A</span> <span class="bound">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">|</span> Notes <span class="bound">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">|</span> <span class="free">X</span> <span class="main">∈</span> initState Spy"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_knows_Spy_subset_used<span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">⊆</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>  
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parts_insert_knows_A knows_Cons <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> event.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> usedI <span class="main">=</span> parts_knows_Spy_subset_used <span class="main">[</span><span class="operator">THEN</span> subsetD<span class="main">,</span> <span class="operator">intro</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> initState_into_used<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> parts <span class="main">(</span>initState <span class="free">B</span><span class="main">)</span> <span class="main">==&gt;</span> <span class="free">X</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parts_insert_knows_A <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> used_Says <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"used <span class="main">(</span>Says <span class="free">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> parts<span class="main">{</span><span class="free">X</span><span class="main">}</span> <span class="main">∪</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> used_Notes <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"used <span class="main">(</span>Notes <span class="free">A</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> parts<span class="main">{</span><span class="free">X</span><span class="main">}</span> <span class="main">∪</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> used_Gets <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"used <span class="main">(</span>Gets <span class="free">A</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> used_nil_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"used <span class="main">[]</span> <span class="main">⊆</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> initState_into_used<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹NOTE REMOVAL--laws above are cleaner, as they don't involve "case"›</span></span>
<span class="keyword1"><span class="command">declare</span></span> knows_Cons <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
        used_Nil <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> used_Cons <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹For proving theorems of the form <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">X</span></span> <span class="main"><span class="main">∉</span></span> analz <span class="main"><span class="main">(</span></span>knows Spy <span class="free"><span class="free">evs</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">--&gt;</span></span> <span class="free"><span class="free">P</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>
  New events added by induction to "evs" are discarded.  Provided 
  this information isn't needed, the proof will be much shorter, since
  it will omit complicated reasoning about <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">analz</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> analz_mono_contra <span class="main">=</span>
       knows_Spy_subset_knows_Spy_Says <span class="main">[</span><span class="operator">THEN</span> analz_mono<span class="main">,</span> <span class="operator">THEN</span> contra_subsetD<span class="main">]</span>
       knows_Spy_subset_knows_Spy_Notes <span class="main">[</span><span class="operator">THEN</span> analz_mono<span class="main">,</span> <span class="operator">THEN</span> contra_subsetD<span class="main">]</span>
       knows_Spy_subset_knows_Spy_Gets <span class="main">[</span><span class="operator">THEN</span> analz_mono<span class="main">,</span> <span class="operator">THEN</span> contra_subsetD<span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> knows_subset_knows_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span> <span class="main">⊆</span> knows <span class="free">A</span> <span class="main">(</span><span class="free">e</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> knows_Cons<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> initState_subset_knows<span class="main">:</span> <span class="quoted"><span class="quoted">"initState <span class="free">A</span> <span class="main">⊆</span> knows <span class="free">A</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">evs</span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> knows_subset_knows_Cons <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹For proving <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>new_keys_not_used›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> keysFor_parts_insert<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">K</span> <span class="main">∈</span> keysFor <span class="main">(</span>parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">G</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>  <span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">|]</span> 
      <span class="main">==&gt;</span> <span class="free">K</span> <span class="main">∈</span> keysFor <span class="main">(</span>parts <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> 
    <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> parts_insert_subset_Un <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> keysFor_mono<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span>
           analz_subset_parts <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> keysFor_mono<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span>
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_subset_parts <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span> parts_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">lemmas</span></span> analz_impI <span class="main">=</span> impI <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∉</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">Y</span> <span class="free">evs</span>

<span class="keyword1"><span class="command">ML</span></span>
<span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analz_mono_contra_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> analz_impI<span class="antiquote">}</span></span></span> THEN' 
  REPEAT1 o <span class="main">(</span>dresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> analz_mono_contra<span class="antiquote">}</span></span></span><span class="main">)</span>
  THEN' <span class="entity">mp_tac</span> <span class="entity">ctxt</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> analz_mono_contra <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD</span> <span class="main">(</span>REPEAT_FIRST <span class="main">(</span><span class="entity">analz_mono_contra_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving theorems of the form X ∉ analz (knows Spy evs) --&gt; P"</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Useful for case analysis on whether a hash is a spoof or not›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> syan_impI <span class="main">=</span> impI <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∉</span> synth <span class="main">(</span>analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">Y</span> <span class="free">evs</span>

<span class="keyword1"><span class="command">ML</span></span>
<span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">synth_analz_mono_contra_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> syan_impI<span class="antiquote">}</span></span></span> THEN'
  REPEAT1 o 
    <span class="main">(</span>dresolve_tac <span class="entity">ctxt</span> 
     <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> knows_Spy_subset_knows_Spy_Says<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> synth_analz_mono<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> contra_subsetD<span class="antiquote">}</span></span></span><span class="main">,</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> knows_Spy_subset_knows_Spy_Notes<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> synth_analz_mono<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> contra_subsetD<span class="antiquote">}</span></span></span><span class="main">,</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> knows_Spy_subset_knows_Spy_Gets<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> synth_analz_mono<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> contra_subsetD<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span>
  THEN'
  <span class="entity">mp_tac</span> <span class="entity">ctxt</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> synth_analz_mono_contra <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD</span> <span class="main">(</span>REPEAT_FIRST <span class="main">(</span><span class="entity">synth_analz_mono_contra_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving theorems of the form X ∉ synth (analz (knows Spy evs)) --&gt; P"</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="Public">
<div class="head">
<h1>Theory Public</h1>
</div>
<pre class="source"><span class="comment1">(*  Title:      HOL/Auth/Public.thy
    Author:     Lawrence C Paulson, Cambridge University Computer Laboratory
    Copyright   1996  University of Cambridge*)</span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Theory of Cryptographic Keys for Security Protocols against Dolev-Yao›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Public
<span class="keyword2"><span class="keyword">imports</span></span> <a href="Event.html">Event</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> invKey_K<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">K</span> <span class="main">∈</span> symKeys <span class="main">==&gt;</span> invKey <span class="free">K</span> <span class="main">=</span> <span class="free">K</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Asymmetric Keys›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> keymode <span class="main">=</span> Signature <span class="main">|</span> Encryption

<span class="keyword1"><span class="command">consts</span></span>
  publicKey <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>keymode<span class="main">,</span>agent<span class="main">]</span> <span class="main">=&gt;</span> key"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">pubEK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pubEK</span> <span class="main">==</span> publicKey Encryption"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">pubSK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pubSK</span> <span class="main">==</span> publicKey Signature"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">privateKey</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>keymode<span class="main">,</span> agent<span class="main">]</span> <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">privateKey</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> invKey <span class="main">(</span>publicKey <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="comment1">(*BEWARE!! priEK, priSK DON'T WORK with inj, range, image, etc.*)</span>
  <span class="entity">priEK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">priEK</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> privateKey Encryption <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">priSK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">priSK</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> privateKey Signature <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹These abbreviations give backward compatibility.  They represent the
simple situation where the signature and encryption keys are the same.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">pubK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pubK</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> pubEK <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">priK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">priK</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> invKey <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹By freeness of agents, no two agents have the same key.  Since
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"True<span class="main"><span class="main">≠</span></span>False"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, no agent has identical signing and encryption keys›</span></span>
<span class="keyword1"><span class="command">specification</span></span> <span class="main">(</span><span class="quoted">publicKey</span><span class="main">)</span>
  injective_publicKey<span class="main">:</span>
    <span class="quoted"><span class="quoted">"publicKey <span class="free">b</span> <span class="free">A</span> <span class="main">=</span> publicKey <span class="free">c</span> <span class="free">A'</span> <span class="main">==&gt;</span> <span class="free">b</span><span class="main">=</span><span class="free">c</span> <span class="main">∧</span> <span class="free">A</span><span class="main">=</span><span class="free">A'</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> 
       <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">%</span></span><span class="bound"><span class="bound">b</span></span> <span class="bound"><span class="bound">A</span></span><span class="main"><span class="main">.</span></span> <span class="numeral"><span class="numeral">2</span></span> <span class="main"><span class="main">*</span></span> case_agent <span class="main"><span class="main">0</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">n</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">+</span></span> <span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">1</span></span> <span class="bound"><span class="bound">A</span></span> <span class="main"><span class="main">+</span></span> case_keymode <span class="main"><span class="main">0</span></span> <span class="main"><span class="main">1</span></span> <span class="bound"><span class="bound">b</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> agent.split keymode.split<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>                       


<span class="keyword1"><span class="command">axiomatization</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="comment1">(*No private key equals any public key (essential to ensure that private
    keys are private!) *)</span>
  privateKey_neq_publicKey <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"privateKey <span class="free">b</span> <span class="free">A</span> <span class="main">≠</span> publicKey <span class="free">c</span> <span class="free">A'</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> publicKey_neq_privateKey <span class="main">=</span> privateKey_neq_publicKey <span class="main">[</span><span class="operator">THEN</span> not_sym<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> publicKey_neq_privateKey <span class="main">[</span><span class="operator">iff</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Basic properties of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">pubK</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">priK</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> publicKey_inject <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>publicKey <span class="free">b</span> <span class="free">A</span> <span class="main">=</span> publicKey <span class="free">c</span> <span class="free">A'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span><span class="main">=</span><span class="free">c</span> <span class="main">∧</span> <span class="free">A</span><span class="main">=</span><span class="free">A'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> injective_publicKey<span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> not_symKeys_pubK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"publicKey <span class="free">b</span> <span class="free">A</span> <span class="main">∉</span> symKeys"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> not_symKeys_priK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"privateKey <span class="free">b</span> <span class="free">A</span> <span class="main">∉</span> symKeys"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> symKey_neq_priEK<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">K</span> <span class="main">∈</span> symKeys <span class="main">==&gt;</span> <span class="free">K</span> <span class="main">≠</span> priEK <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> symKeys_neq_imp_neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">)</span> <span class="main">≠</span> <span class="main">(</span><span class="free">K'</span> <span class="main">∈</span> symKeys<span class="main">)</span> <span class="main">==&gt;</span> <span class="free">K</span> <span class="main">≠</span> <span class="free">K'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> symKeys_invKey_iff <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>invKey <span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> symKeys_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_symKeys_Decrypt<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span>  <span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">;</span>  Key <span class="free">K</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span>  
      <span class="main">==&gt;</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_def<span class="main">)</span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹"Image" equations that hold for injective functions›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> invKey_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>invKey <span class="free">x</span> <span class="main">∈</span> invKey<span class="main">`</span><span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(*holds because invKey is injective*)</span>
<span class="keyword1"><span class="command">lemma</span></span> publicKey_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span>publicKey <span class="free">b</span> <span class="free">x</span> <span class="main">∈</span> publicKey <span class="free">c</span> <span class="main">`</span> <span class="free">AA</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span><span class="main">=</span><span class="free">c</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">AA</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> privateKey_notin_image_publicKey <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"privateKey <span class="free">b</span> <span class="free">x</span> <span class="main">∉</span> publicKey <span class="free">c</span> <span class="main">`</span> <span class="free">AA</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> privateKey_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span>privateKey <span class="free">b</span> <span class="free">A</span> <span class="main">∈</span> invKey <span class="main">`</span> publicKey <span class="free">c</span> <span class="main">`</span> <span class="free">AS</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span><span class="main">=</span><span class="free">c</span> <span class="main">∧</span> <span class="free">A</span><span class="main">∈</span><span class="free">AS</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> publicKey_notin_image_privateKey <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"publicKey <span class="free">b</span> <span class="free">A</span> <span class="main">∉</span> invKey <span class="main">`</span> publicKey <span class="free">c</span> <span class="main">`</span> <span class="free">AS</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Symmetric Keys›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹For some protocols, it is convenient to equip agents with symmetric as
well as asymmetric keys.  The theory <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Shared›</span></span></span></span> assumes that all keys
are symmetric.›</span></span>

<span class="keyword1"><span class="command">consts</span></span>
  shrK    <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span>    <span class="comment1">― ‹long-term shared keys›</span>

<span class="keyword1"><span class="command">specification</span></span> <span class="main">(</span><span class="quoted">shrK</span><span class="main">)</span>
  inj_shrK<span class="main">:</span> <span class="quoted"><span class="quoted">"inj shrK"</span></span>
  <span class="comment1">― ‹No two agents have the same long-term key›</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"case_agent <span class="main"><span class="main">0</span></span> <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">n</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">+</span></span> <span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">)</span></span> <span class="main"><span class="main">1</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> agent.split<span class="main">)</span> 
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">axiomatization</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  sym_shrK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shrK <span class="free">X</span> <span class="main">∈</span> symKeys"</span></span> <span class="comment1">― ‹All shared keys are symmetric›</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Injectiveness: Agents' long-term keys are distinct.›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> shrK_injective <span class="main">=</span> inj_shrK <span class="main">[</span><span class="operator">THEN</span> inj_eq<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> shrK_injective <span class="main">[</span><span class="operator">iff</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> invKey_shrK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"invKey <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">=</span> shrK <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invKey_K<span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> analz_shrK_Decrypt<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> Crypt <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span> Key<span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_Decrypt'<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span> <span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">;</span> Key <span class="free">K</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invKey_K<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> priK_neq_shrK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shrK <span class="free">A</span> <span class="main">≠</span> privateKey <span class="free">b</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_neq_imp_neq<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> shrK_neq_priK <span class="main">=</span> priK_neq_shrK <span class="main">[</span><span class="operator">THEN</span> not_sym<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> shrK_neq_priK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> pubK_neq_shrK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shrK <span class="free">A</span> <span class="main">≠</span> publicKey <span class="free">b</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_neq_imp_neq<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> shrK_neq_pubK <span class="main">=</span> pubK_neq_shrK <span class="main">[</span><span class="operator">THEN</span> not_sym<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> shrK_neq_pubK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> priEK_noteq_shrK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"priEK <span class="free">A</span> <span class="main">≠</span> shrK <span class="free">B</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> publicKey_notin_image_shrK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"publicKey <span class="free">b</span> <span class="free">x</span> <span class="main">∉</span> shrK <span class="main">`</span> <span class="free">AA</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> privateKey_notin_image_shrK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"privateKey <span class="free">b</span> <span class="free">x</span> <span class="main">∉</span> shrK <span class="main">`</span> <span class="free">AA</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_notin_image_publicKey <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shrK <span class="free">x</span> <span class="main">∉</span> publicKey <span class="free">b</span> <span class="main">`</span> <span class="free">AA</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_notin_image_privateKey <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shrK <span class="free">x</span> <span class="main">∉</span> invKey <span class="main">`</span> publicKey <span class="free">b</span> <span class="main">`</span> <span class="free">AA</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>shrK <span class="free">x</span> <span class="main">∈</span> shrK <span class="main">`</span> <span class="free">AA</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> <span class="free">AA</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹For some reason, moving this up can make some proofs loop!›</span></span>
<span class="keyword1"><span class="command">declare</span></span> invKey_K <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Initial States of Agents›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Note: for all practical purposes, all that matters is the initial
knowledge of the Spy.  All other agents are automata, merely following the
protocol.›</span></span>

<span class="keyword1"><span class="command">overloading</span></span>
  initState <span class="main">≡</span> <span class="quoted">initState</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">initState</span> <span class="keyword2"><span class="keyword">where</span></span>
        <span class="comment1">(*Agents know their private key and all public keys*)</span>
  initState_Server<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">initState</span> Server     <span class="main">=</span>    
       <span class="main">{</span>Key <span class="main">(</span>priEK Server<span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK Server<span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
       <span class="main">(</span>Key <span class="main">`</span> range pubEK<span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>Key <span class="main">`</span> range pubSK<span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>Key <span class="main">`</span> range shrK<span class="main">)</span>"</span></span>

<span class="main">|</span> initState_Friend<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">initState</span> <span class="main">(</span>Friend <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span>    
       <span class="main">{</span>Key <span class="main">(</span>priEK<span class="main">(</span>Friend <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK<span class="main">(</span>Friend <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK<span class="main">(</span>Friend <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
       <span class="main">(</span>Key <span class="main">`</span> range pubEK<span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>Key <span class="main">`</span> range pubSK<span class="main">)</span>"</span></span>

<span class="main">|</span> initState_Spy<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">initState</span> Spy        <span class="main">=</span>    
       <span class="main">(</span>Key <span class="main">`</span> invKey <span class="main">`</span> pubEK <span class="main">`</span> bad<span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>Key <span class="main">`</span> invKey <span class="main">`</span> pubSK <span class="main">`</span> bad<span class="main">)</span> <span class="main">∪</span> 
       <span class="main">(</span>Key <span class="main">`</span> shrK <span class="main">`</span> bad<span class="main">)</span> <span class="main">∪</span> 
       <span class="main">(</span>Key <span class="main">`</span> range pubEK<span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>Key <span class="main">`</span> range pubSK<span class="main">)</span>"</span></span>

<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹These lemmas allow reasoning about <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"used <span class="free"><span class="free">evs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> rather than
   <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"knows Spy <span class="free"><span class="free">evs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, which is useful when there are private Notes. 
   Because they depend upon the definition of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">initState</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, they cannot
   be moved up.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> used_parts_subset_parts <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">X</span> <span class="main">∈</span> used <span class="free">evs</span><span class="main">.</span> parts <span class="main">{</span><span class="bound">X</span><span class="main">}</span> <span class="main">⊆</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">evs</span></span><span class="main">)</span> 
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> used_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Un_iff empty_subsetI insert_subset le_supI1 le_supI2 parts_subset_iff<span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Base case›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> parts_cut <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> used_Nil<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> MPair_used_D<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> used <span class="free">H</span> <span class="main">==&gt;</span> <span class="free">X</span> <span class="main">∈</span> used <span class="free">H</span> <span class="main">∧</span> <span class="free">Y</span> <span class="main">∈</span> used <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> used_parts_subset_parts<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹There was a similar theorem in Event.thy, so perhaps this one can
  be moved up if proved directly by induction.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> MPair_used <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> used <span class="free">H</span><span class="main">;</span>
         <span class="main">[|</span> <span class="free">X</span> <span class="main">∈</span> used <span class="free">H</span><span class="main">;</span> <span class="free">Y</span> <span class="main">∈</span> used <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">P</span> <span class="main">|]</span> 
      <span class="main">==&gt;</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> MPair_used_D<span class="main">)</span> 


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Rewrites should not refer to  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"initState<span class="main"><span class="main">(</span></span>Friend <span class="free"><span class="free">i</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because
  that expression is not in normal form.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_parts_initState <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>parts <span class="main">(</span>initState <span class="free">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">C</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> range_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_notin_initState<span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∉</span> parts <span class="main">(</span>initState <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">B</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_notin_used_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∉</span> used <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Crypt_notin_initState used_Nil<span class="main">)</span>

<span class="comment1">(*** Basic properties of shrK ***)</span>

<span class="comment1">(*Agents see their own shared keys!*)</span>
<span class="keyword1"><span class="command">lemma</span></span> shrK_in_initState <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> initState <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_in_knows <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> initState_subset_knows <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_in_used <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> initState_into_used<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>


<span class="comment1">(** Fresh keys never clash with long-term shared keys **)</span>

<span class="comment1">(*Used in parts_induct_tac and analz_Fake_tac to distinguish session keys
  from long-term shared keys*)</span>
<span class="keyword1"><span class="command">lemma</span></span> Key_not_used <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">∉</span> used <span class="free">evs</span> <span class="main">==&gt;</span> <span class="free">K</span> <span class="main">∉</span> range shrK"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_neq<span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">∉</span> used <span class="free">evs</span> <span class="main">==&gt;</span> shrK <span class="free">B</span> <span class="main">≠</span> <span class="free">K</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> neq_shrK <span class="main">=</span> shrK_neq <span class="main">[</span><span class="operator">THEN</span> not_sym<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> neq_shrK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"knows Spy"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> not_SignatureE <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≠</span> Signature <span class="main">⟹</span> <span class="free">b</span> <span class="main">=</span> Encryption"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Agents see their own private keys!›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> priK_in_initState <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>privateKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> initState <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Agents see all public keys!›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> publicKey_in_initState <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>publicKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> initState <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">B</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹All public keys are visible›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> spies_pubK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>publicKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> spies <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> imageI knows_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> analz_spies_pubK <span class="main">=</span> spies_pubK <span class="main">[</span><span class="operator">THEN</span> analz.Inj<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> analz_spies_pubK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Spy sees private keys of bad agents!›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Spy_spies_bad_privateKey <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∈</span> bad <span class="main">==&gt;</span> Key <span class="main">(</span>privateKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> spies <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> imageI knows_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Spy sees long-term shared keys of bad agents!›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Spy_spies_bad_shrK <span class="main">[</span><span class="operator">intro</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∈</span> bad <span class="main">==&gt;</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> spies <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> imageI knows_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> publicKey_into_used <span class="main">[</span><span class="operator">iff</span><span class="main">]</span> <span class="main">:</span><span class="quoted"><span class="quoted">"Key <span class="main">(</span>publicKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> initState_into_used<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> publicKey_in_initState <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> privateKey_into_used <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>privateKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> initState_into_used<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> priK_in_initState <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(*For case analysis on whether or not an agent is compromised*)</span>
<span class="keyword1"><span class="command">lemma</span></span> Crypt_Spy_analz_bad<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> Crypt <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span>  <span class="free">A</span> <span class="main">∈</span> bad <span class="main">|]</span>  
      <span class="main">==&gt;</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Fresh Nonces›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_notin_initState <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span> <span class="main">∉</span> parts <span class="main">(</span>initState <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_notin_used_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span> <span class="main">∉</span> used <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> used_Nil<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Supply fresh nonces for possibility theorems›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In any trace, there is an upper bound N on the greatest nonce in use›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Nonce_supply_lemma<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">N</span><span class="main">.</span> <span class="main">∀</span><span class="bound">n</span><span class="main">.</span> <span class="bound">N</span><span class="main">≤</span><span class="bound">n</span> <span class="main">--&gt;</span> Nonce <span class="bound">n</span> <span class="main">∉</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="main">0</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> used_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> msg_Nonce_supply <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> exE<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> add_leE<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_supply1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">N</span><span class="main">.</span> Nonce <span class="bound">N</span> <span class="main">∉</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Nonce_supply_lemma <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> exE<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_supply<span class="main">:</span> <span class="quoted"><span class="quoted">"Nonce <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">N</span><span class="main">.</span> Nonce <span class="bound">N</span> <span class="main">∉</span> used <span class="free">evs</span><span class="main">)</span> <span class="main">∉</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Nonce_supply_lemma <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> exE<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> someI<span class="main"><span class="keyword3">,</span></span> <span class="operator">fast</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Specialized Rewriting for Theorems About <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">analz</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and Image›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> insert_Key_singleton<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="free">H</span> <span class="main">=</span> Key <span class="main">`</span> <span class="main">{</span><span class="free">K</span><span class="main">}</span> <span class="main">∪</span> <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> insert_Key_image<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="main">(</span>Key<span class="main">`</span><span class="free">KK</span> <span class="main">∪</span> <span class="free">C</span><span class="main">)</span> <span class="main">=</span> Key <span class="main">`</span> <span class="main">(</span>insert <span class="free">K</span> <span class="free">KK</span><span class="main">)</span> <span class="main">∪</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">lemma</span></span> Crypt_imp_keysFor <span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">[|</span>Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> <span class="free">H</span><span class="main">;</span> <span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">K</span> <span class="main">∈</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> Crypt_imp_invKey_keysFor<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Lemma for the trivial direction of the if-and-only-if of the 
Session Key Compromise Theorem›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_image_freshK_lemma<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> analz <span class="main">(</span>Key<span class="main">`</span><span class="free">nE</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">--&gt;</span> <span class="main">(</span><span class="free">K</span> <span class="main">∈</span> <span class="free">nE</span> <span class="main">|</span> Key <span class="free">K</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">)</span>  <span class="main">==&gt;</span>  
         <span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> analz <span class="main">(</span>Key<span class="main">`</span><span class="free">nE</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">K</span> <span class="main">∈</span> <span class="free">nE</span> <span class="main">|</span> Key <span class="free">K</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> analz_image_freshK_simps <span class="main">=</span>
       simp_thms mem_simps <span class="comment1">― ‹these two allow its use with <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"only:"</span><span class="antiquote">}</span></span>›</span>
       disj_comms 
       image_insert <span class="main">[</span><span class="operator">THEN</span> sym<span class="main">]</span> image_Un <span class="main">[</span><span class="operator">THEN</span> sym<span class="main">]</span> empty_subsetI insert_subset
       analz_insert_eq Un_upper2 <span class="main">[</span><span class="operator">THEN</span> analz_mono<span class="main">,</span> <span class="operator">THEN</span> subsetD<span class="main">]</span>
       insert_Key_singleton 
       Key_not_used insert_Key_image Un_assoc <span class="main">[</span><span class="operator">THEN</span> sym<span class="main">]</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Public</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">analz_image_freshK_ss</span> <span class="main">=</span>
  simpset_of <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
    delsimps <span class="main">[</span><span class="entity">image_insert</span><span class="main">,</span> <span class="entity">image_Un</span><span class="main">]</span>
    delsimps <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> imp_disjL<span class="antiquote">}</span></span></span><span class="main">]</span>    <span class="comment1">(*reduces blow-up*)</span>
    addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> analz_image_freshK_simps<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="comment1">(*Tactic for possibility theorems*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">possibility_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    REPEAT <span class="comment1">(*omit used_Says so that Nonces start from different traces!*)</span>
    <span class="main">(</span>ALLGOALS <span class="main">(</span><span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">ctxt</span> setSolver <span class="entity">safe_solver</span> delsimps <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> used_Says<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
     THEN
     REPEAT_FIRST <span class="main">(</span>eq_assume_tac ORELSE' 
                   resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">refl</span><span class="main">,</span> <span class="entity">conjI</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nonce_supply<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(*For harder protocols (such as Recur) where we have to set up some
  nonces and keys initially*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">basic_possibility_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    REPEAT 
    <span class="main">(</span>ALLGOALS <span class="main">(</span><span class="entity">asm_simp_tac</span> <span class="main">(</span><span class="entity">ctxt</span> setSolver <span class="entity">safe_solver</span><span class="main">)</span><span class="main">)</span>
     THEN
     REPEAT_FIRST <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">refl</span><span class="main">,</span> <span class="entity">conjI</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> analz_freshK <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
     <span class="main">(</span><span class="entity">SIMPLE_METHOD</span>
      <span class="main">(</span>EVERY <span class="main">[</span>REPEAT_FIRST <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">allI</span><span class="main">,</span> <span class="entity">ballI</span><span class="main">,</span> <span class="entity">impI</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          REPEAT_FIRST <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> analz_image_freshK_lemma<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
          ALLGOALS <span class="main">(</span><span class="entity">asm_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">Public.analz_image_freshK_ss</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving the Session Key Compromise theorem"</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Specialized Methods for Possibility Theorems›</span></span>

<span class="keyword1"><span class="command">method_setup</span></span> possibility <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD</span> o <span class="entity">Public.possibility_tac</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving possibility theorems"</span>

<span class="keyword1"><span class="command">method_setup</span></span> basic_possibility <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD</span> o <span class="entity">Public.basic_possibility_tac</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving possibility theorems"</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="NS_Public_Bad">
<div class="head">
<h1>Theory NS_Public_Bad</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹The Needham-Schroeder Public-Key Protocol against Dolev-Yao --- with Gets event, hence with Reception rule›</span></span>

<span class="keyword1"><span class="command">theory</span></span> NS_Public_Bad <span class="keyword2"><span class="keyword">imports</span></span> <a href="Public.html">Public</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">ns_public</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"event list set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
         <span class="comment1">(*Initial trace is empty*)</span>
   Nil<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">∈</span> <span class="free">ns_public</span>"</span></span>

         <span class="comment1">(*The spy MAY say anything he CAN say.  We do not expect him to
           invent new nonces here, but he can also use NS1.  Common to
           all similar protocols.*)</span>
 <span class="main">|</span> Fake<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">evsf</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span><span class="main">;</span>  <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="main">(</span>knows Spy <span class="free"><span class="bound"><span class="entity">evsf</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">⟧</span>
          <span class="main">⟹</span> Says Spy <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span>  <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evsf</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span>"</span></span>

         <span class="comment1">(*A message that is sent may be received*)</span>
 <span class="main">|</span> Reception<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">evsr</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span><span class="main">;</span> Says <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">evsr</span></span></span><span class="main">⟧</span>
                <span class="main">⟹</span> Gets <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evsr</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span>"</span></span>

         <span class="comment1">(*Alice initiates a protocol run, sending a nonce to Bob*)</span>
 <span class="main">|</span> NS1<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">evs1</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span><span class="main">;</span>  Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span> <span class="main">∉</span> used <span class="free"><span class="bound"><span class="entity">evs1</span></span></span><span class="main">⟧</span>
          <span class="main">⟹</span> Says <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span><span class="main">,</span> Agent <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">⦄</span><span class="main">)</span>
                <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evs1</span></span></span>  <span class="main">∈</span>  <span class="free">ns_public</span>"</span></span>

         <span class="comment1">(*Bob responds to Alice's message with a further nonce*)</span>
 <span class="main">|</span> NS2<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">evs2</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span><span class="main">;</span>  Nonce <span class="free"><span class="bound"><span class="entity">NB</span></span></span> <span class="main">∉</span> used <span class="free"><span class="bound"><span class="entity">evs2</span></span></span><span class="main">;</span>
           Gets <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span><span class="main">,</span> Agent <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">evs2</span></span></span><span class="main">⟧</span>
          <span class="main">⟹</span> Says <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span><span class="main">,</span> Nonce <span class="free"><span class="bound"><span class="entity">NB</span></span></span><span class="main">⦄</span><span class="main">)</span>
                <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evs2</span></span></span>  <span class="main">∈</span>  <span class="free">ns_public</span>"</span></span>

         <span class="comment1">(*Alice proves her existence by sending NB back to Bob.*)</span>
 <span class="main">|</span> NS3<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">evs3</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span><span class="main">;</span>
           Says <span class="free"><span class="bound"><span class="entity">A</span></span></span>  <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span><span class="main">,</span> Agent <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">evs3</span></span></span><span class="main">;</span>
           Gets <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span><span class="main">,</span> Nonce <span class="free"><span class="bound"><span class="entity">NB</span></span></span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">evs3</span></span></span><span class="main">⟧</span>
          <span class="main">⟹</span> Says <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">(</span>Nonce <span class="free"><span class="bound"><span class="entity">NB</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evs3</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span>"</span></span>

<span class="keyword1"><span class="command">declare</span></span> knows_Spy_partsEs <span class="main">[</span><span class="operator">elim</span><span class="main">]</span> <span class="keyword1"><span class="command">thm</span></span> knows_Spy_partsEs
<span class="keyword1"><span class="command">declare</span></span> analz_into_parts <span class="main">[</span><span class="operator">dest</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> Fake_parts_insert_in_Un <span class="main">[</span><span class="operator">dest</span><span class="main">]</span>

<span class="comment1">(*A "possibility property": there are traces that reach the end*)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">NB</span><span class="main">.</span> <span class="main">∃</span><span class="bound">evs</span> <span class="main">∈</span> ns_public<span class="main">.</span> Says <span class="free">A</span> <span class="free">B</span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">(</span>Nonce <span class="bound">NB</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> set <span class="bound">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> exI bexI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> <span class="main"><span class="improper">[</span></span>2<span class="main"><span class="improper">]</span></span> ns_public.Nil <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> ns_public.NS1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> ns_public.Reception<span class="main"><span class="main">,</span></span> 
                                   <span class="operator">THEN</span> ns_public.NS2<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> ns_public.Reception<span class="main"><span class="main">,</span></span> 
                                   <span class="operator">THEN</span> ns_public.NS3<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">possibility</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Lemmas about reception invariant: if a message is received it certainly
was sent›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Gets_imp_Says <span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Gets <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟧</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">A</span><span class="main">.</span> Says <span class="bound">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Gets_imp_knows_Spy<span class="main">:</span> 
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Gets <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟧</span>  <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> knows Spy <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> Gets_imp_Says Says_imp_knows_Spy<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Gets_imp_knows_Spy_parts<span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Gets <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟧</span>  <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Gets_imp_knows_Spy <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(**** Inductive proofs about ns_public ****)</span>

<span class="comment1">(** Theorems of the form X ∉ parts (knows Spy evs) imply that NOBODY
    sends messages containing X! **)</span>

<span class="comment1">(*Spy never sees another agent's private key! (unless it's bad at start)*)</span>
<span class="keyword1"><span class="command">lemma</span></span> Spy_see_priEK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟹</span> <span class="main">(</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">∈</span> bad<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Spy_analz_priEK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟹</span> <span class="main">(</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">∈</span> bad<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="comment1">(*** Authenticity properties obtained from NS2 ***)</span>

<span class="comment1">(*It is impossible to re-use a nonce in both NS1 and NS2, provided the nonce
  is secret.  (Honest users generate fresh nonces.)*)</span>
<span class="keyword1"><span class="command">lemma</span></span> no_nonce_NS1_NS2 <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="free">evs</span> <span class="main">∈</span> ns_public 
       <span class="main">⟹</span> Crypt <span class="main">(</span>pubEK <span class="free">C</span><span class="main">)</span> <span class="main">⦃</span><span class="free">NA'</span><span class="main">,</span> Nonce <span class="free">NA</span><span class="main">⦄</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">⟶</span>
           Crypt <span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A</span><span class="main">⦄</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">⟶</span>  
           Nonce <span class="free">NA</span> <span class="main">∈</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_insertI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="comment1">(*Unicity for NS1: nonce NA identifies agents A and B*)</span>
<span class="keyword1"><span class="command">lemma</span></span> unique_NA<span class="main">:</span> 
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Crypt<span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span>  <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A</span> <span class="main">⦄</span> <span class="main">∈</span> parts<span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span>  
       Crypt<span class="main">(</span>pubEK <span class="free">B'</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A'</span><span class="main">⦄</span> <span class="main">∈</span> parts<span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span>  
       Nonce <span class="free">NA</span> <span class="main">∉</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>
      <span class="main">⟹</span> <span class="free">A</span><span class="main">=</span><span class="free">A'</span> <span class="main">∧</span> <span class="free">B</span><span class="main">=</span><span class="free">B'</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main">)</span>   
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="comment1">(*Fake, NS1*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> analz_insertI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="comment1">(*Secrecy: Spy does not see the nonce sent in msg NS1 if A and B are secure
  The major premise "Says A B ..." makes it a dest-rule, so we use
  (erule rev_mp) rather than rule_format. *)</span>
<span class="keyword1"><span class="command">theorem</span></span> Spy_not_see_NA<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Says <span class="free">A</span> <span class="free">B</span> <span class="main">(</span>Crypt<span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span>
        <span class="free">A</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">B</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>                     
       <span class="main">⟹</span> Nonce <span class="free">NA</span> <span class="main">∉</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>   
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">spy_analz</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> unique_NA <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> no_nonce_NS1_NS2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="comment1">(*Authentication for A: if she receives message 2 and has used NA
  to start a run, then B has sent message 2.*)</span>
<span class="keyword1"><span class="command">lemma</span></span> A_trusts_NS2_lemma <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> 
   <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">A</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">B</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>                     
    <span class="main">⟹</span> Crypt <span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">⟶</span>
        Says <span class="free">A</span> <span class="free">B</span> <span class="main">(</span>Crypt<span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">⟶</span>
        Says <span class="free">B</span> <span class="free">A</span> <span class="main">(</span>Crypt<span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Spy_not_see_NA unique_NA<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">theorem</span></span> A_trusts_NS2<span class="main">:</span> 
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Says <span class="free">A</span>  <span class="free">B</span> <span class="main">(</span>Crypt<span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span>   
       Gets <span class="free">A</span> <span class="main">(</span>Crypt<span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span>
       <span class="free">A</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">B</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>                     
      <span class="main">⟹</span> Says <span class="free">B</span> <span class="free">A</span> <span class="main">(</span>Crypt<span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> A_trusts_NS2_lemma<span class="main">)</span>


<span class="comment1">(*If the encrypted message appears then it originated with Alice in NS1*)</span>
<span class="keyword1"><span class="command">lemma</span></span> B_trusts_NS1 <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">evs</span> <span class="main">∈</span> ns_public                                         
      <span class="main">⟹</span> Crypt <span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A</span><span class="main">⦄</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">⟶</span>
          Nonce <span class="free">NA</span> <span class="main">∉</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">⟶</span>
          Says <span class="free">A</span> <span class="free">B</span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="comment1">(*Fake*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> analz_insertI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



<span class="comment1">(*** Authenticity properties obtained from NS2 ***)</span>

<span class="comment1">(*Unicity for NS2: nonce NB identifies nonce NA and agent A
  [proof closely follows that for unique_NA] *)</span>
<span class="keyword1"><span class="command">lemma</span></span> unique_NB <span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span> 
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Crypt<span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span>  <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span> <span class="main">∈</span> parts<span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span>
       Crypt<span class="main">(</span>pubEK <span class="free">A'</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA'</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span> <span class="main">∈</span> parts<span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span>
       Nonce <span class="free">NB</span> <span class="main">∉</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>
     <span class="main">⟹</span> <span class="free">A</span><span class="main">=</span><span class="free">A'</span> <span class="main">∧</span> <span class="free">NA</span><span class="main">=</span><span class="free">NA'</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main">)</span>   
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="comment1">(*Fake, NS2*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> analz_insertI<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="comment1">(*NB remains secret PROVIDED Alice never responds with round 3*)</span>
<span class="keyword1"><span class="command">theorem</span></span> Spy_not_see_NB <span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Says <span class="free">B</span> <span class="free">A</span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span>   
       <span class="main">∀</span><span class="bound">C</span><span class="main">.</span> Says <span class="free">A</span> <span class="bound">C</span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="bound">C</span><span class="main">)</span> <span class="main">(</span>Nonce <span class="free">NB</span><span class="main">)</span><span class="main">)</span> <span class="main">∉</span> set <span class="free">evs</span><span class="main">;</span>       
       <span class="free">A</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">B</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>                      
     <span class="main">⟹</span> Nonce <span class="free">NB</span> <span class="main">∉</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">spy_analz</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> all_conj_distrib<span class="main">)</span> <span class="comment1">(*speeds up the next step*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> no_nonce_NS1_NS2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="comment1">(*Authentication for B: if he receives message 3 and has used NB
  in message 2, then A has sent message 3--to somebody....*)</span>

<span class="keyword1"><span class="command">lemma</span></span> B_trusts_NS3_lemma <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">A</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">B</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>                    
      <span class="main">⟹</span> Crypt <span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">(</span>Nonce <span class="free">NB</span><span class="main">)</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">⟶</span>
          Says <span class="free">B</span> <span class="free">A</span>  <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">⟶</span>
          <span class="main">(</span><span class="main">∃</span><span class="bound">C</span><span class="main">.</span> Says <span class="free">A</span> <span class="bound">C</span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="bound">C</span><span class="main">)</span> <span class="main">(</span>Nonce <span class="free">NB</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> no_nonce_NS1_NS2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>

<span class="keyword1"><span class="command">theorem</span></span> B_trusts_NS3<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Says <span class="free">B</span> <span class="free">A</span>  <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span>
       Gets <span class="free">B</span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">(</span>Nonce <span class="free">NB</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span>             
       <span class="free">A</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">B</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>                    
      <span class="main">⟹</span> <span class="main">∃</span><span class="bound">C</span><span class="main">.</span> Says <span class="free">A</span> <span class="bound">C</span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="bound">C</span><span class="main">)</span> <span class="main">(</span>Nonce <span class="free">NB</span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> B_trusts_NS3_lemma<span class="main">)</span>


<span class="comment1">(*Can we strengthen the secrecy theorem Spy_not_see_NB?  NO*)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">A</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">B</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>            
       <span class="main">⟹</span> Says <span class="free">B</span> <span class="free">A</span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span>  
           <span class="main">⟶</span> Nonce <span class="free">NB</span> <span class="main">∉</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">spy_analz</span><span class="main">)</span>
<span class="comment1">(*NS1: by freshness*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="comment1">(*NS2: by freshness and unicity of NB*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> no_nonce_NS1_NS2<span class="main">)</span>
<span class="comment1">(*NS3: unicity of NB identifies A and NA, but not B*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">frule_tac</span> A' <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="free">A</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> 
       Says_imp_knows_Spy <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> unique_NB<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> evs3 B' C<span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹This is the attack!
<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span>[display,indent=0,margin=65]<span class="antiquote"><span class="antiquote">}</span></span></span></span>
›</span></span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="ConfidentialityDY">
<div class="head">
<h1>Theory ConfidentialityDY</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Inductive Study of Confidentiality against Dolev-Yao›</span></span>

<span class="keyword1"><span class="command">theory</span></span> ConfidentialityDY <span class="keyword2"><span class="keyword">imports</span></span> <a href="NS_Public_Bad.html">NS_Public_Bad</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Existing study - fully spelled out›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In order not to leave hidden anything of the line of reasoning, we cancel some relevant lemmas that were installed previously›</span></span>

<span class="keyword1"><span class="command">declare</span></span> Spy_see_priEK <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
        Spy_analz_priEK <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
        analz_into_parts <span class="main">[</span><span class="operator">rule</span> <span class="quasi_keyword">del</span><span class="main">]</span>
        
<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹On static secrets›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Spy_see_priEK<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟹</span> <span class="main">(</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> parts <span class="main">(</span>spies <span class="free">evs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">∈</span> bad<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="comment1">(*Fake: screenshot1*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">:</span>bad"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">thm</span></span> ccontr
<span class="comment1">(*apply (rule ccontr) apply simp*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span> <span class="comment1">(*Spy knows bad agents' keys since start*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span> <span class="comment1">(*screenshot2*)</span>
<span class="keyword1"><span class="command">thm</span></span> Fake_parts_insert <span class="main">[</span><span class="operator">THEN</span> subsetD<span class="main">]</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> Fake_parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span><span class="comment1">(*screenshot3*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz_into_parts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Spy_analz_priEK<span class="main">:</span> 
      <span class="quoted"><span class="quoted">"<span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟹</span> <span class="main">(</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> analz <span class="main">(</span>spies <span class="free">evs</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">∈</span> bad<span class="main">)</span>"</span></span>
<span class="comment1">(*apply (auto simp: Spy_see_priEK dest: analz_into_parts)*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span>
<span class="comment1">(*Nil*)</span>
<span class="keyword1"><span class="command">thm</span></span> analz_image_freshK_simps
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> analz_image_freshK_simps<span class="main">)</span>
<span class="comment1">(*Fake*)</span>
<span class="comment1">(*apply spy_analz would close, alternatively:*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">:</span>bad"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span> <span class="comment1">(*Spy knows bad agents' keys since start*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> Fake_analz_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹On dynamic secrets›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Spy_not_see_NA<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="main">⟦</span>Says <span class="free">A</span> <span class="free">B</span> <span class="main">(</span>Crypt<span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span>
  <span class="free">A</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">B</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>                     
  <span class="main">⟹</span> Nonce <span class="free">NA</span> <span class="main">∉</span> analz <span class="main">(</span>spies <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> ns_public.induct<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Spy_analz_priEK<span class="main">)</span>
<span class="comment1">(*screenshot1*)</span>
<span class="keyword1"><span class="command">thm</span></span> conjI
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> conjI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="comment1">(*screenshot2*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> Fake_analz_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="comment1">(*screenshot3*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> unique_NA analz_into_parts <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> no_nonce_NS1_NS2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Spy_not_see_NB<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⟦</span>Says <span class="free">B</span> <span class="free">A</span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span>   
 <span class="main">∀</span><span class="bound">C</span><span class="main">.</span> Says <span class="free">A</span> <span class="bound">C</span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="bound">C</span><span class="main">)</span> <span class="main">(</span>Nonce <span class="free">NB</span><span class="main">)</span><span class="main">)</span> <span class="main">∉</span> set <span class="free">evs</span><span class="main">;</span>      
 <span class="free">A</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">B</span> <span class="main">∉</span> bad<span class="main">;</span>  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>                      
 <span class="main">⟹</span> Nonce <span class="free">NB</span> <span class="main">∉</span> analz <span class="main">(</span>spies <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Spy_analz_priEK<span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹apply <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">spy_analz</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>  
   is replaced here with the following list...›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ccontr<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> Fake_analz_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹...of commands!›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> all_conj_distrib<span class="main">)</span> <span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹speeds up next›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz_into_parts <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> no_nonce_NS1_NS2<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Novel study›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Generalising over all initial secrets the existing treatment, which is limited to private encryption keys›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">staticSecret</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">⇒</span> msg set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">staticSecret</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">≡</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Protocol independent study›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Converse doesn't hold because something that is said or noted is not necessarily an initial secret›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> staticSecret_parts_Spy<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">⟧</span>  <span class="main">⟹</span>
 <span class="free">A</span> <span class="main">∈</span> bad <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span><span class="main">.</span> Says <span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span> <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">Y</span><span class="main">.</span> Notes <span class="bound">C</span> <span class="bound">Y</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">∈</span> bad <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">Y</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="improper"><span class="improper">a</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Says›</span></span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equalityD1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Gets›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Notes›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> agent msg<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">agent</span><span class="main">∉</span>bad"</span></span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equalityD1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> staticSecret_analz_Spy<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">⟧</span>  <span class="main">⟹</span>
 <span class="free">A</span> <span class="main">∈</span> bad <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span><span class="main">.</span> Says <span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span> <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">Y</span><span class="main">.</span> Notes <span class="bound">C</span> <span class="bound">Y</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">∈</span> bad <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">Y</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> analz_into_parts <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> staticSecret_parts_Spy<span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">lemma</span></span> secret_parts_Spy<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>  <span class="main">⟹</span>
 <span class="free">m</span> <span class="main">∈</span> initState Spy <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span><span class="main">.</span> Says <span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span> <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">Y</span><span class="main">.</span> Notes <span class="bound">C</span> <span class="bound">Y</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">∈</span> bad <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">Y</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="improper"><span class="improper">a</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Says›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> initState_Spy<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equalityD1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> Un_iff<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Gets›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Notes›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> initState_Spy<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rename_tac</span> agent msg<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">agent</span><span class="main">∉</span>bad"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> initState_Spy<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main"><span class="main">:</span></span> initState_Spy<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equalityD1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> secret_parts_Spy_converse<span class="main">:</span>
<span class="quoted"><span class="quoted">" <span class="free">m</span> <span class="main">∈</span> initState Spy <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span><span class="main">.</span> Says <span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span> <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">Y</span><span class="main">.</span> Notes <span class="bound">C</span> <span class="bound">Y</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">∈</span> bad <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">Y</span><span class="main">}</span><span class="main">)</span>
 <span class="main">⟹</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Says_imp_knows_Spy <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">]</span></span> parts_trans<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> Notes_imp_knows_Spy <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">]</span></span> parts_trans<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> secret_analz_Spy<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span>  <span class="main">⟹</span>
 <span class="free">m</span> <span class="main">∈</span> initState Spy <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span><span class="main">.</span> Says <span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span> <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">Y</span><span class="main">.</span> Notes <span class="bound">C</span> <span class="bound">Y</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="bound">C</span> <span class="main">∈</span> bad <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">Y</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz_into_parts secret_parts_Spy<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Protocol-dependent study›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Proving generalised version of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> Spy_see_priEK<span class="antiquote"><span class="antiquote">}</span></span></span></span> using same strategy, the "direct" strategy›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> NS_Spy_see_staticSecret<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span> <span class="main">⟹</span>
   <span class="free">m</span> <span class="main">∈</span> parts<span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">∈</span> bad<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">:</span>bad"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span> <span class="comment1">(*Spy knows bad agents' keys since start*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> Fake_parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1,goals_limit=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz_into_parts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Seeking a proof of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> NS_Spy_see_staticSecret<span class="antiquote"><span class="antiquote">}</span></span></span></span> using an alternative, "specialisation" strategy›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> NS_no_Notes<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟹</span> Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∉</span> set <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> NS_staticSecret_parts_Spy_weak<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">;</span>
  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">∈</span> bad <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span><span class="main">.</span> Says <span class="bound">C</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> staticSecret_parts_Spy NS_no_Notes<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> NS_Says_staticSecret<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Says <span class="free">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">C</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="free">X</span><span class="main">}</span><span class="main">;</span>
   <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span><span class="main">=</span>Spy"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This generalises <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> Key_synth_eq<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> staticSecret_synth_eq<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">m</span> <span class="main">∈</span> synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">m</span> <span class="main">∈</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> NS_Says_Spy_staticSecret<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span>Says Spy <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="free">X</span><span class="main">}</span><span class="main">;</span>
   <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">∈</span> bad"</span></span>
<span class="comment1">(*
txt{*Alternative start to appreciate that it reduces to @{thm NS_Spy_see_staticSecret}*}
apply (erule rev_mp, erule ns_public.induct)
apply (simp_all del: staticSecret_def)
apply clarify 
txt{*@{subgoals [display,indent=1,goals_limit=1]}*}
apply (drule Fake_parts_sing [THEN subsetD], simp) 
txt{*@{subgoals [display,indent=1,goals_limit=1]}*}
apply (simp del: staticSecret_def add: staticSecret_synth_eq)
txt{*@{subgoals [display,indent=1,goals_limit=1]}*}
oops 
*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> Says_imp_knows_Spy <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">]</span></span><span class="main">)</span> 
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1,goals_limit=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rotate_tac</span> -1<span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1,goals_limit=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">:</span>bad"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span> <span class="comment1">(*Spy knows bad agents' keys since start*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarsimp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> Fake_parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz_into_parts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Here's the specialised version of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">thm</span></span> staticSecret_parts_Spy<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> NS_staticSecret_parts_Spy<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">;</span>
  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span> <span class="main">⟹</span> <span class="free">A</span> <span class="main">∈</span> bad"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> staticSecret_parts_Spy<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span>  [display,indent=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span> 
<span class="comment1">(*Case A bad*)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">assumption</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span> 
<span class="comment1">(*Case: Says*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> exE<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span>  [display,indent=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">C</span><span class="main">=</span>Spy"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> NS_Says_Spy_staticSecret<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> NS_Says_staticSecret<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> NS_no_Notes<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Concluding the specialisation proof strategy...›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> NS_Spy_see_staticSecret_spec<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span> <span class="main">⟹</span>
 <span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">∈</span> bad<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹one line proof:
apply (force dest: <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">NS_staticSecret_parts_Spy</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>)
›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> NS_staticSecret_parts_Spy<span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹one line proof: force›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> b<span class="main"><span class="main">=</span></span><span class="quoted">Encryption</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> evs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">evs</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> Spy_spies_bad_privateKey<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts.Inj<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> disjE<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> b<span class="main"><span class="main">=</span></span><span class="quoted">Signature</span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> evs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">evs</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> Spy_spies_bad_privateKey<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts.Inj<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule_tac</span> evs<span class="main"><span class="main">=</span></span><span class="quoted"><span class="free">evs</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> Spy_spies_bad_shrK<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts.Inj<span class="main"><span class="keyword3">,</span></span> <span class="operator">assumption</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> NS_Spy_analz_staticSecret<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span> <span class="main">⟹</span>
 <span class="free">m</span> <span class="main">∈</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">∈</span> bad<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz_into_parts NS_staticSecret_parts_Spy<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> NS_staticSecret_subset_parts_knows_Spy<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟹</span>
 staticSecret <span class="free">A</span> <span class="main">⊆</span> parts <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">∈</span> bad<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> NS_staticSecret_parts_Spy<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> NS_staticSecret_subset_analz_knows_Spy<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟹</span>
 staticSecret <span class="free">A</span> <span class="main">⊆</span> analz <span class="main">(</span>knows Spy <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span> <span class="main">∈</span> bad<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz_into_parts NS_staticSecret_parts_Spy<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword2"><span class="keyword">end</span></span>


</pre>
</div><div id="MessageGA">
<div class="head">
<h1>Theory MessageGA</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Theory of Agents and Messages for Security Protocols against the General Attacker›</span></span>

<span class="keyword1"><span class="command">theory</span></span> MessageGA <span class="keyword2"><span class="keyword">imports</span></span> <a href="../../HOL/HOL/Main.html">Main</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*Needed occasionally with spy_analz_tac, e.g. in analz_insert_Key_newK*)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span> <span class="main">∪</span> <span class="main">(</span><span class="free">B</span> <span class="main">∪</span> <span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="free">B</span> <span class="main">∪</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">type_synonym</span></span>
  key <span class="main">=</span> <span class="quoted">nat</span>

<span class="keyword1"><span class="command">consts</span></span>
  all_symmetric <span class="main">::</span> <span class="quoted">bool</span>        <span class="comment1">― ‹true if all keys are symmetric›</span>
  invKey        <span class="main">::</span> <span class="quoted"><span class="quoted">"key<span class="main">=&gt;</span>key"</span></span>  <span class="comment1">― ‹inverse of a symmetric key›</span>

<span class="keyword1"><span class="command">specification</span></span> <span class="main">(</span><span class="quoted">invKey</span><span class="main">)</span>
  invKey <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"invKey <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">=</span> <span class="free">K</span>"</span></span>
  invKey_symmetric<span class="main">:</span> <span class="quoted"><span class="quoted">"all_symmetric <span class="main">⟶</span> invKey <span class="main">=</span> id"</span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">id</span></span></span><span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹The inverse of a symmetric key is itself; that of a public key
      is the private key and vice versa›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">symKeys</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"key set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">symKeys</span> <span class="main">==</span> <span class="main">{</span><span class="bound">K</span><span class="main">.</span> invKey <span class="bound">K</span> <span class="main">=</span> <span class="bound">K</span><span class="main">}</span>"</span></span>

<span class="keyword1"><span class="command">datatype</span></span>  <span class="comment1">― ‹We only allow for any number of friendly agents›</span>
  agent <span class="main">=</span> Friend <span class="quoted">nat</span>

<span class="keyword1"><span class="command">datatype</span></span>
     msg <span class="main">=</span> Agent  <span class="quoted">agent</span>     <span class="comment1">― ‹Agent names›</span>
         <span class="main">|</span> Number <span class="quoted">nat</span>       <span class="comment1">― ‹Ordinary integers, timestamps, ...›</span>
         <span class="main">|</span> Nonce  <span class="quoted">nat</span>       <span class="comment1">― ‹Unguessable nonces›</span>
         <span class="main">|</span> Key    <span class="quoted">key</span>       <span class="comment1">― ‹Crypto keys›</span>
         <span class="main">|</span> Hash   <span class="quoted">msg</span>       <span class="comment1">― ‹Hashing›</span>
         <span class="main">|</span> MPair  <span class="quoted">msg</span> <span class="quoted">msg</span>   <span class="comment1">― ‹Compound messages›</span>
         <span class="main">|</span> Crypt  <span class="quoted">key</span> <span class="quoted">msg</span>   <span class="comment1">― ‹Encryption, public- or shared-key›</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Concrete syntax: messages appear as <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>⦃A,B,NA⦄›</span></span></span></span>, etc...›</span></span>
<span class="keyword1"><span class="command">syntax</span></span>
  <span class="quoted">"_MTuple"</span>      <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span><span class="tfree">'a</span><span class="main">,</span> args<span class="main">]</span> <span class="main">=&gt;</span> <span class="tfree">'a</span> <span class="main">*</span> <span class="tfree">'b</span>"</span></span>       <span class="main">(</span><span class="quoted">"<span class="keyword3">(2</span><span class="keyword1">⦃</span>_<span class="keyword1">,</span><span class="keyword3">/ </span>_<span class="keyword1">⦄</span><span class="keyword3">)</span>"</span><span class="main">)</span>
<span class="keyword1"><span class="command">translations</span></span>
  <span class="quoted">"<span class="main">⦃</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">⦄</span>"</span>   <span class="main">==</span> <span class="quoted">"<span class="main">⦃</span><span class="free">x</span><span class="main">,</span> <span class="main">⦃</span><span class="free">y</span><span class="main">,</span> <span class="free">z</span><span class="main">⦄</span><span class="main">⦄</span>"</span>
  <span class="quoted">"<span class="main">⦃</span><span class="free">x</span><span class="main">,</span> <span class="free">y</span><span class="main">⦄</span>"</span>      <span class="main">==</span> <span class="quoted">"<span class="keyword1">CONST</span> MPair <span class="free">x</span> <span class="free">y</span>"</span>


<span class="keyword1"><span class="command">definition</span></span> <span class="entity">HPair</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>msg<span class="main">,</span>msg<span class="main">]</span> <span class="main">=&gt;</span> msg"</span></span> <span class="main">(</span><span class="quoted">"<span class="keyword3">(4</span><span class="keyword1">Hash[</span>_<span class="keyword1">]</span> <span class="keyword3">/</span>_<span class="keyword3">)</span>"</span> <span class="main">[</span>0<span class="main">,</span> 1000<span class="main">]</span><span class="main">)</span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="comment1">― ‹Message Y paired with a MAC computed with the help of X›</span>
    <span class="quoted"><span class="quoted">"<span class="keyword1"><span class="free">Hash[</span></span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main"><span class="free">]</span></span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">==</span> <span class="main">⦃</span> Hash<span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span>"</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">keysFor</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set <span class="main">=&gt;</span> key set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
    <span class="comment1">― ‹Keys useful to decrypt elements of a message set›</span>
  <span class="quoted"><span class="quoted">"<span class="free">keysFor</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span> <span class="main">==</span> invKey <span class="main">`</span> <span class="main">{</span><span class="bound">K</span><span class="main">.</span> <span class="main">∃</span><span class="bound">X</span><span class="main">.</span> Crypt <span class="bound">K</span> <span class="bound">X</span> <span class="main">∈</span> <span class="free"><span class="bound"><span class="entity">H</span></span></span><span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Inductive definition of all parts of a message›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span>
  <span class="entity">parts</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set <span class="main">=&gt;</span> msg set"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">H</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    Inj <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>               <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">H</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Fst<span class="main">:</span>         <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span>   <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Snd<span class="main">:</span>         <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span>   <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Body<span class="main">:</span>        <span class="quoted"><span class="quoted">"Crypt <span class="free"><span class="bound"><span class="entity">K</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">parts</span> <span class="free">H</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Monotonicity›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> parts_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">⊆</span> <span class="free">H</span> <span class="main">⟹</span> parts<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> parts<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> parts.Fst parts.Snd parts.Body<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Equations hold because constructors are injective.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Friend_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Friend <span class="free">x</span> <span class="main">∈</span> Friend<span class="main">`</span><span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">:</span><span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Key_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Key <span class="free">x</span> <span class="main">∈</span> Key<span class="main">`</span><span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span><span class="main">∈</span><span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_Key_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nonce <span class="free">x</span> <span class="main">∉</span> Key<span class="main">`</span><span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Inverse of keys›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> invKey_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>invKey <span class="free">K</span> <span class="main">=</span> invKey <span class="free">K'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">K</span><span class="main">=</span><span class="free">K'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> invKey<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹keysFor operator›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_Un <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span><span class="free">H</span> <span class="main">∪</span> <span class="free">H'</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span> <span class="main">∪</span> keysFor <span class="free">H'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_UN <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">i</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> keysFor <span class="main">(</span><span class="free">H</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Monotonicity›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> keysFor_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G</span> <span class="main">⊆</span> <span class="free">H</span> <span class="main">⟹</span> keysFor<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> keysFor<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Agent <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Agent <span class="free">A</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Nonce <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Nonce <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Number <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Number <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Hash <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Hash <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_MPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_Crypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">(</span>keysFor <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_image_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>Key<span class="main">`</span><span class="free">E</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_imp_invKey_keysFor<span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> <span class="free">H</span> <span class="main">⟹</span> invKey <span class="free">K</span> <span class="main">∈</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Inductive relation "parts"›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> MPair_parts<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> parts <span class="free">H</span><span class="main">;</span>        
         <span class="main">[|</span> <span class="free">X</span> <span class="main">∈</span> parts <span class="free">H</span><span class="main">;</span> <span class="free">Y</span> <span class="main">∈</span> parts <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">P</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> parts.Fst parts.Snd<span class="main">)</span> 

<span class="keyword1"><span class="command">declare</span></span> MPair_parts <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main">!</span></span><span class="main">]</span>  parts.Body <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main">!</span></span><span class="main">]</span>
<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹NB These two rules are UNSAFE in the formal sense, as they discard the
     compound message.  They work well on THIS FILE.  
  <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>MPair_parts›</span></span></span></span> is left as SAFE because it speeds up proofs.
  The Crypt rule is normally kept UNSAFE to avoid breaking up certificates.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_increasing<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">H</span> <span class="main">⊆</span> parts<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> parts_insertI <span class="main">=</span> subset_insertI <span class="main">[</span><span class="operator">THEN</span> parts_mono<span class="main">,</span> <span class="operator">THEN</span> subsetD<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_emptyE <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> parts<span class="main">{}</span> <span class="main">⟹</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹WARNING: loops if H = {Y}, therefore must not be repeated!›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> parts_singleton<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> parts <span class="free">H</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">Y</span><span class="main">∈</span><span class="free">H</span><span class="main">.</span> <span class="free">X</span><span class="main">∈</span> parts <span class="main">{</span><span class="bound">Y</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">fast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Unions›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_Un_subset1<span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">∪</span> parts<span class="main">(</span><span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> parts<span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Un_least parts_mono Un_upper1 Un_upper2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_Un_subset2<span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> parts<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">∪</span> parts<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_Un <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">∪</span> parts<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI parts_Un_subset1 parts_Un_subset2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="main">{</span><span class="free">X</span><span class="main">}</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> insert_is_Un parts_Un<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹TWO inserts to avoid looping.  This rewrite is better than nothing.
  Not suitable for Addsimps: its behaviour can be strange.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> parts_insert2<span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="free">X</span> <span class="main">(</span>insert <span class="free">Y</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> parts <span class="main">{</span><span class="free">X</span><span class="main">}</span> <span class="main">∪</span> parts <span class="main">{</span><span class="free">Y</span><span class="main">}</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_commute Un_empty_right Un_insert_right insert_is_Un parts_Un<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_UN_subset1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> parts<span class="main">(</span><span class="free">H</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> parts<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">x</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> UN_least parts_mono UN_upper<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_UN_subset2<span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">x</span><span class="main">)</span> <span class="main">⊆</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> parts<span class="main">(</span><span class="free">H</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_UN <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">x</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">⋃</span><span class="bound">x</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> parts<span class="main">(</span><span class="free">H</span> <span class="bound">x</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI parts_UN_subset1 parts_UN_subset2<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Added to simplify arguments to parts, analz and synth.
  NOTE: the UN versions are no longer used!›</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This allows <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>blast›</span></span></span></span> to simplify occurrences of 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"parts<span class="main"><span class="main">(</span></span><span class="free"><span class="free">G</span></span><span class="main"><span class="main">∪</span></span><span class="free"><span class="free">H</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> in the assumption.›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> in_parts_UnE <span class="main">=</span> parts_Un <span class="main">[</span><span class="operator">THEN</span> equalityD1<span class="main">,</span> <span class="operator">THEN</span> subsetD<span class="main">,</span> <span class="operator">THEN</span> UnE<span class="main">]</span> 
<span class="keyword1"><span class="command">declare</span></span> in_parts_UnE <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main">!</span></span><span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> parts_insert_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="free">X</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> parts<span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> parts_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Idempotence and transitivity›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_partsD <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> parts <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">X</span><span class="main">∈</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_subset_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>parts <span class="free">G</span> <span class="main">⊆</span> parts <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">G</span> <span class="main">⊆</span> parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> parts_idem parts_increasing parts_mono subset_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">X</span> <span class="main">∈</span> parts <span class="free">G</span><span class="main">;</span>  <span class="free">G</span> <span class="main">⊆</span> parts <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">X</span><span class="main">∈</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> parts_mono<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Cut›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> parts_cut<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">Y</span><span class="main">∈</span> parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">G</span><span class="main">)</span><span class="main">;</span>  <span class="free">X</span> <span class="main">∈</span> parts <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">Y</span><span class="main">∈</span> parts <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> parts_trans<span class="main">)</span> 


<span class="keyword1"><span class="command">lemma</span></span> parts_cut_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> parts <span class="free">H</span> <span class="main">⟹</span> parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> parts_cut <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> parts_insertI<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Rewrite rules for pulling out atomic messages›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> parts_insert_eq_I <span class="main">=</span> equalityI <span class="main">[</span><span class="operator">OF</span> subsetI parts_insert_subset<span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Agent <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Agent <span class="free">agt</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Agent <span class="free">agt</span><span class="main">)</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parts_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Nonce <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Nonce <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Nonce <span class="free">N</span><span class="main">)</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parts_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Number <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Number <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Number <span class="free">N</span><span class="main">)</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parts_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parts_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Hash <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Hash <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Hash <span class="free">X</span><span class="main">)</span> <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> parts_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_Crypt <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> parts.Body<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_MPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>  
          insert <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">(</span>parts <span class="main">(</span>insert <span class="free">X</span> <span class="main">(</span>insert <span class="free">Y</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> parts.Fst parts.Snd<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_image_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>Key<span class="main">`</span><span class="free">N</span><span class="main">)</span> <span class="main">=</span> Key<span class="main">`</span><span class="free">N</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In any message, there is an upper bound N on its greatest nonce.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> msg_Nonce_supply<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">N</span><span class="main">.</span> <span class="main">∀</span><span class="bound">n</span><span class="main">.</span> <span class="bound">N</span><span class="main">≤</span><span class="bound">n</span> <span class="main">⟶</span> Nonce <span class="bound">n</span> <span class="main">∉</span> parts <span class="main">{</span><span class="free">msg</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">msg</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> exI parts_insert2<span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Nonce case›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Suc_n_not_le_n<span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹MPair case: metis works out the necessary sum itself!›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> le_trans nat_le_linear<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Inductive relation "analz"›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Inductive definition of "analz" -- what can be broken down from a set of
    messages, including keys.  A form of downward closure.  Pairs can
    be taken apart; messages decrypted with known keys.›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span>
  <span class="entity">analz</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set <span class="main">=&gt;</span> msg set"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">H</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    Inj <span class="main">[</span><span class="operator">intro</span><span class="main">,</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span>    <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">H</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Fst<span class="main">:</span>     <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Snd<span class="main">:</span>     <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Decrypt <span class="main">[</span><span class="operator">dest</span><span class="main">]</span><span class="main">:</span> 
             <span class="quoted"><span class="quoted">"<span class="main">[|</span>Crypt <span class="free"><span class="bound"><span class="entity">K</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span><span class="main">;</span> Key<span class="main">(</span>invKey <span class="free"><span class="bound"><span class="entity">K</span></span></span><span class="main">)</span><span class="main">:</span> <span class="free">analz</span> <span class="free">H</span><span class="main">|]</span> <span class="main">==&gt;</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">analz</span> <span class="free">H</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Monotonicity; Lemma 1 of Lowe's paper›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G</span><span class="main">⊆</span><span class="free">H</span> <span class="main">⟹</span> analz<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> analz<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz.Fst analz.Snd<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Making it safe speeds up proofs›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> MPair_analz <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span>        
             <span class="main">[|</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span> <span class="free">Y</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">P</span>   
          <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz.Fst analz.Snd<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_increasing<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">H</span> <span class="main">⊆</span> analz<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_subset_parts<span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="free">H</span> <span class="main">⊆</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> analz_into_parts <span class="main">=</span> analz_subset_parts <span class="main">[</span><span class="operator">THEN</span> subsetD<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> not_parts_not_analz <span class="main">=</span> analz_subset_parts <span class="main">[</span><span class="operator">THEN</span> contra_subsetD<span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> parts_analz <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> analz_increasing analz_subset_parts equalityI parts_mono parts_subset_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_parts <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>parts <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> analz_insertI <span class="main">=</span> subset_insertI <span class="main">[</span><span class="operator">THEN</span> analz_mono<span class="main">,</span> <span class="operator">THEN</span> <span class="main"><span class="main">[</span></span>2<span class="main"><span class="main">]</span></span> rev_subsetD<span class="main">]</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹General equational properties›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz<span class="main">{}</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Converse fails: we can analz more from the union than from the 
  separate parts, as a key in one might decrypt a message in the other›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"analz<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">∪</span> analz<span class="main">(</span><span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> analz<span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Un_least analz_mono Un_upper1 Un_upper2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="free">X</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> analz<span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Rewrite rules for pulling out atomic messages›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> analz_insert_eq_I <span class="main">=</span> equalityI <span class="main">[</span><span class="operator">OF</span> subsetI analz_insert<span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Agent <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Agent <span class="free">agt</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Agent <span class="free">agt</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Nonce <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Nonce <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Nonce <span class="free">N</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Number <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Number <span class="free">N</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Number <span class="free">N</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Hash <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Hash <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Hash <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Can only pull out Keys if they are not needed to decrypt the rest›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"<span class="free">K</span> <span class="main">∉</span> keysFor <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">⟹</span>   
          analz <span class="main">(</span>insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_MPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>  
          insert <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="main">(</span>insert <span class="free">Y</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz.Fst analz.Snd<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Can pull out enCrypted message if the Key is not known›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Crypt<span class="main">:</span>
     <span class="quoted"><span class="quoted">"Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∉</span> analz <span class="free">H</span> 
      <span class="main">⟹</span> analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> analz_insert_eq_I<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 

<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lemma1<span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">⟹</span>   
               analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span>  
               insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> lemma2<span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">⟹</span>   
               insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span>  
               analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="improper">x</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_insertI analz.Decrypt<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Decrypt<span class="main">:</span>
     <span class="quoted"><span class="quoted">"Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">⟹</span>   
               analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>  
               insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI lemma1 lemma2<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Case analysis: either the message is secure, or it is not! Effective,
but can cause subgoals to blow up! Use with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>if_split›</span></span></span></span>; apparently
<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>split_tac›</span></span></span></span> does not cope with patterns such as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span><span class="quoted"><span class="quoted">"analz <span class="main"><span class="main">(</span></span>insert
<span class="main"><span class="main">(</span></span>Crypt <span class="free"><span class="free">K</span></span> <span class="free"><span class="free">X</span></span><span class="main"><span class="main">)</span></span> <span class="free"><span class="free">H</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span> 
<span class="keyword1"><span class="command">lemma</span></span> analz_Crypt_if <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>                 
          <span class="main">(</span><span class="keyword1">if</span> <span class="main">(</span>Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">)</span>                 
           <span class="keyword1">then</span> insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>  
           <span class="keyword1">else</span> insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> analz_insert_Crypt analz_insert_Decrypt<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This rule supposes "for the sake of argument" that we have the key.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_insert_Crypt_subset<span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span>   
           insert <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> analz_image_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>Key<span class="main">`</span><span class="free">N</span><span class="main">)</span> <span class="main">=</span> Key<span class="main">`</span><span class="free">N</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Idempotence and transitivity›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_analzD <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> analz <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_idem <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_subset_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>analz <span class="free">G</span> <span class="main">⊆</span> analz <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">G</span> <span class="main">⊆</span> analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> analz_idem analz_increasing analz_mono subset_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">X</span><span class="main">∈</span> analz <span class="free">G</span><span class="main">;</span>  <span class="free">G</span> <span class="main">⊆</span> analz <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">X</span><span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> analz_mono<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Cut; Lemma 2 of Lowe›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_cut<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">Y</span><span class="main">∈</span> analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">;</span>  <span class="free">X</span><span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">Y</span><span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> analz_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="comment1">(*Cut can be proved easily by induction on
   "Y: analz (insert X H) ⟹ X: analz H ⟶ Y: analz H"
*)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹This rewrite rule helps in the simplification of messages that involve
  the forwarding of unknown components (X).  Without it, removing occurrences
  of X can be very complicated.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_insert_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">⟹</span> analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_cut analz_insertI<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹A congruence rule for "analz"›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_subset_cong<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> analz <span class="free">G</span> <span class="main">⊆</span> analz <span class="free">G'</span><span class="main">;</span> analz <span class="free">H</span> <span class="main">⊆</span> analz <span class="free">H'</span> <span class="main">|]</span> 
      <span class="main">==&gt;</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> analz <span class="main">(</span><span class="free">G'</span> <span class="main">∪</span> <span class="free">H'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> conjI subset_trans analz_mono Un_upper1 Un_upper2<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_cong<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> analz <span class="free">G</span> <span class="main">=</span> analz <span class="free">G'</span><span class="main">;</span> analz <span class="free">H</span> <span class="main">=</span> analz <span class="free">H'</span> <span class="main">|]</span> 
      <span class="main">==&gt;</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="main">(</span><span class="free">G'</span> <span class="main">∪</span> <span class="free">H'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> equalityI analz_subset_cong<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp_all</span><span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_cong<span class="main">:</span>
     <span class="quoted"><span class="quoted">"analz <span class="free">H</span> <span class="main">=</span> analz <span class="free">H'</span> <span class="main">⟹</span> analz<span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz<span class="main">(</span>insert <span class="free">X</span> <span class="free">H'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> insert_def <span class="quasi_keyword">intro</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> analz_cong<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹If there are no pairs or encryptions then analz does nothing›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_trivial<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="main">∀</span><span class="bound">X</span> <span class="bound">Y</span><span class="main">.</span> <span class="main">⦃</span><span class="bound">X</span><span class="main">,</span><span class="bound">Y</span><span class="main">⦄</span> <span class="main">∉</span> <span class="free">H</span><span class="main">;</span>  <span class="main">∀</span><span class="bound">X</span> <span class="bound">K</span><span class="main">.</span> Crypt <span class="bound">K</span> <span class="bound">X</span> <span class="main">∉</span> <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> analz <span class="free">H</span> <span class="main">=</span> <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹These two are obsolete but cost little to prove...›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_UN_analz_lemma<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> analz <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> analz <span class="main">(</span><span class="free">H</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">X</span><span class="main">∈</span> analz <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_UN_analz <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> analz <span class="main">(</span><span class="free">H</span> <span class="bound">i</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> analz <span class="main">(</span><span class="main">⋃</span><span class="bound">i</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">H</span> <span class="bound">i</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_UN_analz_lemma analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Inductive relation "synth"›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Inductive definition of "synth" -- what can be built up from a set of
    messages.  A form of upward closure.  Pairs can be built, messages
    encrypted with known keys.  Agent names are public domain.
    Numbers can be guessed, but Nonces cannot be.›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span>
  <span class="entity">synth</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set <span class="main">=&gt;</span> msg set"</span></span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="entity">H</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    Inj    <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">H</span> <span class="main">⟹</span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Agent  <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"Agent <span class="free"><span class="bound"><span class="entity">agt</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Number <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"Number <span class="free"><span class="bound"><span class="entity">n</span></span></span>  <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Hash   <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span> <span class="main">⟹</span> Hash <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> MPair  <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="main">[|</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span><span class="main">;</span>  <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span><span class="main">|]</span> <span class="main">==&gt;</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>
  <span class="main">|</span> Crypt  <span class="main">[</span><span class="operator">intro</span><span class="main">]</span><span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="main">[|</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span><span class="main">;</span>  Key<span class="main">(</span><span class="free"><span class="bound"><span class="entity">K</span></span></span><span class="main">)</span> <span class="main">∈</span> <span class="free">H</span><span class="main">|]</span> <span class="main">==&gt;</span> Crypt <span class="free"><span class="bound"><span class="entity">K</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">synth</span> <span class="free">H</span>"</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Monotonicity›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> synth_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G</span><span class="main">⊆</span><span class="free">H</span> <span class="main">⟹</span> synth<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">⊆</span> synth<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> synth.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>  

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹NO <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Agent_synth›</span></span></span></span>, as any Agent name can be synthesized.  
  The same holds for <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">Number</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">inductive_simps</span></span> synth_simps <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
 <span class="quoted"><span class="quoted">"Nonce <span class="free">n</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
 <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
 <span class="quoted"><span class="quoted">"Hash <span class="free">X</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
 <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
 <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> synth_increasing<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">H</span> <span class="main">⊆</span> synth<span class="main">(</span><span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Unions›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Converse fails: we can synth more from the union than from the 
  separate parts, building a compound message using elements of each.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> synth_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"synth<span class="main">(</span><span class="free">G</span><span class="main">)</span> <span class="main">∪</span> synth<span class="main">(</span><span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> synth<span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">intro</span> Un_least synth_mono Un_upper1 Un_upper2<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="free">X</span> <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> synth<span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> synth_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Idempotence and transitivity›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> synth_synthD <span class="main">[</span><span class="operator">dest</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">X</span><span class="main">∈</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> synth.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_idem<span class="main">:</span> <span class="quoted"><span class="quoted">"synth <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_subset_iff <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>synth <span class="free">G</span> <span class="main">⊆</span> synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">G</span> <span class="main">⊆</span> synth <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> subset_trans synth_idem synth_increasing synth_mono<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_trans<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">X</span><span class="main">∈</span> synth <span class="free">G</span><span class="main">;</span>  <span class="free">G</span> <span class="main">⊆</span> synth <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">X</span><span class="main">∈</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> synth_mono<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Cut; Lemma 2 of Lowe›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> synth_cut<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">Y</span><span class="main">∈</span> synth <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">;</span>  <span class="free">X</span><span class="main">∈</span> synth <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">Y</span><span class="main">∈</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">erule</span> synth_trans<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Agent_synth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Agent <span class="free">A</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Number_synth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Number <span class="free">n</span> <span class="main">∈</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_synth_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Nonce <span class="free">N</span> <span class="main">∈</span> synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Nonce <span class="free">N</span> <span class="main">∈</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Key_synth_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_synth_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">∉</span> <span class="free">H</span> <span class="main">⟹</span> <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">lemma</span></span> keysFor_synth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span> <span class="main">∪</span> invKey<span class="main">`</span><span class="main">{</span><span class="bound">K</span><span class="main">.</span> Key <span class="bound">K</span> <span class="main">∈</span> <span class="free">H</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Combinations of parts, analz and synth›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_synth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> parts <span class="free">H</span> <span class="main">∪</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> parts.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> synth_increasing <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts_mono<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span> 
                    parts.Fst parts.Snd parts.Body<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_analz_Un <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>analz <span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">intro</span> equalityI analz_subset_cong<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_synth_Un <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>synth <span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span> <span class="main">∪</span> synth <span class="free">G</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> equalityI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 5 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz.Fst analz.Snd analz.Decrypt<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_synth <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"analz <span class="main">(</span>synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> analz <span class="free">H</span> <span class="main">∪</span> synth <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_empty_right analz_synth_Un<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹For reasoning about the Fake rule in traces›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_subset_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> <span class="free">G</span> <span class="main">⟹</span> parts<span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> parts <span class="free">G</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> UnCI Un_upper2 insert_subset parts_Un parts_mono<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹More specifically for Fake. See also <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Fake_parts_sing›</span></span></span></span> below›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Fake_parts_insert<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">⟹</span>  
      parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Un_commute analz_increasing insert_subset parts_analz parts_mono 
          parts_synth synth_mono synth_subset_iff<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Fake_parts_insert_in_Un<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span><span class="free">Z</span> <span class="main">∈</span> parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">;</span>  <span class="free">X</span><span class="main">:</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">|]</span> 
      <span class="main">==&gt;</span> <span class="free">Z</span> <span class="main">∈</span>  synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Fake_parts_insert subsetD<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">H</span></span></span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> is sometimes <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span><span class="quoted"><span class="quoted">"Key <span class="main"><span class="main">`</span></span> <span class="free"><span class="free">KK</span></span> <span class="main"><span class="main">∪</span></span> <span class="free"><span class="free">spies</span></span> <span class="free"><span class="free">evs</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, so can't put 
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">G</span></span><span class="main"><span class="main">=</span></span><span class="free"><span class="free">H</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Fake_analz_insert<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span><span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">G</span><span class="main">)</span> <span class="main">⟹</span>  
      analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span> <span class="main">⊆</span> synth <span class="main">(</span>analz <span class="free">G</span><span class="main">)</span> <span class="main">∪</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> subsetI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">x</span> <span class="main">∈</span> analz <span class="main">(</span>synth <span class="main">(</span>analz <span class="free">G</span><span class="main">)</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span>"</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> synth_mono<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> analz_conj_parts <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">∧</span> <span class="free">X</span> <span class="main">∈</span> parts <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_subset_parts <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_disj_parts <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|</span> <span class="free">X</span> <span class="main">∈</span> parts <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">∈</span> parts <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_subset_parts <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Without this equation, other rules for synth and analz would yield
  redundant cases›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> MPair_synth_analz <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  
      <span class="main">(</span><span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">∧</span> <span class="free">Y</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_synth_analz<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> Key <span class="free">K</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span>  Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span>  
       <span class="main">==&gt;</span> <span class="main">(</span>Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">lemma</span></span> Hash_synth_analz <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∉</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>  
      <span class="main">⟹</span> <span class="main">(</span>Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹HPair: a combination of Hash and MPair›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Freeness›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Agent_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Agent <span class="free">A</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Number_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Number <span class="free">N</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Key_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Hash_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Hash <span class="free">Z</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_neq_HPair<span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X'</span> <span class="main">~=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> HPair_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> HPair_neqs <span class="main">=</span> Agent_neq_HPair Nonce_neq_HPair Number_neq_HPair 
                    Key_neq_HPair Hash_neq_HPair Crypt_neq_HPair

<span class="keyword1"><span class="command">declare</span></span> HPair_neqs <span class="main">[</span><span class="operator">iff</span><span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> HPair_neqs <span class="main">[</span><span class="operator">symmetric</span><span class="main">,</span> <span class="operator">iff</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> HPair_eq <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X'</span><span class="main">]</span> <span class="free">Y'</span> <span class="main">=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X'</span> <span class="main">=</span> <span class="free">X</span> <span class="main">∧</span> <span class="free">Y'</span><span class="main">=</span><span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> MPair_eq_HPair <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="main">⦃</span><span class="free">X'</span><span class="main">,</span><span class="free">Y'</span><span class="main">⦄</span> <span class="main">=</span> <span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X'</span> <span class="main">=</span> Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∧</span> <span class="free">Y'</span><span class="main">=</span><span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> HPair_eq_MPair <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span> <span class="main">=</span> <span class="main">⦃</span><span class="free">X'</span><span class="main">,</span><span class="free">Y'</span><span class="main">⦄</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">X'</span> <span class="main">=</span> Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∧</span> <span class="free">Y'</span><span class="main">=</span><span class="free">Y</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span><span class="quoted"><span class="plain_text">‹Specialized laws, proved in terms of those for Hash and MPair›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_insert_HPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>insert <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> parts_insert_HPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"parts <span class="main">(</span>insert <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>  
     insert <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="main">(</span>insert <span class="main">(</span>Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span><span class="main">)</span> <span class="main">(</span>parts <span class="main">(</span>insert <span class="free">Y</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_HPair <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> 
    <span class="quoted"><span class="quoted">"analz <span class="main">(</span>insert <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="free">H</span><span class="main">)</span> <span class="main">=</span>  
     insert <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span><span class="main">)</span> <span class="main">(</span>insert <span class="main">(</span>Hash<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span><span class="main">)</span> <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">Y</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> HPair_synth_analz <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∉</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>  
    <span class="main">⟹</span> <span class="main">(</span><span class="keyword1">Hash[</span><span class="free">X</span><span class="main">]</span> <span class="free">Y</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span>  
        <span class="main">(</span>Hash <span class="main">⦃</span><span class="free">X</span><span class="main">,</span> <span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">∧</span> <span class="free">Y</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HPair_def<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹We do NOT want Crypt... messages broken up in protocols!!›</span></span>
<span class="keyword1"><span class="command">declare</span></span> parts.Body <span class="main">[</span><span class="operator">rule</span> <span class="quasi_keyword">del</span><span class="main">]</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Rewrites to push in Key and Crypt messages, so that other messages can
    be pulled out using the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>analz_insert›</span></span></span></span> rules›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> pushKeys <span class="main">=</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Agent <span class="free">C</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Number <span class="free">N</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Hash <span class="free">X</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"MPair <span class="free">X</span> <span class="free">Y</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K'</span>"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">K</span> <span class="free">C</span> <span class="free">N</span> <span class="free">X</span> <span class="free">Y</span> <span class="free">K'</span>

<span class="keyword1"><span class="command">lemmas</span></span> pushCrypts <span class="main">=</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Agent <span class="free">C</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Agent <span class="free">C</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Number <span class="free">N</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"Hash <span class="free">X'</span>"</span></span><span class="main">]</span>
  insert_commute <span class="main">[</span><span class="operator">of</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">X</span> <span class="free">K</span>"</span></span> <span class="quoted"><span class="quoted">"MPair <span class="free">X'</span> <span class="free">Y</span>"</span></span><span class="main">]</span>
  <span class="keyword2"><span class="keyword">for</span></span> <span class="free">X</span> <span class="free">K</span> <span class="free">C</span> <span class="free">N</span> <span class="free">X'</span> <span class="free">Y</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Cannot be added with <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>[simp]›</span></span></span></span> -- messages should not always be
  re-ordered.›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> pushes <span class="main">=</span> pushKeys pushCrypts


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹The set of key-free messages›</span></span>

<span class="comment1">(*Note that even the encryption of a key-free message remains key-free.
  This concept is valuable because of the theorem analz_keyfree_into_Un, proved below. *)</span>

<span class="keyword1"><span class="command">inductive_set</span></span>
  <span class="entity">keyfree</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"msg set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    Agent<span class="main">:</span>  <span class="quoted"><span class="quoted">"Agent <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>
  <span class="main">|</span> Number<span class="main">:</span> <span class="quoted"><span class="quoted">"Number <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>
  <span class="main">|</span> Nonce<span class="main">:</span>  <span class="quoted"><span class="quoted">"Nonce <span class="free"><span class="bound"><span class="entity">N</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>
  <span class="main">|</span> Hash<span class="main">:</span>   <span class="quoted"><span class="quoted">"Hash <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>
  <span class="main">|</span> MPair<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">[|</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span><span class="main">;</span>  <span class="free"><span class="bound"><span class="entity">Y</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span><span class="main">|]</span> <span class="main">==&gt;</span> <span class="main">⦃</span><span class="free"><span class="bound"><span class="entity">X</span></span></span><span class="main">,</span><span class="free"><span class="bound"><span class="entity">Y</span></span></span><span class="main">⦄</span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>
  <span class="main">|</span> Crypt<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">[|</span><span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span><span class="main">|]</span> <span class="main">==&gt;</span> Crypt <span class="free"><span class="bound"><span class="entity">K</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> <span class="free">keyfree</span>"</span></span>


<span class="keyword1"><span class="command">declare</span></span> keyfree.intros <span class="main">[</span><span class="operator">intro</span><span class="main">]</span> 

<span class="keyword1"><span class="command">inductive_cases</span></span> keyfree_KeyE<span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">∈</span> keyfree"</span></span>
<span class="keyword1"><span class="command">inductive_cases</span></span> keyfree_MPairE<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> keyfree"</span></span>
<span class="keyword1"><span class="command">inductive_cases</span></span> keyfree_CryptE<span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> keyfree"</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_keyfree<span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>keyfree<span class="main">)</span> <span class="main">⊆</span> keyfree"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">clarify</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> parts.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> keyfree_KeyE keyfree_MPairE keyfree_CryptE<span class="main">)</span>

<span class="comment1">(*The key-free part of a set of messages can be removed from the scope of the analz operator.*)</span>
<span class="keyword1"><span class="command">lemma</span></span> analz_keyfree_into_Un<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">X</span> <span class="main">∈</span> analz <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span><span class="main">;</span> <span class="free">G</span> <span class="main">⊆</span> keyfree<span class="main">⟧</span> <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> parts <span class="free">G</span> <span class="main">∪</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span>parts.Body<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> parts.Body<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> Un_absorb2 keyfree_KeyE parts_Un parts_keyfree UnI2<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Tactics useful for many protocol proofs›</span></span>
<span class="keyword1"><span class="command">ML</span></span>
<span class="quoted">‹
<span class="comment1">(*Analysis of Fake cases.  Also works for messages that forward unknown parts,
  but this application is no longer necessary if analz_insert_eq is used.
  DEPENDS UPON "X" REFERRING TO THE FRADULENT MESSAGE *)</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">impOfSubs</span> <span class="entity">th</span> <span class="main">=</span> <span class="entity">th</span> RSN <span class="main">(</span><span class="inner_numeral">2</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> rev_subsetD<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="comment1">(*Apply rules to break down assumptions of the form
  Y ∈ parts(insert X H)  and  Y ∈ analz(insert X H)
*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">Fake_insert_tac</span> <span class="entity">ctxt</span> <span class="main">=</span> 
    dresolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">impOfSubs</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fake_analz_insert<span class="antiquote">}</span></span></span><span class="main">,</span>
                  <span class="entity">impOfSubs</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Fake_parts_insert<span class="antiquote">}</span></span></span><span class="main">]</span> THEN'
    eresolve_tac <span class="entity">ctxt</span> <span class="main">[</span>asm_rl<span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> synth.Inj<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">Fake_insert_simp_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span> <span class="main">=</span> 
  REPEAT <span class="main">(</span><span class="entity">Fake_insert_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">)</span> THEN <span class="entity">asm_full_simp_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">atomic_spy_analz_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  SELECT_GOAL
   <span class="main">(</span><span class="entity">Fake_insert_simp_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span> THEN
    IF_UNSOLVED
      <span class="main">(</span><span class="entity">Blast.depth_tac</span>
        <span class="main">(</span><span class="entity">ctxt</span> <span class="entity">addIs</span> <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> analz_insertI<span class="antiquote">}</span></span></span><span class="main">,</span> <span class="entity">impOfSubs</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> analz_subset_parts<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span> <span class="inner_numeral">4</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>

<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">spy_analz_tac</span> <span class="entity">ctxt</span> <span class="entity">i</span> <span class="main">=</span>
  DETERM
   <span class="main">(</span>SELECT_GOAL
     <span class="main">(</span>EVERY 
      <span class="main">[</span>  <span class="comment1">(*push in occurrences of X...*)</span>
       <span class="main">(</span>REPEAT o CHANGED<span class="main">)</span>
         <span class="main">(</span><span class="entity">Rule_Insts.res_inst_tac</span> <span class="entity">ctxt</span> <span class="main">[</span><span class="main">(</span><span class="main">(</span><span class="main">(</span><span class="inner_quoted">"x"</span><span class="main">,</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span> Position.none<span class="main">)</span><span class="main">,</span> <span class="inner_quoted">"X"</span><span class="main">)</span><span class="main">]</span> <span class="main">[</span><span class="main">]</span>
          <span class="main">(</span><span class="entity">insert_commute</span> RS <span class="entity">ssubst</span><span class="main">)</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">,</span>
       <span class="comment1">(*...allowing further simplifications*)</span>
       <span class="entity">simp_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">,</span>
       REPEAT <span class="main">(</span>FIRSTGOAL <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">allI</span><span class="main">,</span><span class="entity">impI</span><span class="main">,</span><span class="entity">notI</span><span class="main">,</span><span class="entity">conjI</span><span class="main">,</span><span class="entity">iffI</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">,</span>
       DEPTH_SOLVE <span class="main">(</span><span class="entity">atomic_spy_analz_tac</span> <span class="entity">ctxt</span> <span class="inner_numeral">1</span><span class="main">)</span><span class="main">]</span><span class="main">)</span> <span class="entity">i</span><span class="main">)</span><span class="main">;</span>
›</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹By default only <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>o_apply›</span></span></span></span> is built-in.  But in the presence of
eta-expansion this means that some terms displayed as <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"<span class="free"><span class="free">f</span></span> <span class="keyword1"><span class="keyword1">o</span></span> <span class="free"><span class="free">g</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> will be
rewritten, and others will not!›</span></span>
<span class="keyword1"><span class="command">declare</span></span> o_def <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> Crypt_notin_image_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∉</span> Key <span class="main">`</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> Hash_notin_image_Key <span class="main">[</span><span class="operator">simp</span><span class="main">]</span> <span class="main">:</span><span class="quoted"><span class="quoted">"Hash <span class="free">X</span> <span class="main">∉</span> Key <span class="main">`</span> <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_analz_mono<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">G</span><span class="main">⊆</span><span class="free">H</span> <span class="main">⟹</span> synth <span class="main">(</span>analz<span class="main">(</span><span class="free">G</span><span class="main">)</span><span class="main">)</span> <span class="main">⊆</span> synth <span class="main">(</span>analz<span class="main">(</span><span class="free">H</span><span class="main">)</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">iprover</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> synth_mono analz_mono<span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> Fake_analz_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> synth<span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">⟹</span> synth <span class="main">(</span>analz <span class="main">(</span>insert <span class="free">X</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Fake_analz_insert Un_absorb Un_absorb1 Un_commute 
          subset_insertI synth_analz_mono synth_increasing synth_subset_iff<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Two generalizations of <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>analz_insert_eq›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> gen_analz_insert_eq <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">G</span><span class="main">.</span> <span class="free">H</span> <span class="main">⊆</span> <span class="bound">G</span> <span class="main">⟶</span> analz <span class="main">(</span>insert <span class="free">X</span> <span class="bound">G</span><span class="main">)</span> <span class="main">=</span> analz <span class="bound">G</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_cut analz_insertI analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> synth_analz_insert_eq <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> 
      <span class="main">⟹</span> <span class="main">∀</span> <span class="bound">G</span><span class="main">.</span> <span class="free">H</span> <span class="main">⊆</span> <span class="bound">G</span> <span class="main">⟶</span> <span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> analz <span class="main">(</span>insert <span class="free">X</span> <span class="bound">G</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> analz <span class="bound">G</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> synth.induct<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> gen_analz_insert_eq subset_trans <span class="main"><span class="main">[</span></span><span class="operator">OF</span> _ subset_insertI<span class="main"><span class="main">]</span></span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Fake_parts_sing<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">⟹</span> parts<span class="main">{</span><span class="free">X</span><span class="main">}</span> <span class="main">⊆</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">∪</span> parts <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">metis</span> Fake_parts_insert empty_subsetI insert_mono parts_mono subset_trans<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> Fake_parts_sing_imp_Un <span class="main">=</span> Fake_parts_sing <span class="main">[</span><span class="operator">THEN</span> <span class="main"><span class="main">[</span></span>2<span class="main"><span class="main">]</span></span> rev_subsetD<span class="main">]</span>

<span class="keyword1"><span class="command">method_setup</span></span> spy_analz <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> o <span class="entity">spy_analz_tac</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving the Fake case when analz is involved"</span>

<span class="keyword1"><span class="command">method_setup</span></span> atomic_spy_analz <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> o <span class="entity">atomic_spy_analz_tac</span><span class="main">)</span>›</span>
    <span class="quoted">"for debugging spy_analz"</span>

<span class="keyword1"><span class="command">method_setup</span></span> Fake_insert_simp <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD'</span> o <span class="entity">Fake_insert_simp_tac</span><span class="main">)</span>›</span>
    <span class="quoted">"for debugging spy_analz"</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="EventGA">
<div class="head">
<h1>Theory EventGA</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Theory of Events for Security Protocols against the General Attacker›</span></span>

<span class="keyword1"><span class="command">theory</span></span> EventGA <span class="keyword2"><span class="keyword">imports</span></span> <a href="MessageGA.html">MessageGA</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">consts</span></span>  <span class="comment1">(*Initial states of agents -- parameter of the construction*)</span>
  initState <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> msg set"</span></span>

<span class="keyword1"><span class="command">datatype</span></span>
  event <span class="main">=</span> Says  <span class="quoted">agent</span> <span class="quoted">agent</span> <span class="quoted">msg</span>
        <span class="main">|</span> Gets  <span class="quoted">agent</span>       <span class="quoted">msg</span>
        <span class="main">|</span> Notes <span class="quoted">agent</span>       <span class="quoted">msg</span>
       
<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">knows</span>  <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> event list <span class="main">=&gt;</span> msg set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
   knows_Nil<span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">[]</span> <span class="main">=</span> initState <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>
 <span class="main">|</span> knows_Cons<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ev</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span> <span class="main">=</span>
        <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ev</span></span></span> <span class="keyword1">of</span>
           Says <span class="bound">A'</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">⇒</span> insert <span class="bound">X</span> <span class="main">(</span><span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span>
         <span class="main">|</span> Gets <span class="bound">A'</span> <span class="bound">X</span>   <span class="main">⇒</span> <span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span>
         <span class="main">|</span> Notes <span class="bound">A'</span> <span class="bound">X</span>  <span class="main">⇒</span> 
             <span class="keyword1">if</span> <span class="bound">A'</span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="keyword1">then</span> insert <span class="bound">X</span> <span class="main">(</span><span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span> <span class="keyword1">else</span> <span class="free">knows</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">primrec</span></span>
  <span class="comment1">(*Set of items that might be visible to somebody:
    complement of the set of fresh items*)</span>
 <span class="entity">used</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"event list <span class="main">=&gt;</span> msg set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
   used_Nil<span class="main">:</span>   <span class="quoted"><span class="quoted">"<span class="free">used</span> <span class="main">[]</span>         <span class="main">=</span> <span class="main">(</span><span class="keyword1">UN</span> <span class="bound">B</span><span class="main">.</span> parts <span class="main">(</span>initState <span class="bound">B</span><span class="main">)</span><span class="main">)</span>"</span></span>
 <span class="main">|</span> used_Cons<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="free">used</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">ev</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span> <span class="main">=</span>
                     <span class="main">(</span><span class="keyword1">case</span> <span class="free"><span class="bound"><span class="entity">ev</span></span></span> <span class="keyword1">of</span>
                        Says <span class="bound">A</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">=&gt;</span> parts <span class="main">{</span><span class="bound">X</span><span class="main">}</span> <span class="main">∪</span> <span class="free">used</span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span>
                      <span class="main">|</span> Gets <span class="bound">A</span> <span class="bound">X</span>   <span class="main">=&gt;</span> <span class="free">used</span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span>
                      <span class="main">|</span> Notes <span class="bound">A</span> <span class="bound">X</span>  <span class="main">=&gt;</span> parts <span class="main">{</span><span class="bound">X</span><span class="main">}</span> <span class="main">∪</span> <span class="free">used</span> <span class="free"><span class="bound"><span class="entity">evs</span></span></span><span class="main">)</span>"</span></span>
    <span class="comment1">― ‹The case for <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Gets</span><span class="antiquote">}</span></span> seems anomalous, but <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Gets</span><span class="antiquote">}</span></span> always
        follows <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">term</span> <span class="quoted">Says</span><span class="antiquote">}</span></span> in real protocols.  Seems difficult to change.
        See <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">Gets_correct</span><span class="antiquote">}</span></span> in theory <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"Guard/Extensions.thy"</span><span class="antiquote">}</span></span>.›</span>

<span class="keyword1"><span class="command">lemma</span></span> Notes_imp_used <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">⟶</span> <span class="free">X</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">evs</span></span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Says_imp_used <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Says <span class="free">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">⟶</span> <span class="free">X</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">evs</span></span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">knows</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> parts_insert_knows_A <span class="main">=</span> parts_insert <span class="main">[</span><span class="operator">of</span> <span class="main">_</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span>"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">A</span> <span class="free">evs</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Says <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="main">(</span>Says <span class="free">A'</span> <span class="free">B</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">X</span> <span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Notes <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="main">(</span>Notes <span class="free">A'</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span>  
          <span class="main">(</span><span class="keyword1">if</span> <span class="free">A</span><span class="main">=</span><span class="free">A'</span> <span class="keyword1">then</span> insert <span class="free">X</span> <span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span> <span class="keyword1">else</span> knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_Gets <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="main">(</span>Gets <span class="free">A'</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> knows <span class="free">A</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Everybody sees what is sent on the traffic›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Says_imp_knows <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"Says <span class="free">A'</span> <span class="free">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">⟶</span> <span class="main">(</span><span class="main">∀</span><span class="bound">A</span><span class="main">.</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="bound">A</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Notes_imp_knows <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"Notes <span class="free">A'</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">⟶</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">A'</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Elimination rules: derive contradictions from old Says events containing
  items known to be fresh›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> Says_imp_parts_knows <span class="main">=</span> 
       Says_imp_knows <span class="main">[</span><span class="operator">THEN</span> parts.Inj<span class="main">,</span> <span class="operator">THEN</span> revcut_rl<span class="main">]</span> 

<span class="keyword1"><span class="command">lemmas</span></span> knows_partsEs <span class="main">=</span>
     Says_imp_parts_knows parts.Body <span class="main">[</span><span class="operator">THEN</span> revcut_rl<span class="main">]</span>

<span class="keyword1"><span class="command">lemmas</span></span> Says_imp_analz <span class="main">=</span> Says_imp_knows <span class="main">[</span><span class="operator">THEN</span> analz.Inj<span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Knowledge of generic agents›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> knows_subset_knows_Says<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span> <span class="main">⊆</span> knows <span class="free">A</span> <span class="main">(</span>Says <span class="free">A'</span> <span class="free">B</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_insertI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_subset_knows_Notes<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span> <span class="main">⊆</span> knows <span class="free">A</span> <span class="main">(</span>Notes <span class="free">A'</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_insertI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_subset_knows_Gets<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span> <span class="main">⊆</span> knows <span class="free">A</span> <span class="main">(</span>Gets <span class="free">A'</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> subset_insertI<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> knows_imp_Says_Gets_Notes_initState <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span> <span class="main">⟹</span> <span class="main">∃</span><span class="bound">A'</span> <span class="bound">B</span><span class="main">.</span>  
  Says <span class="bound">A'</span> <span class="bound">B</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∨</span> Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∨</span> <span class="free">X</span> <span class="main">∈</span> initState <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_knows_subset_used<span class="main">:</span> <span class="quoted"><span class="quoted">"parts <span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span> <span class="main">⊆</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span><span class="main">)</span>  
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parts_insert_knows_A <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> event.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> usedI <span class="main">=</span> parts_knows_subset_used <span class="main">[</span><span class="operator">THEN</span> subsetD<span class="main">,</span> <span class="operator">intro</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> initState_into_used<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">X</span> <span class="main">∈</span> parts <span class="main">(</span>initState <span class="free">B</span><span class="main">)</span> <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parts_insert_knows_A <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> used_Says <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"used <span class="main">(</span>Says <span class="free">A</span> <span class="free">B</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> parts<span class="main">{</span><span class="free">X</span><span class="main">}</span> <span class="main">∪</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> used_Notes <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"used <span class="main">(</span>Notes <span class="free">A</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> parts<span class="main">{</span><span class="free">X</span><span class="main">}</span> <span class="main">∪</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> used_Gets <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"used <span class="main">(</span>Gets <span class="free">A</span> <span class="free">X</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

<span class="keyword1"><span class="command">lemma</span></span> used_nil_subset<span class="main">:</span> <span class="quoted"><span class="quoted">"used <span class="main">[]</span> <span class="main">⊆</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> initState_into_used<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹NOTE REMOVAL--laws above are cleaner, as they don't involve "case"›</span></span>
<span class="keyword1"><span class="command">declare</span></span> knows_Cons <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>
        used_Nil <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span> used_Cons <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>


<span class="keyword1"><span class="command">lemmas</span></span> analz_mono_contra <span class="main">=</span>
       knows_subset_knows_Says <span class="main">[</span><span class="operator">THEN</span> analz_mono<span class="main">,</span> <span class="operator">THEN</span> contra_subsetD<span class="main">]</span>
       knows_subset_knows_Notes <span class="main">[</span><span class="operator">THEN</span> analz_mono<span class="main">,</span> <span class="operator">THEN</span> contra_subsetD<span class="main">]</span>
       knows_subset_knows_Gets <span class="main">[</span><span class="operator">THEN</span> analz_mono<span class="main">,</span> <span class="operator">THEN</span> contra_subsetD<span class="main">]</span>


<span class="keyword1"><span class="command">lemma</span></span> knows_subset_knows_Cons<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span> <span class="main">⊆</span> knows <span class="free">A</span> <span class="main">(</span><span class="free">e</span> <span class="main">#</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">e</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">simp</span><span class="main"><span class="main">:</span></span> knows_Cons<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> initState_subset_knows<span class="main">:</span> <span class="quoted"><span class="quoted">"initState <span class="free">A</span> <span class="main">⊆</span> knows <span class="free">A</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">evs</span></span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> knows_subset_knows_Cons <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹For proving <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>new_keys_not_used›</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> keysFor_parts_insert<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="free">K</span> <span class="main">∈</span> keysFor <span class="main">(</span>parts <span class="main">(</span>insert <span class="free">X</span> <span class="free">G</span><span class="main">)</span><span class="main">)</span><span class="main">;</span>  <span class="free">X</span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="free">H</span><span class="main">)</span> <span class="main">|]</span> 
      <span class="main">==&gt;</span> <span class="free">K</span> <span class="main">∈</span> keysFor <span class="main">(</span>parts <span class="main">(</span><span class="free">G</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">|</span> Key <span class="main">(</span>invKey <span class="free">K</span><span class="main">)</span> <span class="main">∈</span> parts <span class="free">H</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">force</span> 
    <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> parts_insert_subset_Un <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> keysFor_mono<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span>
           analz_subset_parts <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> keysFor_mono<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span>
    <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_subset_parts <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span> parts_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">lemmas</span></span> analz_impI <span class="main">=</span> impI <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∉</span> analz <span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span>"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">Y</span> <span class="free">A</span> <span class="free">evs</span>

<span class="keyword1"><span class="command">ML</span></span>
<span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">analz_mono_contra_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> analz_impI<span class="antiquote">}</span></span></span> THEN' 
  REPEAT1 o <span class="main">(</span>dresolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> analz_mono_contra<span class="antiquote">}</span></span></span><span class="main">)</span>
  THEN' <span class="entity">mp_tac</span> <span class="entity">ctxt</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> analz_mono_contra <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD</span> <span class="main">(</span>REPEAT_FIRST <span class="main">(</span><span class="entity">analz_mono_contra_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving theorems of the form X ∉ analz (knows A evs) ⟶ P"</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Useful for case analysis on whether a hash is a spoof or not›</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> syan_impI <span class="main">=</span> impI <span class="main">[</span><span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> P <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">"<span class="free">Y</span> <span class="main">∉</span> synth <span class="main">(</span>analz <span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">]</span> <span class="keyword2"><span class="keyword">for</span></span> <span class="free">Y</span> <span class="free">A</span> <span class="free">evs</span>

<span class="keyword1"><span class="command">ML</span></span>
<span class="quoted">‹
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">synth_analz_mono_contra_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
  resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> syan_impI<span class="antiquote">}</span></span></span> THEN'
  REPEAT1 o 
    <span class="main">(</span>dresolve_tac <span class="entity">ctxt</span> 
     <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> knows_subset_knows_Says<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> synth_analz_mono<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> contra_subsetD<span class="antiquote">}</span></span></span><span class="main">,</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> knows_subset_knows_Notes<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> synth_analz_mono<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> contra_subsetD<span class="antiquote">}</span></span></span><span class="main">,</span>
      <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> knows_subset_knows_Gets<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> synth_analz_mono<span class="antiquote">}</span></span></span> RS <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> contra_subsetD<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span>
  THEN'
  <span class="entity">mp_tac</span> <span class="entity">ctxt</span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> synth_analz_mono_contra <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span> <span class="entity">SIMPLE_METHOD</span> <span class="main">(</span>REPEAT_FIRST <span class="main">(</span><span class="entity">synth_analz_mono_contra_tac</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving theorems of the form X ∉ synth (analz (knows A evs)) ⟶ P"</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="PublicGA">
<div class="head">
<h1>Theory PublicGA</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Theory of Cryptographic Keys for Security Protocols against the General Attacker›</span></span>

<span class="keyword1"><span class="command">theory</span></span> PublicGA <span class="keyword2"><span class="keyword">imports</span></span> <a href="EventGA.html">EventGA</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">lemma</span></span> invKey_K<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">K</span> <span class="main">∈</span> symKeys <span class="main">⟹</span> invKey <span class="free">K</span> <span class="main">=</span> <span class="free">K</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_def<span class="main">)</span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Asymmetric Keys›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> keymode <span class="main">=</span> Signature <span class="main">|</span> Encryption

<span class="keyword1"><span class="command">consts</span></span>
  publicKey <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>keymode<span class="main">,</span>agent<span class="main">]</span> <span class="main">=&gt;</span> key"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">pubEK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pubEK</span> <span class="main">==</span> publicKey Encryption"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">pubSK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pubSK</span> <span class="main">==</span> publicKey Signature"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">privateKey</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"<span class="main">[</span>keymode<span class="main">,</span> agent<span class="main">]</span> <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">privateKey</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> invKey <span class="main">(</span>publicKey <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="comment1">(*BEWARE!! priEK, priSK DON'T WORK with inj, range, image, etc.*)</span>
  <span class="entity">priEK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">priEK</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> privateKey Encryption <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">priSK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">priSK</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> privateKey Signature <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹These abbreviations give backward compatibility.  They represent the
simple situation where the signature and encryption keys are the same.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">pubK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">pubK</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> pubEK <span class="free"><span class="bound"><span class="entity">A</span></span></span>"</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span>
  <span class="entity">priK</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="quoted"><span class="quoted">"<span class="free">priK</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> invKey <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹By freeness of agents, no two agents have the same key.  Since
  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"True<span class="main"><span class="main">≠</span></span>False"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>, no agent has identical signing and encryption keys›</span></span>
<span class="keyword1"><span class="command">specification</span></span> <span class="main">(</span><span class="quoted">publicKey</span><span class="main">)</span>
  injective_publicKey<span class="main">:</span>
    <span class="quoted"><span class="quoted">"publicKey <span class="free">b</span> <span class="free">A</span> <span class="main">=</span> publicKey <span class="free">c</span> <span class="free">A'</span> <span class="main">⟹</span> <span class="free">b</span><span class="main">=</span><span class="free">c</span> <span class="main">∧</span> <span class="free">A</span><span class="main">=</span><span class="free">A'</span>"</span></span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> 
       <span class="quoted"><span class="quoted"><span class="quoted">"<span class="main"><span class="main">%</span></span><span class="bound"><span class="bound">b</span></span> <span class="bound"><span class="bound">A</span></span><span class="main"><span class="main">.</span></span> <span class="numeral"><span class="numeral">2</span></span> <span class="main"><span class="main">*</span></span> case_agent <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">n</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">+</span></span> <span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">)</span></span> <span class="bound"><span class="bound">A</span></span> <span class="main"><span class="main">+</span></span> case_keymode <span class="main"><span class="main">0</span></span> <span class="main"><span class="main">1</span></span> <span class="bound"><span class="bound">b</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> agent.split keymode.split<span class="main">)</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">presburger</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>                       


<span class="keyword1"><span class="command">axiomatization</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  <span class="comment1">(*No private key equals any public key (essential to ensure that private
    keys are private!) *)</span>
  privateKey_neq_publicKey <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"privateKey <span class="free">b</span> <span class="free">A</span> <span class="main">≠</span> publicKey <span class="free">c</span> <span class="free">A'</span>"</span></span>

<span class="keyword1"><span class="command">lemmas</span></span> publicKey_neq_privateKey <span class="main">=</span> privateKey_neq_publicKey <span class="main">[</span><span class="operator">THEN</span> not_sym<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> publicKey_neq_privateKey <span class="main">[</span><span class="operator">iff</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Basic properties of <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">pubK</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">priK</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> publicKey_inject <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>publicKey <span class="free">b</span> <span class="free">A</span> <span class="main">=</span> publicKey <span class="free">c</span> <span class="free">A'</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span><span class="main">=</span><span class="free">c</span> <span class="main">∧</span> <span class="free">A</span><span class="main">=</span><span class="free">A'</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> injective_publicKey<span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> not_symKeys_pubK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"publicKey <span class="free">b</span> <span class="free">A</span> <span class="main">∉</span> symKeys"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> not_symKeys_priK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"privateKey <span class="free">b</span> <span class="free">A</span> <span class="main">∉</span> symKeys"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_def<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> symKey_neq_priEK<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">K</span> <span class="main">∈</span> symKeys <span class="main">⟹</span> <span class="free">K</span> <span class="main">≠</span> priEK <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> symKeys_neq_imp_neq<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span><span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">)</span> <span class="main">≠</span> <span class="main">(</span><span class="free">K'</span> <span class="main">∈</span> symKeys<span class="main">)</span> <span class="main">⟹</span> <span class="free">K</span> <span class="main">≠</span> <span class="free">K'</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> symKeys_invKey_iff <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>invKey <span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">unfold</span> symKeys_def<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_symKeys_Decrypt<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span>  <span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">;</span>  Key <span class="free">K</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span>  
      <span class="main">==&gt;</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_def<span class="main">)</span>



<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹"Image" equations that hold for injective functions›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> invKey_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>invKey <span class="free">x</span> <span class="main">∈</span> invKey<span class="main">`</span><span class="free">A</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> <span class="free">A</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="comment1">(*holds because invKey is injective*)</span>
<span class="keyword1"><span class="command">lemma</span></span> publicKey_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span>publicKey <span class="free">b</span> <span class="free">x</span> <span class="main">∈</span> publicKey <span class="free">c</span> <span class="main">`</span> <span class="free">AA</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span><span class="main">=</span><span class="free">c</span> <span class="main">∧</span> <span class="free">x</span> <span class="main">∈</span> <span class="free">AA</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> privateKey_notin_image_publicKey <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"privateKey <span class="free">b</span> <span class="free">x</span> <span class="main">∉</span> publicKey <span class="free">c</span> <span class="main">`</span> <span class="free">AA</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> privateKey_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span>privateKey <span class="free">b</span> <span class="free">A</span> <span class="main">∈</span> invKey <span class="main">`</span> publicKey <span class="free">c</span> <span class="main">`</span> <span class="free">AS</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">b</span><span class="main">=</span><span class="free">c</span> <span class="main">∧</span> <span class="free">A</span><span class="main">∈</span><span class="free">AS</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> publicKey_notin_image_privateKey <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"publicKey <span class="free">b</span> <span class="free">A</span> <span class="main">∉</span> invKey <span class="main">`</span> publicKey <span class="free">c</span> <span class="main">`</span> <span class="free">AS</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Symmetric Keys›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹For some protocols, it is convenient to equip agents with symmetric as
well as asymmetric keys.  The theory <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>Shared›</span></span></span></span> assumes that all keys
are symmetric.›</span></span>

<span class="keyword1"><span class="command">consts</span></span>
  shrK    <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">=&gt;</span> key"</span></span>    <span class="comment1">― ‹long-term shared keys›</span>

<span class="keyword1"><span class="command">specification</span></span> <span class="main">(</span><span class="quoted">shrK</span><span class="main">)</span>
  inj_shrK<span class="main">:</span> <span class="quoted"><span class="quoted">"inj shrK"</span></span>
  <span class="comment1">― ‹No two agents have the same long-term key›</span>
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> exI <span class="main"><span class="main">[</span></span><span class="operator">of</span> <span class="main"><span class="main">_</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"case_agent <span class="main"><span class="main">(</span></span><span class="main"><span class="main">λ</span></span><span class="bound"><span class="bound">n</span></span><span class="main"><span class="main">.</span></span> <span class="bound"><span class="bound">n</span></span> <span class="main"><span class="main">+</span></span> <span class="numeral"><span class="numeral">2</span></span><span class="main"><span class="main">)</span></span>"</span></span></span><span class="main"><span class="main">]</span></span><span class="main">)</span> 
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> inj_on_def <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> agent.split<span class="main">)</span> 
   <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">axiomatization</span></span> <span class="keyword2"><span class="keyword">where</span></span>
  sym_shrK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shrK <span class="free">X</span> <span class="main">∈</span> symKeys"</span></span> <span class="comment1">― ‹All shared keys are symmetric›</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Injectiveness: Agents' long-term keys are distinct.›</span></span>
<span class="keyword1"><span class="command">lemmas</span></span> shrK_injective <span class="main">=</span> inj_shrK <span class="main">[</span><span class="operator">THEN</span> inj_eq<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> shrK_injective <span class="main">[</span><span class="operator">iff</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> invKey_shrK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"invKey <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">=</span> shrK <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invKey_K<span class="main">)</span> 

<span class="keyword1"><span class="command">lemma</span></span> analz_shrK_Decrypt<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> Crypt <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span> Key<span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_Decrypt'<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">;</span> <span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">;</span> Key <span class="free">K</span> <span class="main">∈</span> analz <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> invKey_K<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> priK_neq_shrK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shrK <span class="free">A</span> <span class="main">≠</span> privateKey <span class="free">b</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_neq_imp_neq<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> shrK_neq_priK <span class="main">=</span> priK_neq_shrK <span class="main">[</span><span class="operator">THEN</span> not_sym<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> shrK_neq_priK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> pubK_neq_shrK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shrK <span class="free">A</span> <span class="main">≠</span> publicKey <span class="free">b</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> symKeys_neq_imp_neq<span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> shrK_neq_pubK <span class="main">=</span> pubK_neq_shrK <span class="main">[</span><span class="operator">THEN</span> not_sym<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> shrK_neq_pubK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> priEK_noteq_shrK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"priEK <span class="free">A</span> <span class="main">≠</span> shrK <span class="free">B</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> publicKey_notin_image_shrK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"publicKey <span class="free">b</span> <span class="free">x</span> <span class="main">∉</span> shrK <span class="main">`</span> <span class="free">AA</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> privateKey_notin_image_shrK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"privateKey <span class="free">b</span> <span class="free">x</span> <span class="main">∉</span> shrK <span class="main">`</span> <span class="free">AA</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_notin_image_publicKey <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shrK <span class="free">x</span> <span class="main">∉</span> publicKey <span class="free">b</span> <span class="main">`</span> <span class="free">AA</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_notin_image_privateKey <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"shrK <span class="free">x</span> <span class="main">∉</span> invKey <span class="main">`</span> publicKey <span class="free">b</span> <span class="main">`</span> <span class="free">AA</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_image_eq <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">(</span>shrK <span class="free">x</span> <span class="main">∈</span> shrK <span class="main">`</span> <span class="free">AA</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">x</span> <span class="main">∈</span> <span class="free">AA</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹For some reason, moving this up can make some proofs loop!›</span></span>
<span class="keyword1"><span class="command">declare</span></span> invKey_K <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Initial States of Agents›</span></span>

<span class="keyword1"><span class="command">overloading</span></span>
  initState <span class="main">≡</span> <span class="quoted">initState</span>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">primrec</span></span> <span class="entity">initState</span> <span class="keyword2"><span class="keyword">where</span></span>

  initState_Friend<span class="main">:</span>
    <span class="quoted"><span class="quoted">"<span class="free">initState</span> <span class="main">(</span>Friend <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span> <span class="main">=</span>    
       <span class="main">{</span>Key <span class="main">(</span>priEK <span class="main">(</span>Friend <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="main">(</span>Friend <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="main">(</span>Friend <span class="free"><span class="bound"><span class="entity">i</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
       <span class="main">(</span>Key <span class="main">`</span> range pubEK<span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>Key <span class="main">`</span> range pubSK<span class="main">)</span>"</span></span>
<span class="keyword2"><span class="keyword">end</span></span>


<span class="keyword1"><span class="command">lemma</span></span> used_parts_subset_parts <span class="main">[</span><span class="operator">rule_format</span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">∀</span><span class="bound">X</span> <span class="main">∈</span> used <span class="free">evs</span><span class="main">.</span> parts <span class="main">{</span><span class="bound">X</span><span class="main">}</span> <span class="main">⊆</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">evs</span></span><span class="main">)</span> 
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> used_Cons<span class="main">)</span>
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> ballI<span class="main">)</span>  
 <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="improper">a</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>  
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> parts_cut<span class="main">)</span> 
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Base case›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> used_Nil<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> MPair_used_D<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> used <span class="free">H</span> <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> used <span class="free">H</span> <span class="main">∧</span> <span class="free">Y</span> <span class="main">∈</span> used <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> used_parts_subset_parts<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹There was a similar theorem in Event.thy, so perhaps this one can
  be moved up if proved directly by induction.›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> MPair_used <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> <span class="main">⦃</span><span class="free">X</span><span class="main">,</span><span class="free">Y</span><span class="main">⦄</span> <span class="main">∈</span> used <span class="free">H</span><span class="main">;</span>
         <span class="main">[|</span> <span class="free">X</span> <span class="main">∈</span> used <span class="free">H</span><span class="main">;</span> <span class="free">Y</span> <span class="main">∈</span> used <span class="free">H</span> <span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">P</span> <span class="main">|]</span> 
      <span class="main">==&gt;</span> <span class="free">P</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> MPair_used_D<span class="main">)</span> 


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Rewrites should not refer to  <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"initState<span class="main"><span class="main">(</span></span>Friend <span class="free"><span class="free">i</span></span><span class="main"><span class="main">)</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> because
  that expression is not in normal form.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> keysFor_parts_initState <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"keysFor <span class="main">(</span>parts <span class="main">(</span>initState <span class="free">C</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">{}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">unfold</span> keysFor_def<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">C</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> range_eqI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_notin_initState<span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∉</span> parts <span class="main">(</span>initState <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">B</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_notin_used_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∉</span> used <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Crypt_notin_initState used_Nil<span class="main">)</span>

<span class="comment1">(*** Basic properties of shrK ***)</span>

<span class="comment1">(*Agents see their own shared keys!*)</span>
<span class="keyword1"><span class="command">lemma</span></span> shrK_in_initState <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> initState <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_in_knows <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> initState_subset_knows <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_in_used <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> initState_into_used<span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>


<span class="comment1">(** Fresh keys never clash with long-term shared keys **)</span>

<span class="comment1">(*Used in parts_induct_tac and analz_Fake_tac to distinguish session keys
  from long-term shared keys*)</span>
<span class="keyword1"><span class="command">lemma</span></span> Key_not_used <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">∉</span> used <span class="free">evs</span> <span class="main">⟹</span> <span class="free">K</span> <span class="main">∉</span> range shrK"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> shrK_neq<span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="free">K</span> <span class="main">∉</span> used <span class="free">evs</span> <span class="main">⟹</span> shrK <span class="free">B</span> <span class="main">≠</span> <span class="free">K</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemmas</span></span> neq_shrK <span class="main">=</span> shrK_neq <span class="main">[</span><span class="operator">THEN</span> not_sym<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> neq_shrK <span class="main">[</span><span class="operator">simp</span><span class="main">]</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Function <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">"knows <span class="free"><span class="free">Spy</span></span>"</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> not_SignatureE <span class="main">[</span><span class="operator">elim</span><span class="main"><span class="main"><span class="main"><span class="main">!</span></span></span></span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">b</span> <span class="main">≠</span> Signature <span class="main">⟹</span> <span class="free">b</span> <span class="main">=</span> Encryption"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">b</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Agents see their own private keys!›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> priK_in_initState <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>privateKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> initState <span class="free">A</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Agents see all public keys!›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> publicKey_in_initState <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>publicKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> initState <span class="free">B</span>"</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">B</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span> 

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹All public keys are visible›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> spies_pubK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>publicKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> knows <span class="free">B</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">auto</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> imageI knows_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemmas</span></span> analz_spies_pubK <span class="main">=</span> spies_pubK <span class="main">[</span><span class="operator">THEN</span> analz.Inj<span class="main">]</span>
<span class="keyword1"><span class="command">declare</span></span> analz_spies_pubK <span class="main">[</span><span class="operator">iff</span><span class="main">]</span>

<span class="comment1">(*Note: there never is at this stage a lemma about what an agent cannot know*)</span>

<span class="keyword1"><span class="command">lemma</span></span> publicKey_into_used <span class="main">[</span><span class="operator">iff</span><span class="main">]</span> <span class="main">:</span><span class="quoted"><span class="quoted">"Key <span class="main">(</span>publicKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> initState_into_used<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> publicKey_in_initState <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> privateKey_into_used <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Key <span class="main">(</span>privateKey <span class="free">b</span> <span class="free">A</span><span class="main">)</span> <span class="main">∈</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> initState_into_used<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="main">(</span><span class="operator">rule</span> priK_in_initState <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Crypt_analz_bad<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">[|</span> Crypt <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span> <span class="main">|]</span>  
      <span class="main">==&gt;</span> <span class="free">X</span> <span class="main">∈</span> analz <span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Fresh Nonces›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_notin_initState <span class="main">[</span><span class="operator">iff</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span> <span class="main">∉</span> parts <span class="main">(</span>initState <span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_notin_used_empty <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span> <span class="main">∉</span> used <span class="main">[]</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> used_Nil<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Supply fresh nonces for possibility theorems›</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹In any trace, there is an upper bound N on the greatest nonce in use›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> Nonce_supply_lemma<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">N</span><span class="main">.</span> <span class="main">∀</span><span class="bound">n</span><span class="main">.</span> <span class="bound">N</span><span class="main">≤</span><span class="bound">n</span> <span class="main">⟶</span> Nonce <span class="bound">n</span> <span class="main">∉</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule_tac</span> x <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="main">0</span></span> <span class="keyword2"><span class="keyword"><span class="quasi_keyword">in</span></span></span> exI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span> <span class="main"><span class="main">(</span></span><span class="quasi_keyword">no_asm_simp</span><span class="main"><span class="main">)</span></span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> used_Cons <span class="quasi_keyword">split</span><span class="main"><span class="main">:</span></span> event.split<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> msg_Nonce_supply <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> exE<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span> <span class="quasi_keyword">elim</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> add_leE<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_supply1<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">∃</span><span class="bound">N</span><span class="main">.</span> Nonce <span class="bound">N</span> <span class="main">∉</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">rule</span> Nonce_supply_lemma <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> exE<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> Nonce_supply<span class="main">:</span> <span class="quoted"><span class="quoted">"Nonce <span class="main">(</span><span class="keyword1">SOME</span> <span class="bound">N</span><span class="main">.</span> Nonce <span class="bound">N</span> <span class="main">∉</span> used <span class="free">evs</span><span class="main">)</span> <span class="main">∉</span> used <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> Nonce_supply_lemma <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> exE<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> someI<span class="main"><span class="keyword3">,</span></span> <span class="operator">fast</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Specialized Rewriting for Theorems About <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">term</span></span> <span class="quoted"><span class="quoted">analz</span></span><span class="antiquote"><span class="antiquote">}</span></span></span></span> and Image›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> insert_Key_singleton<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="free">H</span> <span class="main">=</span> Key <span class="main">`</span> <span class="main">{</span><span class="free">K</span><span class="main">}</span> <span class="main">∪</span> <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

<span class="keyword1"><span class="command">lemma</span></span> insert_Key_image<span class="main">:</span> <span class="quoted"><span class="quoted">"insert <span class="main">(</span>Key <span class="free">K</span><span class="main">)</span> <span class="main">(</span>Key<span class="main">`</span><span class="free">KK</span> <span class="main">∪</span> <span class="free">C</span><span class="main">)</span> <span class="main">=</span> Key <span class="main">`</span> <span class="main">(</span>insert <span class="free">K</span> <span class="free">KK</span><span class="main">)</span> <span class="main">∪</span> <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>


<span class="keyword1"><span class="command">lemma</span></span> Crypt_imp_keysFor <span class="main">:</span><span class="quoted"><span class="quoted">"<span class="main">[|</span>Crypt <span class="free">K</span> <span class="free">X</span> <span class="main">∈</span> <span class="free">H</span><span class="main">;</span> <span class="free">K</span> <span class="main">∈</span> symKeys<span class="main">|]</span> <span class="main">==&gt;</span> <span class="free">K</span> <span class="main">∈</span> keysFor <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> Crypt_imp_invKey_keysFor<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Lemma for the trivial direction of the if-and-only-if of the 
Session Key Compromise Theorem›</span></span>
<span class="keyword1"><span class="command">lemma</span></span> analz_image_freshK_lemma<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> analz <span class="main">(</span>Key<span class="main">`</span><span class="free">nE</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">⟶</span> <span class="main">(</span><span class="free">K</span> <span class="main">∈</span> <span class="free">nE</span> <span class="main">|</span> Key <span class="free">K</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">)</span>  <span class="main">⟹</span>  
         <span class="main">(</span>Key <span class="free">K</span> <span class="main">∈</span> analz <span class="main">(</span>Key<span class="main">`</span><span class="free">nE</span> <span class="main">∪</span> <span class="free">H</span><span class="main">)</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">K</span> <span class="main">∈</span> <span class="free">nE</span> <span class="main">|</span> Key <span class="free">K</span> <span class="main">∈</span> analz <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> analz_mono <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> <span class="main"><span class="main"><span class="main">[</span></span></span>2<span class="main"><span class="main"><span class="main">]</span></span></span> rev_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemmas</span></span> analz_image_freshK_simps <span class="main">=</span>
       simp_thms mem_simps <span class="comment1">― ‹these two allow its use with <span class="antiquoted"><span class="antiquote">@{</span><span class="operator">text</span> <span class="raw_text">"only:"</span><span class="antiquote">}</span></span>›</span>
       disj_comms 
       image_insert <span class="main">[</span><span class="operator">THEN</span> sym<span class="main">]</span> image_Un <span class="main">[</span><span class="operator">THEN</span> sym<span class="main">]</span> empty_subsetI insert_subset
       analz_insert_eq Un_upper2 <span class="main">[</span><span class="operator">THEN</span> analz_mono<span class="main">,</span> <span class="operator">THEN</span> subsetD<span class="main">]</span>
       insert_Key_singleton 
       Key_not_used insert_Key_image Un_assoc <span class="main">[</span><span class="operator">THEN</span> sym<span class="main">]</span>

<span class="keyword1"><span class="command">ML</span></span> <span class="quoted">‹
<span class="keyword1"><span class="keyword">structure</span></span> <span class="entity">Public</span> <span class="main">=</span>
<span class="keyword2"><span class="keyword">struct</span></span>

<span class="keyword1"><span class="keyword">val</span></span> <span class="entity">analz_image_freshK_ss</span> <span class="main">=</span>
  simpset_of <span class="main">(</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">context</span><span class="antiquote">}</span></span></span>
    delsimps <span class="main">[</span><span class="entity">image_insert</span><span class="main">,</span> <span class="entity">image_Un</span><span class="main">]</span>
    delsimps <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> imp_disjL<span class="antiquote">}</span></span></span><span class="main">]</span>    <span class="comment1">(*reduces blow-up*)</span>
    addsimps <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> analz_image_freshK_simps<span class="antiquote">}</span></span></span><span class="main">)</span>

<span class="comment1">(*Tactic for possibility theorems*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">possibility_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    REPEAT <span class="comment1">(*omit used_Says so that Nonces start from different traces!*)</span>
    <span class="main">(</span>ALLGOALS <span class="main">(</span><span class="entity">simp_tac</span> <span class="main">(</span><span class="entity">ctxt</span> delsimps <span class="main">[</span><span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> used_Says<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span><span class="main">)</span>
     THEN
     REPEAT_FIRST <span class="main">(</span>eq_assume_tac ORELSE' 
                   resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">refl</span><span class="main">,</span> <span class="entity">conjI</span><span class="main">,</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thm</span> Nonce_supply<span class="antiquote">}</span></span></span><span class="main">]</span><span class="main">)</span><span class="main">)</span>

<span class="comment1">(*For harder protocols (such as Recur) where we have to set up some
  nonces and keys initially*)</span>
<span class="keyword1"><span class="keyword">fun</span></span> <span class="entity">basic_possibility_tac</span> <span class="entity">ctxt</span> <span class="main">=</span>
    REPEAT 
    <span class="main">(</span>ALLGOALS <span class="main">(</span><span class="entity">asm_simp_tac</span> <span class="main">(</span><span class="entity">ctxt</span> setSolver <span class="entity">safe_solver</span><span class="main">)</span><span class="main">)</span>
     THEN
     REPEAT_FIRST <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">refl</span><span class="main">,</span> <span class="entity">conjI</span><span class="main">]</span><span class="main">)</span><span class="main">)</span>

<span class="keyword2"><span class="keyword">end</span></span>
›</span>

<span class="keyword1"><span class="command">method_setup</span></span> analz_freshK <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="keyword1"><span class="keyword">fn</span></span> <span class="entity">ctxt</span> <span class="main">=&gt;</span>
     <span class="main">(</span><span class="entity">SIMPLE_METHOD</span>
      <span class="main">(</span>EVERY <span class="main">[</span>REPEAT_FIRST <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="main">[</span><span class="entity">allI</span><span class="main">,</span> <span class="entity">ballI</span><span class="main">,</span> <span class="entity">impI</span><span class="main">]</span><span class="main">)</span><span class="main">,</span>
          REPEAT_FIRST <span class="main">(</span>resolve_tac <span class="entity">ctxt</span> <span class="antiquoted"><span class="entity"><span class="antiquote">@{</span><span class="operator">thms</span> analz_image_freshK_lemma<span class="antiquote">}</span></span></span><span class="main">)</span><span class="main">,</span>
          ALLGOALS <span class="main">(</span><span class="entity">asm_simp_tac</span> <span class="main">(</span>put_simpset <span class="entity">Public.analz_image_freshK_ss</span> <span class="entity">ctxt</span><span class="main">)</span><span class="main">)</span><span class="main">]</span><span class="main">)</span><span class="main">)</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving the Session Key Compromise theorem"</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Specialized Methods for Possibility Theorems›</span></span>

<span class="keyword1"><span class="command">method_setup</span></span> possibility <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD</span> o <span class="entity">Public.possibility_tac</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving possibility theorems"</span>

<span class="keyword1"><span class="command">method_setup</span></span> basic_possibility <span class="main">=</span> <span class="quoted">‹
    Scan.succeed <span class="main">(</span><span class="entity">SIMPLE_METHOD</span> o <span class="entity">Public.basic_possibility_tac</span><span class="main">)</span>›</span>
    <span class="quoted">"for proving possibility theorems"</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="NS_Public_Bad_GA">
<div class="head">
<h1>Theory NS_Public_Bad_GA</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹The Needham-Schroeder Public-Key Protocol against the General Attacker›</span></span>

<span class="keyword1"><span class="command">theory</span></span> NS_Public_Bad_GA <span class="keyword2"><span class="keyword">imports</span></span> <a href="PublicGA.html">PublicGA</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">ns_public</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"event list set"</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>

   Nil<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">[]</span> <span class="main">∈</span> <span class="free">ns_public</span>"</span></span>

 <span class="main">|</span> Fake<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">evsf</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span><span class="main">;</span>  <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> synth <span class="main">(</span>analz <span class="main">(</span>knows <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">evsf</span></span></span><span class="main">)</span><span class="main">)</span><span class="main">⟧</span>
          <span class="main">⟹</span> Says <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span>  <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evsf</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span>"</span></span>

 <span class="main">|</span> Reception<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free"><span class="bound"><span class="entity">evsr</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span><span class="main">;</span> Says <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">evsr</span></span></span> <span class="main">⟧</span>
                <span class="main">⟹</span> Gets <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="free"><span class="bound"><span class="entity">X</span></span></span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evsr</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span>"</span></span>

 <span class="main">|</span> NS1<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">evs1</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span><span class="main">;</span>  Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span> <span class="main">∉</span> used <span class="free"><span class="bound"><span class="entity">evs1</span></span></span><span class="main">⟧</span>
          <span class="main">⟹</span> Says <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span><span class="main">,</span> Agent <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">⦄</span><span class="main">)</span>
                <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evs1</span></span></span>  <span class="main">∈</span>  <span class="free">ns_public</span>"</span></span>

 <span class="main">|</span> NS2<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">evs2</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span><span class="main">;</span>  Nonce <span class="free"><span class="bound"><span class="entity">NB</span></span></span> <span class="main">∉</span> used <span class="free"><span class="bound"><span class="entity">evs2</span></span></span><span class="main">;</span>
           Gets <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span><span class="main">,</span> Agent <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">evs2</span></span></span><span class="main">⟧</span>
          <span class="main">⟹</span> Says <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span><span class="main">,</span> Nonce <span class="free"><span class="bound"><span class="entity">NB</span></span></span><span class="main">⦄</span><span class="main">)</span>
                <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evs2</span></span></span>  <span class="main">∈</span>  <span class="free">ns_public</span>"</span></span>

 <span class="main">|</span> NS3<span class="main">:</span>  <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free"><span class="bound"><span class="entity">evs3</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span><span class="main">;</span>
           Says <span class="free"><span class="bound"><span class="entity">A</span></span></span>  <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span><span class="main">,</span> Agent <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">evs3</span></span></span><span class="main">;</span>
           Gets <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free"><span class="bound"><span class="entity">NA</span></span></span><span class="main">,</span> Nonce <span class="free"><span class="bound"><span class="entity">NB</span></span></span><span class="main">⦄</span><span class="main">)</span> <span class="main">∈</span> set <span class="free"><span class="bound"><span class="entity">evs3</span></span></span><span class="main">⟧</span>
          <span class="main">⟹</span> Says <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="free"><span class="bound"><span class="entity">B</span></span></span> <span class="main">(</span>Crypt <span class="main">(</span>pubEK <span class="free"><span class="bound"><span class="entity">B</span></span></span><span class="main">)</span> <span class="main">(</span>Nonce <span class="free"><span class="bound"><span class="entity">NB</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">#</span> <span class="free"><span class="bound"><span class="entity">evs3</span></span></span> <span class="main">∈</span> <span class="free">ns_public</span>"</span></span>


<span class="keyword1"><span class="command">lemma</span></span> NS_no_Notes<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟹</span> Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∉</span> set <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> ns_public.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp_all</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Confidentiality treatment in separate theory file›</span></span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div><div id="ConfidentialityGA">
<div class="head">
<h1>Theory ConfidentialityGA</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Inductive Study of Confidentiality against the General Attacker›</span></span>

<span class="keyword1"><span class="command">theory</span></span>  ConfidentialityGA <span class="keyword2"><span class="keyword">imports</span></span> <a href="NS_Public_Bad_GA.html">NS_Public_Bad_GA</a> <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹New subsidiary lemmas to reason on a generic agent initial state›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_initState<span class="main">:</span> <span class="quoted"><span class="quoted">"parts<span class="main">(</span>initState <span class="free">C</span><span class="main">)</span> <span class="main">=</span> initState <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">C</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_initState<span class="main">:</span> <span class="quoted"><span class="quoted">"analz<span class="main">(</span>initState <span class="free">C</span><span class="main">)</span> <span class="main">=</span> initState <span class="free">C</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">C</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz_into_parts<span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Generalising over all initial secrets the existing treatment, which is limited to private encryption keys›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">staticSecret</span> <span class="main">::</span> <span class="quoted"><span class="quoted">"agent <span class="main">⇒</span> msg set"</span></span> <span class="keyword2"><span class="keyword">where</span></span>
 <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">staticSecret</span> <span class="free"><span class="bound"><span class="entity">A</span></span></span> <span class="main">==</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free"><span class="bound"><span class="entity">A</span></span></span><span class="main">)</span><span class="main">}</span>"</span></span>


<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹More subsidiary lemmas combining initial secrets and knowledge of generic agent›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> staticSecret_in_initState <span class="main">[</span><span class="operator">simp</span><span class="main">]</span><span class="main">:</span>
<span class="quoted"><span class="quoted">"staticSecret <span class="free">A</span> <span class="main">⊆</span> initState <span class="free">A</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command">thm</span></span> parts_insert

<span class="keyword1"><span class="command">lemma</span></span> staticSecretA_notin_initStateB<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">∈</span> initState <span class="free">B</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span><span class="main">=</span><span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">B</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> staticSecretA_notin_parts_initStateB<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">(</span>initState <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span><span class="main">=</span><span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">B</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> staticSecretA_notin_analz_initStateB<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span> <span class="main">⟹</span> <span class="free">m</span> <span class="main">∈</span> analz<span class="main">(</span>initState <span class="free">B</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">A</span><span class="main">=</span><span class="free">B</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">B</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz_into_parts<span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> staticSecret_synth_eq<span class="main">:</span> 
<span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">m</span> <span class="main">∈</span> synth <span class="free">H</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">m</span> <span class="main">∈</span> <span class="free">H</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">declare</span></span> staticSecret_def <span class="main">[</span><span class="operator">simp</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> nonce_notin_analz_initState<span class="main">:</span>
  <span class="quoted"><span class="quoted">"Nonce <span class="free">N</span> <span class="main">∉</span> analz<span class="main">(</span>initState <span class="free">A</span><span class="main">)</span>"</span></span> 
<span class="keyword1"><span class="command">by</span></span><span class="main">(</span><span class="operator">cases</span> <span class="quoted"><span class="free">A</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> analz_into_parts<span class="main">)</span>


<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Protocol independent study›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> staticSecret_parts_agent<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows <span class="free">C</span> <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">⟧</span> <span class="main">⟹</span>  
   <span class="free">A</span><span class="main">=</span><span class="free">C</span> <span class="main">∨</span> 
  <span class="main">(</span><span class="main">∃</span><span class="bound">D</span> <span class="bound">E</span> <span class="bound">X</span><span class="main">.</span> Says <span class="bound">D</span> <span class="bound">E</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span> <span class="main">∨</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">Y</span><span class="main">.</span> Notes <span class="free">C</span> <span class="bound">Y</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">Y</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="free"><span class="quoted"><span class="free">evs</span></span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent =1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> staticSecretA_notin_parts_initStateB<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="improper"><span class="quoted"><span class="improper">a</span></span></span></span><span class="main">)</span>
<span class="comment1">(*Says*)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> impI<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equalityD1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="comment1">(*Gets*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="comment1">(*Notes*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span> 
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent =1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equalityD1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> staticSecret_analz_agent<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> analz <span class="main">(</span>knows <span class="free">C</span> <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">⟧</span> <span class="main">⟹</span>  
   <span class="free">A</span><span class="main">=</span><span class="free">C</span> <span class="main">∨</span> 
  <span class="main">(</span><span class="main">∃</span><span class="bound">D</span> <span class="bound">E</span> <span class="bound">X</span><span class="main">.</span> Says <span class="bound">D</span> <span class="bound">E</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span> <span class="main">∨</span>
  <span class="main">(</span><span class="main">∃</span><span class="bound">Y</span><span class="main">.</span> Notes <span class="free">C</span> <span class="bound">Y</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">Y</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">drule</span> analz_into_parts <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> staticSecret_parts_agent<span class="main"><span class="main">]</span></span><span class="main">)</span>

<span class="keyword1"><span class="command">lemma</span></span> secret_parts_agent<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows <span class="free">C</span> <span class="free">evs</span><span class="main">)</span>  <span class="main">⟹</span> <span class="free">m</span> <span class="main">∈</span> initState <span class="free">C</span> <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">A</span> <span class="bound">B</span> <span class="bound">X</span><span class="main">.</span> Says <span class="bound">A</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span> <span class="main">∨</span>
 <span class="main">(</span><span class="main">∃</span><span class="bound">Y</span><span class="main">.</span> Notes <span class="free">C</span> <span class="bound">Y</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">Y</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> parts_initState<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="improper"><span class="improper">a</span></span>"</span></span></span><span class="main">)</span>
<span class="comment1">(*Says*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">rule</span> impI<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equalityD1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="comment1">(*Gets*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="comment1">(*Notes*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equalityD1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">subsection</span></span><span class="quoted"><span class="plain_text">‹Protocol dependent study›</span></span>

<span class="comment1">(*NS_no_Notes moved up in NS_Public_Bad_GA.thy so that it's visible to a sibling theory of this one's

As with DolevYao, studying a guarantee similar to
NS_no_Says_staticSecret makes the specialisation proof strategy collapse, because it elicits the same assumptions of the theorem that should be specified.
*)</span>

<span class="keyword1"><span class="command">lemma</span></span> NS_staticSecret_parts_agent_weak<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows <span class="free">C</span> <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">;</span> 
   <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span> <span class="main">⟹</span>
  <span class="free">A</span><span class="main">=</span><span class="free">C</span> <span class="main">∨</span> <span class="main">(</span><span class="main">∃</span><span class="bound">D</span> <span class="bound">E</span> <span class="bound">X</span><span class="main">.</span> Says <span class="bound">D</span> <span class="bound">E</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts<span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> NS_no_Notes staticSecret_parts_agent<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹Can't prove the homologous theorem of NS\_Says\_Spy\_staticSecret, hence the specialisation proof strategy cannot be applied›</span></span>

<span class="comment1">(*Simple though illustrative corollary*)</span>
<span class="comment1">(*note use of Says_imp_knows, an enforcement of the threat model*)</span>
<span class="keyword1"><span class="command">lemma</span></span> NS_staticSecret_parts_agent_parts<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows <span class="free">C</span> <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">;</span> <span class="free">A</span><span class="main">≠</span><span class="free">C</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span> <span class="main">⟹</span>
  <span class="free">m</span> <span class="main">∈</span> parts<span class="main">(</span>knows <span class="free">D</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> NS_staticSecret_parts_agent_weak Says_imp_knows <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">]</span></span> parts_trans<span class="main">)</span>
<span class="comment1">(*Alternative proof
apply (blast dest: staticSecret_parts_agent NS_no_Notes Says_imp_knows [THEN parts.Inj] parts_trans)*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">text</span></span><span class="quoted"><span class="plain_text">‹
The previous theorems show that in general any agent could send anybody's initial secret, namely the threat model does not impose anything against it. However, the actual protocol specification will, where agents either follow the protocol or build messages out of their traffic analysis - this is actually the same in DY

Therefore, we are only left with the direct proof strategy.
›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> NS_staticSecret_parts_agent<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows <span class="free">C</span> <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">;</span> 
   <span class="free">C</span><span class="main">≠</span><span class="free">A</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>
 <span class="main">⟹</span> <span class="main">∃</span> <span class="bound">B</span> <span class="bound">X</span><span class="main">.</span> Says <span class="free">A</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts <span class="main">{</span><span class="bound">X</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> ns_public.induct<span class="main">)</span>
<span class="comment1">(*Nil*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> staticSecretA_notin_parts_initStateB<span class="main">)</span>
<span class="comment1">(*Fake*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> parts_insert <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> equalityD1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="comment1">(*shot1*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">case_tac</span> <span class="quoted"><span class="quoted">"<span class="improper">Aa</span><span class="main">=</span><span class="free">A</span>"</span></span><span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1,goals_limit=2]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span>
<span class="comment1">(*Aa≠A*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span> <span class="comment1">(*applies induction hypothesis!*)</span><span class="comment1">(*shot2*)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1,goals_limit=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> Fake_parts_sing <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> subsetD<span class="main"><span class="main">]</span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>  <span class="comment1">(*shot3*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> staticSecret_synth_eq<span class="main">)</span> 
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1,goals_limit=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> NS_staticSecret_parts_agent_parts<span class="main">)</span>
<span class="comment1">(*rest!*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> staticSecret_def<span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">lemma</span></span> NS_agent_see_staticSecret<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span><span class="free">m</span> <span class="main">∈</span> staticSecret <span class="free">A</span><span class="main">;</span> <span class="free">C</span><span class="main">≠</span><span class="free">A</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>
 <span class="main">⟹</span> <span class="free">m</span> <span class="main">∈</span> parts <span class="main">(</span>knows <span class="free">C</span> <span class="free">evs</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">B</span> <span class="bound">X</span><span class="main">.</span> Says <span class="free">A</span> <span class="bound">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∧</span> <span class="free">m</span> <span class="main">∈</span> parts <span class="main">{</span><span class="bound">X</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> NS_staticSecret_parts_agent Says_imp_knows <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> parts.Inj<span class="main"><span class="main">]</span></span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> parts_trans<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>


<span class="keyword1"><span class="command">declare</span></span> analz.Decrypt <span class="main">[</span><span class="operator">rule</span> <span class="quasi_keyword">del</span><span class="main">]</span>

<span class="keyword1"><span class="command">lemma</span></span> analz_insert_analz<span class="main">:</span> <span class="quoted"><span class="quoted">"
<span class="main">⟦</span> <span class="free">c</span> <span class="main">∉</span> parts<span class="main">{</span><span class="free">Z</span><span class="main">}</span><span class="main">;</span> <span class="main">∀</span><span class="bound">K</span><span class="main">.</span> Key <span class="bound">K</span> <span class="main">∉</span> parts<span class="main">{</span><span class="free">Z</span><span class="main">}</span><span class="main">;</span> <span class="free">c</span> <span class="main">∈</span> analz<span class="main">(</span>insert <span class="free">Z</span> <span class="free">H</span><span class="main">)</span><span class="main">⟧</span> <span class="main">⟹</span> <span class="free">c</span> <span class="main">∈</span> analz <span class="free">H</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> analz.induct<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 4
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1,goals_limit=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> parts.Body analz.Decrypt<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> Agent_not_see_NA<span class="main">:</span>
     <span class="quoted"><span class="quoted">"<span class="main">⟦</span> Key <span class="main">(</span>priEK <span class="free">B</span><span class="main">)</span> <span class="main">∉</span> analz<span class="main">(</span>knows <span class="free">C</span> <span class="free">evs</span><span class="main">)</span><span class="main">;</span> 
        Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span> <span class="main">∉</span> analz<span class="main">(</span>knows <span class="free">C</span> <span class="free">evs</span><span class="main">)</span><span class="main">;</span>
        <span class="main">∀</span><span class="bound">S</span> <span class="bound">R</span> <span class="bound">Y</span><span class="main">.</span> Says <span class="bound">S</span> <span class="bound">R</span> <span class="bound">Y</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">⟶</span> 
         <span class="bound">Y</span> <span class="main">=</span> Crypt <span class="main">(</span>pubEK <span class="free">B</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A</span><span class="main">⦄</span> <span class="main">∨</span>
         <span class="bound">Y</span> <span class="main">=</span> Crypt <span class="main">(</span>pubEK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span> <span class="main">∨</span>
         Nonce <span class="free">NA</span> <span class="main">∉</span> parts<span class="main">{</span><span class="bound">Y</span><span class="main">}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">K</span><span class="main">.</span> Key <span class="bound">K</span> <span class="main">∉</span> parts<span class="main">{</span><span class="bound">Y</span><span class="main">}</span><span class="main">)</span><span class="main">;</span>
        <span class="free">C</span><span class="main">≠</span><span class="free">A</span><span class="main">;</span> <span class="free">C</span><span class="main">≠</span><span class="free">B</span><span class="main">;</span>  <span class="free">evs</span> <span class="main">∈</span> ns_public<span class="main">⟧</span>                     
       <span class="main">⟹</span> Nonce <span class="free">NA</span> <span class="main">∉</span> analz <span class="main">(</span>knows <span class="free">C</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> ns_public.induct<span class="main">)</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> nonce_notin_analz_initState<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">clarify</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="comment1">(*fixing confidentiality of both private keys*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> subset_insertI <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> analz_mono<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> contra_subsetD<span class="main"><span class="main">]</span></span><span class="main">)</span><span class="main"><span class="keyword3">+</span></span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1,goals_limit=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">subgoal_tac</span> <span class="quoted"><span class="quoted">"
        <span class="main">∀</span><span class="bound">S</span> <span class="bound">R</span> <span class="bound">Y</span><span class="main">.</span>
           <span class="main">(</span><span class="bound">S</span> <span class="main">=</span> <span class="improper">Aa</span> <span class="main">∧</span> <span class="bound">R</span> <span class="main">=</span> <span class="improper">Ba</span> <span class="main">∧</span> <span class="bound">Y</span> <span class="main">=</span> <span class="improper">X</span> <span class="main">⟶</span>
            <span class="improper">X</span> <span class="main">=</span> Crypt <span class="main">(</span>pubK <span class="free">B</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Agent <span class="free">A</span><span class="main">⦄</span> <span class="main">∨</span>
            <span class="improper">X</span> <span class="main">=</span> Crypt <span class="main">(</span>pubK <span class="free">A</span><span class="main">)</span> <span class="main">⦃</span>Nonce <span class="free">NA</span><span class="main">,</span> Nonce <span class="free">NB</span><span class="main">⦄</span> <span class="main">∨</span>
            Nonce <span class="free">NA</span> <span class="main">∉</span> parts <span class="main">{</span><span class="improper">X</span><span class="main">}</span> <span class="main">∧</span> <span class="main">(</span><span class="main">∀</span><span class="bound">K</span><span class="main">.</span> Key <span class="bound">K</span> <span class="main">∉</span> parts <span class="main">{</span><span class="improper">X</span><span class="main">}</span><span class="main">)</span><span class="main">)</span>"</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span> 2 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span> 
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">subgoals</span></span> [display,indent=1,goals_limit=1]<span class="antiquote"><span class="antiquote">}</span></span></span></span>›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">!</span></span><span class="main"><span class="main">:</span></span> analz_insert_analz<span class="main">)</span>
<span class="comment1">(*Alternative proof
apply (erule disjE) apply simp 
apply (erule disjE) apply simp 
apply (blast dest: analz_insert_analz)
*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



<span class="keyword2"><span class="keyword">end</span></span>

</pre>
</div><div id="Knowledge">
<div class="head">
<h1>Theory Knowledge</h1>
</div>
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="quoted"><span class="plain_text">‹Study on knowledge equivalence --- results to relate the knowledge of an agent to that of another's›</span></span>

<span class="keyword1"><span class="command">theory</span></span> Knowledge
<span class="keyword2"><span class="keyword">imports</span></span> <a href="NS_Public_Bad_GA.html">NS_Public_Bad_GA</a>
<span class="keyword2"><span class="keyword">begin</span></span>

<span class="comment1">(*Protocol independent study*)</span>

<span class="comment1">(*Whatever A knows, which is neither static-private nor dynamic-private for
  her, then also B knows that*)</span>
<span class="keyword1"><span class="command">theorem</span></span> knowledge_equiv<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span><span class="main">;</span> Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∉</span> set <span class="free">evs</span><span class="main">;</span>
   <span class="free">X</span> <span class="main">∉</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span> <span class="main">⟧</span>
 <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">B</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main"><span class="keyword3">,</span></span> <span class="operator">erule</span> rev_mp<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="main"><span class="improper">[</span></span>2<span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="improper"><span class="improper">a</span></span>"</span></span></span><span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> knowledge_equiv_bis<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span><span class="main">;</span> Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∉</span> set <span class="free">evs</span> <span class="main">⟧</span>
 <span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> knows <span class="free">B</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> knowledge_equiv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> knowledge_equiv_ter<span class="main">:</span>
 <span class="quoted"><span class="quoted">"<span class="main">⟦</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span><span class="main">;</span> <span class="free">X</span> <span class="main">∉</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span> <span class="main">⟧</span>
<span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">B</span> <span class="free">evs</span> <span class="main">∨</span> Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> knowledge_equiv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> knowledge_equiv_quater<span class="main">:</span>
 <span class="quoted"><span class="quoted">" <span class="free">X</span> <span class="main">∈</span> knows <span class="free">A</span> <span class="free">evs</span>
<span class="main">⟹</span> <span class="free">X</span> <span class="main">∈</span> knows <span class="free">B</span> <span class="free">evs</span> <span class="main">∨</span> Notes <span class="free">A</span> <span class="free">X</span> <span class="main">∈</span> set <span class="free">evs</span> <span class="main">∨</span> 
   <span class="free">X</span> <span class="main">∈</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">blast</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> knowledge_equiv<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> setdiff_diff_insert<span class="main">:</span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">-</span><span class="free">B</span><span class="main">-</span><span class="free">C</span><span class="main">=</span><span class="free">D</span><span class="main">-</span><span class="free">E</span><span class="main">-</span><span class="free">F</span> <span class="main">⟹</span> insert <span class="free">m</span> <span class="main">(</span><span class="free">A</span><span class="main">-</span><span class="free">B</span><span class="main">-</span><span class="free">C</span><span class="main">)</span> <span class="main">=</span> insert <span class="free">m</span> <span class="main">(</span><span class="free">D</span><span class="main">-</span><span class="free">E</span><span class="main">-</span><span class="free">F</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="comment1">(*IMPORTANT NOTE TO PREVIOUS LEMMA: removing parentheses from rhs falsifies
the lemma because set insertion seems to have higher priority than set
difference, hence insert m A-B-C ≠ insert m (A-B-C)!
Seen such operand priority, it can be understood why the lemma wouldn't hold
without parentheses*)</span>
<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"<span class="free">A</span><span class="main">-</span><span class="free">B</span><span class="main">-</span><span class="free">C</span><span class="main">=</span><span class="free">D</span><span class="main">-</span><span class="free">E</span><span class="main">-</span><span class="free">F</span> <span class="main">⟹</span> insert <span class="free">m</span> <span class="free">A</span><span class="main">-</span><span class="free">B</span><span class="main">-</span><span class="free">C</span> <span class="main">=</span> insert <span class="free">m</span> <span class="free">D</span><span class="main">-</span><span class="free">E</span><span class="main">-</span><span class="free">F</span>"</span></span>
<span class="keyword1"><span class="command">oops</span></span>

<span class="keyword1"><span class="command">lemma</span></span> knowledge_equiv_eq_setdiff<span class="main">:</span>
 <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span>  <span class="main">-</span>
   <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span> <span class="main">-</span>
     <span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">A</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span>
  <span class="main">=</span>
  knows <span class="free">B</span> <span class="free">evs</span> <span class="main">-</span>
   <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">B</span><span class="main">)</span><span class="main">}</span> <span class="main">-</span>
     <span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="improper"><span class="improper">a</span></span>"</span></span></span><span class="main">)</span>

<span class="comment1">(*Gets case solves because this event doesn't touch any agent knowledge*)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>

<span class="comment1">(*Says case fails because both agents extract the said message, plus
discussion on lemma setdiff_diff_insert*)</span>

<span class="comment1">(*Notes case solves in case neither of the two agents is the agent of the
  current step, because no notes are extracted and inductive premise applies;
  it fails in the two subcases when either of them is the agent of the current
  step, because a note would be extracted i.e. inserted in his knowledge, and
  hence falsification by discussion on lemma setdiff_diff_insert*)</span>

<span class="keyword1"><span class="command">oops</span></span> <span class="comment1">(*So we have clear counterexamples of why this theorem CANNOT be proved inductively. Alternative stretegy using symbolic evaluation introduces clear counterexamples such as when an agent says A's shared key: it would be in the rhs but not in the lhs!*)</span>

<span class="comment1">(* Old proof*)</span>
<span class="keyword1"><span class="command">lemma</span></span> knowledge_equiv_eq_old<span class="main">:</span>
 <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span>  <span class="main">∪</span>  
   <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">B</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
     <span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span> 
  <span class="main">=</span> 
  knows <span class="free">B</span> <span class="free">evs</span> <span class="main">∪</span> 
   <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
     <span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">A</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">B</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="improper"><span class="improper">a</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹Gets case solves because this event doesn't touch any agent knowledge›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">simp_all</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">safe</span> <span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹speeds up subsequent blasting›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span>  <span class="keyword1"><span class="command">txt</span></span><span class="quoted"><span class="plain_text">‹very very slow›</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="comment1">(* New proof*)</span>

<span class="keyword1"><span class="command">theorem</span></span> knowledge_eval<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span> <span class="main">=</span> 
       <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
       <span class="main">(</span>Key <span class="main">`</span> range pubEK<span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>Key <span class="main">`</span> range pubSK<span class="main">)</span> <span class="main">∪</span>
       <span class="main">{</span><span class="bound">X</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">S</span> <span class="bound">R</span><span class="main">.</span> Says <span class="bound">S</span> <span class="bound">R</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span> <span class="main">∪</span>
       <span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">A</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">A</span></span>"</span></span></span><span class="main"><span class="keyword3">,</span></span> <span class="operator">induct_tac</span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="free"><span class="free">evs</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct_tac</span> <span class="main"><span class="improper">[</span></span>2<span class="main"><span class="improper">]</span></span> <span class="quoted"><span class="quoted"><span class="quoted">"<span class="improper"><span class="improper">a</span></span>"</span></span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> knowledge_eval_setdiff<span class="main">:</span>
 <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span>  <span class="main">-</span> 
   <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span> <span class="main">-</span>
     <span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">A</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span>
  <span class="main">=</span> 
       <span class="main">(</span>Key <span class="main">`</span> range pubEK<span class="main">)</span> <span class="main">∪</span> <span class="main">(</span>Key <span class="main">`</span> range pubSK<span class="main">)</span> <span class="main">∪</span>
       <span class="main">{</span><span class="bound">X</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">S</span> <span class="bound">R</span><span class="main">.</span> Says <span class="bound">S</span> <span class="bound">R</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> knowledge_eval<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">oops</span></span><span class="comment1">(*here are clear counterexamples!*)</span>

<span class="keyword1"><span class="command">theorem</span></span> knowledge_equiv_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span>  <span class="main">∪</span>  
   <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">B</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
     <span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span> 
  <span class="main">=</span> 
  knows <span class="free">B</span> <span class="free">evs</span> <span class="main">∪</span> 
   <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
     <span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">A</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> knowledge_eval<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> <span class="quoted"><span class="quoted">"knows <span class="free">A</span> <span class="free">evs</span>  <span class="main">∪</span>  
   <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">B</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
     <span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span> <span class="main">-</span>
<span class="main">(</span>  <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">B</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
     <span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span> <span class="main">)</span> <span class="main">=</span> knows <span class="free">A</span> <span class="free">evs</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">oops</span></span>
<span class="comment1">(*Here the prover tells you why this fails*)</span>

<span class="keyword1"><span class="command">theorem</span></span> parts_knowledge_equiv_eq<span class="main">:</span> <span class="quoted"><span class="quoted">"
parts<span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span>  <span class="main">∪</span>  
   <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">B</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
     parts<span class="main">(</span><span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">B</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span><span class="main">)</span> 
  <span class="main">=</span> 
parts<span class="main">(</span>knows <span class="free">B</span> <span class="free">evs</span><span class="main">)</span> <span class="main">∪</span> 
   <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span> <span class="main">∪</span> 
     parts<span class="main">(</span><span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">A</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> knowledge_eval parts_Un<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemmas</span></span> parts_knowledge_equiv <span class="main">=</span> parts_knowledge_equiv_eq <span class="main">[</span><span class="operator">THEN</span> equalityD1<span class="main">,</span> <span class="operator">THEN</span> subsetD<span class="main">]</span>
<span class="keyword1"><span class="command">thm</span></span> parts_knowledge_equiv
<span class="keyword1"><span class="command">theorem</span></span> noprishr_parts_knowledge_equiv<span class="main">:</span> <span class="quoted"><span class="quoted">"
<span class="main">⟦</span> <span class="free">X</span> <span class="main">∉</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span><span class="main">;</span>
  <span class="free">X</span> <span class="main">∈</span> parts<span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span> <span class="main">⟧</span>
<span class="main">⟹</span>  <span class="free">X</span> <span class="main">∈</span> parts<span class="main">(</span>knows <span class="free">B</span> <span class="free">evs</span><span class="main">)</span> <span class="main">∪</span> 
      parts<span class="main">(</span><span class="main">{</span><span class="bound">X</span><span class="main">.</span> Notes <span class="free">A</span> <span class="bound">X</span> <span class="main">∈</span> set <span class="free">evs</span><span class="main">}</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">dest</span><span class="main"><span class="main">:</span></span> UnI1 <span class="main"><span class="main">[</span></span><span class="operator">THEN</span> UnI1<span class="main"><span class="main">,</span></span> <span class="operator">THEN</span> parts_knowledge_equiv<span class="main"><span class="main">]</span></span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>



<span class="comment1">(*Protocol-dependent study*)</span>


<span class="keyword1"><span class="command">lemma</span></span> knowledge_equiv_eq_NS<span class="main">:</span> <span class="quoted"><span class="quoted">" 
  <span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟹</span>
  knows <span class="free">A</span> <span class="free">evs</span>  <span class="main">∪</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">B</span><span class="main">)</span><span class="main">}</span>  <span class="main">=</span> 
  knows <span class="free">B</span> <span class="free">evs</span> <span class="main">∪</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> knowledge_eval NS_no_Notes<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">lemma</span></span> parts_knowledge_equiv_eq_NS<span class="main">:</span> <span class="quoted"><span class="quoted">" 
  <span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟹</span>
  parts<span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">B</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">B</span><span class="main">)</span><span class="main">}</span>  <span class="main">=</span> 
  parts<span class="main">(</span>knows <span class="free">B</span> <span class="free">evs</span><span class="main">)</span> <span class="main">∪</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">only</span><span class="main"><span class="main">:</span></span> knowledge_eval NS_no_Notes parts_Un<span class="main">)</span> <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="operator">force</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">theorem</span></span> noprishr_parts_knowledge_equiv_NS<span class="main">:</span> <span class="quoted"><span class="quoted">" 
<span class="main">⟦</span> <span class="free">X</span> <span class="main">∉</span> <span class="main">{</span>Key <span class="main">(</span>priEK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>priSK <span class="free">A</span><span class="main">)</span><span class="main">,</span> Key <span class="main">(</span>shrK <span class="free">A</span><span class="main">)</span><span class="main">}</span><span class="main">;</span>
  <span class="free">X</span> <span class="main">∈</span> parts<span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟧</span>
<span class="main">⟹</span>  <span class="free">X</span> <span class="main">∈</span> parts<span class="main">(</span>knows <span class="free">B</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">drule</span> noprishr_parts_knowledge_equiv<span class="main"><span class="keyword3">,</span></span> <span class="operator">simp</span><span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> NS_no_Notes<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>

<span class="keyword1"><span class="command">theorem</span></span> Agent_not_analz_N<span class="main">:</span>
<span class="quoted"><span class="quoted">"<span class="main">⟦</span> Nonce <span class="free">N</span> <span class="main">∉</span> parts<span class="main">(</span>knows <span class="free">A</span> <span class="free">evs</span><span class="main">)</span><span class="main">;</span> <span class="free">evs</span> <span class="main">∈</span> ns_public <span class="main">⟧</span>
 <span class="main">⟹</span> Nonce <span class="free">N</span> <span class="main">∉</span> analz<span class="main">(</span>knows <span class="free">B</span> <span class="free">evs</span><span class="main">)</span>"</span></span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">force</span> <span class="quasi_keyword">intro</span><span class="main"><span class="main">:</span></span> noprishr_parts_knowledge_equiv_NS analz_into_parts<span class="main">)</span>
<span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
<span class="comment1">(*Conclusion in terms of analz because we are more used to it. It would have been a stronger law in terms of parts, though*)</span>

<span class="keyword2"><span class="keyword">end</span></span>
</pre>
</div>