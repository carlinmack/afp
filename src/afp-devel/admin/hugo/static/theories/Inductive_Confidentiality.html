<div id="Message">
<div class="head"><h1>Theory Message</h1>
<span class="command">theory</span> <span class="name">Message</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      HOL/Auth/Message.thy
    Author:     Lawrence C Paulson, Cambridge University Computer Laboratory
    Copyright   1996  University of Cambridge

Datatypes of agents and messages;
Inductive relations "parts", "analz" and "synth"
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Theory of Agents and Messages for Security Protocols against Dolev-Yao›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Message</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Needed occasionally with spy_analz_tac, e.g. in analz_insert_Key_newK*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ (B ∪ A) = B ∪ A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span>
</span><span>  </span><span>key</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span>  </span><span>all_symmetric</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>        </span><span class="comment">― ‹true if all keys are symmetric›</span><span>
</span><span>  </span><span>invKey</span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"key=&gt;key"</span></span></span><span>  </span><span class="comment">― ‹inverse of a symmetric key›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">specification</span></span><span> </span><span class="delimiter">(</span><span>invKey</span><span class="delimiter">)</span><span>
</span><span>  </span><span>invKey</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invKey (invKey K) = K"</span></span></span><span>
</span><span>  </span><span>invKey_symmetric</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"all_symmetric --&gt; invKey = id"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>id</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The inverse of a symmetric key is itself; that of a public key
      is the private key and vice versa›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>symKeys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"key set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"symKeys == {K. invKey K = K}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span>  </span><span class="comment">― ‹We allow any number of friendly agents›</span><span>
</span><span>  </span><span>agent</span><span> </span><span class="delimiter">=</span><span> </span><span>Server</span><span> </span><span class="delimiter">|</span><span> </span><span>Friend</span><span> </span><span>nat</span><span> </span><span class="delimiter">|</span><span> </span><span>Spy</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span>
</span><span>     </span><span>msg</span><span> </span><span class="delimiter">=</span><span> </span><span>Agent</span><span>  </span><span>agent</span><span>     </span><span class="comment">― ‹Agent names›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>Number</span><span> </span><span>nat</span><span>       </span><span class="comment">― ‹Ordinary integers, timestamps, ...›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>Nonce</span><span>  </span><span>nat</span><span>       </span><span class="comment">― ‹Unguessable nonces›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>Key</span><span>    </span><span>key</span><span>       </span><span class="comment">― ‹Crypto keys›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>Hash</span><span>   </span><span>msg</span><span>       </span><span class="comment">― ‹Hashing›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>MPair</span><span>  </span><span>msg</span><span> </span><span>msg</span><span>   </span><span class="comment">― ‹Compound messages›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>Crypt</span><span>  </span><span>key</span><span> </span><span>msg</span><span>   </span><span class="comment">― ‹Encryption, public- or shared-key›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Concrete syntax: messages appear as ‹⦃A,B,NA⦄›, etc...›</span></span></span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_MTuple"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['a, args] =&gt; 'a * 'b"</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(2⦃_,/ _⦄)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃x, y, z⦄"</span></span></span><span>   </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃x, ⦃y, z⦄⦄"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃x, y⦄"</span></span></span><span>      </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST MPair x y"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HPair</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[msg,msg] =&gt; msg"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(4Hash[_] /_)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>1000</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="comment">― ‹Message Y paired with a MAC computed with the help of X›</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Hash[X] Y == ⦃ Hash⦃X,Y⦄, Y⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>keysFor</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set =&gt; key set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="comment">― ‹Keys useful to decrypt elements of a message set›</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"keysFor H == invKey ` {K. ∃X. Crypt K X ∈ H}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive definition of all parts of a message›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>parts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set =&gt; msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>Inj</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>               </span><span class="string"><span class="delete"><span class="delete">"X ∈ H ==&gt; X ∈ parts H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Fst</span><span class="delimiter">:</span><span>         </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄   ∈ parts H ==&gt; X ∈ parts H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Snd</span><span class="delimiter">:</span><span>         </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄   ∈ parts H ==&gt; Y ∈ parts H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Body</span><span class="delimiter">:</span><span>        </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∈ parts H ==&gt; X ∈ parts H"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G ⊆ H ==&gt; parts(G) ⊆ parts(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>parts.Fst</span><span> </span><span>parts.Snd</span><span> </span><span>parts.Body</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Equations hold because constructors are injective.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Friend_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Friend x ∈ Friend`A) = (x:A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Key_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Key x ∈ Key`A) = (x∈A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_Key_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Nonce x ∉ Key`A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inverse of keys›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invKey_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(invKey K = invKey K') = (K=K')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>invKey</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹keysFor operator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor {} = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_Un</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (H ∪ H') = keysFor H ∪ keysFor H'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_UN</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (⋃i∈A. H i) = (⋃i∈A. keysFor (H i))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G ⊆ H ==&gt; keysFor(G) ⊆ keysFor(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Agent</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Agent A) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Nonce</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Nonce N) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Number</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Number N) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Key K) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Hash</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Hash X) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_MPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert ⦃X,Y⦄ H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Crypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Crypt K X) H) = insert (invKey K) (keysFor H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_image_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (Key`E) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_imp_invKey_keysFor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∈ H ==&gt; invKey K ∈ keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive relation "parts"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_parts</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| ⦃X,Y⦄ ∈ parts H;        
         [| X ∈ parts H; Y ∈ parts H |] ==&gt; P |] ==&gt; P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>parts.Fst</span><span> </span><span>parts.Snd</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>MPair_parts</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span>  </span><span>parts.Body</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹NB These two rules are UNSAFE in the formal sense, as they discard the
     compound message.  They work well on THIS FILE.  
  ‹MPair_parts› is left as SAFE because it speeds up proofs.
  The Crypt rule is normally kept UNSAFE to avoid breaking up certificates.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_increasing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ⊆ parts(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>parts_insertI</span><span> </span><span class="delimiter">=</span><span> </span><span>subset_insertI</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts{} = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_emptyE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ parts{} ==&gt; P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹WARNING: loops if H = {Y}, therefore must not be repeated!›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_singleton</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ parts H ==&gt; ∃Y∈H. X∈ parts {Y}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Unions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_Un_subset1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(G) ∪ parts(H) ⊆ parts(G ∪ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Un_least</span><span> </span><span>parts_mono</span><span> </span><span>Un_upper1</span><span> </span><span>Un_upper2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_Un_subset2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(G ∪ H) ⊆ parts(G) ∪ parts(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_Un</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(G ∪ H) = parts(G) ∪ parts(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>parts_Un_subset1</span><span> </span><span>parts_Un_subset2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (insert X H) = parts {X} ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_is_Un</span><span> </span><span>parts_Un</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹TWO inserts to avoid looping.  This rewrite is better than nothing.
  Not suitable for Addsimps: its behaviour can be strange.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert2</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert X (insert Y H)) = parts {X} ∪ parts {Y} ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_commute</span><span> </span><span>Un_empty_right</span><span> </span><span>Un_insert_right</span><span> </span><span>insert_is_Un</span><span> </span><span>parts_Un</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_UN_subset1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃x∈A. parts(H x)) ⊆ parts(⋃x∈A. H x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>UN_least</span><span> </span><span>parts_mono</span><span> </span><span>UN_upper</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_UN_subset2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(⋃x∈A. H x) ⊆ (⋃x∈A. parts(H x))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_UN</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(⋃x∈A. H x) = (⋃x∈A. parts(H x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>parts_UN_subset1</span><span> </span><span>parts_UN_subset2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Added to simplify arguments to parts, analz and synth.
  NOTE: the UN versions are no longer used!›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This allows ‹blast› to simplify occurrences of 
  @{term "parts(G∪H)"} in the assumption.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>in_parts_UnE</span><span> </span><span class="delimiter">=</span><span> </span><span>parts_Un</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>UnE</span><span class="delimiter">]</span><span> 
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>in_parts_UnE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert X (parts H) ⊆ parts(insert X H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>parts_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Idempotence and transitivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_partsD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ parts (parts H) ==&gt; X∈ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (parts H) = parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_subset_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(parts G ⊆ parts H) = (G ⊆ parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>parts_idem</span><span> </span><span>parts_increasing</span><span> </span><span>parts_mono</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| X∈ parts G;  G ⊆ parts H |] ==&gt; X∈ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>parts_subset_iff</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cut›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_cut</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Y∈ parts (insert X G);  X∈ parts H |] ==&gt; Y∈ parts (G ∪ H)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>parts_trans</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_cut_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ parts H ==&gt; parts (insert X H) = parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_absorb</span><span> </span><span>parts_idem</span><span> </span><span>parts_insert</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Rewrite rules for pulling out atomic messages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>parts_insert_eq_I</span><span> </span><span class="delimiter">=</span><span> </span><span>equalityI</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>subsetI</span><span> </span><span>parts_insert_subset</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Agent</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Agent agt) H) = insert (Agent agt) (parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>parts_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Nonce</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Nonce N) H) = insert (Nonce N) (parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>parts_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Number</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Number N) H) = insert (Number N) (parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>parts_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Key K) H) = insert (Key K) (parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>parts_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Hash</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Hash X) H) = insert (Hash X) (parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>parts_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Crypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Crypt K X) H) = insert (Crypt K X) (parts (insert X H))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>parts.Body</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_MPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert ⦃X,Y⦄ H) =  
          insert ⦃X,Y⦄ (parts (insert X (insert Y H)))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>parts.Fst</span><span> </span><span>parts.Snd</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_image_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (Key`N) = Key`N"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In any message, there is an upper bound N on its greatest nonce.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>msg_Nonce_supply</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃N. ∀n. N≤n --&gt; Nonce n ∉ parts {msg}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>msg</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span>parts_insert2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Nonce case›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_n_not_le_n</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹MPair case: metis works out the necessary sum itself!›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_trans</span><span> </span><span>nat_le_linear</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive relation "analz"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive definition of "analz" -- what can be broken down from a set of
    messages, including keys.  A form of downward closure.  Pairs can
    be taken apart; messages decrypted with known keys.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>analz</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set =&gt; msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>Inj</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span>    </span><span class="string"><span class="delete"><span class="delete">"X ∈ H ==&gt; X ∈ analz H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Fst</span><span class="delimiter">:</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄ ∈ analz H ==&gt; X ∈ analz H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Snd</span><span class="delimiter">:</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄ ∈ analz H ==&gt; Y ∈ analz H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Decrypt</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"[|Crypt K X ∈ analz H; Key(invKey K): analz H|] ==&gt; X ∈ analz H"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity; Lemma 1 of Lowe's paper›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G⊆H ==&gt; analz(G) ⊆ analz(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz.Fst</span><span> </span><span>analz.Snd</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Making it safe speeds up proofs›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_analz</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| ⦃X,Y⦄ ∈ analz H;        
             [| X ∈ analz H; Y ∈ analz H |] ==&gt; P   
          |] ==&gt; P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz.Fst</span><span> </span><span>analz.Snd</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_increasing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ⊆ analz(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_subset_parts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz H ⊆ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_into_parts</span><span> </span><span class="delimiter">=</span><span> </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>not_parts_not_analz</span><span> </span><span class="delimiter">=</span><span> </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>contra_subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_analz</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (analz H) = parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>analz_increasing</span><span> </span><span>analz_subset_parts</span><span> </span><span>equalityI</span><span> </span><span>parts_mono</span><span> </span><span>parts_subset_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_parts</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (parts H) = parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_insertI</span><span> </span><span class="delimiter">=</span><span> </span><span>subset_insertI</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹General equational properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz{} = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Converse fails: we can analz more from the union than from the 
  separate parts, as a key in one might decrypt a message in the other›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz(G) ∪ analz(H) ⊆ analz(G ∪ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Un_least</span><span> </span><span>analz_mono</span><span> </span><span>Un_upper1</span><span> </span><span>Un_upper2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert X (analz H) ⊆ analz(insert X H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Rewrite rules for pulling out atomic messages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_insert_eq_I</span><span> </span><span class="delimiter">=</span><span> </span><span>equalityI</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>subsetI</span><span> </span><span>analz_insert</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Agent</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Agent agt) H) = insert (Agent agt) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Nonce</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Nonce N) H) = insert (Nonce N) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Number</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Number N) H) = insert (Number N) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Hash</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Hash X) H) = insert (Hash X) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Can only pull out Keys if they are not needed to decrypt the rest›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∉ keysFor (analz H) ==&gt;   
          analz (insert (Key K) H) = insert (Key K) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_MPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert ⦃X,Y⦄ H) =  
          insert ⦃X,Y⦄ (analz (insert X (insert Y H)))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz.Fst</span><span> </span><span>analz.Snd</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Can pull out enCrypted message if the Key is not known›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Crypt</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Key (invKey K) ∉ analz H 
      ==&gt; analz (insert (Crypt K X) H) = insert (Crypt K X) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (invKey K) ∈ analz H ==&gt;   
               analz (insert (Crypt K X) H) ⊆  
               insert (Crypt K X) (analz (insert X H))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (invKey K) ∈ analz H ==&gt;   
               insert (Crypt K X) (analz (insert X H)) ⊆  
               analz (insert (Crypt K X) H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_insertI</span><span> </span><span>analz.Decrypt</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Decrypt</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Key (invKey K) ∈ analz H ==&gt;   
               analz (insert (Crypt K X) H) =  
               insert (Crypt K X) (analz (insert X H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>lemma1</span><span> </span><span>lemma2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Case analysis: either the message is secure, or it is not! Effective,
but can cause subgoals to blow up! Use with ‹if_split›; apparently
‹split_tac› does not cope with patterns such as @{term"analz (insert
(Crypt K X) H)"}›</span></span></span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_Crypt_if</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Crypt K X) H) =                 
          (if (Key (invKey K) ∈ analz H)                 
           then insert (Crypt K X) (analz (insert X H))  
           else insert (Crypt K X) (analz H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>analz_insert_Crypt</span><span> </span><span>analz_insert_Decrypt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This rule supposes "for the sake of argument" that we have the key.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Crypt_subset</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Crypt K X) H) ⊆   
           insert (Crypt K X) (analz (insert X H))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_image_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (Key`N) = Key`N"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Idempotence and transitivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_analzD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ analz (analz H) ==&gt; X∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (analz H) = analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_subset_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(analz G ⊆ analz H) = (G ⊆ analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>analz_idem</span><span> </span><span>analz_increasing</span><span> </span><span>analz_mono</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| X∈ analz G;  G ⊆ analz H |] ==&gt; X∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cut; Lemma 2 of Lowe›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_cut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| Y∈ analz (insert X H);  X∈ analz H |] ==&gt; Y∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz_trans</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Cut can be proved easily by induction on
   "Y: analz (insert X H) ==&gt; X: analz H --&gt; Y: analz H"
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This rewrite rule helps in the simplification of messages that involve
  the forwarding of unknown components (X).  Without it, removing occurrences
  of X can be very complicated.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ analz H ==&gt; analz (insert X H) = analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>analz_cut</span><span> </span><span>analz_insert_eq_I</span><span> </span><span>insert_absorb</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A congruence rule for "analz"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_subset_cong</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| analz G ⊆ analz G'; analz H ⊆ analz H' |] 
      ==&gt; analz (G ∪ H) ⊆ analz (G' ∪ H')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_mono</span><span> </span><span>analz_Un</span><span> </span><span>analz_subset_iff</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_cong</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| analz G = analz G'; analz H = analz H' |] 
      ==&gt; analz (G ∪ H) = analz (G' ∪ H')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>analz_subset_cong</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_cong</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz H = analz H' ==&gt; analz(insert X H) = analz(insert X H')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>insert_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>analz_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹If there are no pairs or encryptions then analz does nothing›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_trivial</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| ∀X Y. ⦃X,Y⦄ ∉ H;  ∀X K. Crypt K X ∉ H |] ==&gt; analz H = H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹These two are obsolete (with a single Spy) but cost little to prove...›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_UN_analz_lemma</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X∈ analz (⋃i∈A. analz (H i)) ==&gt; X∈ analz (⋃i∈A. H i)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_UN_analz</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (⋃i∈A. analz (H i)) = analz (⋃i∈A. H i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_UN_analz_lemma</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive relation "synth"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive definition of "synth" -- what can be built up from a set of
    messages.  A form of upward closure.  Pairs can be built, messages
    encrypted with known keys.  Agent names are public domain.
    Numbers can be guessed, but Nonces cannot be.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>synth</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set =&gt; msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>Inj</span><span>    </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"X ∈ H ==&gt; X ∈ synth H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Agent</span><span>  </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Agent agt ∈ synth H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Number</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Number n  ∈ synth H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Hash</span><span>   </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth H ==&gt; Hash X ∈ synth H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>MPair</span><span>  </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"[|X ∈ synth H;  Y ∈ synth H|] ==&gt; ⦃X,Y⦄ ∈ synth H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Crypt</span><span>  </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"[|X ∈ synth H;  Key(K) ∈ H|] ==&gt; Crypt K X ∈ synth H"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G⊆H ==&gt; synth(G) ⊆ synth(H)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>synth.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹NO ‹Agent_synth›, as any Agent name can be synthesized.  
  The same holds for @{term Number}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_simps</span></span><span> </span><span>synth_simps</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce n ∈ synth H"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K ∈ synth H"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"Hash X ∈ synth H"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄ ∈ synth H"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∈ synth H"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_increasing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ⊆ synth(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Unions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Converse fails: we can synth more from the union than from the 
  separate parts, building a compound message using elements of each.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"synth(G) ∪ synth(H) ⊆ synth(G ∪ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Un_least</span><span> </span><span>synth_mono</span><span> </span><span>Un_upper1</span><span> </span><span>Un_upper2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert X (synth H) ⊆ synth(insert X H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>synth_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Idempotence and transitivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_synthD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ synth (synth H) ==&gt; X∈ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>synth.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_idem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"synth (synth H) = synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_subset_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(synth G ⊆ synth H) = (G ⊆ synth H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subset_trans</span><span> </span><span>synth_idem</span><span> </span><span>synth_increasing</span><span> </span><span>synth_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| X∈ synth G;  G ⊆ synth H |] ==&gt; X∈ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>synth_mono</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cut; Lemma 2 of Lowe›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_cut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| Y∈ synth (insert X H);  X∈ synth H |] ==&gt; Y∈ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>synth_trans</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Agent_synth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Agent A ∈ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Number_synth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Number n ∈ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_synth_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Nonce N ∈ synth H) = (Nonce N ∈ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Key_synth_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Key K ∈ synth H) = (Key K ∈ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_synth_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Key K ∉ H ==&gt; (Crypt K X ∈ synth H) = (Crypt K X ∈ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_synth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"keysFor (synth H) = keysFor H ∪ invKey`{K. Key K ∈ H}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Combinations of parts, analz and synth›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_synth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (synth H) = parts H ∪ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>synth_increasing</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span> 
</span><span>                    </span><span>parts.Fst</span><span> </span><span>parts.Snd</span><span> </span><span>parts.Body</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_analz_Un</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (analz G ∪ H) = analz (G ∪ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>analz_subset_cong</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_synth_Un</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (synth G ∪ H) = analz (G ∪ H) ∪ synth G"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>5</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz.Fst</span><span> </span><span>analz.Snd</span><span> </span><span>analz.Decrypt</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_synth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (synth H) = analz H ∪ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_empty_right</span><span> </span><span>analz_synth_Un</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For reasoning about the Fake rule in traces›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_subset_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ G ==&gt; parts(insert X H) ⊆ parts G ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnCI</span><span> </span><span>Un_upper2</span><span> </span><span>insert_subset</span><span> </span><span>parts_Un</span><span> </span><span>parts_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹More specifically for Fake. See also ‹Fake_parts_sing› below›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fake_parts_insert</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth (analz H) ==&gt;  
      parts (insert X H) ⊆ synth (analz H) ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_commute</span><span> </span><span>analz_increasing</span><span> </span><span>insert_subset</span><span> </span><span>parts_analz</span><span> </span><span>parts_mono</span><span> 
</span><span>          </span><span>parts_synth</span><span> </span><span>synth_mono</span><span> </span><span>synth_subset_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fake_parts_insert_in_Un</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[|Z ∈ parts (insert X H);  X: synth (analz H)|] 
      ==&gt; Z ∈  synth (analz H) ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Fake_parts_insert</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{term H} is sometimes @{term"Key ` KK ∪ spies evs"}, so can't put 
  @{term "G=H"}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fake_analz_insert</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X∈ synth (analz G) ==&gt;  
      analz (insert X H) ⊆ synth (analz G) ∪ analz (G ∪ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ analz (synth (analz G) ∪ H)"</span></span></span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>synth_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_conj_parts</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(X ∈ analz H ∧ X ∈ parts H) = (X ∈ analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_disj_parts</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(X ∈ analz H | X ∈ parts H) = (X ∈ parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Without this equation, other rules for synth and analz would yield
  redundant cases›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_synth_analz</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(⦃X,Y⦄ ∈ synth (analz H)) =  
      (X ∈ synth (analz H) ∧ Y ∈ synth (analz H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_synth_analz</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Key K ∈ analz H;  Key (invKey K) ∈ analz H |]  
       ==&gt; (Crypt K X ∈ synth (analz H)) = (X ∈ synth (analz H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Hash_synth_analz</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∉ synth (analz H)  
      ==&gt; (Hash⦃X,Y⦄ ∈ synth (analz H)) = (Hash⦃X,Y⦄ ∈ analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹HPair: a combination of Hash and MPair›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Freeness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Agent_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Agent A ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce N ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Number_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Number N ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Key_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Hash_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Hash Z ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X' ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>HPair_neqs</span><span> </span><span class="delimiter">=</span><span> </span><span>Agent_neq_HPair</span><span> </span><span>Nonce_neq_HPair</span><span> </span><span>Number_neq_HPair</span><span> 
</span><span>                    </span><span>Key_neq_HPair</span><span> </span><span>Hash_neq_HPair</span><span> </span><span>Crypt_neq_HPair</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_neqs</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_neqs</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>iff</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPair_eq</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Hash[X'] Y' = Hash[X] Y) = (X' = X ∧ Y'=Y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_eq_HPair</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(⦃X',Y'⦄ = Hash[X] Y) = (X' = Hash⦃X,Y⦄ ∧ Y'=Y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPair_eq_MPair</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(Hash[X] Y = ⦃X',Y'⦄) = (X' = Hash⦃X,Y⦄ ∧ Y'=Y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Specialized laws, proved in terms of those for Hash and MPair›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_HPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Hash[X] Y) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_HPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Hash[X] Y) H) =  
     insert (Hash[X] Y) (insert (Hash⦃X,Y⦄) (parts (insert Y H)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_HPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Hash[X] Y) H) =  
     insert (Hash[X] Y) (insert (Hash⦃X,Y⦄) (analz (insert Y H)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPair_synth_analz</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∉ synth (analz H)  
    ==&gt; (Hash[X] Y ∈ synth (analz H)) =  
        (Hash ⦃X, Y⦄ ∈ analz H ∧ Y ∈ synth (analz H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We do NOT want Crypt... messages broken up in protocols!!›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>parts.Body</span><span> </span><span class="delimiter">[</span><span>rule</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Rewrites to push in Key and Crypt messages, so that other messages can
    be pulled out using the ‹analz_insert› rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>pushKeys</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agent C"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce N"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Number N"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Hash X"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"MPair X Y"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K'"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>K</span><span> </span><span>C</span><span> </span><span>N</span><span> </span><span>X</span><span> </span><span>Y</span><span> </span><span>K'</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>pushCrypts</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agent C"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agent C"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce N"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Number N"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Hash X'"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"MPair X' Y"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span> </span><span>K</span><span> </span><span>C</span><span> </span><span>N</span><span> </span><span>X'</span><span> </span><span>Y</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cannot be added with ‹[simp]› -- messages should not always be
  re-ordered.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>pushes</span><span> </span><span class="delimiter">=</span><span> </span><span>pushKeys</span><span> </span><span>pushCrypts</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The set of key-free messages›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Note that even the encryption of a key-free message remains key-free.
  This concept is valuable because of the theorem analz_keyfree_into_Un, proved below. *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>keyfree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>Agent</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Agent A ∈ keyfree"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Number</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Number N ∈ keyfree"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Nonce</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Nonce N ∈ keyfree"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Hash</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Hash X ∈ keyfree"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>MPair</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"[|X ∈ keyfree;  Y ∈ keyfree|] ==&gt; ⦃X,Y⦄ ∈ keyfree"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Crypt</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"[|X ∈ keyfree|] ==&gt; Crypt K X ∈ keyfree"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>keyfree.intros</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>keyfree_KeyE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K ∈ keyfree"</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>keyfree_MPairE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄ ∈ keyfree"</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>keyfree_CryptE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∈ keyfree"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_keyfree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (keyfree) ⊆ keyfree"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>keyfree_KeyE</span><span> </span><span>keyfree_MPairE</span><span> </span><span>keyfree_CryptE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*The key-free part of a set of messages can be removed from the scope of the analz operator.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_keyfree_into_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦X ∈ analz (G ∪ H); G ⊆ keyfree⟧ ⟹ X ∈ parts G ∪ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span>parts.Body</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>parts.Body</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_absorb2</span><span> </span><span>keyfree_KeyE</span><span> </span><span>parts_Un</span><span> </span><span>parts_keyfree</span><span> </span><span>UnI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Tactics useful for many protocol proofs›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‹
(*Analysis of Fake cases.  Also works for messages that forward unknown parts,
  but this application is no longer necessary if analz_insert_eq is used.
  DEPENDS UPON "X" REFERRING TO THE FRADULENT MESSAGE *)

fun impOfSubs th = th RSN (2, @{thm rev_subsetD})

(*Apply rules to break down assumptions of the form
  Y ∈ parts(insert X H)  and  Y ∈ analz(insert X H)
*)
fun Fake_insert_tac ctxt = 
    dresolve_tac ctxt [impOfSubs @{thm Fake_analz_insert},
                  impOfSubs @{thm Fake_parts_insert}] THEN'
    eresolve_tac ctxt [asm_rl, @{thm synth.Inj}];

fun Fake_insert_simp_tac ctxt i = 
  REPEAT (Fake_insert_tac ctxt i) THEN asm_full_simp_tac ctxt i;

fun atomic_spy_analz_tac ctxt =
  SELECT_GOAL
   (Fake_insert_simp_tac ctxt 1 THEN
    IF_UNSOLVED
      (Blast.depth_tac
        (ctxt addIs [@{thm analz_insertI}, impOfSubs @{thm analz_subset_parts}]) 4 1));

fun spy_analz_tac ctxt i =
  DETERM
   (SELECT_GOAL
     (EVERY 
      [  (*push in occurrences of X...*)
       (REPEAT o CHANGED)
         (Rule_Insts.res_inst_tac ctxt [((("x", 1), Position.none), "X")] []
          (insert_commute RS ssubst) 1),
       (*...allowing further simplifications*)
       simp_tac ctxt 1,
       REPEAT (FIRSTGOAL (resolve_tac ctxt [allI,impI,notI,conjI,iffI])),
       DEPTH_SOLVE (atomic_spy_analz_tac ctxt 1)]) i);
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹By default only ‹o_apply› is built-in.  But in the presence of
eta-expansion this means that some terms displayed as @{term "f o g"} will be
rewritten, and others will not!›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>o_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_notin_image_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∉ Key ` A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Hash_notin_image_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Hash X ∉ Key ` A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_analz_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G⊆H ==&gt; synth (analz(G)) ⊆ synth (analz(H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>iprover</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>synth_mono</span><span> </span><span>analz_mono</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fake_analz_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth(analz H) ==&gt; synth (analz (insert X H)) = synth (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Fake_analz_insert</span><span> </span><span>Un_absorb</span><span> </span><span>Un_absorb1</span><span> </span><span>Un_commute</span><span> 
</span><span>          </span><span>subset_insertI</span><span> </span><span>synth_analz_mono</span><span> </span><span>synth_increasing</span><span> </span><span>synth_subset_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Two generalizations of ‹analz_insert_eq››</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_analz_insert_eq</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ analz H ==&gt; ∀G. H ⊆ G --&gt; analz (insert X G) = analz G"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_cut</span><span> </span><span>analz_insertI</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_analz_insert_eq</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth (analz H) 
      ==&gt; ∀G. H ⊆ G --&gt; (Key K ∈ analz (insert X G)) = (Key K ∈ analz G)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>synth.induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gen_analz_insert_eq</span><span> </span><span>subset_trans</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>subset_insertI</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fake_parts_sing</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth (analz H) ==&gt; parts{X} ⊆ synth (analz H) ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Fake_parts_insert</span><span> </span><span>empty_subsetI</span><span> </span><span>insert_mono</span><span> </span><span>parts_mono</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Fake_parts_sing_imp_Un</span><span> </span><span class="delimiter">=</span><span> </span><span>Fake_parts_sing</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>spy_analz</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (SIMPLE_METHOD' o spy_analz_tac)›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving the Fake case when analz is involved"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>atomic_spy_analz</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (SIMPLE_METHOD' o atomic_spy_analz_tac)›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for debugging spy_analz"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>Fake_insert_simp</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (SIMPLE_METHOD' o Fake_insert_simp_tac)›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for debugging spy_analz"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Event">
<div class="head"><h1>Theory Event</h1>
<span class="command">theory</span> <span class="name">Event</span><br/>
<span class="keyword">imports</span> <a href="Message.html"><span class="name">Message</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      HOL/Auth/Event.thy
    Author:     Lawrence C Paulson, Cambridge University Computer Laboratory
    Copyright   1996  University of Cambridge

Datatype of events; function "spies"; freshness

"bad" agents have been broken by the Spy; their private keys and internal
    stores are visible to him
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Theory of Events for Security Protocols against Dolev-Yao›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Event</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Message</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Initial states of agents -- parameter of the construction*)</span></span></span></span></span><span>
</span><span>  </span><span>initState</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; msg set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span>
</span><span>  </span><span>event</span><span> </span><span class="delimiter">=</span><span> </span><span>Says</span><span>  </span><span>agent</span><span> </span><span>agent</span><span> </span><span>msg</span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span>Gets</span><span>  </span><span>agent</span><span>       </span><span>msg</span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span>Notes</span><span> </span><span>agent</span><span>       </span><span>msg</span><span>
</span><span>       
</span><span class="keyword1"><span class="command">consts</span></span><span> 
</span><span>  </span><span>bad</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent set"</span></span></span><span>                         </span><span class="comment">― ‹compromised agents›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Spy has access to his own key for spoof messages, but Server is secure›</span></span></span><span>
</span><span class="keyword1"><span class="command">specification</span></span><span> </span><span class="delimiter">(</span><span>bad</span><span class="delimiter">)</span><span>
</span><span>  </span><span>Spy_in_bad</span><span>     </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Spy ∈ bad"</span></span></span><span>
</span><span>  </span><span>Server_not_bad</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Server ∉ bad"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"{Spy}"</span></span></span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>knows</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; event list =&gt; msg set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>knows_Nil</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"knows A [] = initState A"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>knows_Cons</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"knows A (ev # evs) =
       (if A = Spy then 
        (case ev of
           Says A' B X =&gt; insert X (knows Spy evs)
         | Gets A' X =&gt; knows Spy evs
         | Notes A' X  =&gt; 
             if A' ∈ bad then insert X (knows Spy evs) else knows Spy evs)
        else
        (case ev of
           Says A' B X =&gt; 
             if A'=A then insert X (knows A evs) else knows A evs
         | Gets A' X    =&gt; 
             if A'=A then insert X (knows A evs) else knows A evs
         | Notes A' X    =&gt; 
             if A'=A then insert X (knows A evs) else knows A evs))"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
  Case A=Spy on the Gets event
  enforces the fact that if a message is received then it must have been sent,
  therefore the oops case must use Notes
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The constant "spies" is retained for compatibility's sake›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>spies</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list =&gt; msg set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"spies == knows Spy"</span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Set of items that might be visible to somebody:
    complement of the set of fresh items*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>used</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list =&gt; msg set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>used_Nil</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"used []         = (UN B. parts (initState B))"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>used_Cons</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"used (ev # evs) =
                     (case ev of
                        Says A B X =&gt; parts {X} ∪ used evs
                      | Gets A X   =&gt; used evs
                      | Notes A X  =&gt; parts {X} ∪ used evs)"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹The case for @{term Gets} seems anomalous, but @{term Gets} always
        follows @{term Says} in real protocols.  Seems difficult to change.
        See @{text Gets_correct} in theory @{text "Guard/Extensions.thy"}.›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Notes_imp_used</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Notes A X ∈ set evs --&gt; X ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>evs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Says_imp_used</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Says A B X ∈ set evs --&gt; X ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>evs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Function @{term knows}›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Simplifying   
 parts(insert X (knows Spy evs)) = parts{X} ∪ parts(knows Spy evs).
  This version won't loop with the simplifier.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>parts_insert_knows_A</span><span> </span><span class="delimiter">=</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span> </span><span>evs</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Spy_Says</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"knows Spy (Says A B X # evs) = insert X (knows Spy evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Letting the Spy see "bad" agents' notes avoids redundant case-splits
      on whether @{term "A=Spy"} and whether @{term "A∈bad"}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Spy_Notes</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"knows Spy (Notes A X # evs) =  
          (if A:bad then insert X (knows Spy evs) else knows Spy evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Spy_Gets</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows Spy (Gets A X # evs) = knows Spy evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Spy_subset_knows_Spy_Says</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"knows Spy evs ⊆ knows Spy (Says A B X # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_insertI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Spy_subset_knows_Spy_Notes</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"knows Spy evs ⊆ knows Spy (Notes A X # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Spy_subset_knows_Spy_Gets</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"knows Spy evs ⊆ knows Spy (Gets A X # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_insertI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Spy sees what is sent on the traffic›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Says_imp_knows_Spy</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Says A B X ∈ set evs --&gt; X ∈ knows Spy evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Notes_imp_knows_Spy</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Notes A X ∈ set evs --&gt; A: bad --&gt; X ∈ knows Spy evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Elimination rules: derive contradictions from old Says events containing
  items known to be fresh›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Says_imp_parts_knows_Spy</span><span> </span><span class="delimiter">=</span><span> 
</span><span>       </span><span>Says_imp_knows_Spy</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>revcut_rl</span><span class="delimiter">]</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>knows_Spy_partsEs</span><span> </span><span class="delimiter">=</span><span>
</span><span>     </span><span>Says_imp_parts_knows_Spy</span><span> </span><span>parts.Body</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>revcut_rl</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Says_imp_analz_Spy</span><span> </span><span class="delimiter">=</span><span> </span><span>Says_imp_knows_Spy</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz.Inj</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Compatibility for the old "spies" function›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>spies_partsEs</span><span> </span><span class="delimiter">=</span><span> </span><span>knows_Spy_partsEs</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Says_imp_spies</span><span> </span><span class="delimiter">=</span><span> </span><span>Says_imp_knows_Spy</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>parts_insert_spies</span><span> </span><span class="delimiter">=</span><span> </span><span>parts_insert_knows_A</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>Spy</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Knowledge of Agents›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Says</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A (Says A B X # evs) = insert X (knows A evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Notes</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A (Notes A X # evs) = insert X (knows A evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Gets</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"A ≠ Spy --&gt; knows A (Gets A X # evs) = insert X (knows A evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_subset_knows_Says</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs ⊆ knows A (Says A' B X # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_insertI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_subset_knows_Notes</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs ⊆ knows A (Notes A' X # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_insertI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_subset_knows_Gets</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs ⊆ knows A (Gets A' X # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_insertI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Agents know what they say›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Says_imp_knows</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Says A B X ∈ set evs --&gt; X ∈ knows A evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Agents know what they note›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Notes_imp_knows</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Notes A X ∈ set evs --&gt; X ∈ knows A evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Agents know what they receive›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Gets_imp_knows_agents</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"A ≠ Spy --&gt; Gets A X ∈ set evs --&gt; X ∈ knows A evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹What agents DIFFERENT FROM Spy know 
  was either said, or noted, or got, or known initially›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_imp_Says_Gets_Notes_initState</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| X ∈ knows A evs; A ≠ Spy |] ==&gt; ∃B.  
  Says A B X ∈ set evs | Gets A X ∈ set evs | Notes A X ∈ set evs | X ∈ initState A"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹What the Spy knows -- for the time being --
  was either said or noted, or known initially›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Spy_imp_Says_Notes_initState</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| X ∈ knows Spy evs |] ==&gt; ∃A B.  
  Says A B X ∈ set evs | Notes A X ∈ set evs | X ∈ initState Spy"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_knows_Spy_subset_used</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (knows Spy evs) ⊆ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>  
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>parts_insert_knows_A</span><span> </span><span>knows_Cons</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>usedI</span><span> </span><span class="delimiter">=</span><span> </span><span>parts_knows_Spy_subset_used</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>initState_into_used</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ parts (initState B) ==&gt; X ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>parts_insert_knows_A</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>used_Says</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"used (Says A B X # evs) = parts{X} ∪ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>used_Notes</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"used (Notes A X # evs) = parts{X} ∪ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>used_Gets</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"used (Gets A X # evs) = used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>used_nil_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"used [] ⊆ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>initState_into_used</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹NOTE REMOVAL--laws above are cleaner, as they don't involve "case"›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>knows_Cons</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>        </span><span>used_Nil</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span>used_Cons</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For proving theorems of the form @{term "X ∉ analz (knows Spy evs) --&gt; P"}
  New events added by induction to "evs" are discarded.  Provided 
  this information isn't needed, the proof will be much shorter, since
  it will omit complicated reasoning about @{term analz}.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_mono_contra</span><span> </span><span class="delimiter">=</span><span>
</span><span>       </span><span>knows_Spy_subset_knows_Spy_Says</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>contra_subsetD</span><span class="delimiter">]</span><span>
</span><span>       </span><span>knows_Spy_subset_knows_Spy_Notes</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>contra_subsetD</span><span class="delimiter">]</span><span>
</span><span>       </span><span>knows_Spy_subset_knows_Spy_Gets</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>contra_subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_subset_knows_Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs ⊆ knows A (e # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>e</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>knows_Cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>initState_subset_knows</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initState A ⊆ knows A evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>evs</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>knows_subset_knows_Cons</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For proving ‹new_keys_not_used››</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_parts_insert</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| K ∈ keysFor (parts (insert X G));  X ∈ synth (analz H) |] 
      ==&gt; K ∈ keysFor (parts (G ∪ H)) | Key (invKey K) ∈ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> 
</span><span>    </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>parts_insert_subset_Un</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>keysFor_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span>
</span><span>           </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>keysFor_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span> </span><span>parts_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_impI</span><span> </span><span class="delimiter">=</span><span> </span><span>impI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ∉ analz (knows Spy evs)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Y</span><span> </span><span>evs</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‹
fun analz_mono_contra_tac ctxt =
  resolve_tac ctxt @{thms analz_impI} THEN' 
  REPEAT1 o (dresolve_tac ctxt @{thms analz_mono_contra})
  THEN' mp_tac ctxt
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>analz_mono_contra</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (fn ctxt =&gt; SIMPLE_METHOD (REPEAT_FIRST (analz_mono_contra_tac ctxt)))›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving theorems of the form X ∉ analz (knows Spy evs) --&gt; P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Useful for case analysis on whether a hash is a spoof or not›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>syan_impI</span><span> </span><span class="delimiter">=</span><span> </span><span>impI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ∉ synth (analz (knows Spy evs))"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Y</span><span> </span><span>evs</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‹
fun synth_analz_mono_contra_tac ctxt =
  resolve_tac ctxt @{thms syan_impI} THEN'
  REPEAT1 o 
    (dresolve_tac ctxt 
     [@{thm knows_Spy_subset_knows_Spy_Says} RS @{thm synth_analz_mono} RS @{thm contra_subsetD},
      @{thm knows_Spy_subset_knows_Spy_Notes} RS @{thm synth_analz_mono} RS @{thm contra_subsetD},
      @{thm knows_Spy_subset_knows_Spy_Gets} RS @{thm synth_analz_mono} RS @{thm contra_subsetD}])
  THEN'
  mp_tac ctxt
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>synth_analz_mono_contra</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (fn ctxt =&gt; SIMPLE_METHOD (REPEAT_FIRST (synth_analz_mono_contra_tac ctxt)))›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving theorems of the form X ∉ synth (analz (knows Spy evs)) --&gt; P"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="Public">
<div class="head"><h1>Theory Public</h1>
<span class="command">theory</span> <span class="name">Public</span><br/>
<span class="keyword">imports</span> <a href="Event.html"><span class="name">Event</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      HOL/Auth/Public.thy
    Author:     Lawrence C Paulson, Cambridge University Computer Laboratory
    Copyright   1996  University of Cambridge*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Theory of Cryptographic Keys for Security Protocols against Dolev-Yao›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Public</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Event</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invKey_K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K ∈ symKeys ==&gt; invKey K = K"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Asymmetric Keys›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>keymode</span><span> </span><span class="delimiter">=</span><span> </span><span>Signature</span><span> </span><span class="delimiter">|</span><span> </span><span>Encryption</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span>  </span><span>publicKey</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[keymode,agent] =&gt; key"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>pubEK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pubEK == publicKey Encryption"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>pubSK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pubSK == publicKey Signature"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>privateKey</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[keymode, agent] =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"privateKey b A == invKey (publicKey b A)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*BEWARE!! priEK, priSK DON'T WORK with inj, range, image, etc.*)</span></span></span></span></span><span>
</span><span>  </span><span>priEK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"priEK A == privateKey Encryption A"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>priSK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"priSK A == privateKey Signature A"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹These abbreviations give backward compatibility.  They represent the
simple situation where the signature and encryption keys are the same.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>pubK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pubK A == pubEK A"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>priK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"priK A == invKey (pubEK A)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹By freeness of agents, no two agents have the same key.  Since
  @{term "True≠False"}, no agent has identical signing and encryption keys›</span></span></span><span>
</span><span class="keyword1"><span class="command">specification</span></span><span> </span><span class="delimiter">(</span><span>publicKey</span><span class="delimiter">)</span><span>
</span><span>  </span><span>injective_publicKey</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"publicKey b A = publicKey c A' ==&gt; b=c ∧ A=A'"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> 
</span><span>       </span><span class="string"><span class="delete"><span class="delete">"%b A. 2 * case_agent 0 (λn. n + 2) 1 A + case_keymode 0 1 b"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>agent.split</span><span> </span><span>keymode.split</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>presburger</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>presburger</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>                       
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*No private key equals any public key (essential to ensure that private
    keys are private!) *)</span></span></span></span></span><span>
</span><span>  </span><span>privateKey_neq_publicKey</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"privateKey b A ≠ publicKey c A'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>publicKey_neq_privateKey</span><span> </span><span class="delimiter">=</span><span> </span><span>privateKey_neq_publicKey</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>publicKey_neq_privateKey</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Basic properties of @{term pubK} and @{term priK}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_inject</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(publicKey b A = publicKey c A') = (b=c ∧ A=A')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>injective_publicKey</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_symKeys_pubK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"publicKey b A ∉ symKeys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_symKeys_priK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"privateKey b A ∉ symKeys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symKey_neq_priEK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K ∈ symKeys ==&gt; K ≠ priEK A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symKeys_neq_imp_neq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(K ∈ symKeys) ≠ (K' ∈ symKeys) ==&gt; K ≠ K'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symKeys_invKey_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(invKey K ∈ symKeys) = (K ∈ symKeys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>symKeys_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_symKeys_Decrypt</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Crypt K X ∈ analz H;  K ∈ symKeys;  Key K ∈ analz H |]  
      ==&gt; X ∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹"Image" equations that hold for injective functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invKey_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(invKey x ∈ invKey`A) = (x ∈ A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*holds because invKey is injective*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(publicKey b x ∈ publicKey c ` AA) = (b=c ∧ x ∈ AA)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>privateKey_notin_image_publicKey</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"privateKey b x ∉ publicKey c ` AA"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>privateKey_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(privateKey b A ∈ invKey ` publicKey c ` AS) = (b=c ∧ A∈AS)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_notin_image_privateKey</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"publicKey b A ∉ invKey ` publicKey c ` AS"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Symmetric Keys›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For some protocols, it is convenient to equip agents with symmetric as
well as asymmetric keys.  The theory ‹Shared› assumes that all keys
are symmetric.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span>  </span><span>shrK</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span>    </span><span class="comment">― ‹long-term shared keys›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">specification</span></span><span> </span><span class="delimiter">(</span><span>shrK</span><span class="delimiter">)</span><span>
</span><span>  </span><span>inj_shrK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj shrK"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹No two agents have the same long-term key›</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"case_agent 0 (λn. n + 2) 1"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>agent.split</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>sym_shrK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shrK X ∈ symKeys"</span></span></span><span> </span><span class="comment">― ‹All shared keys are symmetric›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Injectiveness: Agents' long-term keys are distinct.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>shrK_injective</span><span> </span><span class="delimiter">=</span><span> </span><span>inj_shrK</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>inj_eq</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>shrK_injective</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invKey_shrK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invKey (shrK A) = shrK A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invKey_K</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_shrK_Decrypt</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Crypt (shrK A) X ∈ analz H; Key(shrK A) ∈ analz H |] ==&gt; X ∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_Decrypt'</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Crypt K X ∈ analz H; K ∈ symKeys; Key K ∈ analz H |] ==&gt; X ∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invKey_K</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>priK_neq_shrK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shrK A ≠ privateKey b C"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_neq_imp_neq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>shrK_neq_priK</span><span> </span><span class="delimiter">=</span><span> </span><span>priK_neq_shrK</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>shrK_neq_priK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pubK_neq_shrK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shrK A ≠ publicKey b C"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_neq_imp_neq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>shrK_neq_pubK</span><span> </span><span class="delimiter">=</span><span> </span><span>pubK_neq_shrK</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>shrK_neq_pubK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>priEK_noteq_shrK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"priEK A ≠ shrK B"</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_notin_image_shrK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"publicKey b x ∉ shrK ` AA"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>privateKey_notin_image_shrK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"privateKey b x ∉ shrK ` AA"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_notin_image_publicKey</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shrK x ∉ publicKey b ` AA"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_notin_image_privateKey</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shrK x ∉ invKey ` publicKey b ` AA"</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(shrK x ∈ shrK ` AA) = (x ∈ AA)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For some reason, moving this up can make some proofs loop!›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>invKey_K</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Initial States of Agents›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Note: for all practical purposes, all that matters is the initial
knowledge of the Spy.  All other agents are automata, merely following the
protocol.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">overloading</span></span><span>
</span><span>  </span><span>initState</span><span> </span><span class="delimiter">≡</span><span> </span><span>initState</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>initState</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Agents know their private key and all public keys*)</span></span></span></span></span><span>
</span><span>  </span><span>initState_Server</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"initState Server     =    
       {Key (priEK Server), Key (priSK Server)} ∪ 
       (Key ` range pubEK) ∪ (Key ` range pubSK) ∪ (Key ` range shrK)"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>initState_Friend</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"initState (Friend i) =    
       {Key (priEK(Friend i)), Key (priSK(Friend i)), Key (shrK(Friend i))} ∪ 
       (Key ` range pubEK) ∪ (Key ` range pubSK)"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>initState_Spy</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"initState Spy        =    
       (Key ` invKey ` pubEK ` bad) ∪ (Key ` invKey ` pubSK ` bad) ∪ 
       (Key ` shrK ` bad) ∪ 
       (Key ` range pubEK) ∪ (Key ` range pubSK)"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹These lemmas allow reasoning about @{term "used evs"} rather than
   @{term "knows Spy evs"}, which is useful when there are private Notes. 
   Because they depend upon the definition of @{term initState}, they cannot
   be moved up.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>used_parts_subset_parts</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"∀X ∈ used evs. parts {X} ⊆ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>evs</span><span class="delimiter">)</span><span> 
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>used_Cons</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_iff</span><span> </span><span>empty_subsetI</span><span> </span><span>insert_subset</span><span> </span><span>le_supI1</span><span> </span><span>le_supI2</span><span> </span><span>parts_subset_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Base case›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>parts_cut</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>used_Nil</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_used_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄ ∈ used H ==&gt; X ∈ used H ∧ Y ∈ used H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>used_parts_subset_parts</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹There was a similar theorem in Event.thy, so perhaps this one can
  be moved up if proved directly by induction.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_used</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| ⦃X,Y⦄ ∈ used H;
         [| X ∈ used H; Y ∈ used H |] ==&gt; P |] 
      ==&gt; P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>MPair_used_D</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Rewrites should not refer to  @{term "initState(Friend i)"} because
  that expression is not in normal form.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_parts_initState</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (parts (initState C)) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"C"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>range_eqI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_notin_initState</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∉ parts (initState B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>B</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_notin_used_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∉ used []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Crypt_notin_initState</span><span> </span><span>used_Nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*** Basic properties of shrK ***)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Agents see their own shared keys!*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_in_initState</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (shrK A) ∈ initState A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"A"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_in_knows</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (shrK A) ∈ knows A evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>initState_subset_knows</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_in_used</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (shrK A) ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>initState_into_used</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** Fresh keys never clash with long-term shared keys **)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Used in parts_induct_tac and analz_Fake_tac to distinguish session keys
  from long-term shared keys*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Key_not_used</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K ∉ used evs ==&gt; K ∉ range shrK"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_neq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K ∉ used evs ==&gt; shrK B ≠ K"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>neq_shrK</span><span> </span><span class="delimiter">=</span><span> </span><span>shrK_neq</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>neq_shrK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Function @{term "knows Spy"}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_SignatureE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ Signature ⟹ b = Encryption"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Agents see their own private keys!›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>priK_in_initState</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (privateKey b A) ∈ initState A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Agents see all public keys!›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_in_initState</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (publicKey b A) ∈ initState B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>B</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹All public keys are visible›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>spies_pubK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (publicKey b A) ∈ spies evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>imageI</span><span> </span><span>knows_Cons</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_spies_pubK</span><span> </span><span class="delimiter">=</span><span> </span><span>spies_pubK</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz.Inj</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>analz_spies_pubK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Spy sees private keys of bad agents!›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Spy_spies_bad_privateKey</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"A ∈ bad ==&gt; Key (privateKey b A) ∈ spies evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>imageI</span><span> </span><span>knows_Cons</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Spy sees long-term shared keys of bad agents!›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Spy_spies_bad_shrK</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"A ∈ bad ==&gt; Key (shrK A) ∈ spies evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>imageI</span><span> </span><span>knows_Cons</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_into_used</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Key (publicKey b A) ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>initState_into_used</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>publicKey_in_initState</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>privateKey_into_used</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (privateKey b A) ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>initState_into_used</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>priK_in_initState</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*For case analysis on whether or not an agent is compromised*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_Spy_analz_bad</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Crypt (shrK A) X ∈ analz (knows Spy evs);  A ∈ bad |]  
      ==&gt; X ∈ analz (knows Spy evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Fresh Nonces›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_notin_initState</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce N ∉ parts (initState B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"B"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_notin_used_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce N ∉ used []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>used_Nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Supply fresh nonces for possibility theorems›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In any trace, there is an upper bound N on the greatest nonce in use›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_supply_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃N. ∀n. N≤n --&gt; Nonce n ∉ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>0</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>used_Cons</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>msg_Nonce_supply</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>exE</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>add_leE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_supply1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃N. Nonce N ∉ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Nonce_supply_lemma</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>exE</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_supply</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce (SOME N. Nonce N ∉ used evs) ∉ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Nonce_supply_lemma</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>exE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>someI</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Specialized Rewriting for Theorems About @{term analz} and Image›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_Key_singleton</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert (Key K) H = Key ` {K} ∪ H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_Key_image</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert (Key K) (Key`KK ∪ C) = Key ` (insert K KK) ∪ C"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_imp_keysFor</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"[|Crypt K X ∈ H; K ∈ symKeys|] ==&gt; K ∈ keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Crypt_imp_invKey_keysFor</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma for the trivial direction of the if-and-only-if of the 
Session Key Compromise Theorem›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_image_freshK_lemma</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(Key K ∈ analz (Key`nE ∪ H)) --&gt; (K ∈ nE | Key K ∈ analz H)  ==&gt;  
         (Key K ∈ analz (Key`nE ∪ H)) = (K ∈ nE | Key K ∈ analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_image_freshK_simps</span><span> </span><span class="delimiter">=</span><span>
</span><span>       </span><span>simp_thms</span><span> </span><span>mem_simps</span><span> </span><span class="comment">― ‹these two allow its use with @{text "only:"}›</span><span>
</span><span>       </span><span>disj_comms</span><span> 
</span><span>       </span><span>image_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span> </span><span>image_Un</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span> </span><span>empty_subsetI</span><span> </span><span>insert_subset</span><span>
</span><span>       </span><span>analz_insert_eq</span><span> </span><span>Un_upper2</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span>
</span><span>       </span><span>insert_Key_singleton</span><span> 
</span><span>       </span><span>Key_not_used</span><span> </span><span>insert_Key_image</span><span> </span><span>Un_assoc</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
structure Public =
struct

val analz_image_freshK_ss =
  simpset_of (@{context}
    delsimps [image_insert, image_Un]
    delsimps [@{thm imp_disjL}]    (*reduces blow-up*)
    addsimps @{thms analz_image_freshK_simps})

(*Tactic for possibility theorems*)
fun possibility_tac ctxt =
    REPEAT (*omit used_Says so that Nonces start from different traces!*)
    (ALLGOALS (simp_tac (ctxt setSolver safe_solver delsimps [@{thm used_Says}]))
     THEN
     REPEAT_FIRST (eq_assume_tac ORELSE' 
                   resolve_tac ctxt [refl, conjI, @{thm Nonce_supply}]))

(*For harder protocols (such as Recur) where we have to set up some
  nonces and keys initially*)
fun basic_possibility_tac ctxt =
    REPEAT 
    (ALLGOALS (asm_simp_tac (ctxt setSolver safe_solver))
     THEN
     REPEAT_FIRST (resolve_tac ctxt [refl, conjI]))

end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>analz_freshK</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (fn ctxt =&gt;
     (SIMPLE_METHOD
      (EVERY [REPEAT_FIRST (resolve_tac ctxt [allI, ballI, impI]),
          REPEAT_FIRST (resolve_tac ctxt @{thms analz_image_freshK_lemma}),
          ALLGOALS (asm_simp_tac (put_simpset Public.analz_image_freshK_ss ctxt))])))›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving the Session Key Compromise theorem"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Specialized Methods for Possibility Theorems›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>possibility</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (SIMPLE_METHOD o Public.possibility_tac)›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving possibility theorems"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>basic_possibility</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (SIMPLE_METHOD o Public.basic_possibility_tac)›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving possibility theorems"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="NS_Public_Bad">
<div class="head"><h1>Theory NS_Public_Bad</h1>
<span class="command">theory</span> <span class="name">NS_Public_Bad</span><br/>
<span class="keyword">imports</span> <a href="Public.html"><span class="name">Public</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The Needham-Schroeder Public-Key Protocol against Dolev-Yao --- with Gets event, hence with Reception rule›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NS_Public_Bad</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Public</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>ns_public</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>         </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Initial trace is empty*)</span></span></span></span></span><span>
</span><span>   </span><span>Nil</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"[] ∈ ns_public"</span></span></span><span>
</span><span>
</span><span>         </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*The spy MAY say anything he CAN say.  We do not expect him to
           invent new nonces here, but he can also use NS1.  Common to
           all similar protocols.*)</span></span></span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>Fake</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦evsf ∈ ns_public;  X ∈ synth (analz (knows Spy evsf))⟧
          ⟹ Says Spy B X  # evsf ∈ ns_public"</span></span></span><span>
</span><span>
</span><span>         </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*A message that is sent may be received*)</span></span></span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>Reception</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦evsr ∈ ns_public; Says A B X ∈ set evsr⟧
                ⟹ Gets B X # evsr ∈ ns_public"</span></span></span><span>
</span><span>
</span><span>         </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Alice initiates a protocol run, sending a nonce to Bob*)</span></span></span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>NS1</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦evs1 ∈ ns_public;  Nonce NA ∉ used evs1⟧
          ⟹ Says A B (Crypt (pubEK B) ⦃Nonce NA, Agent A⦄)
                # evs1  ∈  ns_public"</span></span></span><span>
</span><span>
</span><span>         </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Bob responds to Alice's message with a further nonce*)</span></span></span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>NS2</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦evs2 ∈ ns_public;  Nonce NB ∉ used evs2;
           Gets B (Crypt (pubEK B) ⦃Nonce NA, Agent A⦄) ∈ set evs2⟧
          ⟹ Says B A (Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄)
                # evs2  ∈  ns_public"</span></span></span><span>
</span><span>
</span><span>         </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Alice proves her existence by sending NB back to Bob.*)</span></span></span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>NS3</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦evs3 ∈ ns_public;
           Says A  B (Crypt (pubEK B) ⦃Nonce NA, Agent A⦄) ∈ set evs3;
           Gets A (Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄) ∈ set evs3⟧
          ⟹ Says A B (Crypt (pubEK B) (Nonce NB)) # evs3 ∈ ns_public"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>knows_Spy_partsEs</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>knows_Spy_partsEs</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>analz_into_parts</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Fake_parts_insert_in_Un</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*A "possibility property": there are traces that reach the end*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∃NB. ∃evs ∈ ns_public. Says A B (Crypt (pubEK B) (Nonce NB)) ∈ set evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>exI</span><span> </span><span>bexI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>ns_public.Nil</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>ns_public.NS1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ns_public.Reception</span><span class="delimiter">,</span><span> 
</span><span>                                   </span><span>THEN</span><span> </span><span>ns_public.NS2</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>ns_public.Reception</span><span class="delimiter">,</span><span> 
</span><span>                                   </span><span>THEN</span><span> </span><span>ns_public.NS3</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>possibility</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Lemmas about reception invariant: if a message is received it certainly
was sent›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Gets_imp_Says</span><span> </span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⟦ Gets B X ∈ set evs; evs ∈ ns_public ⟧ ⟹ ∃A. Says A B X ∈ set evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Gets_imp_knows_Spy</span><span class="delimiter">:</span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⟦ Gets B X ∈ set evs; evs ∈ ns_public ⟧  ⟹ X ∈ knows Spy evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>Gets_imp_Says</span><span> </span><span>Says_imp_knows_Spy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Gets_imp_knows_Spy_parts</span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"⟦ Gets B X ∈ set evs; evs ∈ ns_public ⟧  ⟹ X ∈ parts (knows Spy evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Gets_imp_knows_Spy</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(**** Inductive proofs about ns_public ****)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** Theorems of the form X ∉ parts (knows Spy evs) imply that NOBODY
    sends messages containing X! **)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Spy never sees another agent's private key! (unless it's bad at start)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Spy_see_priEK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"evs ∈ ns_public ⟹ (Key (priEK A) ∈ parts (knows Spy evs)) = (A ∈ bad)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Spy_analz_priEK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"evs ∈ ns_public ⟹ (Key (priEK A) ∈ analz (knows Spy evs)) = (A ∈ bad)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*** Authenticity properties obtained from NS2 ***)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*It is impossible to re-use a nonce in both NS1 and NS2, provided the nonce
  is secret.  (Honest users generate fresh nonces.)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_nonce_NS1_NS2</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"evs ∈ ns_public 
       ⟹ Crypt (pubEK C) ⦃NA', Nonce NA⦄ ∈ parts (knows Spy evs) ⟶
           Crypt (pubEK B) ⦃Nonce NA, Agent A⦄ ∈ parts (knows Spy evs) ⟶  
           Nonce NA ∈ analz (knows Spy evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_insertI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Unicity for NS1: nonce NA identifies agents A and B*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unique_NA</span><span class="delimiter">:</span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⟦Crypt(pubEK B)  ⦃Nonce NA, Agent A ⦄ ∈ parts(knows Spy evs);  
       Crypt(pubEK B') ⦃Nonce NA, Agent A'⦄ ∈ parts(knows Spy evs);  
       Nonce NA ∉ analz (knows Spy evs); evs ∈ ns_public⟧
      ⟹ A=A' ∧ B=B'"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>   
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Fake, NS1*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>analz_insertI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Secrecy: Spy does not see the nonce sent in msg NS1 if A and B are secure
  The major premise "Says A B ..." makes it a dest-rule, so we use
  (erule rev_mp) rather than rule_format. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Spy_not_see_NA</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"⟦Says A B (Crypt(pubEK B) ⦃Nonce NA, Agent A⦄) ∈ set evs;
        A ∉ bad;  B ∉ bad;  evs ∈ ns_public⟧                     
       ⟹ Nonce NA ∉ analz (knows Spy evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>   
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>spy_analz</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>unique_NA</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>no_nonce_NS1_NS2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Authentication for A: if she receives message 2 and has used NA
  to start a run, then B has sent message 2.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>A_trusts_NS2_lemma</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">"⟦A ∉ bad;  B ∉ bad;  evs ∈ ns_public⟧                     
    ⟹ Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄ ∈ parts (knows Spy evs) ⟶
        Says A B (Crypt(pubEK B) ⦃Nonce NA, Agent A⦄) ∈ set evs ⟶
        Says B A (Crypt(pubEK A) ⦃Nonce NA, Nonce NB⦄) ∈ set evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Spy_not_see_NA</span><span> </span><span>unique_NA</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>A_trusts_NS2</span><span class="delimiter">:</span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⟦Says A  B (Crypt(pubEK B) ⦃Nonce NA, Agent A⦄) ∈ set evs;   
       Gets A (Crypt(pubEK A) ⦃Nonce NA, Nonce NB⦄) ∈ set evs;
       A ∉ bad;  B ∉ bad;  evs ∈ ns_public⟧                     
      ⟹ Says B A (Crypt(pubEK A) ⦃Nonce NA, Nonce NB⦄) ∈ set evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>A_trusts_NS2_lemma</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*If the encrypted message appears then it originated with Alice in NS1*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B_trusts_NS1</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"evs ∈ ns_public                                         
      ⟹ Crypt (pubEK B) ⦃Nonce NA, Agent A⦄ ∈ parts (knows Spy evs) ⟶
          Nonce NA ∉ analz (knows Spy evs) ⟶
          Says A B (Crypt (pubEK B) ⦃Nonce NA, Agent A⦄) ∈ set evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Fake*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>analz_insertI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*** Authenticity properties obtained from NS2 ***)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Unicity for NS2: nonce NB identifies nonce NA and agent A
  [proof closely follows that for unique_NA] *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>unique_NB</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⟦Crypt(pubEK A)  ⦃Nonce NA, Nonce NB⦄ ∈ parts(knows Spy evs);
       Crypt(pubEK A') ⦃Nonce NA', Nonce NB⦄ ∈ parts(knows Spy evs);
       Nonce NB ∉ analz (knows Spy evs); evs ∈ ns_public⟧
     ⟹ A=A' ∧ NA=NA'"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>   
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Fake, NS2*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>analz_insertI</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NB remains secret PROVIDED Alice never responds with round 3*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Spy_not_see_NB</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⟦Says B A (Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄) ∈ set evs;   
       ∀C. Says A C (Crypt (pubEK C) (Nonce NB)) ∉ set evs;       
       A ∉ bad;  B ∉ bad;  evs ∈ ns_public⟧                      
     ⟹ Nonce NB ∉ analz (knows Spy evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>spy_analz</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*speeds up the next step*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>no_nonce_NS1_NS2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Authentication for B: if he receives message 3 and has used NB
  in message 2, then A has sent message 3--to somebody....*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>B_trusts_NS3_lemma</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⟦A ∉ bad;  B ∉ bad;  evs ∈ ns_public⟧                    
      ⟹ Crypt (pubEK B) (Nonce NB) ∈ parts (knows Spy evs) ⟶
          Says B A  (Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄) ∈ set evs ⟶
          (∃C. Says A C (Crypt (pubEK C) (Nonce NB)) ∈ set evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>no_nonce_NS1_NS2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>B_trusts_NS3</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⟦Says B A  (Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄) ∈ set evs;
       Gets B (Crypt (pubEK B) (Nonce NB)) ∈ set evs;             
       A ∉ bad;  B ∉ bad;  evs ∈ ns_public⟧                    
      ⟹ ∃C. Says A C (Crypt (pubEK C) (Nonce NB)) ∈ set evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>B_trusts_NS3_lemma</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Can we strengthen the secrecy theorem Spy_not_see_NB?  NO*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦A ∉ bad;  B ∉ bad;  evs ∈ ns_public⟧            
       ⟹ Says B A (Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄) ∈ set evs  
           ⟶ Nonce NB ∉ analz (knows Spy evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">,</span><span> </span><span>spy_analz</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NS1: by freshness*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NS2: by freshness and unicity of NB*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>no_nonce_NS1_NS2</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NS3: unicity of NB identifies A and NA, but not B*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule_tac</span><span> </span><span>A'</span><span> </span><span class="delimiter">=</span><span> </span><span>A</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> 
</span><span>       </span><span>Says_imp_knows_Spy</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>unique_NB</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>evs3</span><span> </span><span>B'</span><span> </span><span>C</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This is the attack!
@{subgoals[display,indent=0,margin=65]}
›</span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="ConfidentialityDY">
<div class="head"><h1>Theory ConfidentialityDY</h1>
<span class="command">theory</span> <span class="name">ConfidentialityDY</span><br/>
<span class="keyword">imports</span> <a href="NS_Public_Bad.html"><span class="name">NS_Public_Bad</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive Study of Confidentiality against Dolev-Yao›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>ConfidentialityDY</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>NS_Public_Bad</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Existing study - fully spelled out›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In order not to leave hidden anything of the line of reasoning, we cancel some relevant lemmas that were installed previously›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>Spy_see_priEK</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>        </span><span>Spy_analz_priEK</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>        </span><span>analz_into_parts</span><span> </span><span class="delimiter">[</span><span>rule</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>        
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹On static secrets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Spy_see_priEK</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"evs ∈ ns_public ⟹ (Key (priEK A) ∈ parts (spies evs)) = (A ∈ bad)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Fake: screenshot1*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A:bad"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>ccontr</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply (rule ccontr) apply simp*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Spy knows bad agents' keys since start*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*screenshot2*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>Fake_parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Fake_parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*screenshot3*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz_into_parts</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Spy_analz_priEK</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">"evs ∈ ns_public ⟹ (Key (priEK A) ∈ analz (spies evs)) = (A ∈ bad)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply (auto simp: Spy_see_priEK dest: analz_into_parts)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Nil*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>analz_image_freshK_simps</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>analz_image_freshK_simps</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Fake*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*apply spy_analz would close, alternatively:*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A:bad"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Spy knows bad agents' keys since start*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Fake_analz_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹On dynamic secrets›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Spy_not_see_NA</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"⟦Says A B (Crypt(pubEK B) ⦃Nonce NA, Agent A⦄) ∈ set evs;
  A ∉ bad;  B ∉ bad;  evs ∈ ns_public⟧                     
  ⟹ Nonce NA ∉ analz (spies evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Spy_analz_priEK</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*screenshot1*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>conjI</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*screenshot2*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Fake_analz_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*screenshot3*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>unique_NA</span><span> </span><span>analz_into_parts</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>no_nonce_NS1_NS2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Spy_not_see_NB</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦Says B A (Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄) ∈ set evs;   
 ∀C. Says A C (Crypt (pubEK C) (Nonce NB)) ∉ set evs;      
 A ∉ bad;  B ∉ bad;  evs ∈ ns_public⟧                      
 ⟹ Nonce NB ∉ analz (spies evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Spy_analz_priEK</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹apply @{term spy_analz}  
   is replaced here with the following list...›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ccontr</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Fake_analz_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹...of commands!›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>all_conj_distrib</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹speeds up next›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz_into_parts</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>no_nonce_NS1_NS2</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Novel study›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Generalising over all initial secrets the existing treatment, which is limited to private encryption keys›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>staticSecret</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent ⇒ msg set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"staticSecret A ≡ {Key (priEK A), Key (priSK A), Key (shrK A)}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Protocol independent study›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Converse doesn't hold because something that is said or noted is not necessarily an initial secret›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>staticSecret_parts_Spy</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ parts (knows Spy evs); m ∈ staticSecret A⟧  ⟹
 A ∈ bad ∨
 (∃C B X. Says C B X ∈ set evs ∧ m ∈ parts{X}) ∨
 (∃C Y. Notes C Y ∈ set evs ∧ C ∈ bad ∧ m ∈ parts{Y})"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Says›</span></span></span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Gets›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Notes›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>agent</span><span> </span><span>msg</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent∉bad"</span></span></span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>staticSecret_analz_Spy</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ analz (knows Spy evs); m ∈ staticSecret A⟧  ⟹
 A ∈ bad ∨
 (∃C B X. Says C B X ∈ set evs ∧ m ∈ parts{X}) ∨
 (∃C Y. Notes C Y ∈ set evs ∧ C ∈ bad ∧ m ∈ parts{Y})"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>analz_into_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>staticSecret_parts_Spy</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>secret_parts_Spy</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ parts (knows Spy evs)  ⟹
 m ∈ initState Spy ∨
 (∃C B X. Says C B X ∈ set evs ∧ m ∈ parts{X}) ∨
 (∃C Y. Notes C Y ∈ set evs ∧ C ∈ bad ∧ m ∈ parts{Y})"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Says›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>initState_Spy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>Un_iff</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Gets›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Notes›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>initState_Spy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>agent</span><span> </span><span>msg</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent∉bad"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>initState_Spy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>del</span><span class="delimiter">:</span><span> </span><span>initState_Spy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>secret_parts_Spy_converse</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">" m ∈ initState Spy ∨
 (∃C B X. Says C B X ∈ set evs ∧ m ∈ parts{X}) ∨
 (∃C Y. Notes C Y ∈ set evs ∧ C ∈ bad ∧ m ∈ parts{Y})
 ⟹ m ∈ parts(knows Spy evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Says_imp_knows_Spy</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">]</span><span> </span><span>parts_trans</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>Notes_imp_knows_Spy</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">]</span><span> </span><span>parts_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>secret_analz_Spy</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ analz (knows Spy evs)  ⟹
 m ∈ initState Spy ∨
 (∃C B X. Says C B X ∈ set evs ∧ m ∈ parts{X}) ∨
 (∃C Y. Notes C Y ∈ set evs ∧ C ∈ bad ∧ m ∈ parts{Y})"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz_into_parts</span><span> </span><span>secret_parts_Spy</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Protocol-dependent study›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Proving generalised version of @{thm Spy_see_priEK} using same strategy, the "direct" strategy›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_Spy_see_staticSecret</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ staticSecret A; evs ∈ ns_public⟧ ⟹
   m ∈ parts(knows Spy evs) = (A ∈ bad)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A:bad"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Spy knows bad agents' keys since start*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Fake_parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1,goals_limit=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz_into_parts</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Seeking a proof of @{thm NS_Spy_see_staticSecret} using an alternative, "specialisation" strategy›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_no_Notes</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs ∈ ns_public ⟹ Notes A X ∉ set evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_staticSecret_parts_Spy_weak</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ parts (knows Spy evs); m ∈ staticSecret A;
  evs ∈ ns_public⟧ ⟹ A ∈ bad ∨
 (∃C B X. Says C B X ∈ set evs ∧ m ∈ parts{X})"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>staticSecret_parts_Spy</span><span> </span><span>NS_no_Notes</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_Says_staticSecret</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Says A B X ∈ set evs; m ∈ staticSecret C; m ∈ parts{X};
   evs ∈ ns_public⟧ ⟹ A=Spy"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This generalises @{thm Key_synth_eq}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>staticSecret_synth_eq</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"m ∈ staticSecret A ⟹ (m ∈ synth H) = (m ∈ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_Says_Spy_staticSecret</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦Says Spy B X ∈ set evs; m ∈ parts{X};
   m ∈ staticSecret A; evs ∈ ns_public⟧ ⟹ A ∈ bad"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
txt{*Alternative start to appreciate that it reduces to @{thm NS_Spy_see_staticSecret}*}
apply (erule rev_mp, erule ns_public.induct)
apply (simp_all del: staticSecret_def)
apply clarify 
txt{*@{subgoals [display,indent=1,goals_limit=1]}*}
apply (drule Fake_parts_sing [THEN subsetD], simp) 
txt{*@{subgoals [display,indent=1,goals_limit=1]}*}
apply (simp del: staticSecret_def add: staticSecret_synth_eq)
txt{*@{subgoals [display,indent=1,goals_limit=1]}*}
oops 
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Says_imp_knows_Spy</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1,goals_limit=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_trans</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rotate_tac</span><span> </span><span>-</span><span>1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1,goals_limit=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"A:bad"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Spy knows bad agents' keys since start*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Fake_parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz_into_parts</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Here's the specialised version of @{thm staticSecret_parts_Spy}›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_staticSecret_parts_Spy</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ parts (knows Spy evs); m ∈ staticSecret A;
  evs ∈ ns_public⟧ ⟹ A ∈ bad"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>staticSecret_parts_Spy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals  [display,indent=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Case A bad*)</span></span></span></span></span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Case: Says*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals  [display,indent=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"C=Spy"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>NS_Says_Spy_staticSecret</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>NS_Says_staticSecret</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>NS_no_Notes</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Concluding the specialisation proof strategy...›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_Spy_see_staticSecret_spec</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ staticSecret A; evs ∈ ns_public⟧ ⟹
 m ∈ parts (knows Spy evs) = (A ∈ bad)"</span></span></span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹one line proof:
apply (force dest: @{term NS_staticSecret_parts_Spy})
›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>NS_staticSecret_parts_Spy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹one line proof: force›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>b</span><span class="delimiter">=</span><span>Encryption</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>evs</span><span class="delimiter">=</span><span>evs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Spy_spies_bad_privateKey</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts.Inj</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>b</span><span class="delimiter">=</span><span>Signature</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>evs</span><span class="delimiter">=</span><span>evs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Spy_spies_bad_privateKey</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts.Inj</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>evs</span><span class="delimiter">=</span><span>evs</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Spy_spies_bad_shrK</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts.Inj</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_Spy_analz_staticSecret</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ staticSecret A; evs ∈ ns_public⟧ ⟹
 m ∈ analz (knows Spy evs) = (A ∈ bad)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz_into_parts</span><span> </span><span>NS_staticSecret_parts_Spy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_staticSecret_subset_parts_knows_Spy</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"evs ∈ ns_public ⟹
 staticSecret A ⊆ parts (knows Spy evs) = (A ∈ bad)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>NS_staticSecret_parts_Spy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_staticSecret_subset_analz_knows_Spy</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"evs ∈ ns_public ⟹
 staticSecret A ⊆ analz (knows Spy evs) = (A ∈ bad)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz_into_parts</span><span> </span><span>NS_staticSecret_parts_Spy</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span></pre>
</div>
</div><div id="MessageGA">
<div class="head"><h1>Theory MessageGA</h1>
<span class="command">theory</span> <span class="name">MessageGA</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Theory of Agents and Messages for Security Protocols against the General Attacker›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>MessageGA</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>Main</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Needed occasionally with spy_analz_tac, e.g. in analz_insert_Key_newK*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A ∪ (B ∪ A) = B ∪ A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span>
</span><span>  </span><span>key</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span>  </span><span>all_symmetric</span><span> </span><span class="delimiter">::</span><span> </span><span>bool</span><span>        </span><span class="comment">― ‹true if all keys are symmetric›</span><span>
</span><span>  </span><span>invKey</span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"key=&gt;key"</span></span></span><span>  </span><span class="comment">― ‹inverse of a symmetric key›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">specification</span></span><span> </span><span class="delimiter">(</span><span>invKey</span><span class="delimiter">)</span><span>
</span><span>  </span><span>invKey</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invKey (invKey K) = K"</span></span></span><span>
</span><span>  </span><span>invKey_symmetric</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"all_symmetric ⟶ invKey = id"</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>id</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The inverse of a symmetric key is itself; that of a public key
      is the private key and vice versa›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>symKeys</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"key set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"symKeys == {K. invKey K = K}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span>  </span><span class="comment">― ‹We only allow for any number of friendly agents›</span><span>
</span><span>  </span><span>agent</span><span> </span><span class="delimiter">=</span><span> </span><span>Friend</span><span> </span><span>nat</span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span>
</span><span>     </span><span>msg</span><span> </span><span class="delimiter">=</span><span> </span><span>Agent</span><span>  </span><span>agent</span><span>     </span><span class="comment">― ‹Agent names›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>Number</span><span> </span><span>nat</span><span>       </span><span class="comment">― ‹Ordinary integers, timestamps, ...›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>Nonce</span><span>  </span><span>nat</span><span>       </span><span class="comment">― ‹Unguessable nonces›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>Key</span><span>    </span><span>key</span><span>       </span><span class="comment">― ‹Crypto keys›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>Hash</span><span>   </span><span>msg</span><span>       </span><span class="comment">― ‹Hashing›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>MPair</span><span>  </span><span>msg</span><span> </span><span>msg</span><span>   </span><span class="comment">― ‹Compound messages›</span><span>
</span><span>         </span><span class="delimiter">|</span><span> </span><span>Crypt</span><span>  </span><span>key</span><span> </span><span>msg</span><span>   </span><span class="comment">― ‹Encryption, public- or shared-key›</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Concrete syntax: messages appear as ‹⦃A,B,NA⦄›, etc...›</span></span></span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_MTuple"</span></span></span><span>      </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"['a, args] =&gt; 'a * 'b"</span></span></span><span>       </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(2⦃_,/ _⦄)"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃x, y, z⦄"</span></span></span><span>   </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃x, ⦃y, z⦄⦄"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃x, y⦄"</span></span></span><span>      </span><span class="delimiter">==</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST MPair x y"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>HPair</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[msg,msg] =&gt; msg"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(4Hash[_] /_)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>1000</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="comment">― ‹Message Y paired with a MAC computed with the help of X›</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"Hash[X] Y == ⦃ Hash⦃X,Y⦄, Y⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>keysFor</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set =&gt; key set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span class="comment">― ‹Keys useful to decrypt elements of a message set›</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"keysFor H == invKey ` {K. ∃X. Crypt K X ∈ H}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive definition of all parts of a message›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>parts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set =&gt; msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>Inj</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>               </span><span class="string"><span class="delete"><span class="delete">"X ∈ H ⟹ X ∈ parts H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Fst</span><span class="delimiter">:</span><span>         </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄   ∈ parts H ⟹ X ∈ parts H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Snd</span><span class="delimiter">:</span><span>         </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄   ∈ parts H ⟹ Y ∈ parts H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Body</span><span class="delimiter">:</span><span>        </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∈ parts H ⟹ X ∈ parts H"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G ⊆ H ⟹ parts(G) ⊆ parts(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>parts.Fst</span><span> </span><span>parts.Snd</span><span> </span><span>parts.Body</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Equations hold because constructors are injective.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Friend_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Friend x ∈ Friend`A) = (x:A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Key_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Key x ∈ Key`A) = (x∈A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_Key_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Nonce x ∉ Key`A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inverse of keys›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invKey_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(invKey K = invKey K') = (K=K')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>invKey</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹keysFor operator›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor {} = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_Un</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (H ∪ H') = keysFor H ∪ keysFor H'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_UN</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (⋃i∈A. H i) = (⋃i∈A. keysFor (H i))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G ⊆ H ⟹ keysFor(G) ⊆ keysFor(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Agent</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Agent A) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Nonce</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Nonce N) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Number</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Number N) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Key K) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Hash</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Hash X) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_MPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert ⦃X,Y⦄ H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_Crypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Crypt K X) H) = insert (invKey K) (keysFor H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_image_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (Key`E) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_imp_invKey_keysFor</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∈ H ⟹ invKey K ∈ keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive relation "parts"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_parts</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| ⦃X,Y⦄ ∈ parts H;        
         [| X ∈ parts H; Y ∈ parts H |] ==&gt; P |] ==&gt; P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>parts.Fst</span><span> </span><span>parts.Snd</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>MPair_parts</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span>  </span><span>parts.Body</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹NB These two rules are UNSAFE in the formal sense, as they discard the
     compound message.  They work well on THIS FILE.  
  ‹MPair_parts› is left as SAFE because it speeds up proofs.
  The Crypt rule is normally kept UNSAFE to avoid breaking up certificates.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_increasing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ⊆ parts(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>parts_insertI</span><span> </span><span class="delimiter">=</span><span> </span><span>subset_insertI</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts{} = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_emptyE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ parts{} ⟹ P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹WARNING: loops if H = {Y}, therefore must not be repeated!›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_singleton</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ parts H ⟹ ∃Y∈H. X∈ parts {Y}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Unions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_Un_subset1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(G) ∪ parts(H) ⊆ parts(G ∪ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Un_least</span><span> </span><span>parts_mono</span><span> </span><span>Un_upper1</span><span> </span><span>Un_upper2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_Un_subset2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(G ∪ H) ⊆ parts(G) ∪ parts(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_Un</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(G ∪ H) = parts(G) ∪ parts(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>parts_Un_subset1</span><span> </span><span>parts_Un_subset2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (insert X H) = parts {X} ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>insert_is_Un</span><span> </span><span>parts_Un</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹TWO inserts to avoid looping.  This rewrite is better than nothing.
  Not suitable for Addsimps: its behaviour can be strange.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert2</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert X (insert Y H)) = parts {X} ∪ parts {Y} ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_commute</span><span> </span><span>Un_empty_right</span><span> </span><span>Un_insert_right</span><span> </span><span>insert_is_Un</span><span> </span><span>parts_Un</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_UN_subset1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(⋃x∈A. parts(H x)) ⊆ parts(⋃x∈A. H x)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>UN_least</span><span> </span><span>parts_mono</span><span> </span><span>UN_upper</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_UN_subset2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(⋃x∈A. H x) ⊆ (⋃x∈A. parts(H x))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_UN</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(⋃x∈A. H x) = (⋃x∈A. parts(H x))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>parts_UN_subset1</span><span> </span><span>parts_UN_subset2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Added to simplify arguments to parts, analz and synth.
  NOTE: the UN versions are no longer used!›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This allows ‹blast› to simplify occurrences of 
  @{term "parts(G∪H)"} in the assumption.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>in_parts_UnE</span><span> </span><span class="delimiter">=</span><span> </span><span>parts_Un</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>UnE</span><span class="delimiter">]</span><span> 
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>in_parts_UnE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert X (parts H) ⊆ parts(insert X H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>parts_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Idempotence and transitivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_partsD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ parts (parts H) ⟹ X∈ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (parts H) = parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_subset_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(parts G ⊆ parts H) = (G ⊆ parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>parts_idem</span><span> </span><span>parts_increasing</span><span> </span><span>parts_mono</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| X ∈ parts G;  G ⊆ parts H |] ==&gt; X∈ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_mono</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cut›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_cut</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Y∈ parts (insert X G);  X ∈ parts H |] ==&gt; Y∈ parts (G ∪ H)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>parts_trans</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_cut_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ parts H ⟹ parts (insert X H) = parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>parts_cut</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>parts_insertI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Rewrite rules for pulling out atomic messages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>parts_insert_eq_I</span><span> </span><span class="delimiter">=</span><span> </span><span>equalityI</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>subsetI</span><span> </span><span>parts_insert_subset</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Agent</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Agent agt) H) = insert (Agent agt) (parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>parts_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Nonce</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Nonce N) H) = insert (Nonce N) (parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>parts_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Number</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Number N) H) = insert (Number N) (parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>parts_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Key K) H) = insert (Key K) (parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>parts_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Hash</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Hash X) H) = insert (Hash X) (parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>parts_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_Crypt</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Crypt K X) H) = insert (Crypt K X) (parts (insert X H))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>parts.Body</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_MPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"parts (insert ⦃X,Y⦄ H) =  
          insert ⦃X,Y⦄ (parts (insert X (insert Y H)))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>parts.Fst</span><span> </span><span>parts.Snd</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_image_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (Key`N) = Key`N"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In any message, there is an upper bound N on its greatest nonce.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>msg_Nonce_supply</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃N. ∀n. N≤n ⟶ Nonce n ∉ parts {msg}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>msg</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exI</span><span> </span><span>parts_insert2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Nonce case›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_n_not_le_n</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹MPair case: metis works out the necessary sum itself!›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>le_trans</span><span> </span><span>nat_le_linear</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive relation "analz"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive definition of "analz" -- what can be broken down from a set of
    messages, including keys.  A form of downward closure.  Pairs can
    be taken apart; messages decrypted with known keys.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>analz</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set =&gt; msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>Inj</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span>    </span><span class="string"><span class="delete"><span class="delete">"X ∈ H ⟹ X ∈ analz H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Fst</span><span class="delimiter">:</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄ ∈ analz H ⟹ X ∈ analz H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Snd</span><span class="delimiter">:</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄ ∈ analz H ⟹ Y ∈ analz H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Decrypt</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>             </span><span class="string"><span class="delete"><span class="delete">"[|Crypt K X ∈ analz H; Key(invKey K): analz H|] ==&gt; X ∈ analz H"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity; Lemma 1 of Lowe's paper›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G⊆H ⟹ analz(G) ⊆ analz(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz.Fst</span><span> </span><span>analz.Snd</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Making it safe speeds up proofs›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_analz</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| ⦃X,Y⦄ ∈ analz H;        
             [| X ∈ analz H; Y ∈ analz H |] ==&gt; P   
          |] ==&gt; P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz.Fst</span><span> </span><span>analz.Snd</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_increasing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ⊆ analz(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_subset_parts</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz H ⊆ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_into_parts</span><span> </span><span class="delimiter">=</span><span> </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>not_parts_not_analz</span><span> </span><span class="delimiter">=</span><span> </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>contra_subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_analz</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (analz H) = parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>analz_increasing</span><span> </span><span>analz_subset_parts</span><span> </span><span>equalityI</span><span> </span><span>parts_mono</span><span> </span><span>parts_subset_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_parts</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (parts H) = parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_insertI</span><span> </span><span class="delimiter">=</span><span> </span><span>subset_insertI</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹General equational properties›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz{} = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Converse fails: we can analz more from the union than from the 
  separate parts, as a key in one might decrypt a message in the other›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz(G) ∪ analz(H) ⊆ analz(G ∪ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Un_least</span><span> </span><span>analz_mono</span><span> </span><span>Un_upper1</span><span> </span><span>Un_upper2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert X (analz H) ⊆ analz(insert X H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Rewrite rules for pulling out atomic messages›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_insert_eq_I</span><span> </span><span class="delimiter">=</span><span> </span><span>equalityI</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>subsetI</span><span> </span><span>analz_insert</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Agent</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Agent agt) H) = insert (Agent agt) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Nonce</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Nonce N) H) = insert (Nonce N) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Number</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Number N) H) = insert (Number N) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Hash</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Hash X) H) = insert (Hash X) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Can only pull out Keys if they are not needed to decrypt the rest›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"K ∉ keysFor (analz H) ⟹   
          analz (insert (Key K) H) = insert (Key K) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_MPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert ⦃X,Y⦄ H) =  
          insert ⦃X,Y⦄ (analz (insert X (insert Y H)))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz.Fst</span><span> </span><span>analz.Snd</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Can pull out enCrypted message if the Key is not known›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Crypt</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Key (invKey K) ∉ analz H 
      ⟹ analz (insert (Crypt K X) H) = insert (Crypt K X) (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>analz_insert_eq_I</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (invKey K) ∈ analz H ⟹   
               analz (insert (Crypt K X) H) ⊆  
               insert (Crypt K X) (analz (insert X H))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lemma2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (invKey K) ∈ analz H ⟹   
               insert (Crypt K X) (analz (insert X H)) ⊆  
               analz (insert (Crypt K X) H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>x</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_insertI</span><span> </span><span>analz.Decrypt</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Decrypt</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Key (invKey K) ∈ analz H ⟹   
               analz (insert (Crypt K X) H) =  
               insert (Crypt K X) (analz (insert X H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>lemma1</span><span> </span><span>lemma2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Case analysis: either the message is secure, or it is not! Effective,
but can cause subgoals to blow up! Use with ‹if_split›; apparently
‹split_tac› does not cope with patterns such as @{term"analz (insert
(Crypt K X) H)"}›</span></span></span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_Crypt_if</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Crypt K X) H) =                 
          (if (Key (invKey K) ∈ analz H)                 
           then insert (Crypt K X) (analz (insert X H))  
           else insert (Crypt K X) (analz H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>analz_insert_Crypt</span><span> </span><span>analz_insert_Decrypt</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This rule supposes "for the sake of argument" that we have the key.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_Crypt_subset</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Crypt K X) H) ⊆   
           insert (Crypt K X) (analz (insert X H))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_image_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (Key`N) = Key`N"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Idempotence and transitivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_analzD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X∈ analz (analz H) ⟹ X ∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_idem</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (analz H) = analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_subset_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(analz G ⊆ analz H) = (G ⊆ analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>analz_idem</span><span> </span><span>analz_increasing</span><span> </span><span>analz_mono</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| X∈ analz G;  G ⊆ analz H |] ==&gt; X∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cut; Lemma 2 of Lowe›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_cut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| Y∈ analz (insert X H);  X∈ analz H |] ==&gt; Y∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz_trans</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Cut can be proved easily by induction on
   "Y: analz (insert X H) ⟹ X: analz H ⟶ Y: analz H"
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹This rewrite rule helps in the simplification of messages that involve
  the forwarding of unknown components (X).  Without it, removing occurrences
  of X can be very complicated.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ analz H ⟹ analz (insert X H) = analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_cut</span><span> </span><span>analz_insertI</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹A congruence rule for "analz"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_subset_cong</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| analz G ⊆ analz G'; analz H ⊆ analz H' |] 
      ==&gt; analz (G ∪ H) ⊆ analz (G' ∪ H')"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>iprover</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>conjI</span><span> </span><span>subset_trans</span><span> </span><span>analz_mono</span><span> </span><span>Un_upper1</span><span> </span><span>Un_upper2</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_cong</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| analz G = analz G'; analz H = analz H' |] 
      ==&gt; analz (G ∪ H) = analz (G' ∪ H')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>analz_subset_cong</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_cong</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"analz H = analz H' ⟹ analz(insert X H) = analz(insert X H')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>insert_def</span><span> </span><span>intro</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>analz_cong</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹If there are no pairs or encryptions then analz does nothing›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_trivial</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| ∀X Y. ⦃X,Y⦄ ∉ H;  ∀X K. Crypt K X ∉ H |] ==&gt; analz H = H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹These two are obsolete but cost little to prove...›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_UN_analz_lemma</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X∈ analz (⋃i∈A. analz (H i)) ⟹ X∈ analz (⋃i∈A. H i)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_UN_analz</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (⋃i∈A. analz (H i)) = analz (⋃i∈A. H i)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_UN_analz_lemma</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive relation "synth"›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive definition of "synth" -- what can be built up from a set of
    messages.  A form of upward closure.  Pairs can be built, messages
    encrypted with known keys.  Agent names are public domain.
    Numbers can be guessed, but Nonces cannot be.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>synth</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set =&gt; msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>H</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>Inj</span><span>    </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"X ∈ H ⟹ X ∈ synth H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Agent</span><span>  </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Agent agt ∈ synth H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Number</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Number n  ∈ synth H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Hash</span><span>   </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth H ⟹ Hash X ∈ synth H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>MPair</span><span>  </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"[|X ∈ synth H;  Y ∈ synth H|] ==&gt; ⦃X,Y⦄ ∈ synth H"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Crypt</span><span>  </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"[|X ∈ synth H;  Key(K) ∈ H|] ==&gt; Crypt K X ∈ synth H"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Monotonicity›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G⊆H ⟹ synth(G) ⊆ synth(H)"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>synth.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹NO ‹Agent_synth›, as any Agent name can be synthesized.  
  The same holds for @{term Number}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_simps</span></span><span> </span><span>synth_simps</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce n ∈ synth H"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K ∈ synth H"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"Hash X ∈ synth H"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄ ∈ synth H"</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∈ synth H"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_increasing</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"H ⊆ synth(H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Unions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Converse fails: we can synth more from the union than from the 
  separate parts, building a compound message using elements of each.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"synth(G) ∪ synth(H) ⊆ synth(G ∪ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>Un_least</span><span> </span><span>synth_mono</span><span> </span><span>Un_upper1</span><span> </span><span>Un_upper2</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert X (synth H) ⊆ synth(insert X H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>synth_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Idempotence and transitivity›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_synthD</span><span> </span><span class="delimiter">[</span><span>dest</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth (synth H) ⟹ X∈ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>synth.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_idem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"synth (synth H) = synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_subset_iff</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(synth G ⊆ synth H) = (G ⊆ synth H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>subset_trans</span><span> </span><span>synth_idem</span><span> </span><span>synth_increasing</span><span> </span><span>synth_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_trans</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| X∈ synth G;  G ⊆ synth H |] ==&gt; X∈ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>synth_mono</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cut; Lemma 2 of Lowe›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_cut</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"[| Y∈ synth (insert X H);  X∈ synth H |] ==&gt; Y∈ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>synth_trans</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Agent_synth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Agent A ∈ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Number_synth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Number n ∈ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_synth_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Nonce N ∈ synth H) = (Nonce N ∈ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Key_synth_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Key K ∈ synth H) = (Key K ∈ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_synth_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Key K ∉ H ⟹ (Crypt K X ∈ synth H) = (Crypt K X ∈ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_synth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"keysFor (synth H) = keysFor H ∪ invKey`{K. Key K ∈ H}"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Combinations of parts, analz and synth›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_synth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (synth H) = parts H ∪ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>synth_increasing</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span> 
</span><span>                    </span><span>parts.Fst</span><span> </span><span>parts.Snd</span><span> </span><span>parts.Body</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_analz_Un</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (analz G ∪ H) = analz (G ∪ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>equalityI</span><span> </span><span>analz_subset_cong</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_synth_Un</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (synth G ∪ H) = analz (G ∪ H) ∪ synth G"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>equalityI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>5</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz.Fst</span><span> </span><span>analz.Snd</span><span> </span><span>analz.Decrypt</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_synth</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz (synth H) = analz H ∪ synth H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_empty_right</span><span> </span><span>analz_synth_Un</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For reasoning about the Fake rule in traces›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_subset_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ G ⟹ parts(insert X H) ⊆ parts G ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>UnCI</span><span> </span><span>Un_upper2</span><span> </span><span>insert_subset</span><span> </span><span>parts_Un</span><span> </span><span>parts_mono</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹More specifically for Fake. See also ‹Fake_parts_sing› below›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fake_parts_insert</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth (analz H) ⟹  
      parts (insert X H) ⊆ synth (analz H) ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_commute</span><span> </span><span>analz_increasing</span><span> </span><span>insert_subset</span><span> </span><span>parts_analz</span><span> </span><span>parts_mono</span><span> 
</span><span>          </span><span>parts_synth</span><span> </span><span>synth_mono</span><span> </span><span>synth_subset_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fake_parts_insert_in_Un</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[|Z ∈ parts (insert X H);  X: synth (analz H)|] 
      ==&gt; Z ∈  synth (analz H) ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Fake_parts_insert</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{term H} is sometimes @{term"Key ` KK ∪ spies evs"}, so can't put 
  @{term "G=H"}.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fake_analz_insert</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X∈ synth (analz G) ⟹  
      analz (insert X H) ⊆ synth (analz G) ∪ analz (G ∪ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subsetI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"x ∈ analz (synth (analz G) ∪ H)"</span></span></span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>synth_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_conj_parts</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(X ∈ analz H ∧ X ∈ parts H) = (X ∈ analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_disj_parts</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(X ∈ analz H | X ∈ parts H) = (X ∈ parts H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Without this equation, other rules for synth and analz would yield
  redundant cases›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_synth_analz</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(⦃X,Y⦄ ∈ synth (analz H)) =  
      (X ∈ synth (analz H) ∧ Y ∈ synth (analz H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_synth_analz</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Key K ∈ analz H;  Key (invKey K) ∈ analz H |]  
       ==&gt; (Crypt K X ∈ synth (analz H)) = (X ∈ synth (analz H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Hash_synth_analz</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∉ synth (analz H)  
      ⟹ (Hash⦃X,Y⦄ ∈ synth (analz H)) = (Hash⦃X,Y⦄ ∈ analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹HPair: a combination of Hash and MPair›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Freeness›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Agent_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Agent A ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce N ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Number_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Number N ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Key_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Hash_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Hash Z ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_neq_HPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X' ~= Hash[X] Y"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>HPair_def</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>HPair_neqs</span><span> </span><span class="delimiter">=</span><span> </span><span>Agent_neq_HPair</span><span> </span><span>Nonce_neq_HPair</span><span> </span><span>Number_neq_HPair</span><span> 
</span><span>                    </span><span>Key_neq_HPair</span><span> </span><span>Hash_neq_HPair</span><span> </span><span>Crypt_neq_HPair</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_neqs</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>HPair_neqs</span><span> </span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">,</span><span> </span><span>iff</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPair_eq</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(Hash[X'] Y' = Hash[X] Y) = (X' = X ∧ Y'=Y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_eq_HPair</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(⦃X',Y'⦄ = Hash[X] Y) = (X' = Hash⦃X,Y⦄ ∧ Y'=Y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPair_eq_MPair</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(Hash[X] Y = ⦃X',Y'⦄) = (X' = Hash⦃X,Y⦄ ∧ Y'=Y)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Specialized laws, proved in terms of those for Hash and MPair›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_insert_HPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (insert (Hash[X] Y) H) = keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_insert_HPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"parts (insert (Hash[X] Y) H) =  
     insert (Hash[X] Y) (insert (Hash⦃X,Y⦄) (parts (insert Y H)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_HPair</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"analz (insert (Hash[X] Y) H) =  
     insert (Hash[X] Y) (insert (Hash⦃X,Y⦄) (analz (insert Y H)))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>HPair_synth_analz</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∉ synth (analz H)  
    ⟹ (Hash[X] Y ∈ synth (analz H)) =  
        (Hash ⦃X, Y⦄ ∈ analz H ∧ Y ∈ synth (analz H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>HPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹We do NOT want Crypt... messages broken up in protocols!!›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>parts.Body</span><span> </span><span class="delimiter">[</span><span>rule</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Rewrites to push in Key and Crypt messages, so that other messages can
    be pulled out using the ‹analz_insert› rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>pushKeys</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agent C"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce N"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Number N"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Hash X"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"MPair X Y"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K'"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>K</span><span> </span><span>C</span><span> </span><span>N</span><span> </span><span>X</span><span> </span><span>Y</span><span> </span><span>K'</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>pushCrypts</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agent C"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Agent C"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce N"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Number N"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"Hash X'"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span>insert_commute</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt X K"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"MPair X' Y"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>X</span><span> </span><span>K</span><span> </span><span>C</span><span> </span><span>N</span><span> </span><span>X'</span><span> </span><span>Y</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cannot be added with ‹[simp]› -- messages should not always be
  re-ordered.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>pushes</span><span> </span><span class="delimiter">=</span><span> </span><span>pushKeys</span><span> </span><span>pushCrypts</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The set of key-free messages›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Note that even the encryption of a key-free message remains key-free.
  This concept is valuable because of the theorem analz_keyfree_into_Un, proved below. *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>keyfree</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"msg set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>Agent</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Agent A ∈ keyfree"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Number</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Number N ∈ keyfree"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Nonce</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Nonce N ∈ keyfree"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Hash</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"Hash X ∈ keyfree"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>MPair</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"[|X ∈ keyfree;  Y ∈ keyfree|] ==&gt; ⦃X,Y⦄ ∈ keyfree"</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Crypt</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"[|X ∈ keyfree|] ==&gt; Crypt K X ∈ keyfree"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>keyfree.intros</span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>keyfree_KeyE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K ∈ keyfree"</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>keyfree_MPairE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄ ∈ keyfree"</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>keyfree_CryptE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∈ keyfree"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_keyfree</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (keyfree) ⊆ keyfree"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>parts.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>keyfree_KeyE</span><span> </span><span>keyfree_MPairE</span><span> </span><span>keyfree_CryptE</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*The key-free part of a set of messages can be removed from the scope of the analz operator.*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_keyfree_into_Un</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦X ∈ analz (G ∪ H); G ⊆ keyfree⟧ ⟹ X ∈ parts G ∪ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span>parts.Body</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>parts.Body</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Un_absorb2</span><span> </span><span>keyfree_KeyE</span><span> </span><span>parts_Un</span><span> </span><span>parts_keyfree</span><span> </span><span>UnI2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Tactics useful for many protocol proofs›</span></span></span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‹
(*Analysis of Fake cases.  Also works for messages that forward unknown parts,
  but this application is no longer necessary if analz_insert_eq is used.
  DEPENDS UPON "X" REFERRING TO THE FRADULENT MESSAGE *)

fun impOfSubs th = th RSN (2, @{thm rev_subsetD})

(*Apply rules to break down assumptions of the form
  Y ∈ parts(insert X H)  and  Y ∈ analz(insert X H)
*)
fun Fake_insert_tac ctxt = 
    dresolve_tac ctxt [impOfSubs @{thm Fake_analz_insert},
                  impOfSubs @{thm Fake_parts_insert}] THEN'
    eresolve_tac ctxt [asm_rl, @{thm synth.Inj}];

fun Fake_insert_simp_tac ctxt i = 
  REPEAT (Fake_insert_tac ctxt i) THEN asm_full_simp_tac ctxt i;

fun atomic_spy_analz_tac ctxt =
  SELECT_GOAL
   (Fake_insert_simp_tac ctxt 1 THEN
    IF_UNSOLVED
      (Blast.depth_tac
        (ctxt addIs [@{thm analz_insertI}, impOfSubs @{thm analz_subset_parts}]) 4 1));

fun spy_analz_tac ctxt i =
  DETERM
   (SELECT_GOAL
     (EVERY 
      [  (*push in occurrences of X...*)
       (REPEAT o CHANGED)
         (Rule_Insts.res_inst_tac ctxt [((("x", 1), Position.none), "X")] []
          (insert_commute RS ssubst) 1),
       (*...allowing further simplifications*)
       simp_tac ctxt 1,
       REPEAT (FIRSTGOAL (resolve_tac ctxt [allI,impI,notI,conjI,iffI])),
       DEPTH_SOLVE (atomic_spy_analz_tac ctxt 1)]) i);
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹By default only ‹o_apply› is built-in.  But in the presence of
eta-expansion this means that some terms displayed as @{term "f o g"} will be
rewritten, and others will not!›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>o_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_notin_image_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∉ Key ` A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Hash_notin_image_Key</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Hash X ∉ Key ` A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_analz_mono</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"G⊆H ⟹ synth (analz(G)) ⊆ synth (analz(H))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>iprover</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>synth_mono</span><span> </span><span>analz_mono</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fake_analz_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth(analz H) ⟹ synth (analz (insert X H)) = synth (analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Fake_analz_insert</span><span> </span><span>Un_absorb</span><span> </span><span>Un_absorb1</span><span> </span><span>Un_commute</span><span> 
</span><span>          </span><span>subset_insertI</span><span> </span><span>synth_analz_mono</span><span> </span><span>synth_increasing</span><span> </span><span>synth_subset_iff</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Two generalizations of ‹analz_insert_eq››</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>gen_analz_insert_eq</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ analz H ⟹ ∀G. H ⊆ G ⟶ analz (insert X G) = analz G"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_cut</span><span> </span><span>analz_insertI</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>synth_analz_insert_eq</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth (analz H) 
      ⟹ ∀ G. H ⊆ G ⟶ (Key K ∈ analz (insert X G)) = (Key K ∈ analz G)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>synth.induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>gen_analz_insert_eq</span><span> </span><span>subset_trans</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>subset_insertI</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Fake_parts_sing</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ synth (analz H) ⟹ parts{X} ⊆ synth (analz H) ∪ parts H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Fake_parts_insert</span><span> </span><span>empty_subsetI</span><span> </span><span>insert_mono</span><span> </span><span>parts_mono</span><span> </span><span>subset_trans</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Fake_parts_sing_imp_Un</span><span> </span><span class="delimiter">=</span><span> </span><span>Fake_parts_sing</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>spy_analz</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (SIMPLE_METHOD' o spy_analz_tac)›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving the Fake case when analz is involved"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>atomic_spy_analz</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (SIMPLE_METHOD' o atomic_spy_analz_tac)›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for debugging spy_analz"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>Fake_insert_simp</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (SIMPLE_METHOD' o Fake_insert_simp_tac)›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for debugging spy_analz"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="EventGA">
<div class="head"><h1>Theory EventGA</h1>
<span class="command">theory</span> <span class="name">EventGA</span><br/>
<span class="keyword">imports</span> <a href="MessageGA.html"><span class="name">MessageGA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Theory of Events for Security Protocols against the General Attacker›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>EventGA</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>MessageGA</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Initial states of agents -- parameter of the construction*)</span></span></span></span></span><span>
</span><span>  </span><span>initState</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; msg set"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span>
</span><span>  </span><span>event</span><span> </span><span class="delimiter">=</span><span> </span><span>Says</span><span>  </span><span>agent</span><span> </span><span>agent</span><span> </span><span>msg</span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span>Gets</span><span>  </span><span>agent</span><span>       </span><span>msg</span><span>
</span><span>        </span><span class="delimiter">|</span><span> </span><span>Notes</span><span> </span><span>agent</span><span>       </span><span>msg</span><span>
</span><span>       
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>knows</span><span>  </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; event list =&gt; msg set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span>knows_Nil</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"knows A [] = initState A"</span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>knows_Cons</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"knows A (ev # evs) =
        (case ev of
           Says A' B X ⇒ insert X (knows A evs)
         | Gets A' X   ⇒ knows A evs
         | Notes A' X  ⇒ 
             if A'=A then insert X (knows A evs) else knows A evs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Set of items that might be visible to somebody:
    complement of the set of fresh items*)</span></span></span></span></span><span>
</span><span> </span><span>used</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list =&gt; msg set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>   </span><span>used_Nil</span><span class="delimiter">:</span><span>   </span><span class="string"><span class="delete"><span class="delete">"used []         = (UN B. parts (initState B))"</span></span></span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>used_Cons</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"used (ev # evs) =
                     (case ev of
                        Says A B X =&gt; parts {X} ∪ used evs
                      | Gets A X   =&gt; used evs
                      | Notes A X  =&gt; parts {X} ∪ used evs)"</span></span></span><span>
</span><span>    </span><span class="comment">― ‹The case for @{term Gets} seems anomalous, but @{term Gets} always
        follows @{term Says} in real protocols.  Seems difficult to change.
        See @{text Gets_correct} in theory @{text "Guard/Extensions.thy"}.›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Notes_imp_used</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Notes A X ∈ set evs ⟶ X ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>evs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Says_imp_used</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Says A B X ∈ set evs ⟶ X ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>evs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Function @{term knows}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>parts_insert_knows_A</span><span> </span><span class="delimiter">=</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>A</span><span> </span><span>evs</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Says</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"knows A (Says A' B X # evs) = insert X (knows A evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Notes</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"knows A (Notes A' X # evs) =  
          (if A=A' then insert X (knows A evs) else knows A evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_Gets</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A (Gets A' X # evs) = knows A evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Everybody sees what is sent on the traffic›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Says_imp_knows</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"Says A' B X ∈ set evs ⟶ (∀A. X ∈ knows A evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Notes_imp_knows</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"Notes A' X ∈ set evs ⟶ X ∈ knows A' evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Elimination rules: derive contradictions from old Says events containing
  items known to be fresh›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Says_imp_parts_knows</span><span> </span><span class="delimiter">=</span><span> 
</span><span>       </span><span>Says_imp_knows</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>revcut_rl</span><span class="delimiter">]</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>knows_partsEs</span><span> </span><span class="delimiter">=</span><span>
</span><span>     </span><span>Says_imp_parts_knows</span><span> </span><span>parts.Body</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>revcut_rl</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Says_imp_analz</span><span> </span><span class="delimiter">=</span><span> </span><span>Says_imp_knows</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz.Inj</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Knowledge of generic agents›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_subset_knows_Says</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs ⊆ knows A (Says A' B X # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_insertI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_subset_knows_Notes</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs ⊆ knows A (Notes A' X # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_insertI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_subset_knows_Gets</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs ⊆ knows A (Gets A' X # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>subset_insertI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_imp_Says_Gets_Notes_initState</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"X ∈ knows A evs ⟹ ∃A' B.  
  Says A' B X ∈ set evs ∨ Notes A X ∈ set evs ∨ X ∈ initState A"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_knows_subset_used</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts (knows A evs) ⊆ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">,</span><span> </span><span>force</span><span class="delimiter">)</span><span>  
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>parts_insert_knows_A</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>usedI</span><span> </span><span class="delimiter">=</span><span> </span><span>parts_knows_subset_used</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>initState_into_used</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"X ∈ parts (initState B) ⟹ X ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>parts_insert_knows_A</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>used_Says</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"used (Says A B X # evs) = parts{X} ∪ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>used_Notes</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"used (Notes A X # evs) = parts{X} ∪ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>used_Gets</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"used (Gets A X # evs) = used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>used_nil_subset</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"used [] ⊆ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>initState_into_used</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹NOTE REMOVAL--laws above are cleaner, as they don't involve "case"›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>knows_Cons</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>        </span><span>used_Nil</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span> </span><span>used_Cons</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_mono_contra</span><span> </span><span class="delimiter">=</span><span>
</span><span>       </span><span>knows_subset_knows_Says</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>contra_subsetD</span><span class="delimiter">]</span><span>
</span><span>       </span><span>knows_subset_knows_Notes</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>contra_subsetD</span><span class="delimiter">]</span><span>
</span><span>       </span><span>knows_subset_knows_Gets</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>contra_subsetD</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knows_subset_knows_Cons</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs ⊆ knows A (e # evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>e</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>knows_Cons</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>initState_subset_knows</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"initState A ⊆ knows A evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>evs</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>knows_subset_knows_Cons</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For proving ‹new_keys_not_used››</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_parts_insert</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| K ∈ keysFor (parts (insert X G));  X ∈ synth (analz H) |] 
      ==&gt; K ∈ keysFor (parts (G ∪ H)) | Key (invKey K) ∈ parts H"</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> 
</span><span>    </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>parts_insert_subset_Un</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>keysFor_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span>
</span><span>           </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>keysFor_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span>
</span><span>    </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_subset_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span> </span><span>parts_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_impI</span><span> </span><span class="delimiter">=</span><span> </span><span>impI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ∉ analz (knows A evs)"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Y</span><span> </span><span>A</span><span> </span><span>evs</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‹
fun analz_mono_contra_tac ctxt =
  resolve_tac ctxt @{thms analz_impI} THEN' 
  REPEAT1 o (dresolve_tac ctxt @{thms analz_mono_contra})
  THEN' mp_tac ctxt
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>analz_mono_contra</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (fn ctxt =&gt; SIMPLE_METHOD (REPEAT_FIRST (analz_mono_contra_tac ctxt)))›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving theorems of the form X ∉ analz (knows A evs) ⟶ P"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Useful for case analysis on whether a hash is a spoof or not›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>syan_impI</span><span> </span><span class="delimiter">=</span><span> </span><span>impI</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"Y ∉ synth (analz (knows A evs))"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>Y</span><span> </span><span>A</span><span> </span><span>evs</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span>
</span><span class="cartouche"><span class="delete"><span class="delete">‹
fun synth_analz_mono_contra_tac ctxt =
  resolve_tac ctxt @{thms syan_impI} THEN'
  REPEAT1 o 
    (dresolve_tac ctxt 
     [@{thm knows_subset_knows_Says} RS @{thm synth_analz_mono} RS @{thm contra_subsetD},
      @{thm knows_subset_knows_Notes} RS @{thm synth_analz_mono} RS @{thm contra_subsetD},
      @{thm knows_subset_knows_Gets} RS @{thm synth_analz_mono} RS @{thm contra_subsetD}])
  THEN'
  mp_tac ctxt
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>synth_analz_mono_contra</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (fn ctxt =&gt; SIMPLE_METHOD (REPEAT_FIRST (synth_analz_mono_contra_tac ctxt)))›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving theorems of the form X ∉ synth (analz (knows A evs)) ⟶ P"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="PublicGA">
<div class="head"><h1>Theory PublicGA</h1>
<span class="command">theory</span> <span class="name">PublicGA</span><br/>
<span class="keyword">imports</span> <a href="EventGA.html"><span class="name">EventGA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Theory of Cryptographic Keys for Security Protocols against the General Attacker›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>PublicGA</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>EventGA</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invKey_K</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K ∈ symKeys ⟹ invKey K = K"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Asymmetric Keys›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>keymode</span><span> </span><span class="delimiter">=</span><span> </span><span>Signature</span><span> </span><span class="delimiter">|</span><span> </span><span>Encryption</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span>  </span><span>publicKey</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[keymode,agent] =&gt; key"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>pubEK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pubEK == publicKey Encryption"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>pubSK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pubSK == publicKey Signature"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>privateKey</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"[keymode, agent] =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"privateKey b A == invKey (publicKey b A)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*BEWARE!! priEK, priSK DON'T WORK with inj, range, image, etc.*)</span></span></span></span></span><span>
</span><span>  </span><span>priEK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"priEK A == privateKey Encryption A"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>priSK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"priSK A == privateKey Signature A"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹These abbreviations give backward compatibility.  They represent the
simple situation where the signature and encryption keys are the same.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>pubK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pubK A == pubEK A"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>priK</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"priK A == invKey (pubEK A)"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹By freeness of agents, no two agents have the same key.  Since
  @{term "True≠False"}, no agent has identical signing and encryption keys›</span></span></span><span>
</span><span class="keyword1"><span class="command">specification</span></span><span> </span><span class="delimiter">(</span><span>publicKey</span><span class="delimiter">)</span><span>
</span><span>  </span><span>injective_publicKey</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"publicKey b A = publicKey c A' ⟹ b=c ∧ A=A'"</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> 
</span><span>       </span><span class="string"><span class="delete"><span class="delete">"%b A. 2 * case_agent (λn. n + 2) A + case_keymode 0 1 b"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>agent.split</span><span> </span><span>keymode.split</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>presburger</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>presburger</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>                       
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*No private key equals any public key (essential to ensure that private
    keys are private!) *)</span></span></span></span></span><span>
</span><span>  </span><span>privateKey_neq_publicKey</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"privateKey b A ≠ publicKey c A'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>publicKey_neq_privateKey</span><span> </span><span class="delimiter">=</span><span> </span><span>privateKey_neq_publicKey</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>publicKey_neq_privateKey</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Basic properties of @{term pubK} and @{term priK}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_inject</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(publicKey b A = publicKey c A') = (b=c ∧ A=A')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>injective_publicKey</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_symKeys_pubK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"publicKey b A ∉ symKeys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_symKeys_priK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"privateKey b A ∉ symKeys"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symKey_neq_priEK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"K ∈ symKeys ⟹ K ≠ priEK A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symKeys_neq_imp_neq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(K ∈ symKeys) ≠ (K' ∈ symKeys) ⟹ K ≠ K'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>symKeys_invKey_iff</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(invKey K ∈ symKeys) = (K ∈ symKeys)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>symKeys_def</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_symKeys_Decrypt</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Crypt K X ∈ analz H;  K ∈ symKeys;  Key K ∈ analz H |]  
      ==&gt; X ∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹"Image" equations that hold for injective functions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invKey_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(invKey x ∈ invKey`A) = (x ∈ A)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*holds because invKey is injective*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(publicKey b x ∈ publicKey c ` AA) = (b=c ∧ x ∈ AA)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>privateKey_notin_image_publicKey</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"privateKey b x ∉ publicKey c ` AA"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>privateKey_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(privateKey b A ∈ invKey ` publicKey c ` AS) = (b=c ∧ A∈AS)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_notin_image_privateKey</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"publicKey b A ∉ invKey ` publicKey c ` AS"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Symmetric Keys›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For some protocols, it is convenient to equip agents with symmetric as
well as asymmetric keys.  The theory ‹Shared› assumes that all keys
are symmetric.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span>
</span><span>  </span><span>shrK</span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent =&gt; key"</span></span></span><span>    </span><span class="comment">― ‹long-term shared keys›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">specification</span></span><span> </span><span class="delimiter">(</span><span>shrK</span><span class="delimiter">)</span><span>
</span><span>  </span><span>inj_shrK</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"inj shrK"</span></span></span><span>
</span><span>  </span><span class="comment">― ‹No two agents have the same long-term key›</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">"case_agent (λn. n + 2)"</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inj_on_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>agent.split</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">axiomatization</span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>sym_shrK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shrK X ∈ symKeys"</span></span></span><span> </span><span class="comment">― ‹All shared keys are symmetric›</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Injectiveness: Agents' long-term keys are distinct.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>shrK_injective</span><span> </span><span class="delimiter">=</span><span> </span><span>inj_shrK</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>inj_eq</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>shrK_injective</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>invKey_shrK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"invKey (shrK A) = shrK A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invKey_K</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_shrK_Decrypt</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Crypt (shrK A) X ∈ analz H; Key(shrK A) ∈ analz H |] ==&gt; X ∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_Decrypt'</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Crypt K X ∈ analz H; K ∈ symKeys; Key K ∈ analz H |] ==&gt; X ∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>invKey_K</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>priK_neq_shrK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shrK A ≠ privateKey b C"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_neq_imp_neq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>shrK_neq_priK</span><span> </span><span class="delimiter">=</span><span> </span><span>priK_neq_shrK</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>shrK_neq_priK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pubK_neq_shrK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shrK A ≠ publicKey b C"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>symKeys_neq_imp_neq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>shrK_neq_pubK</span><span> </span><span class="delimiter">=</span><span> </span><span>pubK_neq_shrK</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>shrK_neq_pubK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>priEK_noteq_shrK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"priEK A ≠ shrK B"</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_notin_image_shrK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"publicKey b x ∉ shrK ` AA"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>privateKey_notin_image_shrK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"privateKey b x ∉ shrK ` AA"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_notin_image_publicKey</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shrK x ∉ publicKey b ` AA"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_notin_image_privateKey</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"shrK x ∉ invKey ` publicKey b ` AA"</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_image_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(shrK x ∈ shrK ` AA) = (x ∈ AA)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹For some reason, moving this up can make some proofs loop!›</span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>invKey_K</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Initial States of Agents›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">overloading</span></span><span>
</span><span>  </span><span>initState</span><span> </span><span class="delimiter">≡</span><span> </span><span>initState</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>initState</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>
</span><span>  </span><span>initState_Friend</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"initState (Friend i) =    
       {Key (priEK (Friend i)), Key (priSK (Friend i)), Key (shrK (Friend i))} ∪ 
       (Key ` range pubEK) ∪ (Key ` range pubSK)"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>used_parts_subset_parts</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"∀X ∈ used evs. parts {X} ⊆ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>evs</span><span class="delimiter">)</span><span> 
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>used_Cons</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>  
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>a</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>  
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>parts_cut</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Base case›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>used_Nil</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_used_D</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃X,Y⦄ ∈ used H ⟹ X ∈ used H ∧ Y ∈ used H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>used_parts_subset_parts</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹There was a similar theorem in Event.thy, so perhaps this one can
  be moved up if proved directly by induction.›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MPair_used</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| ⦃X,Y⦄ ∈ used H;
         [| X ∈ used H; Y ∈ used H |] ==&gt; P |] 
      ==&gt; P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>MPair_used_D</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Rewrites should not refer to  @{term "initState(Friend i)"} because
  that expression is not in normal form.›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>keysFor_parts_initState</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"keysFor (parts (initState C)) = {}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>keysFor_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"C"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>range_eqI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_notin_initState</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∉ parts (initState B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>B</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_notin_used_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Crypt K X ∉ used []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Crypt_notin_initState</span><span> </span><span>used_Nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*** Basic properties of shrK ***)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Agents see their own shared keys!*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_in_initState</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (shrK A) ∈ initState A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"A"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_in_knows</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (shrK A) ∈ knows A evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>initState_subset_knows</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_in_used</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (shrK A) ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>initState_into_used</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(** Fresh keys never clash with long-term shared keys **)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Used in parts_induct_tac and analz_Fake_tac to distinguish session keys
  from long-term shared keys*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Key_not_used</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K ∉ used evs ⟹ K ∉ range shrK"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>shrK_neq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key K ∉ used evs ⟹ shrK B ≠ K"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>neq_shrK</span><span> </span><span class="delimiter">=</span><span> </span><span>shrK_neq</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>neq_shrK</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Function @{term "knows Spy"}›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_SignatureE</span><span> </span><span class="delimiter">[</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"b ≠ Signature ⟹ b = Encryption"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Agents see their own private keys!›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>priK_in_initState</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (privateKey b A) ∈ initState A"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Agents see all public keys!›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_in_initState</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (publicKey b A) ∈ initState B"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>B</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹All public keys are visible›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>spies_pubK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (publicKey b A) ∈ knows B evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>imageI</span><span> </span><span>knows_Cons</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_spies_pubK</span><span> </span><span class="delimiter">=</span><span> </span><span>spies_pubK</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz.Inj</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>analz_spies_pubK</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Note: there never is at this stage a lemma about what an agent cannot know*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>publicKey_into_used</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"Key (publicKey b A) ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>initState_into_used</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>publicKey_in_initState</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>privateKey_into_used</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Key (privateKey b A) ∈ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>initState_into_used</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>priK_in_initState</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_analz_bad</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"[| Crypt (shrK A) X ∈ analz (knows A evs) |]  
      ==&gt; X ∈ analz (knows A evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Fresh Nonces›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_notin_initState</span><span> </span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce N ∉ parts (initState B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"B"</span></span></span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_notin_used_empty</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce N ∉ used []"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>used_Nil</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Supply fresh nonces for possibility theorems›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹In any trace, there is an upper bound N on the greatest nonce in use›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_supply_lemma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃N. ∀n. N≤n ⟶ Nonce n ∉ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span> </span><span class="delimiter">=</span><span> </span><span>0</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>used_Cons</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>event.split</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>msg_Nonce_supply</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>exE</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>blast</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>add_leE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_supply1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∃N. Nonce N ∉ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Nonce_supply_lemma</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>exE</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Nonce_supply</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"Nonce (SOME N. Nonce N ∉ used evs) ∉ used evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Nonce_supply_lemma</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>exE</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>someI</span><span class="delimiter">,</span><span> </span><span>fast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Specialized Rewriting for Theorems About @{term analz} and Image›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_Key_singleton</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert (Key K) H = Key ` {K} ∪ H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>insert_Key_image</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"insert (Key K) (Key`KK ∪ C) = Key ` (insert K KK) ∪ C"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Crypt_imp_keysFor</span><span> </span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">"[|Crypt K X ∈ H; K ∈ symKeys|] ==&gt; K ∈ keysFor H"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Crypt_imp_invKey_keysFor</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Lemma for the trivial direction of the if-and-only-if of the 
Session Key Compromise Theorem›</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_image_freshK_lemma</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(Key K ∈ analz (Key`nE ∪ H)) ⟶ (K ∈ nE | Key K ∈ analz H)  ⟹  
         (Key K ∈ analz (Key`nE ∪ H)) = (K ∈ nE | Key K ∈ analz H)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>analz_mono</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span>rev_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>analz_image_freshK_simps</span><span> </span><span class="delimiter">=</span><span>
</span><span>       </span><span>simp_thms</span><span> </span><span>mem_simps</span><span> </span><span class="comment">― ‹these two allow its use with @{text "only:"}›</span><span>
</span><span>       </span><span>disj_comms</span><span> 
</span><span>       </span><span>image_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span> </span><span>image_Un</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span> </span><span>empty_subsetI</span><span> </span><span>insert_subset</span><span>
</span><span>       </span><span>analz_insert_eq</span><span> </span><span>Un_upper2</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span>
</span><span>       </span><span>insert_Key_singleton</span><span> 
</span><span>       </span><span>Key_not_used</span><span> </span><span>insert_Key_image</span><span> </span><span>Un_assoc</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
structure Public =
struct

val analz_image_freshK_ss =
  simpset_of (@{context}
    delsimps [image_insert, image_Un]
    delsimps [@{thm imp_disjL}]    (*reduces blow-up*)
    addsimps @{thms analz_image_freshK_simps})

(*Tactic for possibility theorems*)
fun possibility_tac ctxt =
    REPEAT (*omit used_Says so that Nonces start from different traces!*)
    (ALLGOALS (simp_tac (ctxt delsimps [@{thm used_Says}]))
     THEN
     REPEAT_FIRST (eq_assume_tac ORELSE' 
                   resolve_tac ctxt [refl, conjI, @{thm Nonce_supply}]))

(*For harder protocols (such as Recur) where we have to set up some
  nonces and keys initially*)
fun basic_possibility_tac ctxt =
    REPEAT 
    (ALLGOALS (asm_simp_tac (ctxt setSolver safe_solver))
     THEN
     REPEAT_FIRST (resolve_tac ctxt [refl, conjI]))

end
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>analz_freshK</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (fn ctxt =&gt;
     (SIMPLE_METHOD
      (EVERY [REPEAT_FIRST (resolve_tac ctxt [allI, ballI, impI]),
          REPEAT_FIRST (resolve_tac ctxt @{thms analz_image_freshK_lemma}),
          ALLGOALS (asm_simp_tac (put_simpset Public.analz_image_freshK_ss ctxt))])))›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving the Session Key Compromise theorem"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Specialized Methods for Possibility Theorems›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>possibility</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (SIMPLE_METHOD o Public.possibility_tac)›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving possibility theorems"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">method_setup</span></span><span> </span><span>basic_possibility</span><span> </span><span class="delimiter">=</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
    Scan.succeed (SIMPLE_METHOD o Public.basic_possibility_tac)›</span></span></span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">"for proving possibility theorems"</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="NS_Public_Bad_GA">
<div class="head"><h1>Theory NS_Public_Bad_GA</h1>
<span class="command">theory</span> <span class="name">NS_Public_Bad_GA</span><br/>
<span class="keyword">imports</span> <a href="PublicGA.html"><span class="name">PublicGA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹The Needham-Schroeder Public-Key Protocol against the General Attacker›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>NS_Public_Bad_GA</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>PublicGA</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>ns_public</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"event list set"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>
</span><span>   </span><span>Nil</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"[] ∈ ns_public"</span></span></span><span>
</span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>Fake</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦evsf ∈ ns_public;  X ∈ synth (analz (knows A evsf))⟧
          ⟹ Says A B X  # evsf ∈ ns_public"</span></span></span><span>
</span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>Reception</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ evsr ∈ ns_public; Says A B X ∈ set evsr ⟧
                ⟹ Gets B X # evsr ∈ ns_public"</span></span></span><span>
</span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>NS1</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦evs1 ∈ ns_public;  Nonce NA ∉ used evs1⟧
          ⟹ Says A B (Crypt (pubEK B) ⦃Nonce NA, Agent A⦄)
                # evs1  ∈  ns_public"</span></span></span><span>
</span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>NS2</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦evs2 ∈ ns_public;  Nonce NB ∉ used evs2;
           Gets B (Crypt (pubEK B) ⦃Nonce NA, Agent A⦄) ∈ set evs2⟧
          ⟹ Says B A (Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄)
                # evs2  ∈  ns_public"</span></span></span><span>
</span><span>
</span><span> </span><span class="delimiter">|</span><span> </span><span>NS3</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦evs3 ∈ ns_public;
           Says A  B (Crypt (pubEK B) ⦃Nonce NA, Agent A⦄) ∈ set evs3;
           Gets A (Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄) ∈ set evs3⟧
          ⟹ Says A B (Crypt (pubEK B) (Nonce NB)) # evs3 ∈ ns_public"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_no_Notes</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs ∈ ns_public ⟹ Notes A X ∉ set evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Confidentiality treatment in separate theory file›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div><div id="ConfidentialityGA">
<div class="head"><h1>Theory ConfidentialityGA</h1>
<span class="command">theory</span> <span class="name">ConfidentialityGA</span><br/>
<span class="keyword">imports</span> <a href="NS_Public_Bad_GA.html"><span class="name">NS_Public_Bad_GA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Inductive Study of Confidentiality against the General Attacker›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span>  </span><span>ConfidentialityGA</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>NS_Public_Bad_GA</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹New subsidiary lemmas to reason on a generic agent initial state›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_initState</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"parts(initState C) = initState C"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_initState</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"analz(initState C) = initState C"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>C</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz_into_parts</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Generalising over all initial secrets the existing treatment, which is limited to private encryption keys›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>staticSecret</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"agent ⇒ msg set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"staticSecret A == {Key (priEK A), Key (priSK A), Key (shrK A)}"</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹More subsidiary lemmas combining initial secrets and knowledge of generic agent›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>staticSecret_in_initState</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"staticSecret A ⊆ initState A"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>parts_insert</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>staticSecretA_notin_initStateB</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ staticSecret A ⟹ m ∈ initState B = (A=B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>B</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>staticSecretA_notin_parts_initStateB</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ staticSecret A ⟹ m ∈ parts(initState B) = (A=B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>B</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>staticSecretA_notin_analz_initStateB</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"m ∈ staticSecret A ⟹ m ∈ analz(initState B) = (A=B)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>B</span><span class="delimiter">,</span><span> </span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz_into_parts</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>staticSecret_synth_eq</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">"m ∈ staticSecret A ⟹ (m ∈ synth H) = (m ∈ H)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>staticSecret_def</span><span> </span><span class="delimiter">[</span><span>simp</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nonce_notin_analz_initState</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Nonce N ∉ analz(initState A)"</span></span></span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>A</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>analz_into_parts</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Protocol independent study›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>staticSecret_parts_agent</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ parts (knows C evs); m ∈ staticSecret A⟧ ⟹  
   A=C ∨ 
  (∃D E X. Says D E X ∈ set evs ∧ m ∈ parts{X}) ∨
  (∃Y. Notes C Y ∈ set evs ∧ m ∈ parts{Y})"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>evs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent =1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>staticSecretA_notin_parts_initStateB</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Says*)</span></span></span></span></span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Gets*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Notes*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span> 
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent =1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>staticSecret_analz_agent</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ analz (knows C evs); m ∈ staticSecret A⟧ ⟹  
   A=C ∨ 
  (∃D E X. Says D E X ∈ set evs ∧ m ∈ parts{X}) ∨
  (∃Y. Notes C Y ∈ set evs ∧ m ∈ parts{Y})"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>analz_into_parts</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>staticSecret_parts_agent</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>secret_parts_agent</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"m ∈ parts (knows C evs)  ⟹ m ∈ initState C ∨
 (∃A B X. Says A B X ∈ set evs ∧ m ∈ parts{X}) ∨
 (∃Y. Notes C Y ∈ set evs ∧ m ∈ parts{Y})"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>parts_initState</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Says*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>impI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Gets*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Notes*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Protocol dependent study›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*NS_no_Notes moved up in NS_Public_Bad_GA.thy so that it's visible to a sibling theory of this one's

As with DolevYao, studying a guarantee similar to
NS_no_Says_staticSecret makes the specialisation proof strategy collapse, because it elicits the same assumptions of the theorem that should be specified.
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_staticSecret_parts_agent_weak</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ parts (knows C evs); m ∈ staticSecret A; 
   evs ∈ ns_public⟧ ⟹
  A=C ∨ (∃D E X. Says D E X ∈ set evs ∧ m ∈ parts{X})"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>NS_no_Notes</span><span> </span><span>staticSecret_parts_agent</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Can't prove the homologous theorem of NS\_Says\_Spy\_staticSecret, hence the specialisation proof strategy cannot be applied›</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Simple though illustrative corollary*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*note use of Says_imp_knows, an enforcement of the threat model*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_staticSecret_parts_agent_parts</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ parts (knows C evs); m ∈ staticSecret A; A≠C; evs ∈ ns_public⟧ ⟹
  m ∈ parts(knows D evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>NS_staticSecret_parts_agent_weak</span><span> </span><span>Says_imp_knows</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">]</span><span> </span><span>parts_trans</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Alternative proof
apply (blast dest: staticSecret_parts_agent NS_no_Notes Says_imp_knows [THEN parts.Inj] parts_trans)*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹
The previous theorems show that in general any agent could send anybody's initial secret, namely the threat model does not impose anything against it. However, the actual protocol specification will, where agents either follow the protocol or build messages out of their traffic analysis - this is actually the same in DY

Therefore, we are only left with the direct proof strategy.
›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_staticSecret_parts_agent</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ parts (knows C evs); m ∈ staticSecret A; 
   C≠A; evs ∈ ns_public⟧
 ⟹ ∃ B X. Says A B X ∈ set evs ∧ m ∈ parts {X}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Nil*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>staticSecretA_notin_parts_initStateB</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Fake*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>parts_insert</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*shot1*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"Aa=A"</span></span></span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1,goals_limit=2]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Aa≠A*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*applies induction hypothesis!*)</span></span></span></span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*shot2*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1,goals_limit=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>Fake_parts_sing</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*shot3*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>staticSecret_synth_eq</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1,goals_limit=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>NS_staticSecret_parts_agent_parts</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*rest!*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>staticSecret_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>NS_agent_see_staticSecret</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦m ∈ staticSecret A; C≠A; evs ∈ ns_public⟧
 ⟹ m ∈ parts (knows C evs) = (∃ B X. Says A B X ∈ set evs ∧ m ∈ parts {X})"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>NS_staticSecret_parts_agent</span><span> </span><span>Says_imp_knows</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>parts.Inj</span><span class="delimiter">]</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>parts_trans</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>analz.Decrypt</span><span> </span><span class="delimiter">[</span><span>rule</span><span> </span><span>del</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>analz_insert_analz</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"
⟦ c ∉ parts{Z}; ∀K. Key K ∉ parts{Z}; c ∈ analz(insert Z H)⟧ ⟹ c ∈ analz H"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>analz.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>4</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1,goals_limit=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>parts.Body</span><span> </span><span>analz.Decrypt</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Agent_not_see_NA</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">"⟦ Key (priEK B) ∉ analz(knows C evs); 
        Key (priEK A) ∉ analz(knows C evs);
        ∀S R Y. Says S R Y ∈ set evs ⟶ 
         Y = Crypt (pubEK B) ⦃Nonce NA, Agent A⦄ ∨
         Y = Crypt (pubEK A) ⦃Nonce NA, Nonce NB⦄ ∨
         Nonce NA ∉ parts{Y} ∧ (∀K. Key K ∉ parts{Y});
        C≠A; C≠B;  evs ∈ ns_public⟧                     
       ⟹ Nonce NA ∉ analz (knows C evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>ns_public.induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nonce_notin_analz_initState</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*fixing confidentiality of both private keys*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>subset_insertI</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>analz_mono</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>contra_subsetD</span><span class="delimiter">]</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1,goals_limit=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"
        ∀S R Y.
           (S = Aa ∧ R = Ba ∧ Y = X ⟶
            X = Crypt (pubK B) ⦃Nonce NA, Agent A⦄ ∨
            X = Crypt (pubK A) ⦃Nonce NA, Nonce NB⦄ ∨
            Nonce NA ∉ parts {X} ∧ (∀K. Key K ∉ parts {X}))"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹@{subgoals [display,indent=1,goals_limit=1]}›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>analz_insert_analz</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Alternative proof
apply (erule disjE) apply simp 
apply (erule disjE) apply simp 
apply (blast dest: analz_insert_analz)
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>
</div>
</div><div id="Knowledge">
<div class="head"><h1>Theory Knowledge</h1>
<span class="command">theory</span> <span class="name">Knowledge</span><br/>
<span class="keyword">imports</span> <a href="NS_Public_Bad_GA.html"><span class="name">NS_Public_Bad_GA</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Study on knowledge equivalence --- results to relate the knowledge of an agent to that of another's›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Knowledge</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>NS_Public_Bad_GA</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Protocol independent study*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Whatever A knows, which is neither static-private nor dynamic-private for
  her, then also B knows that*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>knowledge_equiv</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ X ∈ knows A evs; Notes A X ∉ set evs;
   X ∉ {Key (priEK A), Key (priSK A), Key (shrK A)} ⟧
 ⟹ X ∈ knows B evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>rev_mp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"A"</span></span></span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"B"</span></span></span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knowledge_equiv_bis</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ X ∈ knows A evs; Notes A X ∉ set evs ⟧
 ⟹ X ∈ {Key (priEK A), Key (priSK A), Key (shrK A)} ∪ knows B evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>knowledge_equiv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knowledge_equiv_ter</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ X ∈ knows A evs; X ∉ {Key (priEK A), Key (priSK A), Key (shrK A)} ⟧
⟹ X ∈ knows B evs ∨ Notes A X ∈ set evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>knowledge_equiv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knowledge_equiv_quater</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">" X ∈ knows A evs
⟹ X ∈ knows B evs ∨ Notes A X ∈ set evs ∨ 
   X ∈ {Key (priEK A), Key (priSK A), Key (shrK A)}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>knowledge_equiv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>setdiff_diff_insert</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"A-B-C=D-E-F ⟹ insert m (A-B-C) = insert m (D-E-F)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*IMPORTANT NOTE TO PREVIOUS LEMMA: removing parentheses from rhs falsifies
the lemma because set insertion seems to have higher priority than set
difference, hence insert m A-B-C ≠ insert m (A-B-C)!
Seen such operand priority, it can be understood why the lemma wouldn't hold
without parentheses*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"A-B-C=D-E-F ⟹ insert m A-B-C = insert m D-E-F"</span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knowledge_equiv_eq_setdiff</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs  -
   {Key (priEK A), Key (priSK A), Key (shrK A)} -
     {X. Notes A X ∈ set evs}
  =
  knows B evs -
   {Key (priEK B), Key (priSK B), Key (shrK B)} -
     {X. Notes B X ∈ set evs}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"A"</span></span></span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"B"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Gets case solves because this event doesn't touch any agent knowledge*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Says case fails because both agents extract the said message, plus
discussion on lemma setdiff_diff_insert*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Notes case solves in case neither of the two agents is the agent of the
  current step, because no notes are extracted and inductive premise applies;
  it fails in the two subcases when either of them is the agent of the current
  step, because a note would be extracted i.e. inserted in his knowledge, and
  hence falsification by discussion on lemma setdiff_diff_insert*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*So we have clear counterexamples of why this theorem CANNOT be proved inductively. Alternative stretegy using symbolic evaluation introduces clear counterexamples such as when an agent says A's shared key: it would be in the rhs but not in the lhs!*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Old proof*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knowledge_equiv_eq_old</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs  ∪  
   {Key (priEK B), Key (priSK B), Key (shrK B)} ∪ 
     {X. Notes B X ∈ set evs} 
  = 
  knows B evs ∪ 
   {Key (priEK A), Key (priSK A), Key (shrK A)} ∪ 
     {X. Notes A X ∈ set evs}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"A"</span></span></span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"B"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Gets case solves because this event doesn't touch any agent knowledge›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span> </span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹speeds up subsequent blasting›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span class="delimiter">+</span><span>  </span><span class="keyword1"><span class="command">txt</span></span><span class="cartouche"><span class="delete"><span class="delete">‹very very slow›</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* New proof*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>knowledge_eval</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs = 
       {Key (priEK A), Key (priSK A), Key (shrK A)} ∪ 
       (Key ` range pubEK) ∪ (Key ` range pubSK) ∪
       {X. ∃ S R. Says S R X ∈ set evs} ∪
       {X. Notes A X ∈ set evs}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"A"</span></span></span><span class="delimiter">,</span><span> </span><span>induct_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">"evs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span class="delimiter">[</span><span>2</span><span class="delimiter">]</span><span> </span><span class="string"><span class="delete"><span class="delete">"a"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knowledge_eval_setdiff</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs  - 
   {Key (priEK A), Key (priSK A), Key (shrK A)} -
     {X. Notes A X ∈ set evs}
  = 
       (Key ` range pubEK) ∪ (Key ` range pubSK) ∪
       {X. ∃ S R. Says S R X ∈ set evs}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>knowledge_eval</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*here are clear counterexamples!*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>knowledge_equiv_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs  ∪  
   {Key (priEK B), Key (priSK B), Key (shrK B)} ∪ 
     {X. Notes B X ∈ set evs} 
  = 
  knows B evs ∪ 
   {Key (priEK A), Key (priSK A), Key (shrK A)} ∪ 
     {X. Notes A X ∈ set evs}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>knowledge_eval</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"knows A evs  ∪  
   {Key (priEK B), Key (priSK B), Key (shrK B)} ∪ 
     {X. Notes B X ∈ set evs} -
(  {Key (priEK B), Key (priSK B), Key (shrK B)} ∪ 
     {X. Notes B X ∈ set evs} ) = knows A evs"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Here the prover tells you why this fails*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>parts_knowledge_equiv_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"
parts(knows A evs)  ∪  
   {Key (priEK B), Key (priSK B), Key (shrK B)} ∪ 
     parts({X. Notes B X ∈ set evs}) 
  = 
parts(knows B evs) ∪ 
   {Key (priEK A), Key (priSK A), Key (shrK A)} ∪ 
     parts({X. Notes A X ∈ set evs})"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>knowledge_eval</span><span> </span><span>parts_Un</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>parts_knowledge_equiv</span><span> </span><span class="delimiter">=</span><span> </span><span>parts_knowledge_equiv_eq</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>equalityD1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>subsetD</span><span class="delimiter">]</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>parts_knowledge_equiv</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>noprishr_parts_knowledge_equiv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"
⟦ X ∉ {Key (priEK A), Key (priSK A), Key (shrK A)};
  X ∈ parts(knows A evs) ⟧
⟹  X ∈ parts(knows B evs) ∪ 
      parts({X. Notes A X ∈ set evs})"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>UnI1</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>UnI1</span><span class="delimiter">,</span><span> </span><span>THEN</span><span> </span><span>parts_knowledge_equiv</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Protocol-dependent study*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>knowledge_equiv_eq_NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" 
  evs ∈ ns_public ⟹
  knows A evs  ∪ {Key (priEK B), Key (priSK B), Key (shrK B)}  = 
  knows B evs ∪ {Key (priEK A), Key (priSK A), Key (shrK A)}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>knowledge_eval</span><span> </span><span>NS_no_Notes</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>parts_knowledge_equiv_eq_NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" 
  evs ∈ ns_public ⟹
  parts(knows A evs) ∪ {Key (priEK B), Key (priSK B), Key (shrK B)}  = 
  parts(knows B evs) ∪ {Key (priEK A), Key (priSK A), Key (shrK A)}"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>knowledge_eval</span><span> </span><span>NS_no_Notes</span><span> </span><span>parts_Un</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>noprishr_parts_knowledge_equiv_NS</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">" 
⟦ X ∉ {Key (priEK A), Key (priSK A), Key (shrK A)};
  X ∈ parts(knows A evs); evs ∈ ns_public ⟧
⟹  X ∈ parts(knows B evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>noprishr_parts_knowledge_equiv</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>NS_no_Notes</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>Agent_not_analz_N</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">"⟦ Nonce N ∉ parts(knows A evs); evs ∈ ns_public ⟧
 ⟹ Nonce N ∉ analz(knows B evs)"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>noprishr_parts_knowledge_equiv_NS</span><span> </span><span>analz_into_parts</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*Conclusion in terms of analz because we are more used to it. It would have been a stronger law in terms of parts, though*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>
</div>
</div>