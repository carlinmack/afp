<div id="CIMP_pred">
<div class="head"><h1>Theory CIMP_pred</h1>
<span class="command">theory</span> <span class="name">CIMP_pred</span><br/>
<span class="keyword">imports</span> <a href="../../HOL/HOL/Main.html"><span class="name">Main</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CIMP_pred</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>Main</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹ Point-free notation ›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:cimp-lifted-predicates}

Typically we define predicates as functions of a state. The following
provide a somewhat comfortable point-free imitation of Isabelle/HOL's
operators.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_K</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇒ 'a ⇒ 'b"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⟨_⟩"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟨f⟩ ≡ λs. f"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_not</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ bool) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">¬</span>"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">¬</span>a ≡ λs. ¬a s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_conj</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ bool) ⇒ ('a ⇒ bool) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∧</span>"</span></span></span><span> </span><span>35</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∧</span> b ≡ λs. a s ∧ b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_disj</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ bool) ⇒ ('a ⇒ bool) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∨</span>"</span></span></span><span> </span><span>30</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∨</span> b ≡ λs. a s ∨ b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_implies</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ bool) ⇒ ('a ⇒ bool) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">⟶</span>"</span></span></span><span> </span><span>25</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">⟶</span> b ≡ λs. a s ⟶ b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_eq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) ⇒ ('a ⇒ 'b) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">=</span>"</span></span></span><span> </span><span>40</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">=</span> b ≡ λs. a s = b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_member</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) ⇒ ('a ⇒ 'b set) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∈</span>"</span></span></span><span> </span><span>40</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∈</span> b ≡ λs. a s ∈ b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_neq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) ⇒ ('a ⇒ 'b) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">≠</span>"</span></span></span><span> </span><span>40</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">≠</span> b ≡ λs. a s ≠ b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_If</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ bool) ⇒ ('a ⇒ 'b) ⇒ ('a ⇒ 'b) ⇒ 'a ⇒ 'b"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(If (_)/ Then (_)/ Else (_))"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>10</span><span class="delimiter">]</span><span> </span><span>10</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"If P Then x Else y ≡ λs. if P s then x s else y s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_less</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b::ord) ⇒ ('a ⇒ 'b) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">&lt;</span>"</span></span></span><span> </span><span>40</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">&lt;</span> b ≡ λs. a s &lt; b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_le</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b::ord) ⇒ ('a ⇒ 'b) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">≤</span>"</span></span></span><span> </span><span>40</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">≤</span> b ≡ λs. a s ≤ b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_plus</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b::plus) ⇒ ('a ⇒ 'b) ⇒ 'a ⇒ 'b"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">+</span>"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">+</span> b ≡ λs. a s + b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_minus</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b::minus) ⇒ ('a ⇒ 'b) ⇒ 'a ⇒ 'b"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">-</span>"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">-</span> b ≡ λs. a s - b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>fun_fanout</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) ⇒ ('a ⇒ 'c) ⇒ 'a ⇒ 'b × 'c"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">⨝</span>"</span></span></span><span> </span><span>35</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f <span class="hidden">❙</span><span class="bold">⨝</span> g ≡ λx. (f x, g x)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_all</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'a ⇒ bool) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">binder</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∀</span>"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∀</span>x. P x ≡ λs. ∀x. P x s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_ex</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'a ⇒ bool) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">binder</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∃</span>"</span></span></span><span> </span><span>10</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∃</span>x. P x ≡ λs. ∃x. P x s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_app</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('b ⇒ 'a ⇒ 'c) ⇒ ('a ⇒ 'b) ⇒ 'a ⇒ 'c"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">$</span>"</span></span></span><span> </span><span>100</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"f <span class="hidden">❙</span><span class="bold">$</span> g ≡ λs. f (g s) s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_subseteq</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b set) ⇒ ('a ⇒ 'b set) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infix</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">⊆</span>"</span></span></span><span> </span><span>50</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"A <span class="hidden">❙</span><span class="bold">⊆</span> B ≡ λs. A s ⊆ B s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_union</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b set) ⇒ ('a ⇒ 'b set) ⇒ 'a ⇒ 'b set"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">∪</span>"</span></span></span><span> </span><span>65</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">∪</span> b ≡ λs. a s ∪ b s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

More application specific.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_conjoin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ bool) list ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pred_conjoin xs ≡ foldr (<span class="hidden">❙</span><span class="bold">∧</span>) xs ⟨True⟩"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_is_none</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b option) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"NULL _"</span></span></span><span> </span><span class="delimiter">[</span><span>40</span><span class="delimiter">]</span><span> </span><span>40</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"NULL a ≡ λs. a s = None"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_empty</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b set) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"EMPTY _"</span></span></span><span> </span><span class="delimiter">[</span><span>40</span><span class="delimiter">]</span><span> </span><span>40</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"EMPTY a ≡ λs. a s = {}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_list_null</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b list) ⇒ 'a ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"LIST'_NULL _"</span></span></span><span> </span><span class="delimiter">[</span><span>40</span><span class="delimiter">]</span><span> </span><span>40</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"LIST_NULL a ≡ λs. a s = []"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_pair</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) ⇒ ('a ⇒ 'c) ⇒ 'a ⇒ 'b × 'c"</span></span></span><span> </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"<span class="hidden">❙</span><span class="bold">⊗</span>"</span></span></span><span> </span><span>60</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"a <span class="hidden">❙</span><span class="bold">⊗</span> b ≡ λs. (a s, b s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>pred_singleton</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) ⇒ 'a ⇒ 'b set"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pred_singleton x ≡ λs. {x s}"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="CIMP_lang">
<div class="head"><h1>Theory CIMP_lang</h1>
<span class="command">theory</span> <span class="name">CIMP_lang</span><br/>
<span class="keyword">imports</span> <a href="CIMP_pred.html"><span class="name">CIMP_pred</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CIMP_lang</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CIMP_pred</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹CIMP syntax and semantics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:cimp-syntax-semantics}

We define a small sequential programming language with synchronous
message passing primitives for describing the individual
processes. This has the advantage over raw transition systems in that
it is programmer-readable, includes sequential composition, supports a
program logic and VCG (\S\ref{sec:cimp-vcg}), etc. These processes are
composed in parallel at the top-level.

CIMP is inspired by IMP, as presented by @{cite [cite_macro=citet]
"Winskel:1993"} and @{cite [cite_macro=citet]
"ConcreteSemantics:2014"}, and the classical process algebras CCS
@{cite [cite_macro=citep] "Milner:1980" and "Milner:1989"} and CSP
@{cite [cite_macro=citep] "Hoare:1985"}. Note that the algebraic
properties of this language have not been developed.

As we operate in a concurrent setting, we need to provide a small-step
semantics (\S\ref{sec:cimp-semantics}), which we give in the style of
\emph{structural operational semantics} (SOS) as popularised by @{cite
[cite_macro=citet] "DBLP:journals/jlp/Plotkin04"}. The semantics of a
complete system (\S\ref{sec:cimp-system-steps}) is presently taken
simply to be the states reachable by interleaving the enabled steps of
the individual processes, subject to message passing rendezvous. We
leave a trace or branching semantics to future work.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Syntax›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Programs are represented using an explicit (deep embedding) of their
syntax, as the semantics needs to track the progress of multiple
threads of control. Each (atomic) \emph{basic command}
(\S\ref{sec:cimp-decompose}) is annotated with a @{typ "'location"},
which we use in our assertions (\S\ref{sec:cimp-control-predicates}).
These locations need not be unique, though in practice they likely
will be.

Processes maintain \emph{local states} of type @{typ "'state"}. These
can be updated with arbitrary relations of @{typ "'state ⇒ 'state
set"} with ‹LocalOp›, and conditions of type @{typ "'s ⇒
bool"} are similarly shallowly embedded. This arrangement allows the
end-user to select their own level of atomicity.

The sequential composition operator and control constructs are
standard. We add the infinite looping construct ‹Loop› so we
can construct single-state reactive systems; this has implications for
fairness assertions.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">'s</span><span> </span><span>bexp</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'s ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>com</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span>Request</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'location"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'question"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'answer ⇒ 'state ⇒ 'state set"</span></span></span><span>        </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ Request _ _"</span></span></span><span>  </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>70</span><span class="delimiter">,</span><span> </span><span>70</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Response</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'question ⇒ 'state ⇒ ('state × 'answer) set"</span></span></span><span>               </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ Response _"</span></span></span><span>  </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>70</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>LocalOp</span><span>  </span><span class="string"><span class="delete"><span class="delete">"'location"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'state ⇒ 'state set"</span></span></span><span>                                       </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ LocalOp _"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>70</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Cond1</span><span>    </span><span class="string"><span class="delete"><span class="delete">"'location"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'state bexp"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ IF _ THEN _ FI"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Cond2</span><span>    </span><span class="string"><span class="delete"><span class="delete">"'location"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'state bexp"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com"</span></span></span><span>
</span><span>                           </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com"</span></span></span><span>             </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ IF _/ THEN _/ ELSE _/ FI"</span></span></span><span>  </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Loop</span><span>     </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com"</span></span></span><span>                           </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"LOOP DO _/ OD"</span></span></span><span>  </span><span class="delimiter">[</span><span>0</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>While</span><span>    </span><span class="string"><span class="delete"><span class="delete">"'location"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"'state bexp"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ WHILE _/ DO _/ OD"</span></span></span><span>  </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Seq</span><span>      </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com"</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com"</span></span></span><span>                           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixr</span></span><span> </span><span class="string"><span class="delete"><span class="delete">";;"</span></span></span><span> </span><span>69</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Choose</span><span>   </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com"</span></span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com"</span></span></span><span>                           </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">infixl</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⊔"</span></span></span><span> </span><span>68</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We provide a one-armed conditional as it is the common form and avoids
the need to discover a label for an internal ‹SKIP› and/or
trickier proofs about the VCG.

In contrast to classical process algebras, we have local state and
distinct send and receive actions. These provide an interface to
Isabelle/HOL's datatypes that avoids the need for binding (ala the
$\pi$-calculus of @{cite [cite_macro=citet] "Milner:1989"}) or large
non-deterministic sums (ala CCS @{cite [cite_macro=citep] ‹\S2.8›
"Milner:1980"}). Intuitively the sender asks a @{typ "'question"} with
a ‹Request› command, which upon rendezvous with a
receiver's ‹Response› command receives an @{typ
"'answer"}. The @{typ "'question"} is a deterministic function of the
sender's local state, whereas a receiver can respond
non-deterministically. Note that CIMP does not provide a notion of
channel; these can be modelled by a judicious choice of @{typ
"'question"}.

We also provide a binary external choice operator. Internal choice can
be recovered in combination with local operations (see @{cite
[cite_macro=citet] ‹\S2.3› "Milner:1980"}).

We abbreviate some common commands: ‹SKIP› is a local
operation that does nothing, and the floor brackets simplify
deterministic ‹LocalOp›s. We also adopt some syntax magic from
Makarius's Hoare and Multiquote theories in the Isabelle/HOL
distribution.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>SKIP_syn</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄/ SKIP"</span></span></span><span> </span><span>70</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ SKIP ≡ ⦃l⦄ LocalOp (λs. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>DetLocalOp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location ⇒ ('state ⇒ 'state)
                                  ⇒ ('answer, 'location, 'question, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄ ⌊_⌋"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ⌊f⌋ ≡ ⦃l⦄ LocalOp (λs. {f s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">syntax</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_quote"</span></span></span><span>        </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'b ⇒ ('a ⇒ 'b)"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"«_»"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_antiquote"</span></span></span><span>    </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b) ⇒ 'b"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"´_"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_Assign"</span></span></span><span>       </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location ⇒ idt ⇒ 'b ⇒ ('answer, 'location, 'question, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(⦃_⦄ ´_ :=/ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>70</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* FIXME precedence -- see massive ambiguities in the GC model *)</span></span></span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"_NonDetAssign"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location ⇒ idt ⇒ 'b set ⇒ ('answer, 'location, 'question, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"(⦃_⦄ ´_ :∈/ _)"</span></span></span><span> </span><span class="delimiter">[</span><span>0</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>70</span><span class="delimiter">]</span><span> </span><span>71</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>NonDetAssign</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location ⇒ (('val ⇒ 'val) ⇒ 'state ⇒ 'state) ⇒ ('state ⇒ 'val set)
                                   ⇒ ('answer, 'location, 'question, 'state) com"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"NonDetAssign l upd es ≡ ⦃l⦄ LocalOp (λs. { upd ⟨e⟩ s |e. e ∈ es s })"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">translations</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ´x := e"</span></span></span><span> </span><span class="delimiter">=&gt;</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST DetLocalOp l «´(_update_name x (λ_. e))»"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ´x :∈ es"</span></span></span><span> </span><span class="delimiter">=&gt;</span><span> </span><span class="string"><span class="delete"><span class="delete">"CONST NonDetAssign l (_update_name x) «es»"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">parse_translation</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">‹
  let
    fun antiquote_tr i (Const (@{syntax_const "_antiquote"}, _) $
          (t as Const (@{syntax_const "_antiquote"}, _) $ _)) = skip_antiquote_tr i t
      | antiquote_tr i (Const (@{syntax_const "_antiquote"}, _) $ t) =
          antiquote_tr i t $ Bound i
      | antiquote_tr i (t $ u) = antiquote_tr i t $ antiquote_tr i u
      | antiquote_tr i (Abs (x, T, t)) = Abs (x, T, antiquote_tr (i + 1) t)
      | antiquote_tr _ a = a
    and skip_antiquote_tr i ((c as Const (@{syntax_const "_antiquote"}, _)) $ t) =
          c $ skip_antiquote_tr i t
      | skip_antiquote_tr i t = antiquote_tr i t;

    fun quote_tr [t] = Abs ("s", dummyT, antiquote_tr 0 (Term.incr_boundvars 1 t))
      | quote_tr ts = raise TERM ("quote_tr", ts);
  in [(@{syntax_const "_quote"}, K quote_tr)] end
›</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Process semantics›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:cimp-semantics}

Here we define the semantics of a single process's program. We begin
by defining the type of externally-visible behaviour:

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">)</span><span> </span><span>seq_label</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span>sl_Internal</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"τ"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>sl_Send</span><span> </span><span class="tfree">'question</span><span> </span><span class="tfree">'answer</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"«_, _»"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>sl_Receive</span><span> </span><span class="tfree">'question</span><span> </span><span class="tfree">'answer</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"»_, _«"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We define a \emph{labelled transition system} (an LTS) using an
execution-stack style of semantics that avoids special treatment of
the ‹SKIP›s introduced by a traditional small step
semantics (such as @{cite [cite_macro=citet] ‹Chapter~14›
"Winskel:1993"}) when a basic command is executed. This was suggested
by Thomas Sewell; @{cite [cite_macro=citet] "PittsAM:opespe"} gave a
semantics to an ML-like language using this approach.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>local_state</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com list × 'state"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>small_step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) local_state
               ⇒ ('answer, 'question) seq_label
               ⇒ ('answer, 'location, 'question, 'state) local_state ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ →<span class="hidden">⇘</span><sub>_<span class="hidden">⇙</span></sub> _"</span></span></span><span> </span><span class="delimiter">[</span><span>55</span><span class="delimiter">,</span><span> </span><span>0</span><span class="delimiter">,</span><span> </span><span>56</span><span class="delimiter">]</span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>Request</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ α = action s; s' ∈ val β s ⟧ ⟹ (⦃l⦄ Request action val # cs, s) →<span class="hidden">⇘</span><sub>«α, β»<span class="hidden">⇙</span></sub> (cs, s')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Response</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s', β) ∈ action α s ⟹ (⦃l⦄ Response action # cs, s) →<span class="hidden">⇘</span><sub>»α, β«<span class="hidden">⇙</span></sub> (cs, s')"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>LocalOp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s' ∈ R s ⟹ (⦃l⦄ LocalOp R # cs, s) →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> (cs, s')"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Cond1True</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"b s ⟹ (⦃l⦄ IF b THEN c FI # cs, s) →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> (c # cs, s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Cond1False</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬b s ⟹ (⦃l⦄ IF b THEN c FI # cs, s) →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> (cs, s)"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Cond2True</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">"b s ⟹ (⦃l⦄ IF b THEN c1 ELSE c2 FI # cs, s) →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> (c1 # cs, s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Cond2False</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬b s ⟹ (⦃l⦄ IF b THEN c1 ELSE c2 FI # cs, s) →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> (c2 # cs, s)"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Loop</span><span class="delimiter">:</span><span>       </span><span class="string"><span class="delete"><span class="delete">"(c # LOOP DO c OD # cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> (cs', s') ⟹ (LOOP DO c OD # cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> (cs', s')"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>While</span><span class="delimiter">:</span><span>      </span><span class="string"><span class="delete"><span class="delete">"b s ⟹ (⦃l⦄ WHILE b DO c OD # cs, s) →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> (c # ⦃l⦄ WHILE b DO c OD # cs, s)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>WhileFalse</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"¬ b s ⟹ (⦃l⦄ WHILE b DO c OD # cs, s) →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> (cs, s)"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Seq</span><span class="delimiter">:</span><span>     </span><span class="string"><span class="delete"><span class="delete">"(c1 # c2 # cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> (cs', s') ⟹ (c1;; c2 # cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> (cs', s')"</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Choose1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c1 # cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> (cs', s') ⟹ (c1 ⊔ c2 # cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> (cs', s')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Choose2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c2 # cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> (cs', s') ⟹ (c1 ⊔ c2 # cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> (cs', s')"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The following projections operate on local states. These are internal
to CIMP and should not appear to the end-user.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>cPGM</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) local_state ⇒ ('answer, 'location, 'question, 'state) com list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cPGM ≡ fst"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>cLST</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) local_state ⇒ 'state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"cLST s ≡ snd s"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>small_step.intros</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>small_step_inv</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⦃l⦄ Request action val # cs, ls) →<span class="hidden">⇘</span><sub>a<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⦃l⦄ Response action # cs, ls) →<span class="hidden">⇘</span><sub>a<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⦃l⦄ LocalOp R # cs, ls) →<span class="hidden">⇘</span><sub>a<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⦃l⦄ IF b THEN c FI # cs, ls) →<span class="hidden">⇘</span><sub>a<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⦃l⦄ IF b THEN c1 ELSE c2 FI # cs, ls) →<span class="hidden">⇘</span><sub>a<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(⦃l⦄ WHILE b DO c OD # cs, ls) →<span class="hidden">⇘</span><sub>a<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(LOOP DO c OD # cs, ls) →<span class="hidden">⇘</span><sub>a<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>small_step_impossible</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ Request action val # cs, ls) →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ Request action val # cs, ls) →<span class="hidden">⇘</span><sub>»α, β«<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ Response action' # cs, ls) →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ Response action' # cs, ls) →<span class="hidden">⇘</span><sub>«α, β»<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ LocalOp R # cs, ls) →<span class="hidden">⇘</span><sub>»α, β«<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ LocalOp R # cs, ls) →<span class="hidden">⇘</span><sub>«α, β»<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ IF b THEN c FI # cs, ls) →<span class="hidden">⇘</span><sub>»α, β«<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ IF b THEN c FI # cs, ls) →<span class="hidden">⇘</span><sub>«α, β»<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ IF b THEN c1 ELSE c2 FI # cs, ls) →<span class="hidden">⇘</span><sub>»α, β«<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ IF b THEN c1 ELSE c2 FI # cs, ls) →<span class="hidden">⇘</span><sub>«α, β»<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ WHILE b DO c OD # cs, ls) →<span class="hidden">⇘</span><sub>»α, β«<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬(⦃l⦄ WHILE b DO c OD # cs, ls) →<span class="hidden">⇘</span><sub>«α, β»<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>small_step.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>small_step_stuck</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬ ([], l, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> c'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>small_step.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:cimp-decompose}

To reason about system transitions we need to identify which basic
statement gets executed next. To that end we factor out the recursive
cases of the @{term "small_step"} semantics into \emph{contexts},
which identify the ‹basic_com› commands with immediate
externally-visible behaviour. Note that non-determinism means that
more than one ‹basic_com› can be enabled at a time.

The representation of evaluation contexts follows @{cite
[cite_macro=citet] "DBLP:journals/jar/Berghofer12"}. This style of
operational semantics was originated by @{cite [cite_macro=citet]
"DBLP:journals/tcs/FelleisenH92"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>ctxt</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com ⇒ ('answer, 'location, 'question, 'state) com"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>ctxt</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"( ('answer, 'location, 'question, 'state) ctxt
           × (('answer, 'location, 'question, 'state) com ⇒ ('answer, 'location, 'question, 'state) com list) ) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>C_Hole</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(id, ⟨[]⟩) ∈ ctxt"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>C_Loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(E, fctxt) ∈ ctxt ⟹ (λt. LOOP DO E t OD, λt. fctxt t @ [LOOP DO E t OD]) ∈ ctxt"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>C_Seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(E, fctxt) ∈ ctxt ⟹ (λt. E t;; u, λt. fctxt t @ [u]) ∈ ctxt"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>C_Choose1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(E, fctxt) ∈ ctxt ⟹ (λt. E t ⊔ u, fctxt) ∈ ctxt"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>C_Choose2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(E, fctxt) ∈ ctxt ⟹ (λt. u ⊔ E t, fctxt) ∈ ctxt"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>basic_com</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"basic_com (⦃l⦄ Request action val)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"basic_com (⦃l⦄ Response action)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"basic_com (⦃l⦄ LocalOp R)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"basic_com (⦃l⦄ IF b THEN c FI)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"basic_com (⦃l⦄ IF b THEN c1 ELSE c2 FI)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"basic_com (⦃l⦄ WHILE b DO c OD)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>basic_com.intros</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>basic_com.cases</span><span class="delimiter">[</span><span>elim</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We can decompose a small step into a context and a @{term
"basic_com"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>
</span><span>  </span><span>decompose_com</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com
                      ⇒ ( ('answer, 'location, 'question, 'state) com
                        × ('answer, 'location, 'question, 'state) ctxt
                        × (('answer, 'location, 'question, 'state) com ⇒ ('answer, 'location, 'question, 'state) com list) ) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"decompose_com (LOOP DO c1 OD) = { (c, λt. LOOP DO ictxt t OD, λt. fctxt t @ [LOOP DO ictxt t OD]) |c fctxt ictxt. (c, ictxt, fctxt) ∈ decompose_com c1 }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"decompose_com (c1;; c2) = { (c, λt. ictxt t;; c2, λt. fctxt t @ [c2]) |c fctxt ictxt. (c, ictxt, fctxt) ∈ decompose_com c1 }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"decompose_com (c1 ⊔ c2) = { (c, λt. ictxt t ⊔ c2, fctxt) |c fctxt ictxt. (c, ictxt, fctxt) ∈ decompose_com c1 }
                           ∪ { (c, λt. c1 ⊔ ictxt t, fctxt) |c fctxt ictxt. (c, ictxt, fctxt) ∈ decompose_com c2 }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"decompose_com c = {(c, id, ⟨[]⟩)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>decomposeLS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) local_state
               ⇒ ( ('answer, 'location, 'question, 'state) com
                 × (('answer, 'location, 'question, 'state) com ⇒ ('answer, 'location, 'question, 'state) com)
                 × (('answer, 'location, 'question, 'state) com ⇒ ('answer, 'location, 'question, 'state) com list) ) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"decomposeLS s ≡ case cPGM s of c # _ ⇒ decompose_com c | _ ⇒ {}"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">declare</span></span><span> </span><span>ctxt.intros</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">!</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ctxt_inj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(E, fctxt) ∈ ctxt"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"E x = E y"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"x = y"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>ctxt</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decompose_ctxt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c', ictxt, fctxt) ∈ decompose_com c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(ictxt, fctxt) ∈ ctxt"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>c'</span><span> </span><span>ictxt</span><span> </span><span>fctxt</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decompose_ictxt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c', ictxt, fctxt) ∈ decompose_com c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"c = ictxt c'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>c'</span><span> </span><span>ictxt</span><span> </span><span>fctxt</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>context_decompose</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> s' ⟷ (∃(c, ictxt, fctxt) ∈ decomposeLS s.
                     cPGM s = ictxt c # tl (cPGM s)
                   ∧ basic_com c
                   ∧ (c # fctxt c @ tl (cPGM s), cLST s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> s')"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"?lhs = ?rhs"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?lhs</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?rhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>small_step.induct</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>decomposeLS_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>gen</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c0 # cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>as</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c # fctxt c @ cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>ds</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(c, ictxt, fctxt) ∈ decompose_com c0"</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>cs</span><span> </span><span>c</span><span> </span><span>c0</span><span> </span><span>ictxt</span><span> </span><span>fctxt</span><span> </span><span>l</span><span> </span><span>s</span><span> </span><span>s'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ds</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ic</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ictxt, fctxt) ∈ ctxt"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>decomposeLS_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>decompose_ctxt</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ic</span><span> </span><span>as</span><span> </span><span>decompose_ictxt</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ds</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c0 # cs, s) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ictxt</span><span> </span><span>fctxt</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>c0</span><span> </span><span>cs</span><span> </span><span>set</span><span class="delimiter">:</span><span> </span><span>ctxt</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s'</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>ctxt_inj</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="var">?rhs</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?lhs</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>decomposeLS_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>gen</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

While we only use this result left-to-right (to decompose a small step
into a basic one), this equivalence shows that we lose no information
in doing so.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹System steps›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:cimp-system-steps}

A global state maps process names to process' local states. One might
hope to allow processes to have distinct types of local state, but
there remains no good solution yet in a simply-typed setting; see
@{cite [cite_macro=citet] "DBLP:journals/entcs/SchirmerW09"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'proc</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>global_state</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proc ⇒ ('answer, 'location, 'question, 'state) local_state"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'proc</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>local_states</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proc ⇒ 'state"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

An execution step of the overall system is either any enabled internal
@{term "τ"} step of any process, or a communication rendezvous between
two processes. For the latter to occur, a @{const "Request"} action
must be enabled in process @{term "p1"}, and a @{const "Response"}
action in (distinct) process @{term "p2"}, where the request/response
labels @{term "α"} and @{term "β"} (semantically) match.

We also track global communication history here to support assertional
reasoning (see \S\ref{sec:cimp-assertions}).

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">)</span><span> </span><span>event</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'question × 'answer"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">)</span><span> </span><span>history</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'question) event list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'proc</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>system_state</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) global_state
   × ('answer, 'question) history"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span>
</span><span>  </span><span>system_step</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"( ('answer, 'ls, 'proc, 'question, 'state) system_state
                  × ('answer, 'ls, 'proc, 'question, 'state) system_state ) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>LocalStep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ s p →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> ls'; s' = s(p := ls'); h' = h ⟧ ⟹ ((s, h), (s', h')) ∈ system_step"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CommunicationStep</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ s p1 →<span class="hidden">⇘</span><sub>«α, β»<span class="hidden">⇙</span></sub> ls1'; s p2 →<span class="hidden">⇘</span><sub>»α, β«<span class="hidden">⇙</span></sub> ls2'; p1 ≠ p2;
                        s' = s(p1 := ls1', p2 := ls2'); h' = h @ [(α, β)] ⟧ ⟹ ((s, h), (s', h')) ∈ system_step"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>system_step_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'ls, 'proc, 'question, 'state) system_state
                    ⇒ ('answer, 'ls, 'proc, 'question, 'state) system_state ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ s⇒ _"</span></span></span><span> </span><span class="delimiter">[</span><span>55</span><span class="delimiter">,</span><span> </span><span>56</span><span class="delimiter">]</span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sh s⇒ sh' ≡ (sh, sh') ∈ system_step"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>system_steps_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'ls, 'proc, 'question, 'state) system_state
                     ⇒ ('answer, 'ls, 'proc, 'question, 'state) system_state ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_ s⇒<span class="hidden">⇧</span><sup>*</sup> _"</span></span></span><span> </span><span class="delimiter">[</span><span>55</span><span class="delimiter">,</span><span> </span><span>56</span><span class="delimiter">]</span><span> </span><span>55</span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"sh s⇒<span class="hidden">⇧</span><sup>*</sup> sh' ≡ (sh, sh') ∈ system_step<span class="hidden">⇧</span><sup>*</sup>"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

In classical process algebras matching communication actions yield
‹τ› steps, which aids nested parallel composition
and the restriction operation @{cite [cite_macro=citep]
‹\S2.2› "Milner:1980"}. As CIMP does not provide either
we do not need to hide communication labels. In CCS/CSP it is not
clear how one reasons about the communication history, and it seems
that assertional reasoning about these languages is not well
developed.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Assertions›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:cimp-assertions}

We now develop a technique for showing that a CIMP system satisfies a
single global invariant, following @{cite [cite_macro=citet]
"DBLP:journals/acta/Lamport80" and "DBLP:journals/toplas/LamportS84"}
(and the later @{cite [cite_macro=citet] "DBLP:books/aw/Lamport2002"})
and closely related work by @{cite [cite_macro=citet]
"AptFrancezDeRoever:1980"}, @{cite [cite_macro=citet]
"CousotCousot:1980"} and @{cite [cite_macro=citet]
"DBLP:journals/acta/LevinG81"}, which suggest the incorporation of a
history variable. @{cite [cite_macro=citet] "CousotCousot:1980"}
apparently contains a completeness proof.  Lamport mentions that this
technique was well-known in the mid-80s when he proposed the use of
prophecy variables (see his webpage bibliography). See also @{cite
[cite_macro=citet] "DBLP:books/cu/RoeverBH2001"} for an extended
discussion of some of this.

Achieving the right level of abstraction is a bit fiddly; we want to
avoid revealing too much of the program text as it
executes. Intuitively we wish to expose the processes's present
control locations and local states only. @{cite [cite_macro=citet]
"DBLP:journals/acta/Lamport80"} avoids these issues by only providing
an axiomatic semantics for his language.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Control predicates›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:cimp-control-predicates}

Following @{cite [cite_macro=citet]
"DBLP:journals/acta/Lamport80"}\footnote{@{cite [cite_macro=citet]
"MannaPnueli:1995"} also develop a theory of locations. I think
Lamport attributes control predicates to Owicki in her PhD thesis
(under Gries). I did not find a treatment of procedures. @{cite
[cite_macro=citet] "MannaPnueli:1991"} observe that a set notation for
spreading assertions over sets of locations reduces clutter
significantly.}, we define the ‹at› predicate, which
holds of a process when control resides at that location. Due to
non-determinism processes can be ‹at› a set of locations;
it is more like ``a statement with this location is enabled'', which
incidentally handles non-unique locations. Lamport's language is
deterministic, so he doesn't have this problem. This also allows him
to develop a stronger theory about his control predicates.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span>
</span><span>  </span><span>atC</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com ⇒ 'location ⇒ bool"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"atC (⦃l'⦄ Request action val) = (λl. l = l')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"atC (⦃l'⦄ Response action) = (λl. l = l')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"atC (⦃l'⦄ LocalOp f) = (λl. l = l')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"atC (⦃l'⦄ IF _ THEN _ FI) = (λl. l = l')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"atC (⦃l'⦄ IF _ THEN _ ELSE _ FI) = (λl. l = l')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"atC (⦃l'⦄ WHILE _ DO _ OD) = (λl. l = l')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"atC (LOOP DO c OD) = atC c"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"atC (c1;; c2) = atC c1"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"atC (c1 ⊔ c2) = (atC c1 <span class="hidden">❙</span><span class="bold">∨</span> atC c2)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>atL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com list ⇒ 'location ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"atL [] = ⟨False⟩"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"atL (c # _) = atC c"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>atLS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) local_state ⇒ 'location ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"atLS ≡ λs. atL (cPGM s)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>at_decompose</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(c, ictxt, fctxt) ∈ decompose_com c0 ⟹ (∀l. atC c l ⟶ atC c0 l)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c0</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>c</span><span> </span><span>ictxt</span><span> </span><span>fctxt</span><span class="delimiter">)</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>at_decomposeLS</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(c, ictxt, fctxt) ∈ decomposeLS s ⟹ (∀l. atC c l ⟶ atLS s l)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>decomposeLS_def</span><span> </span><span>at_decompose</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We define predicates over communication histories and a projection of
global states. These are uncurried to ease composition.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'proc</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>pred_local_state</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proc ⇒ (('location ⇒ bool) × 'state)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">record</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'proc</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>pred_state</span><span> </span><span class="delimiter">=</span><span>
</span><span>  </span><span>local_states</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('location, 'proc, 'state) pred_local_state"</span></span></span><span>
</span><span>  </span><span>hist</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'question) history"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'proc</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>pred</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) pred_state ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>mkP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) system_state ⇒ ('answer, 'location, 'proc, 'question, 'state) pred_state"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"mkP ≡ λ(s, h). ⦇ local_states = λp. case s p of (cs, ps) ⇒ (atL cs, ps), hist = h ⦈"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hist_mkP</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"hist (mkP (s, h)) = h"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>mkP_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We provide the following definitions to the end-user.

‹AT› maps process names to a predicate that is true of
locations where control for that process resides. The abbreviation
‹at› shuffles its parameters; the former is
simplifier-friendly and eta-reduced, while the latter is convenient
for writing assertions.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>AT</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) pred_state ⇒ 'proc ⇒ 'location ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"AT ≡ λs p l. fst (local_states s p) l"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>at</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proc ⇒ 'location ⇒ ('answer, 'location, 'proc, 'question, 'state) pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"at p l s ≡ AT s p l"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Often we wish to talk about control residing at one of a set of
locations. This stands in for, and generalises, the ‹in›
predicate of @{cite [cite_macro=citet]
"DBLP:journals/acta/Lamport80"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>atS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proc ⇒ 'location set ⇒ ('answer, 'location, 'proc, 'question, 'state) pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"atS ≡ λp ls s. ∃l∈ls. at p l s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

A process is terminated if it not at any control location.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>terminated</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proc ⇒ ('answer, 'location, 'proc, 'question, 'state) pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"terminated p s ≡ ∀l. ¬at p l s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The ‹LST› operator (written as a postfix ‹↓›) projects
the local states of the processes from a ‹pred_state›, i.e. it
discards control location information.

Conversely the ‹LSTP› operator lifts predicates over
local states into predicates over ‹pred_state›.  @{cite
[cite_macro=citet] ‹\S3.6› "DBLP:journals/acta/LevinG81"}
call such predicates \emph{universal assertions}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'proc</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>state_pred</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('proc, 'state) local_states ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>LST</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) pred_state
                 ⇒ ('proc, 'state) local_states"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_↓"</span></span></span><span> </span><span class="delimiter">[</span><span>1000</span><span class="delimiter">]</span><span> </span><span>1000</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s↓ ≡ snd ∘ local_states s"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span> </span><span>LSTP</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('proc, 'state) state_pred
                            ⇒ ('answer, 'location, 'proc, 'question, 'state) pred"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"LSTP P ≡ λs. P (LST s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

By default we ask the simplifier to rewrite @{const "atS"} using
ambient @{const "AT"} information.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atS_state_cong</span><span class="delimiter">[</span><span>cong</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ AT s p = AT s' p ⟧ ⟹ atS p ls s ⟷ atS p ls s'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We provide an incomplete set of basic rules for label sets.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atS_simps</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"¬atS p {} s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"atS p {l} s ⟷ at p l s"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ at p l s; l ∈ ls ⟧ ⟹ atS p ls s ⟷ True"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀l. at p l s ⟶ l ∉ ls) ⟹ atS p ls s ⟷ False"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atS_mono</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ atS p ls s; ls ⊆ ls' ⟧ ⟹ atS p ls' s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>atS_un</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"atS p (l ∪ l') s ⟷ atS p l s ∨ atS p l' s"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Invariants›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:cimp-invariants}

A complete system consists of one program per process, and a (global)
constraint on their initial local states. From these we can construct
the set of initial global states and all those reachable by system
steps (\S\ref{sec:cimp-system-steps}).

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'proc</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>programs</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proc ⇒ ('answer, 'location, 'question, 'state) com"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'proc</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>system</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) programs
   × ('proc, 'state) state_pred"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>initial_states</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) system
                   ⇒ ('answer, 'location, 'proc, 'question, 'state) global_state set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"initial_states sys ≡
     { f . (∀p. cPGM (f p) = [fst sys p]) ∧ snd sys (cLST ∘ f) }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>reachable_states</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) system
                     ⇒ ('answer, 'location, 'proc, 'question, 'state) system_state set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"reachable_states sys ≡ system_step<span class="hidden">⇧</span><sup>*</sup> `` (initial_states sys × {[]})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The following is a slightly more convenient induction rule for the set
of reachable states.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_states_system_step_induct</span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">,</span><span>
</span><span>                                          </span><span>case_names</span><span> </span><span>init</span><span> </span><span>LocalStep</span><span> </span><span>CommunicationStep</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>r</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, h) ∈ reachable_states sys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>i</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. s ∈ initial_states sys ⟹ P s []"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>l</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s h ls' p. ⟦ (s, h) ∈ reachable_states sys; P s h; s p →<span class="hidden">⇘</span><sub>τ<span class="hidden">⇙</span></sub> ls' ⟧
                    ⟹ P (s(p := ls')) h"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s h ls1' ls2' p1 p2 α β.
                 ⟦ (s, h) ∈ reachable_states sys; P s h;
                 s p1 →<span class="hidden">⇘</span><sub>«α, β»<span class="hidden">⇙</span></sub> ls1'; s p2 →<span class="hidden">⇘</span><sub>»α, β«<span class="hidden">⇙</span></sub> ls2'; p1 ≠ p2 ⟧
                    ⟹ P (s(p1 := ls1', p2 := ls2')) (h @ [(α, β)])"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P s h"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"P s' h'"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, []) s⇒<span class="hidden">⇧</span><sup>*</sup> (s', h')"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ initial_states sys"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s</span><span> </span><span>s'</span><span> </span><span>h'</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>that</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct2</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_states_def</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>system_step.cases</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>i</span><span> </span><span>l</span><span> </span><span>c</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>r</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_states_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>initial_statesD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ∈ initial_states sys ⟹ AT (mkP (s, [])) = atC ∘ fst sys ∧ snd sys (mkP (s, []))↓"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>initial_states_def</span><span> </span><span>mkP_def</span><span> </span><span>split_def</span><span> </span><span>o_def</span><span> </span><span>LST_def</span><span> </span><span>AT_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>initial_states_mkP</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"s ∈ initial_states sys ⟹ at p l (mkP (s, [])) ⟷ atC (fst sys p) l"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>initial_states_def</span><span> </span><span>mkP_def</span><span> </span><span>split_def</span><span> </span><span>AT_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Relating reachable states to the initial programs›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:cimp-decompose-small-step}

To usefully reason about the control locations presumably embedded in
the single global invariant, we need to link the programs we have in
reachable state ‹s› to the programs in the initial states. The
‹fragments› function decomposes the program into statements
that can be directly executed (\S\ref{sec:cimp-decompose}). We also
compute the locations we could be at after executing that statement as
a function of the process's local state.

We could support Lamport's ‹after› control predicate with more
syntactic analysis of this kind.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>
</span><span>  </span><span>extract_cond</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com ⇒ 'state bexp"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"extract_cond (⦃l⦄ IF b THEN c FI) = b"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_cond (⦃l⦄ IF b THEN c1 ELSE c2 FI) = b"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_cond (⦃l⦄ WHILE b DO c OD) = b"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_cond c = ⟨False⟩"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span>  </span><span class="delimiter">(</span><span class="tfree">'answer</span><span class="delimiter">,</span><span> </span><span class="tfree">'location</span><span class="delimiter">,</span><span> </span><span class="tfree">'question</span><span class="delimiter">,</span><span> </span><span class="tfree">'state</span><span class="delimiter">)</span><span> </span><span>loc_comp</span><span>
</span><span>  </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com
   ⇒ 'state ⇒ 'location ⇒ bool"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>lconst</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('location ⇒ bool) ⇒ ('answer, 'location, 'question, 'state) loc_comp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lconst lp b s = lp"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lcond</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('location ⇒ bool) ⇒ ('location ⇒ bool)
                   ⇒ ('answer, 'location, 'question, 'state) loc_comp"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"lcond lp lp' c s ≡ if extract_cond c s then lp else lp'"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcond_split</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Q (lcond lp lp' c s) ⟷ (extract_cond c s ⟶ Q lp) ∧ (¬extract_cond c s ⟶ Q lp')"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lcond_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lcond_split_asm</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Q (lcond lp lp' c s) ⟷ ¬ ((extract_cond c s ∧ ¬Q lp) ∨ (¬extract_cond c s ∧ ¬ Q lp'))"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lcond_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>lcond_splits</span><span> </span><span class="delimiter">=</span><span> </span><span>lcond_split</span><span> </span><span>lcond_split_asm</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>
</span><span>  </span><span>fragments</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com
              ⇒ ('location ⇒ bool)
              ⇒ ( ('answer, 'location, 'question, 'state) com
               × ('answer, 'location, 'question, 'state) loc_comp ) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fragments (⦃l⦄ IF b THEN c FI) ls
       = { (⦃l⦄ IF b THEN c' FI, lcond (atC c) ls) |c'. True }
        ∪ fragments c ls"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fragments (⦃l⦄ IF b THEN c1 ELSE c2 FI) ls
       = { (⦃l⦄ IF b THEN c1' ELSE c2' FI, lcond (atC c1) (atC c2)) |c1' c2'. True }
        ∪ fragments c1 ls ∪ fragments c2 ls"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fragments (LOOP DO c OD) ls = fragments c (atC c)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fragments (⦃l'⦄ WHILE b DO c OD) ls
       = { (⦃l'⦄ WHILE b DO c' OD, lcond (atC c) ls) |c'. True } ∪ fragments c (λl. l = l')"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fragments (c1;; c2) ls = fragments c1 (atC c2) ∪ fragments c2 ls"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fragments (c1 ⊔ c2) ls = fragments c1 ls ∪ fragments c2 ls"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fragments c ls = { (c, lconst ls) }"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>
</span><span>  </span><span>fragmentsL</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com list
               ⇒ ( ('answer, 'location, 'question, 'state) com
                 × ('answer, 'location, 'question, 'state) loc_comp ) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fragmentsL [] = {}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fragmentsL [c] = fragments c ⟨False⟩"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"fragmentsL (c # c' # cs) = fragments c (atC c') ∪ fragmentsL (c' # cs)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>fragmentsLS</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) local_state
               ⇒ ( ('answer, 'location, 'question, 'state) com
                 × ('answer, 'location, 'question, 'state) loc_comp ) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fragmentsLS s ≡ fragmentsL (cPGM s)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fragmentsL_mono_Cons</span><span class="delimiter">[</span><span>iff</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"fragmentsL cs ⊆ fragmentsL (c # cs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>small_step_fragmentsLS</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> s'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fragmentsLS s' ⊆ fragmentsLS s"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>small_step.induct</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="delimiter">[</span><span class="delimiter">!</span><span class="delimiter">]</span><span> </span><span>cs</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>small_step_fragmentsLS_mem</span><span> </span><span class="delimiter">=</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>small_step_fragmentsLS</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Eliding the bodies of ‹IF› and ‹WHILE› statements
yields smaller (but equivalent) proof obligations.

We show that taking system steps preserves fragments.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reachable_states_fragmentsLS</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, h) ∈ reachable_states sys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"fragmentsLS (s p) ⊆ fragments (fst sys p) ⟨False⟩"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>reachable_states_system_step_induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>initial_states_def</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>small_step_fragmentsLS_mem</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Decomposing a compound command preserves fragments too.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>
</span><span>  </span><span>extract_inner_locations</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com
                            ⇒ ('answer, 'location, 'question, 'state) com list
                            ⇒ ('answer, 'location, 'question, 'state) loc_comp"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"extract_inner_locations (⦃l⦄ IF b THEN c FI) cs = lcond (atC c) (atL cs)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_inner_locations (⦃l⦄ IF b THEN c1 ELSE c2 FI) cs = lcond (atC c1) (atC c2)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_inner_locations (LOOP DO c OD) cs = lconst (atC c)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_inner_locations (⦃l⦄ WHILE b DO c OD) cs = lcond (atC c) (atL cs)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_inner_locations c cs = lconst (atL cs)"</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decompose_fragments</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c, ictxt, fctxt) ∈ decompose_com c0"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c, extract_inner_locations c (fctxt c @ cs)) ∈ fragments c0 (atL cs)"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>c0</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>c</span><span> </span><span>ictxt</span><span> </span><span>fctxt</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Loop</span><span> </span><span>c01</span><span> </span><span>c</span><span> </span><span>ictxt</span><span> </span><span>fctxt</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Loop.prems</span><span> </span><span>Loop.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cs</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"ictxt c # cs"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>decompose_ictxt</span><span class="delimiter">[</span><span>symmetric</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seq</span><span> </span><span>c01</span><span> </span><span>c02</span><span> </span><span>c</span><span> </span><span>ictxt</span><span> </span><span>fctxt</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Seq.prems</span><span> </span><span>Seq.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cs</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"c02 # cs"</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>decomposeLS_fragmentsLS</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c, ictxt, fctxt) ∈ decomposeLS s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c, extract_inner_locations c (fctxt c @ tl (cPGM s))) ∈ fragmentsLS s"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">"cPGM s"</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>d</span><span> </span><span>ds</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>assms</span><span> </span><span>decompose_fragments</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cs</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"ds"</span></span></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ds</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>decomposeLS_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>decomposeLS_def</span><span class="delimiter">)</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>small_step_extract_inner_locations</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"basic_com c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c # cs, ls) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> ls'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"extract_inner_locations c cs c ls = atLS ls'"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>lcond_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The headline result allows us to constrain the initial and final states
of a given small step in terms of the original programs, provided the
initial state is reachable.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>decompose_small_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s p →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> ps'"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, h) ∈ reachable_states sys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">obtains</span></span><span> </span><span>c</span><span> </span><span>cs</span><span> </span><span>ls'</span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c, ls') ∈ fragments (fst sys p) ⟨False⟩"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"basic_com c"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"∀l. atC c l ⟶ atLS (s p) l"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"ls' c (cLST (s p)) = atLS ps'"</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(c # cs, cLST (s p)) →<span class="hidden">⇘</span><sub>α<span class="hidden">⇙</span></sub> ps'"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>iffD1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>context_decompose</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>decomposeLS_fragmentsLS</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>at_decomposeLS</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subsetD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>reachable_states_fragmentsLS</span><span class="delimiter">,</span><span> </span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>small_step_extract_inner_locations</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Reasoning with @{thm [source] "reachable_states_system_step_induct"}
and @{thm [source] "decompose_small_step"} is quite tedious. We
provide a very simple VCG that generates friendlier local proof
obligations.

›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="CIMP_vcg">
<div class="head"><h1>Theory CIMP_vcg</h1>
<span class="command">theory</span> <span class="name">CIMP_vcg</span><br/>
<span class="keyword">imports</span> <a href="CIMP_lang.html"><span class="name">CIMP_lang</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CIMP_vcg</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CIMP_lang</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Simple-minded Hoare Logic/VCG for CIMP›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:cimp-vcg}

We do not develop a proper Hoare logic or full VCG for CIMP: this
machinery merely packages up the subgoals that arise from induction
over the reachable states (\S\ref{sec:cimp-invariants}). This is
somewhat in the spirit of @{cite [cite_macro=citet] "Ridge:2009"}.

Note that this approach is not compositional: it consults the original
system to find matching communicating pairs, and ‹aft›
tracks the labels of possible successor statements. More serious Hoare
logics are provided by @{cite [cite_macro=citet]
"DBLP:journals/acta/Lamport80" and "DBLP:journals/toplas/LamportS84"
and "CousotCousot89-IC"}.

Intuitively we need to discharge a proof obligation for either @{const
"Request"}s or @{const "Response"}s but not both. Here we choose to
focus on @{const "Request"}s as we expect to have more local
information available about these.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>
</span><span>  </span><span>vcg</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) programs
        ⇒ 'proc
        ⇒ ('answer, 'location, 'question, 'state) loc_comp
        ⇒ ('answer, 'location, 'proc, 'question, 'state) pred
        ⇒ ('answer, 'location, 'question, 'state) com
        ⇒ ('answer, 'location, 'proc, 'question, 'state) pred
        ⇒ bool"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_, _, _ ⊨/ ⦃_⦄/ _/ ⦃_⦄"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>Request</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀aft' action' s ps' p's' l' β s' p'.
                 ⟦ pre s; (⦃l'⦄ Response action', aft') ∈ fragments (pgms p') ⟨False⟩; p ≠ p';
                   ps' ∈ val β (LST s p); (p's', β) ∈ action' (action (LST s p)) (LST s p');
                   at p l s; at p' l' s;
                   AT s' = (AT s)(p := aft (⦃l⦄ Request action val) (LST s p),
                                  p' := aft' (⦃l'⦄ Response action') (LST s p'));
                   LST s' = (LST s)(p := ps', p' := p's');
                   hist s' = hist s @ [(action (LST s p), β)]
                 ⟧ ⟹ post s'
            ⟧ ⟹ pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ Request action val ⦃post⦄"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>LocalOp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀s ps' s'. ⟦ pre s; ps' ∈ f (LST s p);
                           at p l s;
                           AT s' = (AT s)(p := aft (⦃l⦄ LocalOp f) (LST s p));
                           LST s' = (LST s)(p := ps');
                           hist s' = hist s
                         ⟧ ⟹ post s'
            ⟧ ⟹ pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ LocalOp f ⦃post⦄"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Cond1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀s s'. ⟦ pre s;
                     at p l s;
                     AT s' = (AT s)(p := aft (⦃l⦄ IF b THEN t FI) (LST s p));
                     LST s' = LST s;
                     hist s' = hist s
                   ⟧ ⟹ post s'
       ⟧ ⟹ pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ IF b THEN t FI ⦃post⦄"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Cond2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀s s'. ⟦ pre s;
                     at p l s;
                     AT s' = (AT s)(p := aft (⦃l⦄ IF b THEN t ELSE e FI) (LST s p));
                     LST s' = LST s;
                     hist s' = hist s
                   ⟧ ⟹ post s'
       ⟧ ⟹ pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ IF b THEN t ELSE e FI ⦃post⦄"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>While</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀s s'. ⟦ pre s;
                     at p l s;
                     AT s' = (AT s)(p := aft (⦃l⦄ WHILE b DO c OD) (LST s p));
                     LST s' = LST s;
                     hist s' = hist s
                   ⟧ ⟹ post s'
          ⟧ ⟹ pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ WHILE b DO c OD ⦃post⦄"</span></span></span><span>
</span><span class="comment">― ‹There are no proof obligations for the following commands.›</span><span>
</span><span class="delimiter">|</span><span> </span><span>Response</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ Response action ⦃post⦄"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ c1 ;; c2 ⦃post⦄"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Loop</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ LOOP DO c OD ⦃post⦄"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>Choose</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ c1 ⊔ c2 ⦃post⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We abbreviate invariance with one-sided validity syntax.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>valid_inv</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"_, _, _ ⊨/ ⦃_⦄/ _"</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃I⦄ c ≡ pgms, p, aft ⊨ ⦃I⦄ c ⦃I⦄"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>vcg_inv</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ Request action val ⦃post⦄"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ LocalOp f ⦃post⦄"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ IF b THEN t FI ⦃post⦄"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ IF b THEN t ELSE e FI ⦃post⦄"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ LOOP DO c OD ⦃post⦄"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ WHILE b DO c OD ⦃post⦄"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ ⦃l⦄ Response action ⦃post⦄"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ c1 ;; c2 ⦃post⦄"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"pgms, p, aft ⊨ ⦃pre⦄ c1 ⊔ c2 ⦃post⦄"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_precond_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"P = P' ⟹ (pgms, p, aft ⊨ ⦃P⦄ c ⦃Q⦄) ⟷ (pgms, p, aft ⊨ ⦃P'⦄ c ⦃Q⦄)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_postcond_cong</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Q = Q' ⟹ (pgms, p, aft ⊨ ⦃P⦄ c ⦃Q⦄) ⟷ (pgms, p, aft ⊨ ⦃P⦄ c ⦃Q'⦄)"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We tweak @{const "fragments"} by omitting @{const "Response"}s,
yielding fewer obligations.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span>
</span><span>  </span><span>vcg_fragments'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com
               ⇒ ('location ⇒ bool)
               ⇒ ( ('answer, 'location, 'question, 'state) com
                 × ('answer, 'location, 'question, 'state) loc_comp ) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vcg_fragments' (⦃l⦄ Response action) ls = {}"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"vcg_fragments' (⦃l⦄ IF b THEN c FI) ls
       = vcg_fragments' c ls
       ∪ { (⦃l⦄ IF b THEN c' FI, lcond (atC c) ls) |c'. True }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"vcg_fragments' (⦃l⦄ IF b THEN c1 ELSE c2 FI) ls
       = vcg_fragments' c2 ls ∪ vcg_fragments' c1 ls
       ∪ { (⦃l⦄ IF b THEN c1' ELSE c2' FI, lcond (atC c1) (atC c2)) |c1' c2'. True }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"vcg_fragments' (LOOP DO c OD) ls = vcg_fragments' c (atC c)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"vcg_fragments' (⦃l'⦄ WHILE b DO c OD) ls
       = vcg_fragments' c (λl. l = l') ∪ { (⦃l'⦄ WHILE b DO c' OD, lcond (atC c) ls) |c'. True }"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"vcg_fragments' (c1 ;; c2) ls = vcg_fragments' c2 ls ∪ vcg_fragments' c1 (atC c2)"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"vcg_fragments' (c1 ⊔ c2) ls = vcg_fragments' c1 ls ∪ vcg_fragments' c2 ls"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"vcg_fragments' c ls = {(c, lconst ls)}"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>vcg_fragments</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) com
                  ⇒ ( ('answer, 'location, 'question, 'state) com
                    × ('answer, 'location, 'question, 'state) loc_comp ) set"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"vcg_fragments c ≡ vcg_fragments' c ⟨False⟩"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_fragments'_inc</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ (c', lp) ∈ fragments c ls; ⋀l action. c' ≠ ⦃l⦄ Response action ⟧ ⟹ (c', lp) ∈ vcg_fragments' c ls"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>ls</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VCG_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. ∀(c, afts) ∈ vcg_fragments (fst sys p). ((fst sys), p, afts ⊨ ⦃pre⦄ c ⦃post⦄)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, h) s⇒ (s', h')"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, h) ∈ reachable_states sys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"pre (mkP (s, h))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"post (mkP (s', h'))"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>LocalStep</span><span> </span><span>p</span><span> </span><span>ps'</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>P</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>decompose_small_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>R</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>basic_com.cases</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>V</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span>vcg_fragments'_inc</span><span>
</span><span>                     </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>small_step_inv</span><span> </span><span>vcg_inv</span><span>
</span><span>                      </span><span>simp</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>LST_def</span><span> </span><span>AT_def</span><span> </span><span>mkP_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CommunicationStep</span><span> </span><span>p1</span><span> </span><span>α</span><span> </span><span>β</span><span> </span><span>ls1'</span><span> </span><span>p2</span><span> </span><span>ls2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>P</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>decompose_small_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>R</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>decompose_small_step</span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>R</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>basic_com.cases</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>vcg_fragments'_inc</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>V</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>vcg_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>elim</span><span> </span><span>small_step_inv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fun_eq_iff</span><span> </span><span>LST_def</span><span> </span><span>AT_def</span><span> </span><span>mkP_def</span><span> </span><span>split_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The user sees the conclusion of ‹V› for each element of ‹vcg_fragments›.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>VCG</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>R</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ reachable_states sys"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀s ∈ initial_states sys. I (mkP (s, []))"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>V</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀p. ∀(c, afts) ∈ vcg_fragments (fst sys p). ((fst sys), p, afts ⊨ ⦃I⦄ c)"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I (mkP s)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"I (mkP (s', h'))"</span></span></span><span> </span><span class="keyword2"><span class="keyword">if</span></span><span> </span><span>B</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"s0 ∈ initial_states sys"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"(s0, []) s⇒<span class="hidden">⇧</span><sup>*</sup> (s', h')"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>s0</span><span> </span><span>s'</span><span> </span><span>h'</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>S</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rtrancl_induct2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>refl</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>I</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>step</span><span> </span><span>s'</span><span> </span><span>h'</span><span> </span><span>s''</span><span> </span><span>h''</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>B</span><span> </span><span>V</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>-</span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>VCG_step</span><span class="delimiter">;</span><span> </span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_states_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>I</span><span> </span><span>R</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>reachable_states_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹VCG rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We can develop some (but not all) of the familiar Hoare rules; see
@{cite [cite_macro=citet] "DBLP:journals/acta/Lamport80"} and the
seL4/l4.verified lemma buckets for inspiration. We avoid many of the
issues Lamport mentions as we only treat basic (atomic) commands.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">context</span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>pgms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) programs"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>p</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'proc"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">fixes</span></span><span> </span><span>afts</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'question, 'state) loc_comp"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>valid_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) pred
             ⇒ ('answer, 'location, 'question, 'state) com
             ⇒ ('answer, 'location, 'proc, 'question, 'state) pred ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_syn P c Q ≡ pgms, p, afts ⊨ ⦃P⦄ c ⦃Q⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>valid_syn</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄/ _/ ⦃_⦄"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>valid_inv_syn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('answer, 'location, 'proc, 'question, 'state) pred
                  ⇒ ('answer, 'location, 'question, 'state) com ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"valid_inv_syn P c ≡ ⦃P⦄ c ⦃P⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">notation</span></span><span> </span><span>valid_inv_syn</span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄/ _"</span></span></span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_True</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ c ⦃⟨True⟩⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vcg_inv</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_conj</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ⦃I⦄ c ⦃Q⦄; ⦃I⦄ c ⦃R⦄ ⟧ ⟹ ⦃I⦄ c ⦃Q <span class="hidden">❙</span><span class="bold">∧</span> R⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vcg_inv</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_pre_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀s. P s ⟹ Q s; ⦃Q⦄ c ⦃R⦄ ⟧ ⟹ ⦃P⦄ c ⦃R⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vcg_inv</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>vcg_pre</span><span> </span><span class="delimiter">=</span><span> </span><span>vcg_pre_imp</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_post_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ ⋀s. Q s ⟹ R s; ⦃P⦄ c ⦃Q⦄ ⟧ ⟹ ⦃P⦄ c ⦃R⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vcg_inv</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_prop</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃⟨P⟩⦄ c"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_drop_imp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ c ⦃Q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ c ⦃R <span class="hidden">❙</span><span class="bold">⟶</span> Q⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vcg_inv</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_conj_lift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ c ⦃Q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P'⦄ c ⦃Q'⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>      </span><span class="string"><span class="delete"><span class="delete">"⦃P <span class="hidden">❙</span><span class="bold">∧</span> P'⦄ c ⦃Q <span class="hidden">❙</span><span class="bold">∧</span> Q'⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_conj</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>x</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_pre</span><span class="delimiter">[</span><span>OF</span><span> </span><span>y</span><span class="delimiter">]</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_disj_lift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄  c ⦃Q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>y</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P'⦄ c ⦃Q'⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>      </span><span class="string"><span class="delete"><span class="delete">"⦃P <span class="hidden">❙</span><span class="bold">∨</span> P'⦄ c ⦃Q <span class="hidden">❙</span><span class="bold">∨</span> Q'⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vcg_inv</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_imp_lift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P'⦄ c ⦃<span class="hidden">❙</span><span class="bold">¬</span> P⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃Q'⦄ c ⦃Q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P' <span class="hidden">❙</span><span class="bold">∨</span> Q'⦄ c ⦃P <span class="hidden">❙</span><span class="bold">⟶</span> Q⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>imp_conv_disj</span><span> </span><span>vcg_disj_lift</span><span class="delimiter">[</span><span>OF</span><span> </span><span>assms</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_ex_lift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ⦃P x⦄ c ⦃Q x⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λs. ∃x. P x s⦄ c ⦃λs. ∃x. Q x s⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vcg_inv</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_all_lift</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ⦃P x⦄ c ⦃Q x⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λs. ∀x. P x s⦄ c ⦃λs. ∀x. Q x s⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vcg_inv</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_name_pre_state</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀s. P s ⟹ ⦃(=) s⦄ c ⦃Q⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P⦄ c ⦃Q⦄"</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>vcg_inv</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>vcg_lift_comp</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀P. ⦃λs. P (f s :: 'a :: type)⦄ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"⋀x. ⦃Q x⦄ c ⦃P x⦄"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃λs. Q (f s) s⦄ c ⦃λs. P (f s) s⦄"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_name_pre_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_pre</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_post_imp</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_conj_lift</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"f s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfs. fs = f s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* **************************************** *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Cheap non-interference rules›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

These rules magically construct VCG lifting rules from the easier to
prove ‹eq_imp› facts. We don't actually use these in the GC,
but we do derive @{const "fun_upd"} equations using the same
mechanism. Thanks to Thomas Sewell for the requisite syntax magic.

As these ‹eq_imp› facts do not usefully compose, we make the
definition asymmetric (i.e., ‹g› does not get a bundle of
parameters).

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>eq_imp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"('a ⇒ 'b ⇒ 'c) ⇒ ('b ⇒ 'e) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"eq_imp f g ≡ (∀s s'. (∀x. f x s = f x s') ⟶ (g s = g s'))"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_impD</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ eq_imp f g; ∀x. f x s = f x s' ⟧ ⟹ g s = g s'"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>eq_imp_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_imp_vcg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_imp f g"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x P. ⦃P ∘ (f x)⦄ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P ∘ g⦄ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_name_pre_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_pre</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_post_imp</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_all_lift</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfs. fs = f x s"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>f</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>g</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_imp_vcg_LST</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_imp f g"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x P. ⦃P ∘ (f x) ∘ LST⦄ c"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃P ∘ g ∘ LST⦄ c"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_name_pre_state</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_pre</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_post_imp</span><span class="delimiter">[</span><span>rotated</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg_all_lift</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="tfree">'a</span><span class="delimiter">=</span><span class="tfree">'a</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>x</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfs. fs = f x s↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>f</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>f</span><span class="delimiter">=</span><span>f</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>g</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eq_imp_fun_upd</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>g</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"eq_imp f g"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"∀x. f x (s(fld := val)) = f x s"</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"g (s(fld := val)) = g s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>eq_impD</span><span class="delimiter">[</span><span>OF</span><span> </span><span>g</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>curry_forall_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀f. P f) = (∀f. P (case_prod f))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λx y. f (x, y)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pres_tuple_vcg</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀P. ⦃P ∘ (λs. (f s, g s))⦄ c)
    ⟷ ((∀P. ⦃P ∘ f⦄ c) ∧ (∀P. ⦃P ∘ g⦄ c))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>curry_forall_eq</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"f"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfs s. P fs (g s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>vcg_lift_comp</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pres_tuple_vcg_LST</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"(∀P. ⦃P ∘ (λs. (f s, g s)) ∘ LST⦄ c)
    ⟷ ((∀P. ⦃P ∘ f ∘ LST⦄ c) ∧ (∀P. ⦃P ∘ g ∘ LST⦄ c))"</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>curry_forall_eq</span><span> </span><span>o_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>safe</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span>   </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>f</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λs. f s↓"</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">"λfs s. P fs (g s)"</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>g</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>vcg_lift_comp</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>conj_explode</span><span> </span><span class="delimiter">=</span><span> </span><span>conj_imp_eq_imp_imp</span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="CIMP">
<div class="head"><h1>Theory CIMP</h1>
<span class="command">theory</span> <span class="name">CIMP</span><br/>
<span class="keyword">imports</span> <a href="CIMP_vcg.html"><span class="name">CIMP_vcg</span></a> <a href="../../HOL/HOL-Library/Sublist.html"><span class="name">Sublist</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CIMP</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CIMP_pred</span><span>
</span><span>  </span><span>CIMP_lang</span><span>
</span><span>  </span><span>CIMP_vcg</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Sublist"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">keywords</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"inv_definition"</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">"locset_definition"</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span>thy_defn</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Infrastructure for reasoning about CIMP programs. See AFP entry ‹ConcurrentGC› for examples
of use.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>com</span><span> </span><span class="string"><span class="delete"><span class="delete">"Command definitions"</span></span></span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>inv</span><span> </span><span class="string"><span class="delete"><span class="delete">"Location-sensitive invariant definitions"</span></span></span><span>
</span><span class="keyword1"><span class="command">named_theorems</span></span><span> </span><span>loc</span><span> </span><span class="string"><span class="delete"><span class="delete">"Location set membership cache"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">ML</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

signature CIMP =
sig
    val com_locs_fold : (term -&gt; 'b -&gt; 'b) -&gt; 'b -&gt; term -&gt; 'b
    val com_locs_map : (term -&gt; 'b) -&gt; term -&gt; 'b list
    val com_locs_fold_no_response : (term -&gt; 'b -&gt; 'b) -&gt; 'b -&gt; term -&gt; 'b
    val com_locs_map_no_response : (term -&gt; 'b) -&gt; term -&gt; 'b list
    val def_inv : thm -&gt; local_theory -&gt; local_theory
    val def_locset : thm -&gt; local_theory -&gt; local_theory
end;

structure Cimp : CIMP =
struct

fun com_locs_fold f x (Const (@{const_name Request}, _) $ l $ _ $ _ )    = f l x
  | com_locs_fold f x (Const (@{const_name Response}, _) $ l $ _)        = f l x
  | com_locs_fold f x (Const (@{const_name LocalOp}, _) $ l $ _)         = f l x
  | com_locs_fold f x (Const (@{const_name Cond1}, _) $ l $ _ $ c)       = com_locs_fold f (f l x) c
  | com_locs_fold f x (Const (@{const_name Cond2}, _) $ l $ _ $ c1 $ c2) = com_locs_fold f (com_locs_fold f (f l x) c1) c2
  | com_locs_fold f x (Const (@{const_name Loop}, _) $ c)                = com_locs_fold f x c
  | com_locs_fold f x (Const (@{const_name While}, _) $ l $ _ $ c)       = com_locs_fold f (f l x) c
  | com_locs_fold f x (Const (@{const_name Seq}, _) $ c1 $ c2)           = com_locs_fold f (com_locs_fold f x c1) c2
  | com_locs_fold f x (Const (@{const_name Choose}, _) $ c1 $ c2)        = com_locs_fold f (com_locs_fold f x c1) c2
  | com_locs_fold _ x _ = x;

fun com_locs_map f com = com_locs_fold (fn l =&gt; fn acc =&gt; f l :: acc) [] com

fun com_locs_fold_no_response f x (Const (@{const_name Request}, _) $ l $ _ $ _ )    = f l x
  | com_locs_fold_no_response _ x (Const (@{const_name Response}, _) $ _ $ _)        = x (* can often ignore ‹Response› *)
  | com_locs_fold_no_response f x (Const (@{const_name LocalOp}, _) $ l $ _)         = f l x
  | com_locs_fold_no_response f x (Const (@{const_name Cond1}, _) $ l $ _ $ c)       = com_locs_fold_no_response f (f l x) c
  | com_locs_fold_no_response f x (Const (@{const_name Cond2}, _) $ l $ _ $ c1 $ c2) = com_locs_fold_no_response f (com_locs_fold_no_response f (f l x) c1) c2
  | com_locs_fold_no_response f x (Const (@{const_name Loop}, _) $ c)                = com_locs_fold_no_response f x c
  | com_locs_fold_no_response f x (Const (@{const_name While}, _) $ l $ _ $ c)       = com_locs_fold_no_response f (f l x) c
  | com_locs_fold_no_response f x (Const (@{const_name Seq}, _) $ c1 $ c2)           = com_locs_fold_no_response f (com_locs_fold_no_response f x c1) c2
  | com_locs_fold_no_response f x (Const (@{const_name Choose}, _) $ c1 $ c2)        = com_locs_fold_no_response f (com_locs_fold_no_response f x c1) c2
  | com_locs_fold_no_response _ x _ = x;

fun com_locs_map_no_response f com = com_locs_fold_no_response (fn l =&gt; fn acc =&gt; f l :: acc) [] com

(* Cache location set membership facts.

Decide membership in the given set for each label in the CIMP programs
in the Named_Theorems "com".

If the label set and com types differ, we probably get a nasty error.

*)

fun def_locset thm ctxt =
  let
    val set_name = thm
                   |&gt; Local_Defs.meta_rewrite_rule ctxt (* handle `=` or `≡` *)
                   |&gt; Thm.cprop_of |&gt; Thm.dest_equals |&gt; fst |&gt; Thm.term_of
    val set_typ = set_name |&gt; type_of
    val elt_typ = case set_typ of Type ("Set.set", [t]) =&gt; t | _ =&gt; raise Fail "thm should define a set"
    val set_name_str = case set_name of Const (c, _) =&gt; c | Free (c, _) =&gt; c | _ =&gt; error ("Not an equation of the form x = set: " ^ Thm.string_of_thm ctxt thm)
    val thm_name = Binding.qualify true set_name_str (Binding.name "memb")
    fun mk_memb l = Thm.cterm_of ctxt (Const (@{const_name "Set.member"}, elt_typ --&gt; set_typ --&gt; @{typ "bool"}) $ l $ set_name)
    val rewrite_tac = Simplifier.rewrite (ctxt addsimps ([thm] @ Named_Theorems.get ctxt @{named_theorems "loc"})) (* probably want the ambient simpset + some stuff *)
    val coms = Named_Theorems.get ctxt @{named_theorems "com"} |&gt; map (Thm.cprop_of #&gt; Thm.dest_equals #&gt; snd #&gt; Thm.term_of)
    val attrs = [(* Attrib.internal (K (Clasimp.iff_add)), *) Attrib.internal (K (Named_Theorems.add @{named_theorems "loc"}))]
(* Parallel *)
    fun mk_thms coms = Par_List.map rewrite_tac (maps (com_locs_map_no_response mk_memb) coms)
(* Sequential *)
(*    fun mk_thms coms = List.foldl (fn (c, thms) =&gt; com_locs_fold (fn l =&gt; fn thms =&gt; rewrite_tac (mk_memb l) :: thms) thms c) [] coms *)
  in
    ctxt
    |&gt; Local_Theory.note ((thm_name, attrs), mk_thms coms)
    |&gt; snd
  end;

(* FIXME later need to rewrite using interned labels (fold defs). *)
fun def_inv thm ctxt : local_theory =
  let
    val attrs = [Attrib.internal (K (Named_Theorems.add @{named_theorems "inv"}))]
  in
    ctxt
    |&gt; Local_Theory.note ((Binding.empty, attrs), [thm])
    |&gt; snd
  end;

end;

val _ =
  Outer_Syntax.local_theory' \&lt;^command_keyword&gt;‹inv_definition› "constant definition for invariants"
    (Scan.option Parse_Spec.constdecl -- (Parse_Spec.opt_thm_name ":" -- Parse.prop) --
      Parse_Spec.if_assumes -- Parse.for_fixes &gt;&gt; (fn (((decl, spec), prems), params) =&gt; fn b =&gt; fn lthy =&gt;
        Specification.definition_cmd decl params prems spec b lthy
        |&gt; (fn ((_, (_, thm)), lthy) =&gt; (thm, lthy)) |&gt; uncurry Cimp.def_inv));

val _ =
  Outer_Syntax.local_theory' \&lt;^command_keyword&gt;‹locset_definition› "constant definition for sets of locations"
    (Scan.option Parse_Spec.constdecl -- (Parse_Spec.opt_thm_name ":" -- Parse.prop) --
      Parse_Spec.if_assumes -- Parse.for_fixes &gt;&gt; (fn (((decl, spec), prems), params) =&gt; fn b =&gt; fn lthy =&gt;
        Specification.definition_cmd decl params prems spec b lthy
        |&gt; (fn ((_, (_, thm)), lthy) =&gt; (thm, lthy)) |&gt; uncurry Cimp.def_locset));
›</span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="CIMP_one_place_buffer_ex">
<div class="head"><h1>Theory CIMP_one_place_buffer_ex</h1>
<span class="command">theory</span> <span class="name">CIMP_one_place_buffer_ex</span><br/>
<span class="keyword">imports</span> <a href="CIMP.html"><span class="name">CIMP</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CIMP_one_place_buffer_ex</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CIMP</span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹One-place buffer example›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:one_place_buffer}

To demonstrate the CIMP reasoning infrastructure, we treat the trivial
one-place buffer example of @{cite [cite_macro=citet]
‹\S3.3› "DBLP:journals/toplas/LamportS84"}. Note that the
semantics for our language is different to @{cite
[cite_macro=citeauthor] "DBLP:journals/toplas/LamportS84"}'s, who
treated a historical variant of CSP (i.e., not the one in @{cite
"Hoare:1985"}).

We introduce some syntax for fixed-topology (static channel-based)
scenarios.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>Receive</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location ⇒ 'channel ⇒ ('val ⇒ 'state ⇒ 'state)
             ⇒ (unit, 'location, 'channel × 'val, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄/ _▹_"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ch▹f ≡ ⦃l⦄ Response (λquest s. if fst quest = ch then {(f (snd quest) s, ())} else {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>Send</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location ⇒ 'channel ⇒ ('state ⇒ 'val)
          ⇒ (unit, 'location, 'channel × 'val, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄/ _◃_"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ch◃f ≡ ⦃l⦄ Request (λs. (ch, f s)) (λans s. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

We further specialise these for our particular example.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>Receive'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location ⇒ 'channel ⇒ (unit, 'location, 'channel × 'state, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄/ _▹"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ch▹ ≡ ⦃l⦄ ch▹(λv _. v)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>Send'</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location ⇒ 'channel ⇒ (unit, 'location, 'channel × 'state, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄/ _◃"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ch◃ ≡ ⦃l⦄ ch◃id"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

These definitions largely follow @{cite [cite_macro=citet]
"DBLP:journals/toplas/LamportS84"}. We have three processes
communicating over two channels. We enumerate program locations.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ex_chname</span><span> </span><span class="delimiter">=</span><span> </span><span>ξ12</span><span> </span><span class="delimiter">|</span><span> </span><span>ξ23</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_val</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_ch</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_chname × ex_val"</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ex_loc</span><span> </span><span class="delimiter">=</span><span> </span><span>r12</span><span> </span><span class="delimiter">|</span><span> </span><span>r23</span><span> </span><span class="delimiter">|</span><span> </span><span>s23</span><span> </span><span class="delimiter">|</span><span> </span><span>s12</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ex_proc</span><span> </span><span class="delimiter">=</span><span> </span><span>p1</span><span> </span><span class="delimiter">|</span><span> </span><span>p2</span><span> </span><span class="delimiter">|</span><span> </span><span>p3</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_pgm</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ex_loc, ex_ch, ex_val) com"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_pred</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ex_loc, ex_proc, ex_ch, ex_val) pred"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ex_loc, ex_proc, ex_ch, ex_val) global_state"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_system</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ex_loc, ex_proc, ex_ch, ex_val) system"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_history</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ex_ch × unit) list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span>
</span><span>  </span><span>ex_pgms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_proc ⇒ ex_pgm"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ex_pgms p1 = ⦃s12⦄ ξ12◃"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_pgms p2 = LOOP DO ⦃r12⦄ ξ12▹;; ⦃s23⦄ ξ23◃ OD"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_pgms p3 = ⦃r23⦄ ξ23▹"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Each process starts with an arbitrary initial local state.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ex_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ex_proc ⇒ ex_val) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ex_init ≡ ⟨True⟩"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ex_system</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_system"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ex_system ≡ (ex_pgms, ex_init)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The following adapts Kai Engelhardt's, from his notes titled
\emph{Proving an Asynchronous Message Passing Program Correct},
2011. The history variable tracks the causality of the system, which I
feel is missing in Lamport's treatment. We tack on Lamport's invariant
so we can establish ‹Etern_pred›.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>filter_on_channel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_chname ⇒ ex_history ⇒ ex_val list"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"filter_on_channel ch ≡ map (snd ∘ fst) ∘ filter ((=) ch ∘ fst ∘ fst)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip1_0</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip1_0 ≡ at p1 s12 <span class="hidden">❙</span><span class="bold">⟶</span> (λs. filter_on_channel ξ12 (hist s) = [])"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip1_1</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip1_1 ≡ terminated p1 <span class="hidden">❙</span><span class="bold">⟶</span> (λs. filter_on_channel ξ12 (hist s) = [LST s p1])"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip2_0</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip2_0 ≡ at p2 r12 <span class="hidden">❙</span><span class="bold">⟶</span> (λs. filter_on_channel ξ12 (hist s) = filter_on_channel ξ23 (hist s))"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip2_1</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip2_1 ≡ at p2 s23 <span class="hidden">❙</span><span class="bold">⟶</span> (λs. filter_on_channel ξ12 (hist s) = filter_on_channel ξ23 (hist s) @ [LST s p2]
                           ∧ LST s p1 = LST s p2)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip3_0</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip3_0 ≡ at p3 r23 <span class="hidden">❙</span><span class="bold">⟶</span> (λs. filter_on_channel ξ23 (hist s) = [])"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip3_1</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip3_1 ≡ terminated p3 <span class="hidden">❙</span><span class="bold">⟶</span> (λs. filter_on_channel ξ23 (hist s) = [LST s p2]
                                ∧ LST s p1 = LST s p3)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>I_pred</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"I_pred ≡ pred_conjoin [ Ip1_0, Ip1_1, Ip2_0, Ip2_1, Ip3_0, Ip3_1 ]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>I_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>Ip1_0_def</span><span> </span><span>Ip1_1_def</span><span> </span><span>Ip2_0_def</span><span> </span><span>Ip2_1_def</span><span> </span><span>Ip3_0_def</span><span> </span><span>Ip3_1_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

If process three terminates, then it has process one's value. This is
stronger than @{cite [cite_macro=citeauthor]
"DBLP:journals/toplas/LamportS84"}'s as we don't ask that the first
process has also terminated.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Etern_pred</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Etern_pred ≡ terminated p3 <span class="hidden">❙</span><span class="bold">⟶</span> (λs. LST s p1 = LST s p3)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

Proofs from here down.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_system</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"I_pred sh ⟹ Etern_pred sh"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Etern_pred_def</span><span> </span><span>I_pred_def</span><span> </span><span>I_defs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_pgms, p1, lconst ⟨False⟩ ⊨ ⦃I_pred⦄ ⦃s12⦄ ξ12◃λs. s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>p'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_pred_def</span><span> </span><span>I_defs</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2_1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_pgms, p2, lconst (λl. l = r12) ⊨ ⦃I_pred⦄ ⦃s23⦄ ξ23◃λs. s"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>p'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p'</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_pred_def</span><span> </span><span>I_defs</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"(s, h) ∈ reachable_states ex_system ⟹ I_pred (mkP (s, h))"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>VCG</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_pred_def</span><span> </span><span>I_defs</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* vcg_clarsimp_tac *)</span></span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>p1</span><span> </span><span>p2_1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹›</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div><div id="CIMP_unbounded_buffer_ex">
<div class="head"><h1>Theory CIMP_unbounded_buffer_ex</h1>
<span class="command">theory</span> <span class="name">CIMP_unbounded_buffer_ex</span><br/>
<span class="keyword">imports</span> <a href="CIMP.html"><span class="name">CIMP</span></a> <a href="../../HOL/HOL-Library/Prefix_Order.html"><span class="name">Prefix_Order</span></a><br/>
</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
 * Copyright 2015, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>CIMP_unbounded_buffer_ex</span><span>
</span><span class="keyword2"><span class="keyword">imports</span></span><span>
</span><span>  </span><span>CIMP</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"HOL-Library.Prefix_Order"</span></span></span><span>
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>Receive</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location ⇒ 'channel ⇒ ('val ⇒ 'state ⇒ 'state)
             ⇒ (unit, 'location, 'channel × 'val, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄/ _▹_"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ch▹f ≡ ⦃l⦄ Response (λquest s. if fst quest = ch then {(f (snd quest) s, ())} else {})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>Send</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"'location ⇒ 'channel ⇒ ('state ⇒ 'val)
          ⇒ (unit, 'location, 'channel × 'val, 'state) com"</span></span></span><span> </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">"⦃_⦄/ _◃_"</span></span></span><span class="delimiter">)</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⦃l⦄ ch◃f ≡ ⦃l⦄ Request (λs. (ch, f s)) (λans s. {s})"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>butlastE</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"⟦ butlast xs = ys; xs ≠ []; ⋀z. xs = ys @ [z] ⟹ P ⟧ ⟹ P"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>rev_induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">section</span></span><span class="cartouche"><span class="delete"><span class="delete">‹Unbounded buffer example›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

\label{sec:unbounded_place_buffer}

This is more literally Kai's example from his notes titled
\emph{Proving an Asynchronous Message Passing Program Correct}, 2011.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ex_chname</span><span> </span><span class="delimiter">=</span><span> </span><span>ξ12</span><span> </span><span class="delimiter">|</span><span> </span><span>ξ23</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_val</span><span> </span><span class="delimiter">=</span><span> </span><span>nat</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_ls</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_val list"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_ch</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_chname × ex_val"</span></span></span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ex_loc</span><span> </span><span class="delimiter">=</span><span> </span><span>π4</span><span> </span><span class="delimiter">|</span><span> </span><span>π5</span><span> </span><span class="delimiter">|</span><span> </span><span>c1</span><span> </span><span class="delimiter">|</span><span> </span><span>r12</span><span> </span><span class="delimiter">|</span><span> </span><span>r23</span><span> </span><span class="delimiter">|</span><span> </span><span>s23</span><span> </span><span class="delimiter">|</span><span> </span><span>s12</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span>ex_proc</span><span> </span><span class="delimiter">=</span><span> </span><span>p1</span><span> </span><span class="delimiter">|</span><span> </span><span>p2</span><span> </span><span class="delimiter">|</span><span> </span><span>p3</span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_pgm</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ex_loc, ex_ch, ex_ls) com"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_pred</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ex_loc, ex_proc, ex_ch, ex_ls) pred"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_state</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ex_loc, ex_proc, ex_ch, ex_ls) global_state"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_system</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(unit, ex_loc, ex_proc, ex_ch, ex_ls) system"</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span>ex_history</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ex_ch × unit) list"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

FIXME a bit fake: the local state for the producer process contains
all values produced.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>ex_pgms</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_proc ⇒ ex_pgm"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ex_pgms p1 = LOOP DO ⦃c1⦄ LocalOp (λxs. { xs @ [x] |x. True }) ;; ⦃s12⦄ ξ12◃last OD"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_pgms p2 = LOOP DO ⦃r12⦄ ξ12▹(λx xs. xs @ [x])
                           ⊔ ⦃π4⦄ IF (λs. length s &gt; 0) THEN ⦃s23⦄ Request (λs. (ξ23, hd s)) (λans s. {tl s}) FI
                          OD"</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_pgms p3 = LOOP DO ⦃r23⦄ ξ23▹(λx xs. xs @ [x]) OD"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ex_init</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"(ex_proc ⇒ ex_ls) ⇒ bool"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ex_init f ≡ ∀p. f p = []"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span>ex_system</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_system"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ex_system ≡ (ex_pgms, ex_init)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>filter_on_channel</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">"ex_chname ⇒ ex_history ⇒ ex_val list"</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"filter_on_channel ch ≡ map (snd ∘ fst) ∘ filter ((=) ch ∘ fst ∘ fst)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>filter_on_channel_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"filter_on_channel ch [] = []"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"filter_on_channel ch (xs @ ys) = filter_on_channel ch xs @ filter_on_channel ch ys"</span></span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"filter_on_channel ch (((ch', v), resp) # vals) = (if ch' = ch then [v] else []) @ filter_on_channel ch vals"</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>filter_on_channel_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip1_0</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip1_0 ≡ λs. at p1 c1 s ⟶ filter_on_channel ξ12 (hist s) = s↓ p1"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip1_1</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip1_1 ≡ λs. at p1 s12 s ⟶ length (s↓ p1) &gt; 0 ∧ butlast (s↓ p1) = filter_on_channel ξ12 (hist s)"</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip1_2</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip1_2 ≡ λs. filter_on_channel ξ12 (hist s) ≤ s↓ p1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip2_0</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip2_0 ≡ λs. filter_on_channel ξ12 (hist s) = filter_on_channel ξ23 (hist s) @ s↓ p2"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* We would get this for free from a proper VCG. *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip2_1</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip2_1 ≡ λs. at p2 s23 s ⟶ length (s↓ p2) &gt; 0"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Ip3_0</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Ip3_0 ≡ λs. s↓ p3 = filter_on_channel ξ23 (hist s)"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>I_pred</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"I_pred ≡ pred_conjoin [ Ip1_0, Ip1_1, Ip1_2, Ip2_0, Ip2_1, Ip3_0 ]"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>I_defs</span><span> </span><span class="delimiter">=</span><span> </span><span>I_pred_def</span><span> </span><span>Ip1_0_def</span><span> </span><span>Ip1_1_def</span><span> </span><span>Ip1_2_def</span><span> </span><span>Ip2_0_def</span><span> </span><span>Ip2_1_def</span><span> </span><span>Ip3_0_def</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹

The local state of @{const "p3"} is some prefix of the local state of
@{const "p1"}.

›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>Etern_pred</span><span> </span><span class="delimiter">::</span><span> </span><span>ex_pred</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"Etern_pred ≡ λs. s↓ p3 ≤ s↓ p1"</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>correct_system</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"I_pred s ⟹ Etern_pred s"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>Etern_pred_def</span><span> </span><span>I_defs</span><span> </span><span>less_eq_list_def</span><span> </span><span>prefix_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p1_c1</span><span class="delimiter">[</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ex_pgms, p1, lconst (λl. l = s12) ⊨ ⦃I_pred⦄ ⦃c1⦄ LocalOp (λxs. { xs @ [x] |x. True })"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_defs</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p1_s12</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ex_pgms, p1, lconst (λl. l = c1) ⊨ ⦃I_pred⦄ ⦃s12⦄ ξ12◃last"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>p'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p'</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_defs</span><span> </span><span>atS_def</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>butlastE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2_s23</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ex_pgms, p2, lconst (λl. l = r12 ∨ l = π4) ⊨ ⦃I_pred⦄ ⦃s23⦄ Request (λs. (ξ23, hd s)) (λans s. {tl s})"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>p'</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p'</span><span class="delimiter">,</span><span> </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_defs</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>p2_pi4</span><span class="delimiter">[</span><span>intro</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">"ex_pgms, p2, lcond (λl. l = s23) (λl. l = r12 ∨ l = π4) ⊨ ⦃I_pred⦄ ⦃π4⦄ IF λs. s ≠ [] THEN c' FI"</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>vcg.intros</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_defs</span><span> </span><span>atS_def</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>lcond_splits</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="cartouche"><span class="delete"><span class="delete">‹›</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">"s ∈ reachable_states ex_system ⟹ I_pred (mkP s)"</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>VCG</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span> </span><span>dest</span><span class="delimiter">!</span><span class="delimiter">:</span><span> </span><span>initial_statesD</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>I_defs</span><span> </span><span>atS_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&lt;*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&gt;*)</span></span></span></span></span><span>
</span></pre>
</div>
</div>